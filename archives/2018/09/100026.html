<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="逆向,java,字节码">


    <meta name="description" content="大家可能已经非常熟悉下面的处理流程：将一个“.java”文件输入到Java编译器中（可能会使用javac，也可能像ANT、Maven或Gradle这样的构建工具），编译器对其进行分析，最终生成一...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>字节码操纵技术探秘 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="字节码操纵技术探秘">
            
	            字节码操纵技术探秘
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/crack/">破解</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/java/">java</a> <a class="tag-link" href="/tags/bytecode/">字节码</a> <a class="tag-link" href="/tags/reverse/">逆向</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/09/13</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1675</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>大家可能已经非常熟悉下面的处理流程：将一个“.java”文件输入到Java编译器中（可能会使用javac，也可能像ANT、Maven或Gradle这样的构建工具），编译器对其进行分析，最终生成一个或多个“.class”文件。</p>
<div align="center"><img src="/img/posts/b6affe4f945219825931250e8e68a5a3.jpg" alt="img"><br><br>图：什么是Java字节码？</div>

<p>如果从命令行中运行构建，并启用verbose的话，我们能够看到解析文件直到生成“.class”文件这一过程的输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -verbose src/com/example/spring2gx/BankTransactions.java</span><br></pre></td></tr></table></figure>
<p><img src="/img/posts/3dca5c7115bb78403ae31223a57bf3c8.jpg" alt="img"></p>
<p>所生成的“.class”文件包含了字节码，本质上来讲它就是Java虚拟机（Java virtual machine，JVM）所使用的指令，当程序运行时，它会由Java运行时类加载器进行加载。</p>
<p>在本文中，我们将会研究Java字节码以及如何对其进行操纵，并探讨人们为何想要这样做。</p>
<h2 id="字节码操纵框架"><a href="#字节码操纵框架" class="headerlink" title="字节码操纵框架"></a>字节码操纵框架</h2><p>最为流行的字节码操纵框架包括：</p>
<ul>
<li><a href="https://www.open-open.com/misc/goto?guid=4958197083673280437" target="_blank" rel="noopener">ASM</a></li>
<li><a href="https://www.open-open.com/misc/goto?guid=4959727766609123401" target="_blank" rel="noopener">AspectJ</a></li>
<li><a href="https://www.open-open.com/misc/goto?guid=4959727766699090763" target="_blank" rel="noopener">BCEL</a></li>
<li><a href="https://www.open-open.com/misc/goto?guid=4959675430703778613" target="_blank" rel="noopener">Byte Buddy</a></li>
<li><a href="https://www.open-open.com/misc/goto?guid=4959646057198156943" target="_blank" rel="noopener">CGLIB</a></li>
<li><a href="https://www.open-open.com/misc/goto?guid=4959727766837387890" target="_blank" rel="noopener">Cojen</a></li>
<li><a href="https://www.open-open.com/misc/goto?guid=4959727766920959210" target="_blank" rel="noopener">Javassist</a></li>
<li><a href="https://www.open-open.com/misc/goto?guid=4959727766993272617" target="_blank" rel="noopener">Serp</a></li>
</ul>
<p>本文将会主要关注Javassist和ASM。</p>
<h2 id="我们为什么应该关注字节码操纵呢？"><a href="#我们为什么应该关注字节码操纵呢？" class="headerlink" title="我们为什么应该关注字节码操纵呢？"></a>我们为什么应该关注字节码操纵呢？</h2><p>很多常用的Java库，如Spring和Hibernate，以及大多数的JVM语言甚至我们的IDE，都用到了字节码操纵框架。另外，它也确实非常有趣，所以这是一项很有价值的技术，掌握它之后，我们就能完成一些靠其他技术很难实现或无法完成的任务。一旦学会之后，我们的发挥空间将是无限的！</p>
<p>一个很重要的使用场景就是程序分析。例如，流行的bug定位工具FindBugs在底层就使用了ASM来分析字节码并定位bug。有一些软件商店会有一定的代码复杂性规则，比如方法中if/else语句的最大数量以及方法的最大长度。静态分析工具会分析我们的字节码来确定代码的复杂性。</p>
<p>另外一个常见的使用场景就是类生成功能。例如，ORM框架一般都会基于我们的类定义使用代理的机制。或者，在考虑实现应用的安全性时，可能会提供一种语法来添加授权的注解。在这样的场景下，都能很好地运用字节码操纵技术。</p>
<p>像Scala、Groovy和Grails这样的JVM语言都使用了字节码操纵框架。</p>
<p>考虑这样一种场景，我们需要转换库中的类，这些类我们并没有源码，这样的任务通常会由Java profiler来执行。例如，在New Relic，采用了字节码instrumentation技术实现了对方法执行的计时。</p>
<p>借助字节码操纵，我们可以优化或混淆代码，甚至可以引入一些功能，比如为应用添加重要的日志。本文将会关注一个日志样例，这个样例提供使用这些字节码操纵框架的基本工具。</p>
<h2 id="我们的样例"><a href="#我们的样例" class="headerlink" title="我们的样例"></a>我们的样例</h2><p>Sue负责一家银行的ATM编程，她有了一项新的需求：针对一些指定的重要操作，在日志中添加关键的数据。</p>
<p>如下是一个简化的银行交易类，它允许用户通过用户名和密码进行登录、进行一些处理、提取一些钱，然后打印“交易完成”。这里的重要操作就是登录和提款。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String password, String accountId, String userName)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 登录逻辑 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(String accountId, Double moneyToRemove)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 交易逻辑 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了简化编码，Sue会为这些方法调用创建一个@ImportantLog注解，这个注解所包含的输入参数代表了希望记录的方法参数索引。借助这一点，她就可以为login和withdraw方法添加注解了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 方法注解，用于识别 </span></span><br><span class="line"><span class="comment">* 重要的方法，这些方法的调用需要进行日志记录。 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ImportantLog &#123; </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 需要进行日志记录的方法参数索引。 </span></span><br><span class="line"><span class="comment">* 例如，如果有名为 </span></span><br><span class="line"><span class="comment">* hello(int paramA, int paramB, int paramC)的方法，我们 </span></span><br><span class="line"><span class="comment">* 希望以日志的形式记录paramA和paramC的值，那么fields </span></span><br><span class="line"><span class="comment">* 应该是["0","2"]。如果我们只想记录 </span></span><br><span class="line"><span class="comment">* paramB的值，那么fields将会是["1"]。 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">String[] fields(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于login方法，Sue希望记录账户Id和用户名，那么她的fields应该设置为“1”和“2”（她不希望将密码展现出来！）。对于withdraw方法，她的fields应该设置为“0”和“1”，因为她希望输出前两个域：账户ID以及要提取的金额，其审计日志理想情况下应该包含如下的内容：</p>
<p><img src="/img/posts/dc3a5f3c3303f82714935f09cc9cc962.jpg" alt="img"></p>
<p>要实现该功能，Sue将会使用Java agent技术。Java agent是在JDK 1.5中引入的，它允许我们在处于运行状态的JVM中，修改组成类的字节，在这个过程中，并不需要这些类的源码。</p>
<p>在没有agent的时候，Sue的程序的正常执行流程是这样的：</p>
<ol>
<li>在某个主类上运行Java，这个类会由一个类加载器进行加载；</li>
<li>调用该类的main方法，它会调用预先定义好的处理过程；</li>
<li>打印“交易完成”。</li>
</ol>
<p>在引入Java agent之后，会发生几件额外的事情——但是，在此之前，我们先看一下创建agent都需要些什么。agent必须要包含一个类，这个类要具有一个名为premain的方法。这个类必须要打包为JAR文件，这个包中还需要包含一个正确的manifest文件，在manifest文件中要有一个名为Premain-Class的条目。在启动的时候，必须要设置一个启动项，指向该JAR文件的路径，这样的话，JVM才能知道这个agent：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -javaagent:/to/agent.jar com/example/spring2gx/BankTransactions</span><br></pre></td></tr></table></figure>
<p>在premain方法中，我们可以注册一个Transformer，它会在每个类加载的时候，捕获它的字节，进行所需的修改，然后返回修改后的字节。在Sue的样例中，Transformer会捕获BankTransaction，在这里她会作出修改并返回修改后的字节，这也就是类加载器所加载的字节，main方法将会执行原有的功能，除此之外还会增加Sue所需的日志增强。</p>
<p>当agent类加载后，它的premain方法会在应用程序的main方法之前被调用。</p>
<div align="center"><img src="/img/posts/11793fc958076da1f1a3dc6b4c3707c7.jpg" alt="img"><br><br>图：使用Java agent的过程。</div>

<p>我们最好来看一个样例。</p>
<p>Agent类不需要实现任何接口，但是它必须要包含一个premain方法，如下所示：</p>
<p><img src="/img/posts/e5a99ea36770d668196fe5b587fb31e8.jpg" alt="img"></p>
<p>Transformer类包含了一个transform方法，它的签名会接受ClassLoader、类名、要重定义的类所对应的Class对象、定义权限的ProtectionDomain以及这个类的原始字节。如果从transform方法中返回null的话，将会告诉运行时环境我们并没有对这个类进行变更。</p>
<p><img src="/img/posts/628a118bf728853d5ac56d005c178a0f.jpg" alt="img"></p>
<p>如果要修改类的字节的话，我们需要在transform中提供字节码操纵的逻辑并返回修改后的字节。</p>
<p><img src="/img/posts/ac7bd8b4428d29c1872fe095821cf73a.jpg" alt="img"></p>
<h2 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h2><p>Javassist（“Java Programming Assistant”的缩写形式）是JBoss的子项目，包含了高层级的基于对象的API，同时也包含了低层级更接近字节码的API。基于对象的API社区更为活跃，这也是本文所关注的焦点。读者可以参考 <a href="https://www.open-open.com/misc/goto?guid=4959727767082631929" target="_blank" rel="noopener">Javassist站点</a> 以获取完整的使用指南。</p>
<p>在Javassist中，进行类表述的基本单元是CtClass（即“编译时的类”，compile time class）。组成程序的这些类会存储在一个ClassPool中，它本质上就是CtClass实例的一个容器。</p>
<p>ClassPool的实现使用了一个HashMap，其中key是类的名称，而value是对应的CtClass对象。</p>
<p>正常的Java类都会包含域、构造器以及方法。在CtClass中，分别与之对应的是CtField、CtConstructor和CtMethod。要定位某个CtClass，我们可以根据名称从ClassPool中获取，然后通过CtClass得到任意的方法，并做出我们的修改。</p>
<p><img src="/img/posts/7031f8be37dc18fe0b19f8389d0e04fa.jpg" alt="img"></p>
<p>CtMethod中包含了相关方法的代码行。我们可以借助insertBefore命令在方法开始的地方插入代码。Javassist非常棒的一点在于我们所编写的是纯Java，只不过需要提醒一下：Java代码必须要以引用字符串的形式来实现。但是，大多数的人都会同意这种方式要比处理字节码好得多！（尽管如此，如果你碰巧喜欢直接处理字节码的话，那么可以关注本文ASM相关的内容。）JVM包含了一个字节码验证器（verifier），以防止出现不合法的字节码。如果在你的Javassist代码中，所使用的Java是非法的，那么在运行时字节码验证器会拒绝它。</p>
<p>与insertBefore类似，还有一个名为insertAfter的方法，借助它我们可以在相关方法的结尾处插入代码。我们还可以使用insertAt方法，从而在相关方法的中间插入代码，或者使用addCatch添加catch语句。</p>
<p><img src="/img/posts/2524f08c0b58d5edbb83df54bbf8ecd5.jpg" alt="img"></p>
<p>现在，让我们打开IDE，然后编码实现这个日志特性，首先从Agent（包含premain）和ClassTransformer开始。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.spring2gx.agent;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"Starting the agent"</span>);</span><br><span class="line">   inst.addTransformer(<span class="keyword">new</span> ImportantLogClassTransformer());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.example.spring2gx.agent;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportantLogClassTransformer</span></span></span><br><span class="line"><span class="class">   <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className,</span><br><span class="line">                Class classBeingRedefined, ProtectionDomain protectionDomain,</span><br><span class="line">                <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line"><span class="comment">// 在这里操纵字节</span></span><br><span class="line">     <span class="keyword">return</span> modified_bytes;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>为了添加审计日志，首先要实现transform，将类的字节转换为CtClass对象。然后，我们可以迭代它的方法，并捕获其中带有@ImportantLogin注解的方法，获取要进行日志记录的输入参数索引，并将相关的代码插入到方法开头的位置上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, </span><br><span class="line">                        Class classBeingRedefined, </span><br><span class="line">                        ProtectionDomain protectionDomain, </span><br><span class="line">                        <span class="keyword">byte</span>[] cfbuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123; </span><br><span class="line"><span class="comment">// 将字节数组转换为CtClass对象</span></span><br><span class="line">    pool.insertClassPath(<span class="keyword">new</span> ByteArrayClassPath(className,classfileBuffer)); </span><br><span class="line"><span class="comment">// 将路径斜线转换为点号</span></span><br><span class="line">    CtClass cclass = pool.get(className.replaceAll(<span class="string">"/"</span>, <span class="string">"."</span>)); </span><br><span class="line">    <span class="keyword">if</span> (!cclass.isFrozen()) &#123; </span><br><span class="line"><span class="comment">// 检查CtClass的每个方法是否有@ImportantLog注解</span></span><br><span class="line">      <span class="keyword">for</span> (CtMethod currentMethod : cclass.getDeclaredMethods()) &#123; </span><br><span class="line"><span class="comment">// 查找@ImportantLog注解</span></span><br><span class="line">        Annotation annotation = getAnnotation(currentMethod); </span><br><span class="line">        <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123; </span><br><span class="line"><span class="comment">// 如果方法上有@ImportantLog注解的话，那么</span></span><br><span class="line"><span class="comment">// 获得重要方法的参数索引</span></span><br><span class="line">          List parameterIndexes = getParamIndexes(annotation); </span><br><span class="line"><span class="comment">// 在方法的开头位置添加日志语句</span></span><br><span class="line">          currentMethod.insertBefore(</span><br><span class="line">                 createJavaString(currentMethod, className, parameterIndexes)); </span><br><span class="line">        &#125; </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> cclass.toBytecode(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Javassist注解可以声明为“不可见的（invisible）”和“可见的（visible）”。不可见的注解只会在类加载和编译期可见，它们在声明时需要将RententionPolicy.CLASS参数传递到注解中。可见注解（RententionPolicy.RUNTIME）在运行期会加载，并且是可见的。对于本例来说，我们只在编译期需要这些属性，因此将其设为不可见的。</p>
<p>getAnnotation方法会扫描@ImportantLog注解，如果找不到注解的话，将会返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Annotation <span class="title">getAnnotation</span><span class="params">(CtMethod method)</span> </span>&#123; </span><br><span class="line">    MethodInfo methodInfo = method.getMethodInfo(); </span><br><span class="line">    AnnotationsAttribute attInfo = (AnnotationsAttribute) methodInfo </span><br><span class="line">      .getAttribute(AnnotationsAttribute.invisibleTag); </span><br><span class="line">    <span class="keyword">if</span> (attInfo != <span class="keyword">null</span>) &#123; </span><br><span class="line">      <span class="keyword">return</span> attInfo.getAnnotation(<span class="string">"com.example.spring.mains.ImportantLog"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在得到注解之后，我们就可以检索参数索引了。通过使用Javassist的ArrayMemberValue，会以字符串数组的形式返回成员field的值，然后我们就可以对其进行遍历，从而获取在注解中所嵌入的field索引。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List <span class="title">getParamIndexes</span><span class="params">(Annotation annotation)</span> </span>&#123; </span><br><span class="line">    ArrayMemberValue fields =</span><br><span class="line">                    (ArrayMemberValue) annotation.getMemberValue(“fields”); </span><br><span class="line">    <span class="keyword">if</span> (fields != <span class="keyword">null</span>) &#123; </span><br><span class="line">      MemberValue[] values = (MemberValue[]) fields.getValue(); </span><br><span class="line">      List parameterIndexes = <span class="keyword">new</span> ArrayList(); </span><br><span class="line">      <span class="keyword">for</span> (MemberValue val : values) &#123; </span><br><span class="line">        parameterIndexes.add(((StringMemberValue) val).getValue()); </span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">return</span> parameterIndexes; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList(); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们可以借助createJavaString在某个位置插入日志语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>     <span class="function"><span class="keyword">private</span> String <span class="title">createJavaString</span><span class="params">(CtMethod currentMethod, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">2</span>                  String className, List indexParameters)</span> </span>&#123; </span><br><span class="line"><span class="number">3</span>       StringBuilder sb = <span class="keyword">new</span> StringBuilder(); </span><br><span class="line"><span class="number">4</span>       sb.append(<span class="string">"&#123;StringBuilder sb = new StringBuilder"</span>); </span><br><span class="line"><span class="number">5</span>       sb.append(<span class="string">"(\"A call was made to method '\");"</span>); </span><br><span class="line"><span class="number">6</span>       sb.append(<span class="string">"sb.append(\""</span>); </span><br><span class="line"><span class="number">7</span>       sb.append(currentMethod.getName()); </span><br><span class="line"><span class="number">8</span>       sb.append(<span class="string">"\");sb.append(\"' on class '\");"</span>); </span><br><span class="line"><span class="number">9</span>       sb.append(<span class="string">"sb.append(\""</span>); </span><br><span class="line"><span class="number">10</span>      sb.append(className); </span><br><span class="line"><span class="number">11</span>      sb.append(<span class="string">"\");sb.append(\"'.\");"</span>); </span><br><span class="line"><span class="number">12</span>      sb.append(<span class="string">"sb.append(\"\\n Important params:\");"</span>); </span><br><span class="line"><span class="number">13</span>   </span><br><span class="line"><span class="number">14</span>      <span class="keyword">for</span> (String index : indexParameters) &#123; </span><br><span class="line"><span class="number">15</span>        <span class="keyword">try</span> &#123; </span><br><span class="line"><span class="number">16</span>          <span class="keyword">int</span> localVar = Integer.parseInt(index) + <span class="number">1</span>; </span><br><span class="line"><span class="number">17</span>          sb.append(<span class="string">"sb.append(\"\\n Index: \");"</span>); </span><br><span class="line"><span class="number">18</span>          sb.append(<span class="string">"sb.append(\""</span>); </span><br><span class="line"><span class="number">19</span>          sb.append(index); </span><br><span class="line"><span class="number">20</span>          sb.append(<span class="string">"\");sb.append(\" value: \");"</span>); </span><br><span class="line"><span class="number">21</span>          sb.append(<span class="string">"sb.append($"</span> + localVar + <span class="string">");"</span>); </span><br><span class="line"><span class="number">22</span>        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123; </span><br><span class="line"><span class="number">23</span>          e.printStackTrace(); </span><br><span class="line"><span class="number">24</span>        &#125; </span><br><span class="line"><span class="number">25</span>      &#125; </span><br><span class="line"><span class="number">26</span>      sb.append(<span class="string">"System.out.println(sb.toString());&#125;"</span>); </span><br><span class="line"><span class="number">27</span>      <span class="keyword">return</span> sb.toString(); </span><br><span class="line"><span class="number">28</span>    &#125; </span><br><span class="line"><span class="number">29</span>  &#125;</span><br></pre></td></tr></table></figure>
<p>在我们的实现中，创建了一个StringBuilder，它首先拼接了一些报头信息，紧接着是方法名和类名。需要注意的一件事情是，如果我们插入多行Java语句的话，需要将其用大括号括起来（参见第4行和第26行）。</p>
<p>（如果只有一条语句的话，那没有必要使用括号。）</p>
<p>前文基本上已经全部涵盖了使用Javassist添加审计日志的代码。回顾一下，它的优势在于：</p>
<ul>
<li>因为它使用我们所熟悉的Java语法，所以不需要学习字节码；</li>
<li>没有太多的编码工作要做；</li>
<li>Javassist已经有了很棒的文档。</li>
</ul>
<p>它的不足之处在于：</p>
<ul>
<li>不使用字节码会限制它的功能；</li>
<li>Javassist会比其他的字节码操纵框架更慢一些。</li>
</ul>
<h2 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2><p>ASM最初是一个博士研究项目，在2002年开源。它的更新非常活跃，从5.x版本开始支持Java 8。ASM包含了一个基于事件的库和一个基于对象的库，分别类似于SAX和DOM XML解析器。</p>
<p>一个Java类是由很多组件组成的，包括超类、接口、属性、域和方法。在使用ASM时，我们可以将其均视为事件。我们会提供一个ClassVisitor实现，通过它来解析类，当解析器遇到每个组件时，ClassVisitor上对应的“visitor”事件处理器方法会被调用（始终按照上述的顺序）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.xml.internal.ws.org.objectweb.asm; </span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassVisitor</span> </span>&#123; </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  String superName, String[] interfaces)</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">visitSource</span><span class="params">(String source, String debug)</span></span>; </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">visitOuterClass</span><span class="params">(String owner, String name, String desc)</span></span>; </span><br><span class="line">       <span class="function">AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span></span>; </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">visitAttribute</span><span class="params">(Attribute attr)</span></span>; </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">visitInnerClass</span><span class="params">(String name, String outerName, </span></span></span><br><span class="line"><span class="function"><span class="params">                            String innerName, <span class="keyword">int</span> access)</span></span>; </span><br><span class="line">       <span class="function">FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, </span></span></span><br><span class="line"><span class="function"><span class="params">                               String signature, Object value)</span></span>; </span><br><span class="line">       <span class="function">MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 String signature, String[] exceptions)</span></span>; </span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们将Sue的BankTransaction（在本文的开头中进行了定义）传递到一个ClassReader中进行解析，以便对这种处理方式有个直观的感觉。</p>
<p>同样，我们需要从Agent premain开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation inst)</span> </span>&#123; </span><br><span class="line">    System.out.println(<span class="string">"Starting the agent"</span>); </span><br><span class="line">    inst.addTransformer(<span class="keyword">new</span> ImportantLogClassTransformer()); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，将输出的字节传递给不进行任何操作（no-op）的ClassWriter，将解析得到的字节全部写回到字节数组中，得到一个重新生成的BankTransaction，它的行为与原始类的行为是完全一致的。</p>
<p><img src="/img/posts/d77e7d08185890936c8cda591aea4ba2.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.ClassReader; </span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.ClassWriter; </span><br><span class="line"><span class="keyword">import</span> jdk.internal.org.objectweb.asm.ClassVisitor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer; </span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException; </span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImportantLogClassTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, </span><br><span class="line">               Class classBeingRedefined, ProtectionDomain protectionDomain, </span><br><span class="line">               <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123; </span><br><span class="line">    ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer); </span><br><span class="line">    ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, ClassWriter.COMPUTE_FRAMES); </span><br><span class="line">    cr.accept(cw, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray(); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们修改一下ClassWriter，让它做一些更有用的事情，这需要添加一个ClassVisitor（名为LogMethodClassVisitor）来调用我们的事件处理方法，如visitField或visitMethod，在解析时遇到相关组件时就会调用这些方法。</p>
<p><img src="/img/posts/d1dbfc9a26d0ee0e12eff2998018ff8c.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, </span><br><span class="line">             Class classBeingRedefined, ProtectionDomain protectionDomain, </span><br><span class="line">             <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123; </span><br><span class="line">    ClassReader cr = <span class="keyword">new</span> ClassReader(classfileBuffer); </span><br><span class="line">    ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, ClassWriter.COMPUTE_FRAMES); </span><br><span class="line">    ClassVisitor cv = <span class="keyword">new</span> LogMethodClassVisitor(cw, className); </span><br><span class="line">    cr.accept(cv, <span class="number">0</span>); </span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray(); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>对于日志记录的需求，我们想要检查每个方法是否具有标示注解并添加特定的日志。我们只需要重写ClassVisitor的visitMethod方法，让它返回一个MethodVisitor，从而提供我们自己的实现。就像类是由多个组件组成的一样，方法也是由多个组件组成的，对应着方法属性、注解以及编译后的代码。ASM的MethodVisitor提供了一种钩子（hook）机制，以便访问方法中的每个操作码（opcode），这样我们就能以很细的粒度来进行修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogMethodClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> String className; </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LogMethodIfAnnotationVisitor</span><span class="params">(ClassVisitor cv, String className)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">super</span>(Opcodes.ASM5, cv); </span><br><span class="line">    <span class="keyword">this</span>.className = className; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   String signature, String[] exceptions)</span> </span>&#123; </span><br><span class="line"><span class="comment">// 将我们的逻辑放在这里 </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，事件处理器会始终按照预先定义的相同顺序来调用，所以在实际 <em>访问（visit）</em> 代码的时候，我们就已经得知了方法的所有属性和注解。（顺便说一下，我们还可以将多个MethodVisitor链接在一起，就像我们可以链接多个ClassVisitor实例一样。）所以，在visitMethod方法中，我们将会通过PrintMessageMethodVisitor添加钩子，重载visitAnnotation方法来获取注解并插入任意所需的日志代码。</p>
<p><img src="/img/posts/e5e537d3e4a3755b050d4f9bc423a2ab.jpg" alt="img"></p>
<p>我们的PrintMessageMethodVisitor重载了两个方法。首先是visitAnnotation，所以可以检查方法的@ImportantLog注解。如果存在这个注解的话，我们需要提取field属性上的索引。当visitCode执行的时候，是否存在注解已经确定了，所以我们就可以添加特定的日志了。visitAnnotation的代码以钩子的形式添加到了AnnotationVisitor中，它能够暴露@ImportantLog 注解上的field参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"Lcom/example/spring2gx/mains/ImportantLog;"</span>.equals(desc)) &#123; </span><br><span class="line">      isAnnotationPresent = <span class="keyword">true</span>; </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> AnnotationVisitor(Opcodes.ASM5, </span><br><span class="line">        <span class="keyword">super</span>.visitAnnotation(desc, visible)) &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitArray</span><span class="params">(String name)</span> </span>&#123; </span><br><span class="line">          <span class="keyword">if</span> (“fields”.equals(name))&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AnnotationVisitor(Opcodes.ASM5, </span><br><span class="line">              <span class="keyword">super</span>.visitArray(name)) &#123; </span><br><span class="line">              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(String name, Object value)</span> </span>&#123; </span><br><span class="line">                parameterIndexes.add((String) value); </span><br><span class="line">                <span class="keyword">super</span>.visit(name, value); </span><br><span class="line">              &#125; </span><br><span class="line">            &#125;; </span><br><span class="line">          &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitArray(name); </span><br><span class="line">          &#125; </span><br><span class="line">        &#125; </span><br><span class="line">      &#125;; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.visitAnnotation(desc, visible); </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们来看一下visitCode方法。首先，它必须要检查AnnotationVisitor是否有注解存在的标记。如果有的话，那么添加我们自己的字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (isAnnotationPresent) &#123; </span><br><span class="line"><span class="comment">// 创建string builder </span></span><br><span class="line">      mv.visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>,  </span><br><span class="line">                                           <span class="string">"Ljava/io/PrintStream;"</span>); </span><br><span class="line">      mv.visitTypeInsn(Opcodes.NEW, <span class="string">"java/lang/StringBuilder"</span>); </span><br><span class="line">      mv.visitInsn(Opcodes.DUP); </span><br><span class="line"><span class="comment">// 将所需的所有内容添加到string builder上 </span></span><br><span class="line">      mv.visitLdcInsn(<span class="string">"A call was made to method \""</span>); </span><br><span class="line">      mv.visitMethodInsn(Opcodes.INVOKESPECIAL, <span class="string">"java/lang/StringBuilder"</span>, </span><br><span class="line">                         <span class="string">""</span>,  <span class="string">"(Ljava/lang/String;)V"</span>, <span class="keyword">false</span>); </span><br><span class="line">      mv.visitLdcInsn(methodName); </span><br><span class="line">      mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/lang/StringBuilder"</span>, </span><br><span class="line">             <span class="string">"append"</span>, <span class="string">"(Ljava/lang/String;)Ljava/lang/StringBuilder;"</span>, <span class="keyword">false</span>); </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这是ASM非常恐怖的一点——我们必须要编写字节码，所以要学习新的东西。这是一门相当简单的语言，但是如果你只是想随便了解一下的话，那么可以非常容易地借助javap得到现有的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -c com/example/spring2gx/mains/PrintMessage</span><br></pre></td></tr></table></figure>
<p><img src="/img/posts/e8fc757f9a335c352ed4d49867d38aa6.jpg" alt="img"></p>
<p>我推荐你在一个Java测试类中编写你所需的代码、对其进行编译，然后通过javap -c来运行它，以便查看精确的字节码。在上面的样例代码中，以蓝字显示的所有内容都是字节码。其中的每一行都是一个单字节的操作码，后面跟着零个或更多的参数。我们需要为目标代码确定这些参数，它们通常可以通过对原始类执行javap-c -v进行抽取（这里-v代表的意思是verbose，将会展示常量池）。</p>
<p>我鼓励读者查阅一下 <a href="https://www.open-open.com/misc/goto?guid=4959727767158147254" target="_blank" rel="noopener">JVM规范</a> ，该规范定义了所有的字节码。有一些操作，比如load和store（会将数据在操作栈和本地变量之间进行转移），针对每种参数形式都进行了重载。例如，ILOAD会将一个整型值的本地变量推送到栈中，而LLOAD会对长整型执行相同的操作。</p>
<p>除此之外，还有像invokeVirtual、invokeSpecial、invokeStatic这样的操作，以及最近新添加的invokeDynamic，它们分别用来调用标准的实例方法、构造器、静态方法以及动态类型的JVM语言中的动态方法。另外，还有创建新对象的new操作符，以及复制栈顶操作数的指令。</p>
<p>总结起来，ASM的优势在于：</p>
<ul>
<li>它的内存占用很小；</li>
<li>它的运行通常会非常快；</li>
<li>在网上，它的文档很丰富；</li>
<li>所有的操作码都是可用的，所以可以通过它做很多的事情；</li>
<li>有很多的社区支持。</li>
</ul>
<p>它只有一个不足之处，但这是很大的不足：我们编写的是字节码，所以需要理解在幕后是如何运行的，这样的话，开发人员所需要的时间就会增加。</p>
<h2 id="我们学到了什么"><a href="#我们学到了什么" class="headerlink" title="我们学到了什么"></a>我们学到了什么</h2><ul>
<li>当我们处理字节码操纵时，很重要的一点就是步子不要太大。不要编写大量的字节码并希望它们能够立即通过验证并且可以执行。每次只编写一行，考虑一下在你的栈中会有什么，考虑一下局部变量，然后再写下一行。如果它不能通过验证器的校验，那么每次只对一个地方进行修改，否则的话，你永远无法让其正常运行起来。另外，还需要记住，除了JVM的验证器以外，ASM还维护了一个单独的字节码验证器，所以我们最好运行这两个验证器，检查你的字节码是否能够通过它们两者的校验。</li>
<li>在修改类的时候，很重要的一点就是要考虑类加载机制。当我们使用Java agent的时候，它的transformer会在类加载进JVM时接触到每个类，并不关心是哪个类加载器加载的它。所以，我们需要确保类加载器也能看到对应的对象，否则的话，就会遇到麻烦。</li>
<li>如果你将Javassist与应用服务器组合使用时，应用服务器会有多个类加载器，注意类池（class pool）需要能够访问到你的类对象。我们可能需要为类池注册一个新的类路径，以确保它能访问类对象。你可以将类池链接起来，就像Java将类加载器链接起来一样，这样，如果在类池中无法找到CTClass对象的话，它能够访问它的父类池进行查找。</li>
<li>最后，还有很重要的一点需要注意，那就是JDK本身也有转换类的功能，JDK已经转换过的类会有一些特定的限制。我们可以修改方法的实现，但是与原始的转换不同，此时，重新转换就不允许改变类的结构了，例如添加新的域或方法，或者修改签名。</li>
</ul>
<p>字节码操纵能够让我们的生活更加轻松。我们可以查找缺陷、添加日志（就像之前所讨论的）、混淆源码、执行像Spring或Hibernate这样的预处理，甚至编写自己的语言编译器。我们还可以限制API调用、通过分析代码来查看是否有多个线程访问同一个集合、从数据库中懒加载数据，并且还可以通过探测JAR包，寻找这些包的差异。</p>
<p>所以，我鼓励你选择某个字节码操纵框架为友，也许有一天，它就能拯救你的工作。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2018/09/100027.html" class="pre-post btn btn-default" title='Java逆向基础之十四.动态生成类'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Java逆向基础之十四.动态生成类</span>
        </a>
    
    
        <a href="/archives/2018/09/100025.html" class="next-post btn btn-default" title='Java逆向基础之十三.字节码修改工具'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Java逆向基础之十三.字节码修改工具</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#字节码操纵框架"><span class="toc-text">字节码操纵框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我们为什么应该关注字节码操纵呢？"><span class="toc-text">我们为什么应该关注字节码操纵呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我们的样例"><span class="toc-text">我们的样例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Javassist"><span class="toc-text">Javassist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASM"><span class="toc-text">ASM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我们学到了什么"><span class="toc-text">我们学到了什么</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2023&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>