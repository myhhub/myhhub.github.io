<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="git">


    <meta name="description" content="一. 常用命令1. gitk，输入该命令后，简单的图形方式2. git config -l，列出配置文件git config --global user.name &quot;xxx&quot;...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>git使用手册 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="git使用手册">
            
	            git使用手册
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/devops/">运维</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/git/">git</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2018/11/10</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1934</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="一-常用命令"><a href="#一-常用命令" class="headerlink" title="一. 常用命令"></a>一. 常用命令</h1><h2 id="1-gitk，输入该命令后，简单的图形方式"><a href="#1-gitk，输入该命令后，简单的图形方式" class="headerlink" title="1. gitk，输入该命令后，简单的图形方式"></a>1. gitk，输入该命令后，简单的图形方式</h2><h2 id="2-git-config-l，列出配置文件"><a href="#2-git-config-l，列出配置文件" class="headerlink" title="2. git config -l，列出配置文件"></a>2. git config -l，列出配置文件</h2><pre><code>git config --global user.name &quot;xxx&quot;
git config --global  user.email  &quot;xxx&quot;
</code></pre><p>  要删除：git config –unset user.username</p>
<h2 id="3-设置别名"><a href="#3-设置别名" class="headerlink" title="3. 设置别名"></a>3. 设置别名</h2><p>   git config alias.con ‘config -l’</p>
<p>  则git con等同于git config -l</p>
<h2 id="4-GIT的文件，刚新建立的时候，都为UNTRACKED状态，"><a href="#4-GIT的文件，刚新建立的时候，都为UNTRACKED状态，" class="headerlink" title="4. GIT的文件，刚新建立的时候，都为UNTRACKED状态，"></a>4. GIT的文件，刚新建立的时候，都为UNTRACKED状态，</h2><p>建立touch .gitignore 文件,内容为：<br>.gitignore<br>xxx(要忽略的文件或文件夹）</p>
<p>  则 git add xxx的文件会跟踪是否修改新增删除；<br>.gitignore的文件，不会显示是否修改，也不显示其信息；<br> 设置排除忽略，使用！符号<br>  *.txt</p>
<p>  #注释<br>   !note.txt  (忽略所有TXT,不包括note.txt文件）</p>
<h2 id="5-git-log查看历史记录"><a href="#5-git-log查看历史记录" class="headerlink" title="5. git log查看历史记录"></a>5. git log查看历史记录</h2><h2 id="6-首先，Git必须知道当前版本是哪个版本，"><a href="#6-首先，Git必须知道当前版本是哪个版本，" class="headerlink" title="6. 首先，Git必须知道当前版本是哪个版本，"></a>6. 首先，Git必须知道当前版本是哪个版本，</h2><p>在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，<br>所以写成HEAD~100</p>
<p>  回退到上1个版本（对于GIT ADD,GIT COMMIT后的文件都可以这样做）<br> git reset –hard HEAD^<br>回退到某个版本<br>git reset –hard 3628164（这个是版本号，用git log看）</p>
<p>版本回退</p>
<p>阅读: 838585<br>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>
<p>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>然后尝试提交：</p>
<p>$ git add readme.txt<br>$ git commit -m “append GPL”<br>[master 3628164] append GPL<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<p>Git is a version control system.<br>Git is free software.<br>版本2：add distributed</p>
<p>Git is a distributed version control system.<br>Git is free software.<br>版本3：append GPL</p>
<p>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看：</p>
<p>$ git log<br>commit 3628164fb26d48395383f8f31179f24e0882e1e0<br>Author: Michael Liao <a href="mailto:&#97;&#x73;&#x6b;&#120;&#x75;&#101;&#x66;&#x65;&#x6e;&#103;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;" target="_blank" rel="noopener">&#97;&#x73;&#x6b;&#120;&#x75;&#101;&#x66;&#x65;&#x6e;&#103;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;</a><br>Date:   Tue Aug 20 15:11:49 2013 +0800</p>
<pre><code>append GPL
</code></pre><p>commit ea34578d5496d7dd233c827ed32a8cd576c5ee85<br>Author: Michael Liao <a href="mailto:&#97;&#115;&#107;&#120;&#x75;&#101;&#102;&#101;&#x6e;&#103;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#97;&#115;&#107;&#120;&#x75;&#101;&#102;&#101;&#x6e;&#103;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a><br>Date:   Tue Aug 20 14:53:12 2013 +0800</p>
<pre><code>add distributed
</code></pre><p>commit cb926e7ea50ad11b8f9e909c05226233bf755030<br>Author: Michael Liao <a href="mailto:&#x61;&#x73;&#107;&#120;&#x75;&#101;&#x66;&#101;&#110;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;" target="_blank" rel="noopener">&#x61;&#x73;&#107;&#120;&#x75;&#101;&#x66;&#101;&#110;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a><br>Date:   Mon Aug 19 17:51:55 2013 +0800</p>
<pre><code>wrote a readme file
</code></pre><p>git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。<br>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数：</p>
<p>$ git log –pretty=oneline<br>3628164fb26d48395383f8f31179f24e0882e1e0 append GPL<br>ea34578d5496d7dd233c827ed32a8cd576c5ee85 add distributed<br>cb926e7ea50ad11b8f9e909c05226233bf755030 wrote a readme file<br>需要友情提示的是，你看到的一大串类似3628164…882e1e0的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p>
<p>git-log-timeline</p>
<p>好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“add distributed”的那个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p>
<p>现在，我们要把当前版本“append GPL”回退到上一个版本“add distributed”，就可以使用git reset命令：</p>
<p>$ git reset –hard HEAD^<br>HEAD is now at ea34578 add distributed<br>–hard参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看readme.txt的内容是不是版本add distributed：</p>
<p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software.<br>果然。</p>
<p>还可以继续回退到上一个版本wrote a readme file，不过且慢，然我们用git log再看看现在版本库的状态：</p>
<p>$ git log<br>commit ea34578d5496d7dd233c827ed32a8cd576c5ee85<br>Author: Michael Liao <a href="mailto:&#97;&#x73;&#x6b;&#x78;&#117;&#x65;&#102;&#x65;&#110;&#x67;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#97;&#x73;&#x6b;&#x78;&#117;&#x65;&#102;&#x65;&#110;&#x67;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a><br>Date:   Tue Aug 20 14:53:12 2013 +0800</p>
<pre><code>add distributed
</code></pre><p>commit cb926e7ea50ad11b8f9e909c05226233bf755030<br>Author: Michael Liao <a href="mailto:&#x61;&#115;&#x6b;&#x78;&#x75;&#101;&#x66;&#101;&#110;&#103;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x61;&#115;&#x6b;&#x78;&#x75;&#101;&#x66;&#101;&#110;&#103;&#64;&#103;&#x6d;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a><br>Date:   Mon Aug 19 17:51:55 2013 +0800</p>
<pre><code>wrote a readme file
</code></pre><p>最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是3628164…，于是就可以指定回到未来的某个版本：</p>
<p>$ git reset –hard 3628164<br>HEAD is now at 3628164 append GPL<br>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看readme.txt的内容：</p>
<p>$</p>
<p> 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：</p>
<p>$ git reflog<br>ea34578 HEAD@{0}: reset: moving to HEAD^<br>3628164 HEAD@{1}: commit: append GPL<br>ea34578 HEAD@{2}: commit: add distributed<br>cb926e7 HEAD@{3}: commit (initial): wrote a readme file<br>  则可以继续 git reset –hard 3628164</p>
<h2 id="7-我们把文件往Git版本库里添加的时候，是分两步执行的："><a href="#7-我们把文件往Git版本库里添加的时候，是分两步执行的：" class="headerlink" title="7. 我们把文件往Git版本库里添加的时候，是分两步执行的："></a>7. 我们把文件往Git版本库里添加的时候，是分两步执行的：</h2><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支</p>
<h2 id="8-git-diff-HEAD-–-readme-txt命令可以查看工作区和版本库里面最新版本的区别："><a href="#8-git-diff-HEAD-–-readme-txt命令可以查看工作区和版本库里面最新版本的区别：" class="headerlink" title="8. git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别："></a>8. git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</h2><h2 id="9-撤销修改"><a href="#9-撤销修改" class="headerlink" title="9. 撤销修改"></a>9. 撤销修改</h2><p>   1） 放弃工作区修改，gid add，GIT COMMIT后，放弃工作区修改</p>
<p>$ git checkout – readme.txt<br>命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<p> 比如test1.txt在GIT ADD后到暂存区，没COMMIT前，要丢掉：<br>  git checkout – test1.txt<br>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<h2 id="10-删除文件"><a href="#10-删除文件" class="headerlink" title="10. 删除文件"></a>10. 删除文件</h2><pre><code>一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit：
</code></pre><p>$ git rm test.txt<br>rm ‘test.txt’<br>$ git commit -m “remove test.txt”<br>[master d17efd8] remove test.txt<br> 1 file changed, 1 deletion(-)<br> delete mode 100644 test.txt<br>现在，文件就从版本库中被删除了。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<p>$ git checkout – test.txt<br>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h2 id="11-本地库关联远程库："><a href="#11-本地库关联远程库：" class="headerlink" title="11. 本地库关联远程库："></a>11. 本地库关联远程库：</h2><pre><code>git remote add origin git@github.com:jackyrong/learngit.git
</code></pre><h2 id="12-本地库的所有内容推送到远程库上："><a href="#12-本地库的所有内容推送到远程库上：" class="headerlink" title="12. 本地库的所有内容推送到远程库上："></a>12. 本地库的所有内容推送到远程库上：</h2><p>$ git push -u origin master(第一次推送master分支的所有内容；)<br>只要本地作了提交，就可以通过命令：</p>
<p>$ git push origin master</p>
<h2 id="13-克隆GIT："><a href="#13-克隆GIT：" class="headerlink" title="13. 克隆GIT："></a>13. 克隆GIT：</h2><pre><code>git clone git@github.com:jackyrong/gitskills.git
</code></pre><h2 id="14-创建分支"><a href="#14-创建分支" class="headerlink" title="14. 创建分支"></a>14. 创建分支</h2><p> 首先，我们创建dev分支，然后切换到dev分支：</p>
<p>$ git checkout -b dev<br>Switched to a new branch ‘dev’</p>
<p>  git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p>
<p>$ git branch dev<br>$ git checkout dev<br>Switched to branch ‘dev’<br>然后，用git branch命令查看当前分支：</p>
<p>$ git branch</p>
<ul>
<li>dev<br>master<br>git branch命令会列出所有分支，当前分支前面会标一个*号。</li>
</ul>
<p>现在，我们把dev分支的工作成果合并到master分支上：</p>
<p>$ git merge dev</p>
<p>git merge命令用于合并指定分支到当前分支。（因为当前切换到DEV了）</p>
<p>  合并完成后，就可以放心地删除dev分支了：</p>
<p>$ git branch -d dev<br>Deleted branch dev (was fec145a).<br>删除后，查看branch，就只剩下master分支了：</p>
<p>$ git branch</p>
<ul>
<li>master</li>
</ul>
<h2 id="15-分支管理策略"><a href="#15-分支管理策略" class="headerlink" title="15. 分支管理策略"></a>15. 分支管理策略</h2><pre><code>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。
</code></pre><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。<br> git merge –no-ff -m “merge with no-ff” dev<br>加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并</p>
<h2 id="16-BUG分支"><a href="#16-BUG分支" class="headerlink" title="16. BUG分支"></a>16. BUG分支</h2><pre><code>Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：
比如某个文件，只是ADD了，但没有COMMIT，则：
  $ git stash
</code></pre><p>Saved working directory and index state WIP on dev: 6224937 add merge<br>HEAD is now at 6224937 add merge</p>
<pre><code>然后假设MASTER分支上修复
</code></pre><p>$ git checkout master</p>
<p> git checkout -b issue-101<br>修改后<br>$ git add readme.txt<br>$ git commit -m “fix bug 101”<br>修复完成后，切换到master分支，并完成合并，最后删除issue-101分支：</p>
<p>$ git checkout master<br>Switched to branch ‘master’<br>Your branch is ahead of ‘origin/master’ by 2 commits.<br>$ git merge –no-ff -m “merged bug fix 101” issue-101<br>Merge made by the ‘recursive’ strategy.<br> readme.txt |    2 +-<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br>$ git branch -d issue-101<br>Deleted branch issue-101 (was cc17032).</p>
<p>现在，是时候接着回到dev分支干活了！</p>
<p>$ git checkout dev<br>Switched to branch ‘dev’<br>$ git status<br># On branch dev<br>nothing to commit (working directory clean)<br>工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看：</p>
<p>$ git stash list<br>stash@{0}: WIP on dev: 6224937 add merge</p>
<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p>
<p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p>
<p>$ git stash pop</p>
<h2 id="17-强行删除分支"><a href="#17-强行删除分支" class="headerlink" title="17. 强行删除分支"></a>17. 强行删除分支</h2><pre><code>git branch -D feature-vulcan（分支名）
</code></pre><h2 id="18-查看远程库的信息："><a href="#18-查看远程库的信息：" class="headerlink" title="18. 查看远程库的信息："></a>18. 查看远程库的信息：</h2><pre><code>git remote -v
把本地的东西都推送到远程分支上：
  git push origin master
</code></pre><h2 id="19-真正开发的时候，"><a href="#19-真正开发的时候，" class="headerlink" title="19. 真正开发的时候，"></a>19. 真正开发的时候，</h2><pre><code>1） git clone git@github.com:jackyrong/learngit.git

clone下来后，默认情况只看到master分支，
</code></pre><p>要在DEV分支上开发：<br>      git checkout -b dev origin/dev<br> 另外的人先：git pull origin/dev</p>
<p>小结</p>
<p>查看远程库信息，使用git remote -v；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p>
<p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p>
<h2 id="20-标签管理"><a href="#20-标签管理" class="headerlink" title="20. 标签管理"></a>20. 标签管理</h2><pre><code>  $ git tag v1.0
git tag查看所有标签
</code></pre><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<p>$ git log –pretty=oneline –abbrev-commit<br>6a5819e merged bug fix 101<br>cc17032 fix bug 101<br>7825a50 merge with no-ff<br>6224937 add merge<br>59bc1cb conflict fixed<br>400b400 &amp; simple<br>75a857c AND simple<br>fec145a branch test<br>d17efd8 remove test.txt</p>
<p>比方说要对add merge这次提交打标签，它对应的commit id是6224937，敲入命令：</p>
<p>$ git tag v0.9 6224937<br>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p>
<p>$ git tag -a v0.1 -m “version 0.1 released” 3628164</p>
<p>如果标签打错了，也可以删除：</p>
<p>$ git tag -d v0.1<br>Deleted tag ‘v0.1’ (was e078af9)<br>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令git push origin <tagname>：</tagname></p>
<p>$ git push origin v1.0<br>Total 0 (delta 0), reused 0 (delta 0)<br>To <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/learngit.git</p>
<ul>
<li>[new tag]         v1.0 -&gt; v1.0<br>或者，一次性推送全部尚未推送到远程的本地标签：</li>
</ul>
<p>$ git push origin –tags</p>
<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<p>$ git tag -d v0.9<br>Deleted tag ‘v0.9’ (was 6224937)<br>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<p>$ git push origin :refs/tags/v0.9</p>
<h2 id="21-从GITHUB的开源项目中，可以FORK一个出来，用自己的账号"><a href="#21-从GITHUB的开源项目中，可以FORK一个出来，用自己的账号" class="headerlink" title="21. 从GITHUB的开源项目中，可以FORK一个出来，用自己的账号"></a>21. 从GITHUB的开源项目中，可以FORK一个出来，用自己的账号</h2><p>CLONE<br>git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:jackyrong/bootstrap.git</p>
<p>然后就可以本地修改，然后可以PUSH给远端的真正库</p>
<h2 id="22-rebase-命令将提交到某一分支上的所有修改都移至另一分支上"><a href="#22-rebase-命令将提交到某一分支上的所有修改都移至另一分支上" class="headerlink" title="22.  rebase 命令将提交到某一分支上的所有修改都移至另一分支上"></a>22.  rebase 命令将提交到某一分支上的所有修改都移至另一分支上</h2><h2 id="23-一个库关联多个GIT"><a href="#23-一个库关联多个GIT" class="headerlink" title="23.  一个库关联多个GIT"></a>23.  一个库关联多个GIT</h2><p>git remote add github <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/learngit.git<br>然后，先关联GitHub的远程库：</p>
<p>git remote add github <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/learngit.git<br>注意，远程库的名称叫github，不叫origin了。</p>
<p>接着，再关联码云的远程库：</p>
<p>git remote add gitee <a href="mailto:git@gitee.com" target="_blank" rel="noopener">git@gitee.com</a>:liaoxuefeng/learngit.git<br>同样注意，远程库的名称叫gitee，不叫origin。</p>
<p>现在，我们用git remote -v查看远程库信息，可以看到两个远程库：</p>
<p>git remote -v<br>gitee    <a href="mailto:git@gitee.com" target="_blank" rel="noopener">git@gitee.com</a>:liaoxuefeng/learngit.git (fetch)<br>gitee    <a href="mailto:git@gitee.com" target="_blank" rel="noopener">git@gitee.com</a>:liaoxuefeng/learngit.git (push)<br>github    <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/learngit.git (fetch)<br>github    <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:michaelliao/learngit.git (push)<br>如果要推送到GitHub，使用命令：</p>
<p>git push github master<br>如果要推送到码云，使用命令：</p>
<p>git push gitee master</p>
<h2 id="24-GIT文件的忽略"><a href="#24-GIT文件的忽略" class="headerlink" title="24.  GIT文件的忽略"></a>24.  GIT文件的忽略</h2><pre><code>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore
</code></pre><p>不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<p>忽略操作系统自动生成的文件，比如缩略图等；<br>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；<br>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。<br>举个例子：</p>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件：</p>
<p># Windows:<br>Thumbs.db<br>ehthumbs.db<br>Desktop.ini<br>然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录：</p>
<p># Python:<br><em>.py[cod]
</em>.so<br><em>.egg
</em>.egg-info<br>dist<br>build<br>加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下：</p>
<p># Windows:<br>Thumbs.db<br>ehthumbs.db<br>Desktop.ini</p>
<p># Python:<br><em>.py[cod]
</em>.so<br><em>.egg
</em>.egg-info<br>dist<br>build</p>
<p># My configurations:<br>db.ini<br>deploy_key_rsa<br>最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。</p>
<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了：</p>
<p>$ git add App.class<br>The following paths are ignored by one of your .gitignore files:<br>App.class<br>Use -f if you really want to add them.<br>如果你确实想添加该文件，可以用-f强制添加到Git：</p>
<p>$ git add -f App.class<br>或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：</p>
<p>$ git check-ignore -v App.class<br>.gitignore:3:*.class    App.class<br>Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<h2 id="25-配置别名"><a href="#25-配置别名" class="headerlink" title="25. 配置别名"></a>25. 配置别名</h2><pre><code>git config --global alias.st status  //st代替status
</code></pre><h1 id="二-git大小写问题"><a href="#二-git大小写问题" class="headerlink" title="二. git大小写问题"></a>二. git大小写问题</h1><h2 id="1-问题复现"><a href="#1-问题复现" class="headerlink" title="1. 问题复现"></a>1. 问题复现</h2><p>新建一个 a.js 文件(大小写不敏感的状态下)，并提交<br>修改本地 a.js 变为 A.js，文件内容无变更，无法提交<br>执行git config core.ignorecase false，修改 大小写敏感 规则，然后提交，查看结果，此时会存在 大小写 同时存在的文件<br>此时某种机缘下，再次执行 git config core.ignorecase true，大小写不敏感，<br>此时执行 git push ， 即把最新的更新都更新到了 a.js 中<br>此时再修改 大小写敏感规则为敏感， 执行 git pull ，并不会拿到最新的更新。比如自己想要的是第一次修改后的 A.js ，但是服务器有一个没有更新的 A.js 和 有更新的 a.js,而你只能拿到前者，所以就会遇到各种各样的坑……</p>
<h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p>执行git config –global core.ignorecase false，全局设置 大小写敏感 。</p>
<h3 id="2-1-文件变更比较少的情况"><a href="#2-1-文件变更比较少的情况" class="headerlink" title="2.1. 文件变更比较少的情况"></a>2.1. 文件变更比较少的情况</h3><p>直接使用以下命令重命名文件，在 git 中不要直接修改文件名，最好的办法是使用下面的方式，</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git mv -f [你想要删掉的文件] [你想要留下的文件]</span><br><span class="line">git mv -f <span class="selector-tag">a</span><span class="selector-class">.js</span> A.js</span><br><span class="line"></span><br><span class="line">等同于：</span><br><span class="line"></span><br><span class="line">git rm <span class="selector-tag">a</span>.js</span><br><span class="line">git add A.js</span><br></pre></td></tr></table></figure>
<p>这个命令的目的就是删除不需要的大小写同名文件，修改后 git push 提交变更即可。</p>
<p><strong>tips:</strong></p>
<p>因为 git 默认大小写不敏感，所以最好添加项目配置文件,设置 大小写敏感。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch .gitconfig</span><br><span class="line">git<span class="built_in"> config </span>core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-变更比较多，并且拥有分支较高权限"><a href="#2-2-变更比较多，并且拥有分支较高权限" class="headerlink" title="2.2. 变更比较多，并且拥有分支较高权限"></a>2.2. 变更比较多，并且拥有分支较高权限</h3><ul>
<li>在 github 删除该分支</li>
<li>本地执行 git rm -r –cached . (注意后面‘点号’)</li>
<li>然后重新 git push，就ok了</li>
<li>此法不太好，有点暴力，容易出问题，但适用于 变更发生于近期的情况。</li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>其实看解决办法的话，只是一个很小的问题，但是出现的 bug 确实是让人很头疼的，因为 mac windows 在不设置大小写敏感规则的时候默认大小写是不敏感，项目部署的机器是 Linux 的，而 Linux 是大小写敏感的。所以这样的问题平时不易发现，本地调试的时候大部分时候并不会出错误，只有在项目部署的时候问题才会显示出来。</p>
<h1 id="三-GitHub等配置SSH-Key"><a href="#三-GitHub等配置SSH-Key" class="headerlink" title="三. GitHub等配置SSH Key"></a>三. GitHub等配置SSH Key</h1><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https</span>:<span class="comment">//github.com/myhhub/CTK-project.git</span></span><br><span class="line">git<span class="variable">@github</span>.<span class="attribute">com</span>:myhhub/CTK-project.git</span><br></pre></td></tr></table></figure>
<p>上面两个地址展示的是同一个项目，但是这两个地址之间有什么联系呢？<br>前者是https url 直接有效网址打开，但是用户每次通过git提交的时候都要输入用户名和密码，有没有简单的一点的办法，一次配置，永久使用呢？当然，所以有了第二种地址，也就是SSH URL，那如何配置就是本文要分享的内容。<br>GitHub配置SSH Key的目的是为了帮助我们在通过git提交代码是，不需要繁琐的验证过程，简化操作流程。</p>
<p>步骤</p>
<h2 id="1-设置git的user-name和email"><a href="#1-设置git的user-name和email" class="headerlink" title="1. 设置git的user name和email"></a>1. 设置git的user name和email</h2><p>   如果你是第一次使用，或者还没有配置过的话需要操作一下命令，自行替换相应字段。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">"myhhub"</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email  <span class="string">"yh_ma@qq.com"</span></span><br></pre></td></tr></table></figure>
<p>说明：git config –list 查看当前Git环境所有配置，还可以配置一些命令别名之类的。</p>
<h2 id="2-检查是否存在SSH-Key"><a href="#2-检查是否存在SSH-Key" class="headerlink" title="2. 检查是否存在SSH Key"></a>2. 检查是否存在SSH Key</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.ssh</span></span><br><span class="line"><span class="keyword">ls</span></span><br><span class="line">或者</span><br><span class="line">ll</span><br><span class="line"><span class="string">//</span>看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key</span><br></pre></td></tr></table></figure>
<p>如果没有SSH Key，则需要先生成一下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-t</span> <span class="selector-tag">rsa</span> <span class="selector-tag">-C</span> "<span class="selector-tag">yh_ma</span>@<span class="keyword">qq</span>.<span class="keyword">com</span>"</span><br></pre></td></tr></table></figure></p>
<p>执行之后继续执行以下命令来获取SSH Key<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~<span class="string">/.ssh</span></span><br><span class="line"><span class="keyword">ls</span></span><br><span class="line">或者</span><br><span class="line">ll</span><br><span class="line"><span class="string">//</span>看是否存在 id_rsa 和 id_rsa.pub文件，如果存在，说明已经有SSH Key</span><br></pre></td></tr></table></figure></p>
<h2 id="3-获取SSH-Key"><a href="#3-获取SSH-Key" class="headerlink" title="3. 获取SSH Key"></a>3. 获取SSH Key</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br><span class="line"><span class="comment">//拷贝秘钥 ssh-rsa开头</span></span><br></pre></td></tr></table></figure>
<h2 id="4-GitHub添加SSH-Key"><a href="#4-GitHub添加SSH-Key" class="headerlink" title="4. GitHub添加SSH Key"></a>4. GitHub添加SSH Key</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GitHub点击用户头像，选择setting</span><br></pre></td></tr></table></figure>
<p>新建一个SSH Key<br>取个名字，把之前拷贝的秘钥复制进去，添加就好啦。</p>
<h2 id="5-验证和修改"><a href="#5-验证和修改" class="headerlink" title="5. 验证和修改"></a>5. 验证和修改</h2><p>测试是否成功配置SSH Key<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -<span class="type">T</span> git<span class="meta">@github</span>.com</span><br><span class="line"><span class="comment">//运行结果出现类似如下</span></span><br><span class="line"><span class="type">Hi</span> myhhub! <span class="type">You</span><span class="symbol">'ve</span> successfully authenticated, but <span class="type">GitHub</span> does not provide shell</span><br></pre></td></tr></table></figure></p>
<p>之前已经是https的链接，现在想要用SSH提交怎么办？<br>直接修改项目目录下 .git文件夹下的config文件，将地址修改为SSH地址。</p>
<h1 id="四-代理配置-Git-HTTP-SSH"><a href="#四-代理配置-Git-HTTP-SSH" class="headerlink" title="四. 代理配置(Git HTTP+SSH)"></a>四. 代理配置(Git HTTP+SSH)</h1><h2 id="1-HTTP-代理"><a href="#1-HTTP-代理" class="headerlink" title="1. HTTP 代理"></a>1. HTTP 代理</h2><p>HTTP 代理相对简单</p>
<figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTP 代理</span></span><br><span class="line">git config --<span class="keyword">global</span> <span class="keyword">http</span>.proxy <span class="keyword">http</span>://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1080</span></span><br><span class="line">git config --<span class="keyword">global</span> https.proxy <span class="keyword">http</span>://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Socks5 代理</span></span><br><span class="line">git config --<span class="keyword">global</span> <span class="keyword">http</span>.proxy socks5://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1080</span></span><br><span class="line">git config --<span class="keyword">global</span> https.proxy socks5://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config --<span class="keyword">global</span> --<span class="keyword">unset</span> <span class="keyword">http</span>.proxy</span><br><span class="line">git config --<span class="keyword">global</span> --<span class="keyword">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>注意这里的 <code>socks5</code> 仅仅是代理使用的协议，它依然是针对 http 设置的，所以仅对 http 协议的仓库有效。使用 <code>git@xxx</code> 这种 ssh 连接的不会使用代理。</p>
<p>也可以分域名设置代理：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">git config <span class="params">--global</span> http.https:<span class="string">//github.com.proxy</span> http:<span class="string">//127.0.0.1</span><span class="function">:1080</span></span><br><span class="line">git config <span class="params">--global</span> https.https:<span class="string">//github.com.proxy</span> https:<span class="string">//127.0.0.1</span><span class="function">:1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config <span class="params">--global</span> <span class="params">--unset</span> http.https:<span class="string">//github.com.proxy</span></span><br><span class="line">git config <span class="params">--global</span> <span class="params">--unset</span> https.https:<span class="string">//github.com.proxy</span></span><br></pre></td></tr></table></figure>
<h2 id="2-SSH-代理"><a href="#2-SSH-代理" class="headerlink" title="2. SSH 代理"></a>2. SSH 代理</h2><p>SSH 代理需要在密钥目录 (<code>~/.ssh</code>) (Windows 下是 <code>C:\Users\{UserName}\.ssh</code>) 新建一个 <code>config</code> 文件，没有后缀名。</p>
<p>Linux 系统写入以下配置（未验证）：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 需要 <span class="selector-tag">netcat</span></span><br><span class="line"><span class="selector-tag">ProxyCommand</span> <span class="selector-tag">nc</span> <span class="selector-tag">-v</span> <span class="selector-tag">-x</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:1080</span> %<span class="selector-tag">h</span> %<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure>
<p>Windows:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">-S</span> 为 <span class="selector-tag">socks</span>, <span class="selector-tag">-H</span> 为 <span class="selector-tag">HTTP</span></span><br><span class="line"><span class="selector-tag">ProxyCommand</span> <span class="selector-tag">connect</span> <span class="selector-tag">-S</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:1080</span> %<span class="selector-tag">h</span> %<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果找不到 <code>connect</code> 命令那么指定其绝对路径，一般在 git 安装目录下 <code>\mingw64\bin\connect.exe</code>.</p>
<p>赠送一个 <code>connect</code> 的<a href="https://bitbucket.org/gotoh/connect/wiki/Home#!more-detail" target="_blank" rel="noopener">官方文档</a>。</p>
</blockquote>
<p>也可以分域名代理：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Host</span> <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">    <span class="selector-tag">ProxyCommand</span> <span class="selector-tag">connect</span> <span class="selector-tag">-S</span> 127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span><span class="selector-pseudo">:1080</span> %<span class="selector-tag">h</span> %<span class="selector-tag">p</span></span><br></pre></td></tr></table></figure>
<h1 id="五-简单的代码提交流程"><a href="#五-简单的代码提交流程" class="headerlink" title="五. 简单的代码提交流程"></a>五. 简单的代码提交流程</h1><ol>
<li>git clone  克隆GIT</li>
<li>git status 查看工作区代码相对于暂存区的差别</li>
<li>git add . 将当前目录下修改的所有代码从工作区添加到暂存区 . 代表当前目录</li>
<li>git commit -m ‘注释’ 将缓存区内容添加到本地仓库</li>
<li>git push origin master 将本地版本库推送到远程服务器， </li>
<li>origin是远程主机，master表示是远程服务器上的master分支，分支名是可以修改的</li>
</ol>
<h2 id="1-Git-add"><a href="#1-Git-add" class="headerlink" title="1. Git add"></a>1. Git add</h2><p>git add [参数] &lt;路径&gt;　作用就是将我们需要提交的代码从工作区添加到暂存区，就是告诉git系统，我们要提交哪些文件，之后就可以使用git commit命令进行提交了。<br>为了方便下面都用 . 来标识路径， . 表示当前目录，路径可以修改，下列操作的作用范围都在版本库之内。</p>
<ul>
<li><p>git add .<br>不加参数默认为将修改操作的文件和未跟踪新添加的文件添加到git系统的暂存区，注意不包括删除</p>
</li>
<li><p>git add -u .<br>-u 表示将已跟踪文件中的修改和删除的文件添加到暂存区，不包括新增加的文件，注意这些被删除的文件被加入到暂存区再被提交并推送到服务器的版本库之后这个文件就会从git系统中消失了。</p>
</li>
<li><p>git add -A .<br>-A 表示将所有的已跟踪的文件的修改与删除和新增的未跟踪的文件都添加到暂存区。</p>
</li>
</ul>
<h2 id="2-Git-commit"><a href="#2-Git-commit" class="headerlink" title="2. Git commit"></a>2. Git commit</h2><p> git commit 主要是将暂存区里的改动给提交到本地的版本库。每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id，<br> commit-id 在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里.</p>
<ul>
<li>git commit -m ‘message’<br>-m 参数表示可以直接输入后面的“message”，如果不加 -m参数，那么是不能直接输入message的，而是会调用一个编辑器一般是vim来让你输入这个message，<br>message即是我们用来简要说明这次提交的语句。<br>git commit -am ‘message’ -am等同于-a -m<br>-a参数可以将所有已跟踪文件中的执行修改或删除操作的文件都提交到本地仓库，即使它们没有经过git add添加到暂存区，<br>注意: 新加的文件（即没有被git系统管理的文件）是不能被提交到本地仓库的。</li>
</ul>
<h2 id="3-Git-push"><a href="#3-Git-push" class="headerlink" title="3. Git push"></a>3. Git push</h2><p> 在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了，如果不清楚版本库的构成，可以查看我的另一篇，git 仓库的基本结构。<br> git push的一般形式为 git push &lt;远程主机名&gt; &lt;本地分支名&gt; &lt;远程分支名&gt; ，例如 git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名。第一个master是本地分支名，第二个master是远程分支名。</p>
<ul>
<li><p>git push origin master<br>如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建</p>
</li>
<li><p>git push origin ：refs/for/master<br>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支，等同于 git push origin –delete master</p>
</li>
<li><p>git push origin<br>如果当前分支与远程分支存在追踪关系，则本地分支和远程分支都可以省略，将当前分支推送到origin主机的对应分支</p>
</li>
<li><p>git push<br>如果当前分支只有一个远程分支，那么主机名都可以省略，形如 git push，可以使用git branch -r ，查看远程的分支名</p>
</li>
<li><p>关于 refs/for：<br>refs/for 的意义在于我们提交代码到服务器之后是需要经过code review 之后才能进行merge的，而refs/heads 不需要</p>
</li>
</ul>
<h1 id="六-git-lfs"><a href="#六-git-lfs" class="headerlink" title="六.git-lfs"></a>六.git-lfs</h1><h2 id="什么是-git-lfs"><a href="#什么是-git-lfs" class="headerlink" title="什么是 git-lfs"></a>什么是 <code>git-lfs</code></h2><h3 id="Github-对文件大小的限制"><a href="#Github-对文件大小的限制" class="headerlink" title="Github 对文件大小的限制"></a>Github 对文件大小的限制</h3><p>   如果你在命令行用 <code>git push</code> &gt; 50 MB 的文件，你会收到一个 <code>warning</code>，但是你仍然可以正常 <code>push</code>，但是 &gt; 100 MB 的时候就无法 <code>push</code> 了</p>
<p>   如果你在浏览器要上传文件的话，限制更为严重，不能超过 25 MB</p>
<p>   另外有几点值得注意：</p>
<ol>
<li>Github 建议仓库的大小理想情况下不要超过 1 GB，最好不要超过 5 GB</li>
<li><p>Github 从来不建议把仓库当成一种备份工具</p>
<h3 id="为什么需要-gif-lfs"><a href="#为什么需要-gif-lfs" class="headerlink" title="为什么需要 gif-lfs"></a>为什么需要 <code>gif-lfs</code></h3><p>前面提到的 Github 对文件大小的限制是一点</p>
<p>另外因为每次我们在使用 <code>git commit</code> 的时候，其实是给当前的仓库创建了一次快照，本质是全仓库的克隆，如果大文件太多是很不好的，你的 Git 仓库会越来越大</p>
<h3 id="什么情况下不需要用-gif-lfs"><a href="#什么情况下不需要用-gif-lfs" class="headerlink" title="什么情况下不需要用 gif-lfs"></a>什么情况下不需要用 <code>gif-lfs</code></h3></li>
<li><p>文件没有超过限制当然就没有必要用了</p>
</li>
<li>如果是要分发二进制文件（比如 *.exe）等，此时直接用 Github 提供的 release 功能就好了</li>
</ol>
<h2 id="git-lfs-原理"><a href="#git-lfs-原理" class="headerlink" title="git-lfs 原理"></a><code>git-lfs</code> 原理</h2><p>   使用 <code>gif-lfs</code> 之后，在仓库中存储的其实是对大文件的引用，可以理解为指针。而真正的大文件托管在 Git Lfs 的服务器上</p>
<p>   Github 给不同用户的 <code>git-lfs</code> 提供的额度不一样，免费用户和 Pro 用户都是 2 GB</p>
<h3 id="引用文件长什么样子"><a href="#引用文件长什么样子" class="headerlink" title="引用文件长什么样子"></a>引用文件长什么样子</h3><p>   比如官方文档里面提到的例子：</p>
   <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">version</span> http<span class="variable">s:</span>//git-lfs.github.<span class="keyword">com</span>/spec/v1</span><br><span class="line">oid <span class="built_in">sha256</span>:<span class="number">4</span>cac19622fc3ada9c0fdeadb33f88f367b541f38b89102a3f1261ac81fd5bcb5</span><br><span class="line">size <span class="number">84977953</span></span><br></pre></td></tr></table></figure>
<p>   其中 <code>version</code> 是你正在使用的 <code>git-lfs</code> 的版本，<code>oid</code> 是标志符（id），<code>size</code> 是文件的真实大小</p>
<h2 id="开始使用-git-lfs"><a href="#开始使用-git-lfs" class="headerlink" title="开始使用 git-lfs"></a>开始使用 <code>git-lfs</code></h2><h3 id="如何安装-git-lfs-Mac-环境下"><a href="#如何安装-git-lfs-Mac-环境下" class="headerlink" title="如何安装 git-lfs (Mac 环境下)"></a>如何安装 <code>git-lfs</code> (Mac 环境下)</h3>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; brew install git-lfs</span><br><span class="line">&gt; git lfa install                 <span class="comment"># 如果输出为 Git LFS initialized. 就是正常安装好了</span></span><br></pre></td></tr></table></figure>
<h3 id="Case-1-从-0-开始配置使用-git-lfs"><a href="#Case-1-从-0-开始配置使用-git-lfs" class="headerlink" title="Case 1. 从 0 开始配置使用 git-lfs"></a>Case 1. 从 0 开始配置使用 <code>git-lfs</code></h3><p>   我们要指定 <code>git-lfs</code> 会把哪些文件当作大文件，指定方式比如有：</p>
<ol>
<li>指定文件后缀名——<code>git lfs track &quot;*.filetype&quot;</code></li>
<li>指定某个目录下的所有文件——<code>git lfs track &quot;directory/*&quot;</code></li>
<li><p>具体指定某个文件——<code>git lfs track &quot;path/to/file&quot;</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt; mkdir &lt;repo&gt;</span><br><span class="line">&gt; <span class="built_in">cd</span> &lt;repo&gt;</span><br><span class="line">&gt; git init</span><br><span class="line">&gt; git lfs track <span class="string">"*.filetype"</span>			<span class="comment"># 比如 *.zip</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实 git lfs track 会修改 .gitattributes 文件的内容，可以做一个快速的验证</span></span><br><span class="line"><span class="comment"># &gt; cat .gitattributes</span></span><br><span class="line"><span class="comment"># *.zip filter=lfs diff=lfs merge=lfs -text</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面假定在 Github 有一个远程仓库供我们使用</span></span><br><span class="line"><span class="comment"># 往仓库里加你先前指定的文件类型的大文件</span></span><br><span class="line">&gt; git add . 											</span><br><span class="line">&gt; git commit -m <span class="string">""</span></span><br><span class="line">&gt; git branch -M main</span><br><span class="line">&gt; git remote add origin git@github.com:&lt;username&gt;/&lt;remote_repo_name&gt;.git		<span class="comment"># 这里替换为自己的用户名和远程仓库名</span></span><br><span class="line">&gt; git push -u origin main</span><br><span class="line"><span class="comment"># 此时命令行会显示</span></span><br><span class="line"><span class="comment"># &gt; uploading LFS objects</span></span><br><span class="line"><span class="comment"># 如果没有采用 git-lfs，则显示如下内容</span></span><br><span class="line"><span class="comment"># &gt; Enumerating objects: 3, done.</span></span><br><span class="line"><span class="comment">#   Counting objects: 100% (3/3), done.</span></span><br><span class="line"><span class="comment">#   Delta compression using up to 8 threads</span></span><br><span class="line"><span class="comment">#   Compressing objects: 100% (2/2), done.</span></span><br></pre></td></tr></table></figure>
<h3 id="Case-2-要在已有的仓库上用-git-lfs-追踪某些文件"><a href="#Case-2-要在已有的仓库上用-git-lfs-追踪某些文件" class="headerlink" title="Case 2. 要在已有的仓库上用 git-lfs 追踪某些文件"></a>Case 2. 要在已有的仓库上用 <code>git-lfs</code> 追踪某些文件</h3><p>此时只是简单的使用 <code>git lfs track &quot;&quot;</code> 是没用的，因为你之前的 commit 已经生成了快照，你无法追踪历史中的这些大文件。</p>
<p><strong><code>git-lfs</code> 只会在你开始设置的此刻之后追踪新生成的指定文件</strong></p>
<p>可以快速做个验证，假设我们还在这个仓库里⬇️</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; ls &gt; test1.txt</span><br><span class="line">&gt; ls -l &gt; test2.txt</span><br><span class="line">&gt; git add test1.txt test2.txt</span><br><span class="line">&gt; git commit -m <span class="string">"Add txt files"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设我们现在要把 txt 文件当成是大文件，我们可能会想这么做</span></span><br><span class="line">&gt; git lfs track <span class="string">"*.txt"</span></span><br><span class="line">&gt; git add .gitattributes</span><br><span class="line">&gt; git commit -m <span class="string">"Track *.txt files"</span></span><br><span class="line">&gt; git lfs ls-files                      <span class="comment"># 此时你会发现 git-lfs 并没有追踪 txt 文件</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"hello"</span> &gt; test3.txt</span><br><span class="line">&gt; git add test3.txt</span><br><span class="line">&gt; git commit -m <span class="string">"Add test3.txt"</span></span><br><span class="line">&gt; git lfs ls-files                      <span class="comment"># 此时你可以在输出中看到 test3.txt</span></span><br></pre></td></tr></table></figure>
<p>正确的方法是使用 <code>git lfs migrate</code>，这里只列举了简单的用法，更复杂的可以看看手册。比如可以用 <code>--include-ref=</code> 指定分支，多个分支的时候最好一个分支一个分支地迁移，最后是 <code>git push --all -f</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; git lfs migrate import --include=<span class="string">"*.txt"</span>  <span class="comment"># 在当前分支上执行</span></span><br><span class="line">&gt; git lfs ls-files                          <span class="comment"># 此时可以发现 text1.txt 和 text2.txt 也被追踪到了</span></span><br><span class="line">&gt; git push --force                          <span class="comment"># 让远程仓库也改过来</span></span><br></pre></td></tr></table></figure>
<h3 id="Case-3-不再跟踪某些文件"><a href="#Case-3-不再跟踪某些文件" class="headerlink" title="Case 3. 不再跟踪某些文件"></a>Case 3. 不再跟踪某些文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; git lfs untrack <span class="string">"*.filetype"</span></span><br><span class="line">&gt; git rm --cached <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure>
<h2 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h2></li>
<li><p>查看当前 <code>git-lfs</code> 正在追踪的文件类型——<code>git lfs track</code></p>
</li>
<li>查看当前 <code>git-lfs</code> 正在追踪哪些文件——<code>git lfs ls-file</code></li>
</ol>
<h1 id="七-Git的patch相关操作"><a href="#七-Git的patch相关操作" class="headerlink" title="七.Git的patch相关操作"></a>七.Git的patch相关操作</h1><h2 id="用format-patch获取patch"><a href="#用format-patch获取patch" class="headerlink" title="用format-patch获取patch"></a>用format-patch获取patch</h2><p>format-patch是比diff更新的生成patch方式，可以用<code>git apply</code>和<code>git am</code>合并patch，而diff只能利用apply方式<br>基本用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git format-patch xxxx.patch</span><br></pre></td></tr></table></figure>
<p>对不同分支获取patch，</p>
<h2 id="用diff获取patch"><a href="#用diff获取patch" class="headerlink" title="用diff获取patch"></a>用diff获取patch</h2><p>基本用法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &gt; xxxx.patch</span><br></pre></td></tr></table></figure>
<p>这样将<code>git diff</code>的输出放在一个文件中，而diff的输出就是修改的补丁，是<code>tracked</code>的文件的修改记录（相对于commit在库中的修改）。</p>
<p>如果有新增的文件，并不在Git管理之内，也就是还没有commit在仓库中的文件，执行如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached &gt; modified.patch</span><br></pre></td></tr></table></figure>
<p>如果还包含二进制文件，例如图片等</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --cached --binary &gt; modified.patch</span><br></pre></td></tr></table></figure>
<h3 id="对某个commit生成patch"><a href="#对某个commit生成patch" class="headerlink" title="对某个commit生成patch"></a>对某个commit生成patch</h3><p>先用<code>git log</code>找到两个commit记录的签名，然后利用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff xxxxx yyyyy &gt; modified.patch</span><br></pre></td></tr></table></figure>
<p>这里xxxxx和yyyyy分别是两个commit的签名。</p>
<h2 id="am命令应用patch"><a href="#am命令应用patch" class="headerlink" title="am命令应用patch"></a>am命令应用patch</h2><p>基本用法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am xxxx.patch</span><br></pre></td></tr></table></figure>
<p>打补丁：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git am --signoff &lt; xxxx.patch</span><br></pre></td></tr></table></figure>
<p>使用-s或–signoff选项，可以commit信息中加入Signed-off-by信息</p>
<h2 id="apply命令应用patch"><a href="#apply命令应用patch" class="headerlink" title="apply命令应用patch"></a>apply命令应用patch</h2><p>将一个patch应用到Git仓库中的命令是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git apply modified.patch</span><br></pre></td></tr></table></figure>
<p>不过在应用之前应该先检查patch文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git apply --stat modified.patch</span><br></pre></td></tr></table></figure>
<p>检查能否应用成功：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git apply --check modified.patch</span><br></pre></td></tr></table></figure>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2018/11/100081.html" class="pre-post btn btn-default" title='Hadoop HDFS常用命令'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Hadoop HDFS常用命令</span>
        </a>
    
    
        <a href="/archives/2018/11/100079.html" class="next-post btn btn-default" title='关于Javascript Hoisting的变量提升'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">关于Javascript Hoisting的变量提升</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一-常用命令"><span class="toc-text">一. 常用命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-gitk，输入该命令后，简单的图形方式"><span class="toc-text">1. gitk，输入该命令后，简单的图形方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-git-config-l，列出配置文件"><span class="toc-text">2. git config -l，列出配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-设置别名"><span class="toc-text">3. 设置别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-GIT的文件，刚新建立的时候，都为UNTRACKED状态，"><span class="toc-text">4. GIT的文件，刚新建立的时候，都为UNTRACKED状态，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-git-log查看历史记录"><span class="toc-text">5. git log查看历史记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-首先，Git必须知道当前版本是哪个版本，"><span class="toc-text">6. 首先，Git必须知道当前版本是哪个版本，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-我们把文件往Git版本库里添加的时候，是分两步执行的："><span class="toc-text">7. 我们把文件往Git版本库里添加的时候，是分两步执行的：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-git-diff-HEAD-–-readme-txt命令可以查看工作区和版本库里面最新版本的区别："><span class="toc-text">8. git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-撤销修改"><span class="toc-text">9. 撤销修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-删除文件"><span class="toc-text">10. 删除文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-本地库关联远程库："><span class="toc-text">11. 本地库关联远程库：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-本地库的所有内容推送到远程库上："><span class="toc-text">12. 本地库的所有内容推送到远程库上：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-克隆GIT："><span class="toc-text">13. 克隆GIT：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-创建分支"><span class="toc-text">14. 创建分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-分支管理策略"><span class="toc-text">15. 分支管理策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-BUG分支"><span class="toc-text">16. BUG分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-强行删除分支"><span class="toc-text">17. 强行删除分支</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-查看远程库的信息："><span class="toc-text">18. 查看远程库的信息：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-真正开发的时候，"><span class="toc-text">19. 真正开发的时候，</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-标签管理"><span class="toc-text">20. 标签管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-从GITHUB的开源项目中，可以FORK一个出来，用自己的账号"><span class="toc-text">21. 从GITHUB的开源项目中，可以FORK一个出来，用自己的账号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-rebase-命令将提交到某一分支上的所有修改都移至另一分支上"><span class="toc-text">22.  rebase 命令将提交到某一分支上的所有修改都移至另一分支上</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-一个库关联多个GIT"><span class="toc-text">23.  一个库关联多个GIT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-GIT文件的忽略"><span class="toc-text">24.  GIT文件的忽略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-配置别名"><span class="toc-text">25. 配置别名</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二-git大小写问题"><span class="toc-text">二. git大小写问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-问题复现"><span class="toc-text">1. 问题复现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-解决办法"><span class="toc-text">2. 解决办法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-文件变更比较少的情况"><span class="toc-text">2.1. 文件变更比较少的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-变更比较多，并且拥有分支较高权限"><span class="toc-text">2.2. 变更比较多，并且拥有分支较高权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-总结"><span class="toc-text">3. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三-GitHub等配置SSH-Key"><span class="toc-text">三. GitHub等配置SSH Key</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-设置git的user-name和email"><span class="toc-text">1. 设置git的user name和email</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-检查是否存在SSH-Key"><span class="toc-text">2. 检查是否存在SSH Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-获取SSH-Key"><span class="toc-text">3. 获取SSH Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-GitHub添加SSH-Key"><span class="toc-text">4. GitHub添加SSH Key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-验证和修改"><span class="toc-text">5. 验证和修改</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四-代理配置-Git-HTTP-SSH"><span class="toc-text">四. 代理配置(Git HTTP+SSH)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-HTTP-代理"><span class="toc-text">1. HTTP 代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SSH-代理"><span class="toc-text">2. SSH 代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五-简单的代码提交流程"><span class="toc-text">五. 简单的代码提交流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Git-add"><span class="toc-text">1. Git add</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Git-commit"><span class="toc-text">2. Git commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Git-push"><span class="toc-text">3. Git push</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六-git-lfs"><span class="toc-text">六.git-lfs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是-git-lfs"><span class="toc-text">什么是 git-lfs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Github-对文件大小的限制"><span class="toc-text">Github 对文件大小的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么需要-gif-lfs"><span class="toc-text">为什么需要 gif-lfs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么情况下不需要用-gif-lfs"><span class="toc-text">什么情况下不需要用 gif-lfs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#git-lfs-原理"><span class="toc-text">git-lfs 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#引用文件长什么样子"><span class="toc-text">引用文件长什么样子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#开始使用-git-lfs"><span class="toc-text">开始使用 git-lfs</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何安装-git-lfs-Mac-环境下"><span class="toc-text">如何安装 git-lfs (Mac 环境下)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-1-从-0-开始配置使用-git-lfs"><span class="toc-text">Case 1. 从 0 开始配置使用 git-lfs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-2-要在已有的仓库上用-git-lfs-追踪某些文件"><span class="toc-text">Case 2. 要在已有的仓库上用 git-lfs 追踪某些文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Case-3-不再跟踪某些文件"><span class="toc-text">Case 3. 不再跟踪某些文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他常用命令"><span class="toc-text">其他常用命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七-Git的patch相关操作"><span class="toc-text">七.Git的patch相关操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#用format-patch获取patch"><span class="toc-text">用format-patch获取patch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用diff获取patch"><span class="toc-text">用diff获取patch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对某个commit生成patch"><span class="toc-text">对某个commit生成patch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#am命令应用patch"><span class="toc-text">am命令应用patch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apply命令应用patch"><span class="toc-text">apply命令应用patch</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2024&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>