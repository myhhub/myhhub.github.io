<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="java,designpattern">


    <meta name="description" content="设计模式是软件开发人员在软件开发过程中面临的不断重复的问题的解决方案，是解决特定问题的一系列套路，具有一定的普遍性。设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>设计模式（Design pattern） | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="设计模式（Design pattern）">
            
	            设计模式（Design pattern）
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/designpattern/">designpattern</a> <a class="tag-link" href="/tags/java/">java</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2022/07/01</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>445</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>设计模式是软件开发人员在软件开发过程中面临的不断重复的问题的解决方案，是解决特定问题的一系列套路，具有一定的普遍性。设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。使用设计模式是为了复用代码、让代码更容易被他人理解、保证代码可靠性。</p>
<p>GOF设计模式<strong>根据目的</strong>划分为三种类型：</p>
<ul>
<li><p><strong>创建型模式</strong>：用于描述如何创建对象，在创建对象的同时隐藏了创建逻辑。避免使用 new 运算符直接实例化对象。包括：<strong><em>工厂模式（Factory Pattern）</em></strong>、抽象工厂模式（Abstract Factory Pattern）、单例模式（Singleton Pattern）、建造者模式（Builder Pattern）、原型模式（Prototype Pattern）。</p>
</li>
<li><p><strong>结构型模式</strong>：用于描述如何将类或对象按某种方式进行组合形成大的结构。包括：<strong><em>适配器模式（Adapter Pattern）</em></strong>、桥接模式（Bridge Pattern）、组合模式（Composite Pattern）、装饰模式（Decorator Pattern）、外观模式（Facade Pattern）、享元模式（Flyweight Pattern）、代理模式（Proxy Pattern）。</p>
</li>
<li><p><strong>行为型模式</strong>：用于描述类或对象之间怎样相互协作完成单个对象无法单独完成的任务。包括：责任链模式（Chain of Responsibility Pattern）、命令模式（Command Pattern）、<strong><em>解释器模式（Interpreter Pattern）</em></strong>、迭代器模式（Iterator Pattern）、中介者模式（Mediator Pattern）、备忘录模式（Memento Pattern）、观察者模式（Observer Pattern）、状态模式（State Pattern）、策略模式（Strategy Pattern）、<strong><em>模版方法模式（Template Method Pattern）</em></strong>、访问者模式（Visitor Pattern）。</p>
</li>
</ul>
<p>GOF设计模式<strong>根据作用范围</strong>划分为二种类型：</p>
<p>根据模式用于类还是对象上来分，可分为类模式和对象模式两种。</p>
<ul>
<li><p>类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。工厂方法、（类）适配器、模板方法、解释器属于该模式。</p>
</li>
<li><p>对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。除了以上 4 种，其他的都是对象模式。</p>
</li>
</ul>
<p>备注：<strong><em>斜粗体</em></strong>设计模式即应用于类也应用于对象，其它只可以应用于对象。 </p>
<p><strong>J2EE设计模式</strong>：<br>设计模式除了上面GOF提出的23种外还包括其他场景种的模式如Sun Java Center提出的J2EE模式，这些模式主要关注表示层。包括：</p>
<ul>
<li>MVC 模式（MVC Pattern）</li>
<li>业务代表模式（Business Delegate Pattern）</li>
<li>组合实体模式（Composite Entity Pattern）</li>
<li>数据访问对象模式（Data Access Object Pattern）</li>
<li>前端控制器模式（Front Controller Pattern）</li>
<li>拦截过滤器模式（Intercepting Filter Pattern）</li>
<li>服务定位器模式（Service Locator Pattern）</li>
<li>传输对象模式（Transfer Object Pattern）</li>
</ul>
<p>本文对应源代码：<a href="https://github.com/myhhub/DesignPattern" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern</a></p>
<h1 id="一-设计模式目的"><a href="#一-设计模式目的" class="headerlink" title="一. 设计模式目的"></a>一. 设计模式目的</h1><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性 等多方面的挑战，设计模式是为了让程序(软件)，具有更好：</p>
<p>1) 代码重用性 (即：相同功能的代码，不用多次编写)<br>2) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解)<br>3) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护)<br>4) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响)<br>5) 使程序呈现高内聚，低耦合的特性</p>
<h1 id="二-设计模式"><a href="#二-设计模式" class="headerlink" title="二. 设计模式"></a>二. 设计模式</h1><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h2><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/factory" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/factory</a></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p>
<p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p><strong>关键代码：</strong>创建过程在其子类执行。</p>
<p><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p>
<p><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
<p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h2 id="2-抽象工厂模式"><a href="#2-抽象工厂模式" class="headerlink" title="2.抽象工厂模式"></a>2.抽象工厂模式</h2><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/abstractfactory" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/abstractfactory</a></p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>何时使用：</strong>系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p>
<p><strong>如何解决：</strong>在一个产品族里面，定义多个产品。</p>
<p><strong>关键代码：</strong>在一个工厂里聚合多个同类产品。</p>
<p><strong>应用实例：</strong>工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
<p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong>产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p>
<p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p>
<p><strong>注意事项：</strong>产品族难扩展，产品等级易扩展。</p>
<h2 id="3-单例模式"><a href="#3-单例模式" class="headerlink" title="3.单例模式"></a>3.单例模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p><strong>注意：</strong></p>
<ul>
<li>1、单例类只能有一个实例。</li>
<li>2、单例类必须自己创建自己的唯一实例。</li>
<li>3、单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/singleton" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/singleton</a></p>
<h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p>
<p><strong>何时使用：</strong>当您想控制实例数目，节省系统资源的时候。</p>
<p><strong>如何解决：</strong>判断系统是否已经有这个单例，如果有则返回，如果没有则创建。</p>
<p><strong>关键代码：</strong>构造函数是私有的。</p>
<p><strong>应用实例：</strong></p>
<ul>
<li>1、一个班级只有一个班主任。</li>
<li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li>
<li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li>
<li>2、避免对资源的多重占用（比如写文件操作）。</li>
</ul>
<p><strong>缺点：</strong>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>1、要求生产唯一序列号。</li>
<li>2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。</li>
<li>3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。</li>
</ul>
<p><strong>注意事项：</strong>getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。</p>
<h2 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4.建造者模式"></a>4.建造者模式</h2><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/builder" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/builder</a></p>
<h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，有时候面临着”一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p>
<p><strong>何时使用：</strong>一些基本部件不会变，而其组合经常变化的时候。</p>
<p><strong>如何解决：</strong>将变与不变分离开。</p>
<p><strong>关键代码：</strong>建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p>
<p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”。 2、JAVA 中的 StringBuilder。</p>
<p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。</p>
<p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p>
<p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p>
<p><strong>注意事项：</strong>与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p>
<h2 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5.原型模式"></a>5.原型模式</h2><p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/prototype" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/prototype</a></p>
<h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p><strong>主要解决：</strong>在运行期建立和删除原型。</p>
<p><strong>何时使用：</strong> 1、当一个系统应该独立于它的产品创建，构成和表示时。 2、当要实例化的类是在运行时刻指定时，例如，通过动态装载。 3、为了避免创建一个与产品类层次平行的工厂类层次时。 4、当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</p>
<p><strong>如何解决：</strong>利用已有的一个原型对象，快速地生成和原型对象一样的实例。</p>
<p><strong>关键代码：</strong> 1、实现克隆操作，在 JAVA 实现 Cloneable 接口，重写 clone()，在 .NET 中可以使用 Object 类的 MemberwiseClone() 方法来实现对象的浅拷贝或通过序列化的方式来实现深拷贝。 2、原型模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些”易变类”拥有稳定的接口。</p>
<p><strong>应用实例：</strong> 1、细胞分裂。 2、JAVA 中的 Object clone() 方法。</p>
<p><strong>优点：</strong> 1、性能提高。 2、逃避构造函数的约束。</p>
<p><strong>缺点：</strong> 1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</p>
<p><strong>使用场景：</strong> 1、资源优化场景。 2、类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 3、性能和安全要求的场景。 4、通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 5、一个对象多个修改者的场景。 6、一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。 7、在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。</p>
<p><strong>注意事项：</strong>与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过拷贝一个现有对象生成新对象的。浅拷贝实现 Cloneable，重写，深拷贝是通过实现 Serializable 读取二进制流。</p>
<h2 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6.适配器模式"></a>6.适配器模式</h2><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p>
<p>我们通过下面的实例来演示适配器模式的使用。其中，音频播放器设备只能播放 mp3 文件，通过使用一个更高级的音频播放器来播放 vlc 和 mp4 文件。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/adapter" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/adapter</a></p>
<h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p>
<p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p>
<p><strong>如何解决：</strong>继承或依赖（推荐）。</p>
<p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p>
<p><strong>应用实例：</strong> 1、美国电器 110V，中国 220V，就要有一个适配器将 110V 转化为 220V。 2、JAVA JDK 1.1 提供了 Enumeration 接口，而在 1.2 中提供了 Iterator 接口，想要使用 1.2 的 JDK，则要将以前系统的 Enumeration 接口转化为 Iterator 接口，这时就需要适配器模式。 3、在 LINUX 上运行 WINDOWS 程序。 4、JAVA 中的 jdbc。</p>
<p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p>
<p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p>
<p><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p>
<p><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p>
<h2 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7.桥接模式"></a>7.桥接模式</h2><p>桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p>我们通过下面的实例来演示桥接模式（Bridge Pattern）的用法。其中，可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的圆。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/bridge" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/bridge</a></p>
<h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p><strong>主要解决：</strong>在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。</p>
<p><strong>何时使用：</strong>实现系统可能有多个角度分类，每一种角度都可能变化。</p>
<p><strong>如何解决：</strong>把这种多角度分类分离出来，让它们独立变化，减少它们之间耦合。</p>
<p><strong>关键代码：</strong>抽象类依赖实现类。</p>
<p><strong>应用实例：</strong> 1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择。 2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的。</p>
<p><strong>优点：</strong> 1、抽象和实现的分离。 2、优秀的扩展能力。 3、实现细节对客户透明。</p>
<p><strong>缺点：</strong>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
<p><strong>使用场景：</strong> 1、如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。 2、对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 3、一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</p>
<p><strong>注意事项：</strong>对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h2 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8.组合模式"></a>8.组合模式</h2><p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<p>我们通过下面的实例来演示组合模式的用法。实例演示了一个组织中员工的层次结构。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/composite" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/composite</a></p>
<h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>将对象组合成树形结构以表示”部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><strong>主要解决：</strong>它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦。</p>
<p><strong>何时使用：</strong> 1、您想表示对象的部分-整体层次结构（树形结构）。 2、您希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</p>
<p><strong>如何解决：</strong>树枝和叶子实现统一接口，树枝内部组合该接口。</p>
<p><strong>关键代码：</strong>树枝内部组合该接口，并且含有内部属性 List，里面放 Component。</p>
<p><strong>应用实例：</strong> 1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。 2、在 JAVA AWT 和 SWING 中，对于 Button 和 Checkbox 是树叶，Container 是树枝。</p>
<p><strong>优点：</strong> 1、高层模块调用简单。 2、节点自由增加。</p>
<p><strong>缺点：</strong>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</p>
<p><strong>使用场景：</strong>部分、整体场景，如树形菜单，文件、文件夹的管理。</p>
<p><strong>注意事项：</strong>定义时为具体类。</p>
<h2 id="9-装饰模式"><a href="#9-装饰模式" class="headerlink" title="9.装饰模式"></a>9.装饰模式</h2><p>装饰模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/decorator" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/decorator</a></p>
<h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>
<p><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</p>
<p><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。</p>
<p><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>
<p><strong>应用实例：</strong> 1、孙悟空有 72 变，当他变成”庙宇”后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p>
<p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
<p><strong>缺点：</strong>多层装饰比较复杂。</p>
<p><strong>使用场景：</strong> 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>
<p><strong>注意事项：</strong>可代替继承。</p>
<h2 id="10-外观模式"><a href="#10-外观模式" class="headerlink" title="10.外观模式"></a>10.外观模式</h2><p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。</p>
<p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/facade" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/facade</a></p>
<h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<p><strong>主要解决：</strong>降低访问复杂系统的内部子系统时的复杂度，简化客户端之间的接口。</p>
<p><strong>何时使用：</strong> 1、客户端不需要知道系统内部的复杂联系，整个系统只需提供一个”接待员”即可。 2、定义系统的入口。</p>
<p><strong>如何解决：</strong>客户端不与系统耦合，外观类与系统耦合。</p>
<p><strong>关键代码：</strong>在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。</p>
<p><strong>应用实例：</strong> 1、去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。 2、JAVA 的三层开发模式。</p>
<p><strong>优点：</strong> 1、减少系统相互依赖。 2、提高灵活性。 3、提高了安全性。</p>
<p><strong>缺点：</strong>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p>
<p><strong>使用场景：</strong> 1、为复杂的模块或子系统提供外界访问的模块。 2、子系统相对独立。 3、预防低水平人员带来的风险。</p>
<p><strong>注意事项：</strong>在层次化结构中，可以使用外观模式定义系统中每一层的入口。</p>
<h2 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11.享元模式"></a>11.享元模式</h2><p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。我们将通过创建 5 个对象来画出 20 个分布于不同位置的圆来演示这种模式。由于只有 5 种可用的颜色，所以 color 属性被用来检查现有的 <em>Circle</em> 对象。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/flyweight" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/flyweight</a></p>
<h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>运用共享技术有效地支持大量细粒度的对象。</p>
<p><strong>主要解决：</strong>在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。</p>
<p><strong>何时使用：</strong> 1、系统中有大量对象。 2、这些对象消耗大量内存。 3、这些对象的状态大部分可以外部化。 4、这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 5、系统不依赖于这些对象身份，这些对象是不可分辨的。</p>
<p><strong>如何解决：</strong>用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。</p>
<p><strong>关键代码：</strong>用 HashMap 存储这些对象。</p>
<p><strong>应用实例：</strong> 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。</p>
<p><strong>优点：</strong>大大减少对象的创建，降低系统的内存，使效率提高。</p>
<p><strong>缺点：</strong>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。</p>
<p><strong>使用场景：</strong> 1、系统有大量相似对象。 2、需要缓冲池的场景。</p>
<p><strong>注意事项：</strong> 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。</p>
<h2 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12.代理模式"></a>12.代理模式</h2><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/proxy" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/proxy</a></p>
<h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p>
<p><strong>何时使用：</strong>想在访问一个类时做一些控制。</p>
<p><strong>如何解决：</strong>增加中间层。</p>
<p><strong>关键代码：</strong>实现与被代理类组合。</p>
<p><strong>应用实例：</strong> 1、Windows 里面的快捷方式。 2、猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 3、买火车票不一定在火车站买，也可以去代售点。 4、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 5、spring aop。</p>
<p><strong>优点：</strong> 1、职责清晰。 2、高扩展性。 3、智能化。</p>
<p><strong>缺点：</strong> 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</p>
<p><strong>使用场景：</strong>按职责来划分，通常有以下使用场景： 1、远程代理。 2、虚拟代理。 3、Copy-on-Write 代理。 4、保护（Protect or Access）代理。 5、Cache代理。 6、防火墙（Firewall）代理。 7、同步化（Synchronization）代理。 8、智能引用（Smart Reference）代理。</p>
<p><strong>注意事项：</strong> 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<h2 id="13-责任链模式"><a href="#13-责任链模式" class="headerlink" title="13.责任链模式"></a>13.责任链模式</h2><p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/cor" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/cor</a></p>
<h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p>
<p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p>
<p><strong>如何解决：</strong>拦截的类都实现统一接口。</p>
<p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p>
<p><strong>应用实例：</strong> 1、红楼梦中的”击鼓传花”。 2、JS 中的事件冒泡。 3、JAVA WEB 中 Apache Tomcat 对 Encoding 的处理，Struts2 的拦截器，jsp servlet 的 Filter。</p>
<p><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p>
<p><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p>
<p><strong>使用场景：</strong> 1、有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p>
<p><strong>注意事项：</strong>在 JAVA WEB 中遇到很多应用。</p>
<h2 id="14-命令模式"><a href="#14-命令模式" class="headerlink" title="14.命令模式"></a>14.命令模式</h2><p>命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/command" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/command</a></p>
<h3 id="介绍-13"><a href="#介绍-13" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<p><strong>主要解决：</strong>在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p>
<p><strong>何时使用：</strong>在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p>
<p><strong>如何解决：</strong>通过调用者调用接受者执行命令，顺序：调用者→命令→接受者。</p>
<p><strong>关键代码：</strong>定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p>
<p><strong>应用实例：</strong>struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p>
<p><strong>优点：</strong> 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p>
<p><strong>缺点：</strong>使用命令模式可能会导致某些系统有过多的具体命令类。</p>
<p><strong>使用场景：</strong>认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p>
<p><strong>注意事项：</strong>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p>
<h2 id="15-解释器模式"><a href="#15-解释器模式" class="headerlink" title="15.解释器模式"></a>15.解释器模式</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式，它属于行为型模式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在 SQL 解析、符号处理引擎等。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/intepreter" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/intepreter</a></p>
<h3 id="介绍-14"><a href="#介绍-14" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<p><strong>主要解决：</strong>对于一些固定文法构建一个解释句子的解释器。</p>
<p><strong>何时使用：</strong>如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。</p>
<p><strong>如何解决：</strong>构建语法树，定义终结符与非终结符。</p>
<p><strong>关键代码：</strong>构建环境类，包含解释器之外的一些全局信息，一般是 HashMap。</p>
<p><strong>应用实例：</strong>编译器、运算表达式计算。</p>
<p><strong>优点：</strong> 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。</p>
<p><strong>缺点：</strong> 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。</p>
<p><strong>使用场景：</strong> 1、可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 2、一些重复出现的问题可以用一种简单的语言来进行表达。 3、一个简单语法需要解释的场景。</p>
<p><strong>注意事项：</strong>可利用场景比较少，JAVA 中如果碰到可以用 expression4J 代替。</p>
<h2 id="16-迭代器模式"><a href="#16-迭代器模式" class="headerlink" title="16.迭代器模式"></a>16.迭代器模式</h2><p>迭代器模式（Iterator Pattern）是 Java 和 .Net 编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>迭代器模式属于行为型模式。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/Iterator" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/Iterator</a></p>
<h3 id="介绍-15"><a href="#介绍-15" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</p>
<p><strong>主要解决：</strong>不同的方式来遍历整个整合对象。</p>
<p><strong>何时使用：</strong>遍历一个聚合对象。</p>
<p><strong>如何解决：</strong>把在元素之间游走的责任交给迭代器，而不是聚合对象。</p>
<p><strong>关键代码：</strong>定义接口：hasNext, next。</p>
<p><strong>应用实例：</strong>JAVA 中的 iterator。</p>
<p><strong>优点：</strong> 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。</p>
<p><strong>缺点：</strong>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</p>
<p><strong>使用场景：</strong> 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口。</p>
<p><strong>注意事项：</strong>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p>
<h2 id="17-中介者模式"><a href="#17-中介者模式" class="headerlink" title="17.中介者模式"></a>17.中介者模式</h2><p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/mediator" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/mediator</a></p>
<h3 id="介绍-16"><a href="#介绍-16" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p><strong>主要解决：</strong>对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。</p>
<p><strong>何时使用：</strong>多个类相互耦合，形成了网状结构。</p>
<p><strong>如何解决：</strong>将上述网状结构分离为星型结构。</p>
<p><strong>关键代码：</strong>对象 Colleague 之间的通信封装到一个类中单独处理。</p>
<p><strong>应用实例：</strong> 1、中国加入 WTO 之前是各个国家相互贸易，结构复杂，现在是各个国家通过 WTO 来互相贸易。 2、机场调度系统。 3、MVC 框架，其中C（控制器）就是 M（模型）和 V（视图）的中介者。</p>
<p><strong>优点：</strong> 1、降低了类的复杂度，将一对多转化成了一对一。 2、各个类之间的解耦。 3、符合迪米特原则。</p>
<p><strong>缺点：</strong>中介者会庞大，变得复杂难以维护。</p>
<p><strong>使用场景：</strong> 1、系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象。 2、想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</p>
<p><strong>注意事项：</strong>不应当在职责混乱的时候使用。</p>
<h2 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18.备忘录模式"></a>18.备忘录模式</h2><p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/memento" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/memento</a></p>
<h3 id="介绍-17"><a href="#介绍-17" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p><strong>主要解决：</strong>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p><strong>何时使用：</strong>很多时候我们总是需要记录一个对象的内部状态，这样做的目的就是为了允许用户取消不确定或者错误的操作，能够恢复到他原先的状态，使得他有”后悔药”可吃。</p>
<p><strong>如何解决：</strong>通过一个备忘录类专门存储对象状态。</p>
<p><strong>关键代码：</strong>客户不与备忘录类耦合，与备忘录管理类耦合。</p>
<p><strong>应用实例：</strong> 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctrl + z。 4、IE 中的后退。 5、数据库的事务管理。</p>
<p><strong>优点：</strong> 1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 2、实现了信息的封装，使得用户不需要关心状态的保存细节。</p>
<p><strong>缺点：</strong>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p>
<p><strong>使用场景：</strong> 1、需要保存/恢复数据的相关状态场景。 2、提供一个可回滚的操作。</p>
<p><strong>注意事项：</strong> 1、为了符合迪米特原则，还要增加一个管理备忘录的类。 2、为了节约内存，可使用原型模式+备忘录模式。</p>
<h2 id="19-观察者模式"><a href="#19-观察者模式" class="headerlink" title="19.观察者模式"></a>19.观察者模式</h2><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/observer" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/observer</a></p>
<h3 id="介绍-18"><a href="#介绍-18" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p>
<p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p>
<p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p>
<p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p>
<p><strong>应用实例：</strong> 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p>
<p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p>
<p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<p><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p>
<h2 id="20-状态模式"><a href="#20-状态模式" class="headerlink" title="20.状态模式"></a>20.状态模式</h2><p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。这种类型的设计模式属于行为型模式。</p>
<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的 context 对象。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/state" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/state</a></p>
<h3 id="介绍-19"><a href="#介绍-19" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<p><strong>主要解决：</strong>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p>
<p><strong>何时使用：</strong>代码中包含大量与对象状态有关的条件语句。</p>
<p><strong>如何解决：</strong>将各种具体的状态类抽象出来。</p>
<p><strong>关键代码：</strong>通常命令模式的接口中只有一个方法。而状态模式的接口中有一个或者多个方法。而且，状态模式的实现类的方法，一般返回值，或者是改变实例变量的值。也就是说，状态模式一般和对象的状态有关。实现类的方法有不同的功能，覆盖接口中的方法。状态模式和命令模式一样，也可以用于消除 if…else 等条件选择语句。</p>
<p><strong>应用实例：</strong> 1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态。 2、曾侯乙编钟中，’钟是抽象接口’,’钟A’等是具体状态，’曾侯乙编钟’是具体环境（Context）。</p>
<p><strong>优点：</strong> 1、封装了转换规则。 2、枚举可能的状态，在枚举状态之前需要确定状态种类。 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</p>
<p><strong>缺点：</strong> 1、状态模式的使用必然会增加系统类和对象的个数。 2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。 3、状态模式对”开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码。</p>
<p><strong>使用场景：</strong> 1、行为随状态改变而改变的场景。 2、条件、分支语句的代替者。</p>
<p><strong>注意事项：</strong>在行为受状态约束的时候使用状态模式，而且状态不超过 5 个。</p>
<h2 id="21-策略模式"><a href="#21-策略模式" class="headerlink" title="21.策略模式"></a>21.策略模式</h2><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/strategy" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/strategy</a></p>
<h3 id="介绍-20"><a href="#介绍-20" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p>
<p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p>
<p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p>
<p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p>
<p><strong>关键代码：</strong>实现同一个接口。</p>
<p><strong>应用实例：</strong> 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。</p>
<p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p>
<p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p>
<p><strong>使用场景：</strong> 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</p>
<p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p>
<h2 id="22-模版方法模式"><a href="#22-模版方法模式" class="headerlink" title="22. 模版方法模式"></a>22. 模版方法模式</h2><p>在模板方法模式（Template Method Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/TemplateMethod" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/TemplateMethod</a></p>
<h3 id="介绍-21"><a href="#介绍-21" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p><strong>主要解决：</strong>一些方法通用，却在每一个子类都重新写了这一方法。</p>
<p><strong>何时使用：</strong>有一些通用的方法。</p>
<p><strong>如何解决：</strong>将这些通用算法抽象出来。</p>
<p><strong>关键代码：</strong>在抽象类实现，其他步骤在子类实现。</p>
<p><strong>应用实例：</strong> 1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异。 2、西游记里面菩萨定好的 81 难，这就是一个顶层的逻辑骨架。 3、spring 中对 Hibernate 的支持，将一些已经定好的方法封装起来，比如开启事务、获取 Session、关闭 Session 等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>
<p><strong>优点：</strong> 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。</p>
<p><strong>缺点：</strong>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p>
<p><strong>使用场景：</strong> 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。</p>
<p><strong>注意事项：</strong>为防止恶意操作，一般模板方法都加上 final 关键词。</p>
<h2 id="23-访问者模式"><a href="#23-访问者模式" class="headerlink" title="23.访问者模式"></a>23.访问者模式</h2><p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。这种类型的设计模式属于行为型模式。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<p>本设计模式例子：<a href="https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/visitor" target="_blank" rel="noopener">https://github.com/myhhub/DesignPattern/tree/master/src/main/java/com/mayaha/dp/visitor</a></p>
<h3 id="介绍-22"><a href="#介绍-22" class="headerlink" title="介绍"></a>介绍</h3><p><strong>意图：</strong>主要将数据结构与数据操作分离。</p>
<p><strong>主要解决：</strong>稳定的数据结构和易变的操作耦合问题。</p>
<p><strong>何时使用：</strong>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，使用访问者模式将这些封装到类中。</p>
<p><strong>如何解决：</strong>在被访问的类里面加一个对外提供接待访问者的接口。</p>
<p><strong>关键代码：</strong>在数据基础类里面有一个方法接受访问者，将自身引用传入访问者。</p>
<p><strong>应用实例：</strong>您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
<p><strong>优点：</strong> 1、符合单一职责原则。 2、优秀的扩展性。 3、灵活性。</p>
<p><strong>缺点：</strong> 1、具体元素对访问者公布细节，违反了迪米特原则。 2、具体元素变更比较困难。 3、违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</p>
<p><strong>使用场景：</strong> 1、对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</p>
<p><strong>注意事项：</strong>访问者可以对功能进行统一，可以做报表、UI、拦截器与过滤器。</p>
<h1 id="三-设计模式类间关系"><a href="#三-设计模式类间关系" class="headerlink" title="三.设计模式类间关系"></a>三.设计模式类间关系</h1><h2 id="1-关联关系-Association"><a href="#1-关联关系-Association" class="headerlink" title="1.关联关系(Association)"></a>1.关联关系(Association)</h2><p>关联关系是类之间最常见的关系，表示不同类别对象之间具有某种含义的联系，一般是对象之间的引用关系，在代码中以成员变量形式出现，定义了对象之间静态的结构关系，是一种“强关联”的关系。关联关系一般用带箭头的实线表示，箭头从使用类指向被引用类，箭头两端标注角色名，实线上标注关系名称。关联可以是单向的，也可以是双向的，双向的双箭头表示。</p>
<h2 id="2-聚合关系-Aggregation"><a href="#2-聚合关系-Aggregation" class="headerlink" title="2. 聚合关系(Aggregation)"></a>2. 聚合关系(Aggregation)</h2><p>聚合关系是通过成员变量来实现的，所以也是关联关系的一种。成员对象是整体对象的一部分，所以是整体和部分的关系(has-a)。但是，成员对象可以脱离整体而存在。比如，公司与员工，公司没了，员工可以保留。聚合关系在类图中可以用带空心菱形的实线来表示，菱形指向整体。</p>
<h2 id="3-组合关系-Composition"><a href="#3-组合关系-Composition" class="headerlink" title="3. 组合关系(Composition)"></a>3. 组合关系(Composition)</h2><p>   组合关系同样通过引用方式表示整体和局部的关系，但是是不可分的，即整体对象消失，局部对象也不复存在。比如，公司和部门的关系，公司没了，部门也就没了。组合关系用带实心菱形的实线来表示，菱形指向整体。</p>
<h2 id="4-依赖关系-Dependency"><a href="#4-依赖关系-Dependency" class="headerlink" title="4. 依赖关系(Dependency)"></a>4. 依赖关系(Dependency)</h2><p>依赖关系是一种临时的关联关系，是对象之间耦合度最弱的一种关联方式，可能随着运行时的变化依赖关系也发生变化。依赖关系建模的是使用关系，在代码中表现为一个类通过方法参数或者局部变量访问另一个类的对象的方法或者字段。表示一个类在运行中使用到了另一个类中的对象。依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。</p>
<h2 id="5-泛化关系-Generalization"><a href="#5-泛化关系-Generalization" class="headerlink" title="5. 泛化关系(Generalization)"></a>5. 泛化关系(Generalization)</h2><p>泛化关系表示类之间的继承，即is-a关系，是对象之间耦合度最大的一种关系。在代码中表现为继承一个非抽象类。泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。</p>
<h2 id="6-实现关系-Realization"><a href="#6-实现关系-Realization" class="headerlink" title="6. 实现关系(Realization)"></a>6. 实现关系(Realization)</h2><p>实现关系是接口与实现类之间的关系。代码中表现为继承抽象类或者接口。实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。</p>
<h1 id="四-设计模式七大原则"><a href="#四-设计模式七大原则" class="headerlink" title="四.设计模式七大原则"></a>四.设计模式七大原则</h1><p>设计模式的设计遵从着七种设计原则，是设计模式的基础。软件工程一直推崇着低耦合高内聚的思想，让每个类只负责一件事，若有功能相似的类则考虑继承。对于多方法调用的情况要善用接口。降低对象之间的耦合增加程序的复用性、扩展性。</p>
<p>设计模式常用的七大原则有:</p>
<ol>
<li><p>单一职责原则</p>
</li>
<li><p>接口隔离原则</p>
</li>
<li><p>依赖倒转(倒置)原则</p>
</li>
<li><p>里氏替换原则</p>
</li>
<li><p>开闭原则</p>
</li>
<li><p>迪米特法则</p>
</li>
<li><p>合成复用原则</p>
</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:left">设计原则</th>
<th style="text-align:left">归纳</th>
<th style="text-align:left">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">开闭原则</td>
<td style="text-align:left">对扩展开放，对修改关闭</td>
<td style="text-align:left">降低维护带来的新风险</td>
</tr>
<tr>
<td style="text-align:left">依赖倒置原则</td>
<td style="text-align:left">高层不应该依赖低层，要面向接口编程</td>
<td style="text-align:left">更利于代码结构的升级扩展</td>
</tr>
<tr>
<td style="text-align:left">单一职责原则</td>
<td style="text-align:left">一个类只干一件事，实现类要单一</td>
<td style="text-align:left">便于理解，提高代码的可读性</td>
</tr>
<tr>
<td style="text-align:left">接口隔离原则</td>
<td style="text-align:left">一个接口只干一件事，接口要精简单一</td>
<td style="text-align:left">功能解耦，高聚合、低耦合</td>
</tr>
<tr>
<td style="text-align:left">迪米特法则</td>
<td style="text-align:left">不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度</td>
<td style="text-align:left">只和朋友交流，不和陌生人说话，减少代码臃肿</td>
</tr>
<tr>
<td style="text-align:left">里氏替换原则</td>
<td style="text-align:left">不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义</td>
<td style="text-align:left">防止继承泛滥</td>
</tr>
<tr>
<td style="text-align:left">合成复用原则</td>
<td style="text-align:left">尽量使用组合或者聚合关系实现代码复用，少使用继承</td>
<td style="text-align:left">降低代码耦合</td>
</tr>
</tbody>
</table>
<p>总结：设计原则的目的就是降低耦合，提高内聚性，增加程序的复用性和可扩展性。</p>
<h2 id="1、单一职责原则"><a href="#1、单一职责原则" class="headerlink" title="1、单一职责原则"></a>1、单一职责原则</h2><h3 id="1-1基本介绍"><a href="#1-1基本介绍" class="headerlink" title="1.1基本介绍"></a>1.1基本介绍</h3><blockquote>
<p>1、对类来说的，即一个类应该只负责一项职责。</p>
<p>2、如类A负责两个不 同职责：职责1，职责2。</p>
<p>3、当职责1需求变更而改变A时，可能造成职责2执行错误，所以 需要将类A的粒度分解为A1，A2</p>
</blockquote>
<h3 id="1-2应用实例-以交通工具案例讲解"><a href="#1-2应用实例-以交通工具案例讲解" class="headerlink" title="1.2应用实例:以交通工具案例讲解"></a>1.2应用实例:以交通工具案例讲解</h3><p>方案1：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.guan.principle.singleresponsibility;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> class SingleResponsibility1 &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Vehicle vehicle = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vehicle.<span class="built_in">run</span>(<span class="string">"摩托车"</span>);</span><br><span class="line">        vehicle.<span class="built_in">run</span>(<span class="string">"汽车"</span>);</span><br><span class="line">        vehicle.<span class="built_in">run</span>(<span class="string">"飞机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 交通工具类</span></span><br><span class="line"><span class="comment">// 方式1</span></span><br><span class="line"><span class="comment">// 1. 在方式1 的run方法中，违反了单一职责原则</span></span><br><span class="line"><span class="comment">// 2. 解决的方案非常的简单，根据交通工具运行方法不同，分解成不同类即可</span></span><br><span class="line">class Vehicle &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">run</span>(<span class="keyword">String</span> vehicle) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(vehicle + <span class="string">" 在公路上运行...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案2：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SingleResponsibility2.java</span><br><span class="line">package com.guan.principle.singleresponsibility;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingleResponsibility2</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		RoadVehicle roadVehicle = <span class="keyword">new</span> RoadVehicle();</span><br><span class="line">		roadVehicle.run(<span class="string">"摩托车"</span>);</span><br><span class="line">		roadVehicle.run(<span class="string">"汽车"</span>);</span><br><span class="line">		</span><br><span class="line">		AirVehicle airVehicle = <span class="keyword">new</span> AirVehicle();</span><br><span class="line">		</span><br><span class="line">		airVehicle.run(<span class="string">"飞机"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方案2的分析</span></span><br><span class="line"><span class="comment">//1. 遵守单一职责原则</span></span><br><span class="line"><span class="comment">//2. 但是这样做的改动很大，即将类分解，同时修改客户端</span></span><br><span class="line"><span class="comment">//3. 改进：直接修改Vehicle 类，改动的代码会比较少=&gt;方案3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">RoadVehicle</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params">String vehicle</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(vehicle + <span class="string">"公路运行"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">AirVehicle</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params">String vehicle</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(vehicle + <span class="string">"天空运行"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">WaterVehicle</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params">String vehicle</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(vehicle + <span class="string">"水中运行"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方案3：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SingleResponsibility3.java</span><br><span class="line">package com.guan.principle.singleresponsibility;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SingleResponsibility3</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Vehicle2 vehicle2  = <span class="keyword">new</span> Vehicle2();</span><br><span class="line">		vehicle2.run(<span class="string">"汽车"</span>);</span><br><span class="line">		vehicle2.runWater(<span class="string">"轮船"</span>);</span><br><span class="line">		vehicle2.runAir(<span class="string">"飞机"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//方式3的分析</span></span><br><span class="line"><span class="comment">//1. 这种修改方法没有对原来的类做大的修改，只是增加方法</span></span><br><span class="line"><span class="comment">//2. 这里虽然没有在类这个级别上遵守单一职责原则，但是在方法级别上，仍然是遵守单一职责</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Vehicle2</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params">String vehicle</span>)</span> &#123;</span><br><span class="line">		<span class="comment">//处理</span></span><br><span class="line">		</span><br><span class="line">		System.<span class="keyword">out</span>.println(vehicle + <span class="string">" 在公路上运行...."</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runAir</span>(<span class="params">String vehicle</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(vehicle + <span class="string">" 在天空上运行...."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runWater</span>(<span class="params">String vehicle</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(vehicle + <span class="string">" 在水中行...."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-单一职责原则注意事项和细节"><a href="#1-3-单一职责原则注意事项和细节" class="headerlink" title="1.3 单一职责原则注意事项和细节"></a>1.3 单一职责原则注意事项和细节</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) 降低类的复杂度，一个类只负责一项职责。</span><br><span class="line"><span class="number">2</span>) 提高类的可读性，可维护性</span><br><span class="line"><span class="number">3</span>) 降低变更引起的风险</span><br><span class="line"><span class="number">4</span>) 通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级别违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则</span><br></pre></td></tr></table></figure>
<h2 id="2、-接口隔离原则"><a href="#2、-接口隔离原则" class="headerlink" title="2、 接口隔离原则"></a>2、 接口隔离原则</h2><h3 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>1) 客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖，应该建立在最小的接口上<br>2) 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。<br>3) 按隔离原则应当这样处理：<br>    将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则</p>
<h3 id="1-2-应用示例"><a href="#1-2-应用示例" class="headerlink" title="1.2 应用示例"></a>1.2 应用示例</h3><p>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，请编写代码完成此应用实例。<br>没有使用接口隔离代码原则代码</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">package com.guan.principle.segregation;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Segregation1</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Interface1</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation1</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation2</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation3</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation4</span>(<span class="params"></span>)</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation5</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> <span class="title">implements</span> <span class="title">Interface1</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"B 实现了 operation1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"B 实现了 operation2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"B 实现了 operation3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"B 实现了 operation4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"B 实现了 operation5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">D</span> <span class="title">implements</span> <span class="title">Interface1</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"D 实现了 operation1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"D 实现了 operation2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"D 实现了 operation3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"D 实现了 operation4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"D 实现了 operation5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="comment">//A 类通过接口Interface1 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span>(<span class="params">Interface1 i</span>)</span> &#123;</span><br><span class="line">		i.operation1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span>(<span class="params">Interface1 i</span>)</span> &#123;</span><br><span class="line">		i.operation2();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span>(<span class="params">Interface1 i</span>)</span> &#123;</span><br><span class="line">		i.operation3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span> &#123; <span class="comment">//C 类通过接口Interface1 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span>(<span class="params">Interface1 i</span>)</span> &#123;</span><br><span class="line">		i.operation1();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span>(<span class="params">Interface1 i</span>)</span> &#123;</span><br><span class="line">		i.operation4();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span>(<span class="params">Interface1 i</span>)</span> &#123;</span><br><span class="line">		i.operation5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进:</p>
<p>1) 类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法<br>2) 将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则<br>3) 接口Interface1中出现的方法，根据实际情况拆分为三个接口<br>4) 代码实现</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package com.guan.principle.segregation.improve;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Segregation1</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">// 使用一把</span></span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		a.depend1(<span class="keyword">new</span> B()); <span class="comment">// A类通过接口去依赖B类</span></span><br><span class="line">		a.depend2(<span class="keyword">new</span> B());</span><br><span class="line">		a.depend3(<span class="keyword">new</span> B());</span><br><span class="line"> </span><br><span class="line">		C c = <span class="keyword">new</span> C();</span><br><span class="line"> </span><br><span class="line">		c.depend1(<span class="keyword">new</span> D()); <span class="comment">// C类通过接口去依赖(使用)D类</span></span><br><span class="line">		c.depend4(<span class="keyword">new</span> D());</span><br><span class="line">		c.depend5(<span class="keyword">new</span> D());</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 接口1</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Interface1</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation1</span>(<span class="params"></span>)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 接口2</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Interface2</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation2</span>(<span class="params"></span>)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation3</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 接口3</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">Interface3</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation4</span>(<span class="params"></span>)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation5</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> <span class="title">implements</span> <span class="title">Interface1</span>, <span class="title">Interface2</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"B 实现了 operation1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"B 实现了 operation2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation3</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"B 实现了 operation3"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">D</span> <span class="title">implements</span> <span class="title">Interface1</span>, <span class="title">Interface3</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"D 实现了 operation1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation4</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"D 实现了 operation4"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation5</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"D 实现了 operation5"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123; <span class="comment">// A 类通过接口Interface1,Interface2 依赖(使用) B类，但是只会用到1,2,3方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span>(<span class="params">Interface1 i</span>)</span> &#123;</span><br><span class="line">		i.operation1();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend2</span>(<span class="params">Interface2 i</span>)</span> &#123;</span><br><span class="line">		i.operation2();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend3</span>(<span class="params">Interface2 i</span>)</span> &#123;</span><br><span class="line">		i.operation3();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">C</span> &#123; <span class="comment">// C 类通过接口Interface1,Interface3 依赖(使用) D类，但是只会用到1,4,5方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend1</span>(<span class="params">Interface1 i</span>)</span> &#123;</span><br><span class="line">		i.operation1();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend4</span>(<span class="params">Interface3 i</span>)</span> &#123;</span><br><span class="line">		i.operation4();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depend5</span>(<span class="params">Interface3 i</span>)</span> &#123;</span><br><span class="line">		i.operation5();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、-依赖倒转原则"><a href="#3、-依赖倒转原则" class="headerlink" title="3、 依赖倒转原则"></a>3、 依赖倒转原则</h2><h3 id="1-1-基本介绍-1"><a href="#1-1-基本介绍-1" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>依赖倒转原则(Dependence Inversion Principle)是指：</p>
<p>1) 高层模块不应该依赖低层模块，二者都应该依赖其抽象<br>2) 抽象不应该依赖细节，细节应该依赖抽象<br>3) 依赖倒转(倒置)的中心思想是面向接口编程<br>4) 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类<br>5) 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成</p>
<h3 id="1-2-应用实例"><a href="#1-2-应用实例" class="headerlink" title="1.2 应用实例"></a>1.2 应用实例</h3><p>请编程完成Person 接收消息 的功能</p>
<p>实现方案1 + 分析说明：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.guan.principle.inversion;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DependecyInversion</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		Person person = <span class="keyword">new</span> Person();</span><br><span class="line">		person.receive(<span class="keyword">new</span> Email());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title">Email</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//完成Person接收消息的功能</span></span><br><span class="line"><span class="comment">//方式1分析</span></span><br><span class="line"><span class="comment">//1. 简单，比较容易想到</span></span><br><span class="line"><span class="comment">//2. 如果我们获取的对象是 微信，短信等等，则新增类，同时Perons也要增加相应的接收方法</span></span><br><span class="line"><span class="comment">//3. 解决思路：引入一个抽象的接口IReceiver, 表示接收者, 这样Person类与接口IReceiver发生依赖</span></span><br><span class="line"><span class="comment">//   因为Email, WeiXin 等等属于接收的范围，他们各自实现IReceiver 接口就ok, 这样我们就符号依赖倒转原则</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span>(<span class="params">Email email </span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(email.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guan.principle.inversion.improve;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependecyInversion</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">		<span class="comment">//客户端无需改变</span></span><br><span class="line">		Person person = <span class="keyword">new</span> <span class="type">Person</span>();</span><br><span class="line">		person.receive(<span class="keyword">new</span> <span class="type">Email</span>());</span><br><span class="line">		</span><br><span class="line">		person.receive(<span class="keyword">new</span> <span class="type">WeiXin</span>());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReceiver</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> getInfo();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Email</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">IReceiver</span></span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> getInfo() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"电子邮件信息: hello,world"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//增加微信</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">IReceiver</span></span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">String</span> getInfo() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"微信信息: hello,ok"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里我们是对接口的依赖</span></span><br><span class="line">	<span class="keyword">public</span> void receive(IReceiver receiver ) &#123;</span><br><span class="line">		System.out.println(receiver.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-依赖关系传递的三种方式"><a href="#1-3-依赖关系传递的三种方式" class="headerlink" title="1.3 依赖关系传递的三种方式"></a>1.3 依赖关系传递的三种方式</h3><p>1) 接口传递<br>2) 构造方法传递<br>3) setter方式传递</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guan.principle.inversion.improve;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DependencyPass</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		ChangHong changHong = <span class="keyword">new</span> ChangHong();</span><br><span class="line"><span class="comment">//		OpenAndClose openAndClose = new OpenAndClose();</span></span><br><span class="line"><span class="comment">//		openAndClose.open(changHong);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//通过构造器进行依赖传递</span></span><br><span class="line"><span class="comment">//		OpenAndClose openAndClose = new OpenAndClose(changHong);</span></span><br><span class="line"><span class="comment">//		openAndClose.open();</span></span><br><span class="line">		<span class="comment">//通过setter方法进行依赖传递</span></span><br><span class="line">		OpenAndClose openAndClose = <span class="keyword">new</span> OpenAndClose();</span><br><span class="line">		openAndClose.setTv(changHong);</span><br><span class="line">		openAndClose.open();</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 方式1： 通过接口传递实现依赖</span></span><br><span class="line"><span class="comment">// 开关的接口</span></span><br><span class="line"><span class="comment">// interface IOpenAndClose &#123;</span></span><br><span class="line"><span class="comment">// public void open(ITV tv); //抽象方法,接收接口</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// interface ITV &#123; //ITV接口</span></span><br><span class="line"><span class="comment">// public void play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// class ChangHong implements ITV &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	@Override</span></span><br><span class="line"><span class="comment">//	public void play() &#123;</span></span><br><span class="line"><span class="comment">//		// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//		System.out.println("长虹电视机，打开");</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//	 </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="comment">// class OpenAndClose implements IOpenAndClose&#123;</span></span><br><span class="line"><span class="comment">// public void open(ITV tv)&#123;</span></span><br><span class="line"><span class="comment">// tv.play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 方式2: 通过构造方法依赖传递</span></span><br><span class="line"><span class="comment">// interface IOpenAndClose &#123;</span></span><br><span class="line"><span class="comment">// public void open(); //抽象方法</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// interface ITV &#123; //ITV接口</span></span><br><span class="line"><span class="comment">// public void play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// class OpenAndClose implements IOpenAndClose&#123;</span></span><br><span class="line"><span class="comment">// public ITV tv; //成员</span></span><br><span class="line"><span class="comment">// public OpenAndClose(ITV tv)&#123; //构造器</span></span><br><span class="line"><span class="comment">// this.tv = tv;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// public void open()&#123;</span></span><br><span class="line"><span class="comment">// this.tv.play();</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 方式3 , 通过setter方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">// 抽象方法</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">// ITV接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ITV tv;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTv</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv = tv;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.tv.play();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangHong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"长虹电视机，打开"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-依赖倒转原则的注意事项和细节"><a href="#1-4-依赖倒转原则的注意事项和细节" class="headerlink" title="1.4 依赖倒转原则的注意事项和细节"></a>1.4 依赖倒转原则的注意事项和细节</h3><p>1) 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好<br>2) 变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化<br>3) 继承时遵循里氏替换原则</p>
<h2 id="4、-里氏替换原则"><a href="#4、-里氏替换原则" class="headerlink" title="4、 里氏替换原则"></a>4、 里氏替换原则</h2><h3 id="1-1-OO中的继承性的思考和说明"><a href="#1-1-OO中的继承性的思考和说明" class="headerlink" title="1.1 OO中的继承性的思考和说明"></a>1.1 OO中的继承性的思考和说明</h3><p>1) 继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。<br>2) 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障<br>3) 问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则</p>
<h3 id="1-2-基本介绍"><a href="#1-2-基本介绍" class="headerlink" title="1.2 基本介绍"></a>1.2 基本介绍</h3><p>1) 里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里的女士提出的。<br>2) 如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。<br>3) 在使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法<br>4) 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题。.</p>
<h3 id="1-3-应用示例"><a href="#1-3-应用示例" class="headerlink" title="1.3 应用示例"></a>1.3 应用示例</h3><p>一个程序引出的问题和思考：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.guan.principle.liskov;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Liskov</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"11-3="</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"1-8="</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"> </span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">		B b = <span class="keyword">new</span> B();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"11-3="</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11-3</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"1-8="</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1-8</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"11+3+9="</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span> &#123;</span><br><span class="line">	<span class="comment">// 返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span>(<span class="params"><span class="keyword">int</span> num1, <span class="keyword">int</span> num2</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">A</span> &#123;</span><br><span class="line">	<span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：</p>
<p>1) 我们发现原来运行正常的相减功能发生了错误。原因就是类B无意中重写了父类的方法，造成原有功能出现错误。在实际编程中，我们常常会通过重写父类的方法完成新的功能，这样写起来虽然简单，但整个继承体系的复用性会比较差。特别是运行多态比较频繁的时候<br>2) 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖，聚合，组合等关系代替.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.guan.principle.liskov.improve;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Liskov</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"11-3="</span> + a.func1(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"1-8="</span> + a.func1(<span class="number">1</span>, <span class="number">8</span>));</span><br><span class="line"> </span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">		B b = <span class="keyword">new</span> B();</span><br><span class="line">		<span class="comment">//因为B类不再继承A类，因此调用者，不会再func1是求减法</span></span><br><span class="line">		<span class="comment">//调用完成的功能就会很明确</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"11+3="</span> + b.func1(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">//这里本意是求出11+3</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"1+8="</span> + b.func1(<span class="number">1</span>, <span class="number">8</span>));<span class="comment">// 1+8</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"11+3+9="</span> + b.func2(<span class="number">11</span>, <span class="number">3</span>));</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//使用组合仍然可以使用到A类相关方法</span></span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"11-3="</span> + b.func3(<span class="number">11</span>, <span class="number">3</span>));<span class="comment">// 这里本意是求出11-3</span></span><br><span class="line">		</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span><br><span class="line">	<span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">A</span> <span class="title">extends</span> <span class="title">Base</span> &#123;</span><br><span class="line">	<span class="comment">// 返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span>(<span class="params"><span class="keyword">int</span> num1, <span class="keyword">int</span> num2</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">Base</span> &#123;</span><br><span class="line">	<span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">	<span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span>(<span class="params"><span class="keyword">int</span> a, <span class="keyword">int</span> b</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5、开闭原则"><a href="#5、开闭原则" class="headerlink" title="5、开闭原则"></a>5、开闭原则</h2><h3 id="1-1-基本介绍-2"><a href="#1-1-基本介绍-2" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>1) 开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则<br>2) 一个软件实体如类，模块和函数应该对扩展开放(对提供方)，对修改关闭(对使用方)。用抽象构建框架，用实现扩展细节。<br>3) 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。<br>4) 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</p>
<h3 id="1-2应用示例"><a href="#1-2应用示例" class="headerlink" title="1.2应用示例"></a>1.2应用示例</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.guan.principle.ocp;</span><br><span class="line"> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">		<span class="comment">//使用看看存在的问题</span></span><br><span class="line">		<span class="type">GraphicEditor</span> graphicEditor = <span class="keyword">new</span> <span class="type">GraphicEditor</span>();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> <span class="type">Rectangle</span>());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> <span class="type">Circle</span>());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> <span class="type">Triangle</span>());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，然后根据type，来绘制不同的图形</span></span><br><span class="line">	public void drawShape(<span class="type">Shape</span> s) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">			drawRectangle(s);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">			drawCircle(s);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">3</span>)</span><br><span class="line">			drawTriangle(s);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//绘制矩形</span></span><br><span class="line">	public void drawRectangle(<span class="type">Shape</span> r) &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">" 绘制矩形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//绘制圆形</span></span><br><span class="line">	public void drawCircle(<span class="type">Shape</span> r) &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">" 绘制圆形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//绘制三角形</span></span><br><span class="line">	public void drawTriangle(<span class="type">Shape</span> r) &#123;</span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">" 绘制三角形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	int m_type;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="type">Rectangle</span>() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="type">Circle</span>() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="type">Triangle</span>() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进：</p>
<p>改进的思路分析<br>思路：把创建Shape类做成抽象类，并提供一个抽象的draw方法，让子类去实现即可，这样我们有新的图形种类时，只需要让新的图形类继承Shape，并实现draw方法即可，<br>使用方的代码就不需要修 -&gt; 满足了开闭原则</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.guan.principle.ocp.improve;</span><br><span class="line"> </span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Ocp</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">		<span class="comment">//使用看看存在的问题</span></span><br><span class="line">		<span class="type">GraphicEditor</span> graphicEditor = <span class="keyword">new</span> <span class="type">GraphicEditor</span>();</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> <span class="type">Rectangle</span>());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> <span class="type">Circle</span>());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> <span class="type">Triangle</span>());</span><br><span class="line">		graphicEditor.drawShape(<span class="keyword">new</span> <span class="type">OtherGraphic</span>());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">	public void drawShape(<span class="type">Shape</span> s) &#123;</span><br><span class="line">		s.draw();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	int m_type;</span><br><span class="line">	</span><br><span class="line">	public <span class="keyword">abstract</span> void draw();<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="type">Rectangle</span>() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void draw() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">" 绘制矩形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="type">Circle</span>() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void draw() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">" 绘制圆形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="type">Triangle</span>() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void draw() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">" 绘制三角形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="type">OtherGraphic</span>() &#123;</span><br><span class="line">		<span class="keyword">super</span>.m_type = <span class="number">4</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	public void draw() &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="type">System</span>.out.println(<span class="string">" 绘制其它图形 "</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6、-迪米特法则"><a href="#6、-迪米特法则" class="headerlink" title="6、 迪米特法则"></a>6、 迪米特法则</h2><h3 id="1-1-基本介绍-3"><a href="#1-1-基本介绍-3" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>1) 一个对象应该对其他对象保持最少的了解<br>2) 类与类关系越密切，耦合度越大<br>3) 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的<br>越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内<br>部。对外除了提供的public 方法，不对外泄露任何信息<br>4) 迪米特法则还有个更简单的定义：只与直接的朋友通信<br>5) 直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。</p>
<h3 id="1-2-应用实例-1"><a href="#1-2-应用实例-1" class="headerlink" title="1.2 应用实例"></a>1.2 应用实例</h3><p>有一个学校，下属有各个学院和总部，现要求打印出学校总部员工ID和学院员工的id</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">package com.guan.principle.demeter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demeter1</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">		SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">		<span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">		schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CollegeManager</span> &#123;</span></span><br><span class="line">	<span class="comment">//返回学院的所有员工</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;CollegeEmployee&gt; getAllEmployee() &#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">"学院员工id= "</span> + i);</span><br><span class="line">			<span class="built_in">list</span>.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchoolManager</span> &#123;</span></span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="keyword">public</span> List&lt;Employee&gt; getAllEmployee() &#123;</span><br><span class="line">		List&lt;Employee&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">			<span class="built_in">list</span>.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span><span class="params">(CollegeManager sub)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 这里的 CollegeEmployee 不是  SchoolManager的直接朋友</span></span><br><span class="line">		<span class="comment">//2. CollegeEmployee 是以局部变量方式出现在 SchoolManager</span></span><br><span class="line">		<span class="comment">//3. 违反了 迪米特法则 </span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">"------------学院员工------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.out.println(<span class="string">"------------学校总部员工------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.out.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">package com.guan.principle.demeter.improve;</span><br><span class="line"> </span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demeter1</span> &#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"~~~使用迪米特法则的改进~~~"</span>);</span><br><span class="line">		<span class="comment">//创建了一个 SchoolManager 对象</span></span><br><span class="line">		SchoolManager schoolManager = <span class="keyword">new</span> SchoolManager();</span><br><span class="line">		<span class="comment">//输出学院的员工id 和  学校总部的员工信息</span></span><br><span class="line">		schoolManager.printAllEmployee(<span class="keyword">new</span> CollegeManager());</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//学校总部员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span>(<span class="params">String id</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//学院的员工类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CollegeEmployee</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span>(<span class="params">String id</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getId</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//管理学院员工的管理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">CollegeManager</span> &#123;</span><br><span class="line">	<span class="comment">//返回学院的所有员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;CollegeEmployee&gt; <span class="title">getAllEmployee</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		List&lt;CollegeEmployee&gt; list = <span class="keyword">new</span> ArrayList&lt;CollegeEmployee&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">//这里我们增加了10个员工到 list</span></span><br><span class="line">			CollegeEmployee emp = <span class="keyword">new</span> CollegeEmployee();</span><br><span class="line">			emp.setId(<span class="string">"学院员工id= "</span> + i);</span><br><span class="line">			list.<span class="keyword">add</span>(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//输出学院员工的信息</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEmployee</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="comment">//获取到学院员工</span></span><br><span class="line">		List&lt;CollegeEmployee&gt; list1 = getAllEmployee();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"------------学院员工------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (CollegeEmployee e : list1) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//学校管理类</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManager</span></span><br><span class="line"><span class="comment">//CollegeEmployee 不是 直接朋友 而是一个陌生类，这样违背了 迪米特法则 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title">SchoolManager</span> &#123;</span><br><span class="line">	<span class="comment">//返回学校总部的员工</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getAllEmployee</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; <span class="comment">//这里我们增加了5个员工到 list</span></span><br><span class="line">			Employee emp = <span class="keyword">new</span> Employee();</span><br><span class="line">			emp.setId(<span class="string">"学校总部员工id= "</span> + i);</span><br><span class="line">			list.<span class="keyword">add</span>(emp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//该方法完成输出学校总部和学院员工信息(id)</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">printAllEmployee</span>(<span class="params">CollegeManager sub</span>)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//分析问题</span></span><br><span class="line">		<span class="comment">//1. 将输出学院的员工方法，封装到CollegeManager</span></span><br><span class="line">		sub.printEmployee();</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//获取到学校总部员工</span></span><br><span class="line">		List&lt;Employee&gt; list2 = <span class="keyword">this</span>.getAllEmployee();</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"------------学校总部员工------------"</span>);</span><br><span class="line">		<span class="keyword">for</span> (Employee e : list2) &#123;</span><br><span class="line">			System.<span class="keyword">out</span>.println(e.getId());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-迪米特法则注意事项和细节"><a href="#1-3-迪米特法则注意事项和细节" class="headerlink" title="1.3 迪米特法则注意事项和细节"></a>1.3 迪米特法则注意事项和细节</h3><p>1) 迪米特法则的核心是降低类之间的耦合<br>2) 但是注意：由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间(对象间)耦合关系， 并不是要求完全没有依赖关系</p>
<h2 id="7、合成复用原则"><a href="#7、合成复用原则" class="headerlink" title="7、合成复用原则"></a>7、合成复用原则</h2><h3 id="1-1-基本介绍-4"><a href="#1-1-基本介绍-4" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h3><p>合成复用原则是尽量使用合成/聚合的方式，其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p>
<h3 id="1-2-设计原则核心思想"><a href="#1-2-设计原则核心思想" class="headerlink" title="1.2 设计原则核心思想"></a>1.2 设计原则核心思想</h3><p>1) 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。<br>2) 针对接口编程，而不是针对实现编程。<br>3) 为了交互对象之间的松耦合设计而努力。</p>
<h1 id="五-相关知识"><a href="#五-相关知识" class="headerlink" title="五.相关知识"></a>五.相关知识</h1><h2 id="1-volatile和synchronize"><a href="#1-volatile和synchronize" class="headerlink" title="1.volatile和synchronize"></a>1.volatile和synchronize</h2><p>原子性（atomicity）和可见性（visibility）<br>原子性意味着一个时刻，只有一个线程能够执行一段代码，这段代码通过一个monitor object保护。从而防止多个线程在更新共享状态时相互冲突。<br>可见性则更为微妙，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。</p>
<p>volatile<br>它所修饰的变量不保留拷贝，直接访问主内存中的。</p>
<p>在Java内存模型中，有main memory，每个线程也有自己的memory (例如寄存器)。为了性能，一个线程会在自己的memory中保持要访问的变量的副本。这样就会出现同一个变量在某个瞬间，在一个线程的memory中的值可能与另外一个线程memory中的值，或者main memory中的值不一致的情况。 一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。</p>
<p>使用场景<br>您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：<br>1)对变量的写操作不依赖于当前值。<br>2)该变量没有包含在具有其他变量的不变式中。</p>
<p>volatile最适用一个线程写，多个线程读的场合。<br>如果有多个线程并发写操作，仍然需要使用锁或者线程安全的容器或者原子变量来代替。</p>
<p>synchronized<br>当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。</p>
<p>当两个并发线程访问同一个对象object中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。<br>然而，当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。<br>尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。<br>当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。<br>区别<br>volatile是变量修饰符，而synchronized则作用于一段代码或方法。<br>volatile只是在线程内存和“主”内存间同步某个变量的值；而synchronized通过锁定和解锁某个监视器同步所有变量的值, 显然synchronized要比volatile消耗更多资源。<br>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。<br>volatile保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存中和公共内存中的数据做同步。<br>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。<br>线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。<br>关键字volatile主要使用的场合是在多个线程中可以感知实例变量被修改，并且可以获得最新的值使用，也就是多线程读取共享变量时可以获得最新值使用。</p>
<p>关键字volatile提示线程每次从共享内存中读取变量，而不是私有内存中读取，这样就保证了同步数据的可见性。但是要注意的是：如果修改实例变量中的数据</p>
<h2 id="2-接口和抽象类"><a href="#2-接口和抽象类" class="headerlink" title="2.接口和抽象类"></a>2.接口和抽象类</h2><p>A:成员的区别<br>抽象类：<br>构造方法：有构造方法，用于子类实例化使用。<br>成员变量：可以是变量，也可以是常量。<br>成员方法：可以是抽象的，也可以是非抽象的。</p>
<p>接口：<br>构造方法：没有构造方法<br>成员变量：只能是常量。默认修饰符：public static final<br>成员方法：jdk1.7只能是抽象的。默认修饰符：public abstract (推荐：默认修饰符请自己永远手动给出)<br>jdk1.8可以写以default和static开头的具体方法</p>
<p>B:类和接口的关系区别<br>类与类：<br>继承关系,只能单继承。可以多层继承。</p>
<p>类与接口：<br>实现关系,可以单实现,也可以多实现。<br>类还可以在继承一个类的同时实现多个接口。</p>
<p>接口与接口：<br>继承关系,可以单继承,也可以多继承。</p>
<p>C:体现的理念不同<br>抽象类里面定义的都是一个继承体系中的共性内容。<br>接口是功能的集合,是一个体系额外的功能，是暴露出来的规则。</p>
<p>分割一下</p>
<p>你选择使用接口和抽象类的依据是什么？</p>
<p>接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。</p>
<p>抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。</p>
<p>人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.</p>
<p>所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。</p>
<p>当你关注一个事物的本质的时候，用抽象类；当你关注一个操作的时候，用接口。</p>
<p>抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是针对一个动作的描述。而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度。</p>
<h2 id="3-内部类"><a href="#3-内部类" class="headerlink" title="3.内部类"></a>3.内部类</h2><p>一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员（属性、方法、构造器、代码块、内部类），内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>class Outer{ //外部类<br>class Inner{ //内部类<br>}<br>}<br>class Other{ //外部其他类<br>}</strong></p>
<h3 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h3><h4 id="定义在外部类局部位置上-如方法内"><a href="#定义在外部类局部位置上-如方法内" class="headerlink" title="定义在外部类局部位置上(如方法内):"></a>定义在外部类局部位置上(如方法内):</h4><p>1)局部内部类(有类名)<br>2)匿名内部类(没有类名，重点!!!)</p>
<h4 id="定义在外部类的成员位置上"><a href="#定义在外部类的成员位置上" class="headerlink" title="定义在外部类的成员位置上:"></a>定义在外部类的成员位置上:</h4><p>1)成员内部类(没用static修饰)<br>2)静态内部类（使用static修饰)</p>
<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutClass2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">partClassTest</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> d =<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//在partCLassTest方法中定义一个局部内部类PastClass</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PastClass</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:局部内部类是定义在外部类的局部位置，比如方法中，并且有类名。</p>
<ul>
<li>1.可以直接访问外部类的所有成员,包含私有的。</li>
<li>2.不能添加访问修饰符,因为它的地位就是一个局部变量。局部变量是不能使用修饰符的，但是可以使用final修饰，因为局部变量也可以使用final。</li>
<li>3.作用域:仅仅在定义它的方法或代码块中。</li>
<li>4.局部内部类—访问—-&gt;外部类的成员[访问方式:直接访问]。</li>
<li>5.外部类—访问—-&gt;局部内部类的成员<br>访问方式:创建对象,再访问(注意:必须在作用域内)<br>记住:(1)局部内部类定义在方法中/代码块<br>(2)作用域在方法体或者代码块中<br>(3)本质仍然是一个类</li>
<li>6.外部其他类—不能访问—–&gt;局部内部类（因为局部内部类地位是一个局部变量)。</li>
<li>7.如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问。</li>
<li>8.外部类在方法中，可以创建内部类对象，然后调用方法即可。</li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Worker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span>(<span class="params">String name</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">workTime</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params">Worker worker</span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(worker.getName()+<span class="string">"工作时间："</span>+worker.workTime());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="comment">//在方法中定义并使用匿名内部类</span></span><br><span class="line">        test.test(<span class="keyword">new</span> Worker() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">workTime</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"alex"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)本质是类<br>(2)内部类<br>(3)该类没有名字<br>(4)同时还是一个对象<br>说明:匿名内部类是定义在外部类<br>的局部位置,比如方法中，并且没有类名<br>1.匿名内部类的基本语法:<br>new类或接口(参数列表){<br>类体<br>};</p>
<p>①匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义,同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，,因此可以调用匿名内部类方法。<br>②.可以直接访问外部类的所有成员，包含私有的<br>③不能添加访问修饰符,因为它的地位就是一个局部变量<br>④作用域:仅仅在定义它的方法或代码块中。<br>⑤匿名内部类—访问—-&gt;外部类成员[访问方式:直接访问]<br>⑥外部其他类—不能访问—–&gt;匿名内部类（因为匿名内部类地位是一个局部变量)<br>⑦如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则,如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问</p>
<h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OutClass1</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="comment">//定义一个成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MemberInnerClass</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(a);</span><br><span class="line">            System.<span class="keyword">out</span>.println(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:成员内部类是定义在外部类的成员位置,并且没有static修饰。<br>1.可以直接访问外部类的所有成员，包含私有的<br>2.可以添加任意访问修饰符(public、protected、默认、private),因为它的地<br>位就是一个成员。<br>3.作用域和外部类的其他成员一样,为整个类体，在外部类的成员方法中创建成员内部类对象,再调用方法.<br>4.成员内部类—访问—-&gt;外部类成员(比如;属性)[访问方式:直接访问]<br>5.外部类—访问——&gt;成员内部类 访问方式:创建对象，再访问<br>6.外部其他类—访问—-&gt;成员内部类<br>7.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String className=<span class="string">"staticInnerClass"</span>;</span><br><span class="line">    <span class="comment">//定义一个静态内部类</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">class</span> <span class="title">StaticInnerClass</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClassName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"className:"</span>+className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        <span class="comment">//调用静态内部类</span></span><br><span class="line">        OuterClass.StaticInnerClass staticInnerClass =</span><br><span class="line">                <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">        staticInnerClass.getClassName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:静态内部类是定义在外部类的成员位置，并且有static修饰<br>1.可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员<br>2.可以添加任意访问修饰符(public、protected、默认、private),因为它的地位就是一个成员。<br>3.作用域:同其他的成员，为整个类体<br>4.静态内部类—访问—-&gt;外部类(比如:静态属性)[访问方式:直接访问所有静态成员]<br>5.外部类—访问——&gt;静态内部类访问方式:创建对象，再访问<br>6.外部其他类—访问—–&gt;静态内部类<br>7.如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名.成员)去访问</p>
<h2 id="4-桥接模式和适配器模式的区别"><a href="#4-桥接模式和适配器模式的区别" class="headerlink" title="4.桥接模式和适配器模式的区别"></a>4.桥接模式和适配器模式的区别</h2><p>很多时候经常容易把桥接模式和适配器模式弄混。那什么时候用桥接，什么时候用适配器呢 ？</p>
<ul>
<li>共同点</li>
</ul>
<p>桥接和适配器都是让两个东西配合工作</p>
<ul>
<li>不同点</li>
</ul>
<p>出发点不同。<br>     1）适配器：改变已有的两个接口，让他们相容。<br>     2）桥接模式：分离抽象化和实现，使两者的接口可以不同，目的是分离。</p>
<p>​    所以说，如果你拿到两个已有模块，想让他们同时工作，那么你使用的适配器。<br>​    如果你还什么都没有，但是想分开实现，那么桥接是一个选择。</p>
<p>​    桥接是先有桥，才有两端的东西<br>​    适配是先有两边的东西，才有适配器</p>
<p>​    桥接是在桥好了之后，两边的东西还可以变化。</p>
<h2 id="5-代理模式和装饰模式的区别"><a href="#5-代理模式和装饰模式的区别" class="headerlink" title="5.代理模式和装饰模式的区别"></a>5.代理模式和装饰模式的区别</h2><ul>
<li>区别</li>
</ul>
<p>两者都是对类的方法进行增强，但装饰器模式强调的是增强自身，在被装饰之后你能够够在被增强的类上使用增强后的方法。增强过后还是你，只不过能力变强了。</p>
<p>而代理模式则强调要别人帮你去做一些本身与你业务没有太多关系的职责。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。</p>
<ul>
<li>装饰类的代码编写和代理很类似，具体区别如下：</li>
</ul>
<p>1).代理是全权代理，被代理类根本不对外，全部由代理类来完成，通过代理对象来访问。<br>2).装饰是增强，是辅助，被代理类仍然可以自行对外提供服务，装饰器只起增强作用。<br>3).代理的目标也可以是类，装饰目标必须是接口。<br>4).代理模式应用有Spring AOP和Spring 事务等；装饰模式应用IO类，Spring过滤器也会用到装饰模式，可以链式调用。<br>总之，代理模式只能通过代理类访问，装饰模式被装饰都可以被访问，只是功能被增强。</p>
<h2 id="6-策略模式和命令模式的区别"><a href="#6-策略模式和命令模式的区别" class="headerlink" title="6.策略模式和命令模式的区别"></a>6.策略模式和命令模式的区别</h2><p>策略模式是通过不同的算法做同一件事情：例如排序</p>
<p>而命令模式则是通过不同的命令做不同的事情，常含有（关联）接收者。</p>
<p>目标不同！</p>
<p>命令模式是含有不同的命令（含有接收者的请求）：做不同的事情；隐藏接收者执行细节。常见菜单事件，</p>
<p>而策略模式含有不同的算法，做相同的事情；</p>
<p><strong>区别在于是否含有接收者。命令模式含有，策略模式不含有。</strong>命令模式中的命令可以单独运行。</p>
<p>个人观点：java 对象中，所谓做一件事情，其实就是执行一个方法；所谓面向接口，就是自己不干事，交给别人干；策略模式中，对象的行为委托给了不同的策略；命令模式中，对象的行为委托给了命令，命令又将行为委托给了接收者；就是说，命令模式中，命令接口其实就是命令发出者和接收者的一个中间层，使达到解耦的目的；老话说的好，没啥问题是加一个中间层解决不了的，实在不行，再加一层；当然，如果命令的接收执行者是多人，那就又可以考虑责任链模式了</p>
<h2 id="7-策略模式和状态模式的区别"><a href="#7-策略模式和状态模式的区别" class="headerlink" title="7.策略模式和状态模式的区别"></a>7.策略模式和状态模式的区别</h2><p>策略模式与状态模式在实现上有共同之处，都是把不同的情形抽象为统一的接口来实现。2个模式的UML建模图基本相似，区别在于：</p>
<p>状态模式需要在子类实现与context相关的一个状态行为。状态模式的的思想是，状态之间的切换，在状态A执行完毕后自己控制状态指向状态B。状态模式是不停的切换状态执行。</p>
<p>策略模式的思想上是，考虑多种不同的业务规则将不同的算法封装起来，便于调用者选择调用。策略模式只是条件选择执行一次。</p>
<p>个人认为：策略模式抽象的多是方法（行为：将方法抽象为对象，不同的实现达到同一个目标：比如不同的压缩算法，都是为压缩，春运时不同的交通工具选择，都是为回家 等等）；而状态模式，重点是抽象状态，即字段数据；不同状态下，即使同一个方法也会有不同的结果；所以，状态模式下，通常状态对象和环境对象会彼此引用，环境对象会将自己的行为委托给状态对象，状态对象内部行为会涉及到状态的流转变化；</p>
<h2 id="8-模板方法和策略模式的区别"><a href="#8-模板方法和策略模式的区别" class="headerlink" title="8. 模板方法和策略模式的区别"></a>8. 模板方法和策略模式的区别</h2><p>模板方法：定义一个操作算法的骨架,而将这一些步骤延迟到子类中,模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>
<p>策略模式：定义一系列的算法,把他们一个个给封装起来,并且使他们可以互相替换.</p>
<p>二者区别是：这里的模板的操作算法和策略的模式的算法都是指泛义上的算法，可以简单的理解为具体实现。<br>模板方法替换算法的方法最直接，就是继承覆盖，一看就懂。当然模板方法的重点是定义这些算法的结构；模板方法用继承来实现算法的替换；而策略模式采用的是组合复用。一者为垂直的继承实现关系， 二者为水平的包含依赖；</p>
<h2 id="9-模板方法模式和工厂方法模式的区别"><a href="#9-模板方法模式和工厂方法模式的区别" class="headerlink" title="9.模板方法模式和工厂方法模式的区别"></a>9.模板方法模式和工厂方法模式的区别</h2><p>模板方法模式和工厂方法模式分别隶属于行为模式（Behavioral Pattern）和创建类模式（创建型模式）， 但是他们的核心思想却十分相似， 而且通常会同时出现。</p>
<ul>
<li>模板方式和工厂模式的核心思想非常类似， 都是把一些操作留给子类去实现。</li>
<li><strong>模板方法</strong>中常常会调用<strong>工厂方法</strong>的， 他们之间存在着的紧密的情侣关系。</li>
<li>工厂方法模式和模板方法模式的区别在于：<ul>
<li>模板方法模式的意义在于固定了一个算法的整体结构， 复用了其中通用的步骤， 将需要定制的部分留给了子类实现</li>
<li>工厂方法模式的意义在于解决了父类没有办法预知应该实现什么子类的问题</li>
</ul>
</li>
</ul>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2023/03/100685.html" class="pre-post btn btn-default" title='InStock股票系统'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">InStock股票系统</span>
        </a>
    
    
        <a href="/archives/2022/04/100710.html" class="next-post btn btn-default" title='指标解读indicator'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">指标解读indicator</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一-设计模式目的"><span class="toc-text">一. 设计模式目的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二-设计模式"><span class="toc-text">二. 设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-工厂模式"><span class="toc-text">1.工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-抽象工厂模式"><span class="toc-text">2.抽象工厂模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-1"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-单例模式"><span class="toc-text">3.单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-2"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-建造者模式"><span class="toc-text">4.建造者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-3"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-原型模式"><span class="toc-text">5.原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-4"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-适配器模式"><span class="toc-text">6.适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-5"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-桥接模式"><span class="toc-text">7.桥接模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-6"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-组合模式"><span class="toc-text">8.组合模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-7"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-装饰模式"><span class="toc-text">9.装饰模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-8"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-外观模式"><span class="toc-text">10.外观模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-9"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-享元模式"><span class="toc-text">11.享元模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-10"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-代理模式"><span class="toc-text">12.代理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-11"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-责任链模式"><span class="toc-text">13.责任链模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-12"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-命令模式"><span class="toc-text">14.命令模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-13"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-解释器模式"><span class="toc-text">15.解释器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-14"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-迭代器模式"><span class="toc-text">16.迭代器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-15"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-中介者模式"><span class="toc-text">17.中介者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-16"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-备忘录模式"><span class="toc-text">18.备忘录模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-17"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-观察者模式"><span class="toc-text">19.观察者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-18"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-状态模式"><span class="toc-text">20.状态模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-19"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-策略模式"><span class="toc-text">21.策略模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-20"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-模版方法模式"><span class="toc-text">22. 模版方法模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-21"><span class="toc-text">介绍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-访问者模式"><span class="toc-text">23.访问者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#介绍-22"><span class="toc-text">介绍</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三-设计模式类间关系"><span class="toc-text">三.设计模式类间关系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-关联关系-Association"><span class="toc-text">1.关联关系(Association)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-聚合关系-Aggregation"><span class="toc-text">2. 聚合关系(Aggregation)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-组合关系-Composition"><span class="toc-text">3. 组合关系(Composition)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-依赖关系-Dependency"><span class="toc-text">4. 依赖关系(Dependency)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-泛化关系-Generalization"><span class="toc-text">5. 泛化关系(Generalization)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-实现关系-Realization"><span class="toc-text">6. 实现关系(Realization)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四-设计模式七大原则"><span class="toc-text">四.设计模式七大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、单一职责原则"><span class="toc-text">1、单一职责原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1基本介绍"><span class="toc-text">1.1基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2应用实例-以交通工具案例讲解"><span class="toc-text">1.2应用实例:以交通工具案例讲解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-单一职责原则注意事项和细节"><span class="toc-text">1.3 单一职责原则注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、-接口隔离原则"><span class="toc-text">2、 接口隔离原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-基本介绍"><span class="toc-text">1.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-应用示例"><span class="toc-text">1.2 应用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、-依赖倒转原则"><span class="toc-text">3、 依赖倒转原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-基本介绍-1"><span class="toc-text">1.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-应用实例"><span class="toc-text">1.2 应用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-依赖关系传递的三种方式"><span class="toc-text">1.3 依赖关系传递的三种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-依赖倒转原则的注意事项和细节"><span class="toc-text">1.4 依赖倒转原则的注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、-里氏替换原则"><span class="toc-text">4、 里氏替换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-OO中的继承性的思考和说明"><span class="toc-text">1.1 OO中的继承性的思考和说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-基本介绍"><span class="toc-text">1.2 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-应用示例"><span class="toc-text">1.3 应用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、开闭原则"><span class="toc-text">5、开闭原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-基本介绍-2"><span class="toc-text">1.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2应用示例"><span class="toc-text">1.2应用示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、-迪米特法则"><span class="toc-text">6、 迪米特法则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-基本介绍-3"><span class="toc-text">1.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-应用实例-1"><span class="toc-text">1.2 应用实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-迪米特法则注意事项和细节"><span class="toc-text">1.3 迪米特法则注意事项和细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、合成复用原则"><span class="toc-text">7、合成复用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-基本介绍-4"><span class="toc-text">1.1 基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-设计原则核心思想"><span class="toc-text">1.2 设计原则核心思想</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五-相关知识"><span class="toc-text">五.相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-volatile和synchronize"><span class="toc-text">1.volatile和synchronize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-接口和抽象类"><span class="toc-text">2.接口和抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-内部类"><span class="toc-text">3.内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本语法"><span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类的分类"><span class="toc-text">内部类的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义在外部类局部位置上-如方法内"><span class="toc-text">定义在外部类局部位置上(如方法内):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义在外部类的成员位置上"><span class="toc-text">定义在外部类的成员位置上:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#局部内部类"><span class="toc-text">局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匿名内部类"><span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员内部类"><span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态内部类"><span class="toc-text">静态内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-桥接模式和适配器模式的区别"><span class="toc-text">4.桥接模式和适配器模式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-代理模式和装饰模式的区别"><span class="toc-text">5.代理模式和装饰模式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-策略模式和命令模式的区别"><span class="toc-text">6.策略模式和命令模式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-策略模式和状态模式的区别"><span class="toc-text">7.策略模式和状态模式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-模板方法和策略模式的区别"><span class="toc-text">8. 模板方法和策略模式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-模板方法模式和工厂方法模式的区别"><span class="toc-text">9.模板方法模式和工厂方法模式的区别</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2023&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>