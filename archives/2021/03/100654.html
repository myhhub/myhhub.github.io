<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="c++,cmake,qt">


    <meta name="description" content="本章中主要内容有:

检测Python解释器
检测Python库
检测Python模块和包
检测BLAS和LAPACK数学库
检测OpenMP并行环境
检测MPI并行环境
检测Eigen库
检测...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>CMake 完整使用教程 之四 检测外部库和程序 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="CMake 完整使用教程 之四 检测外部库和程序">
            
	            CMake 完整使用教程 之四 检测外部库和程序
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/c/">c++</a> <a class="tag-link" href="/tags/cmake/">cmake</a> <a class="tag-link" href="/tags/qt/">qt</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2021/03/29</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1204</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>本章中主要内容有:</p>
<ul>
<li>检测Python解释器</li>
<li>检测Python库</li>
<li>检测Python模块和包</li>
<li>检测BLAS和LAPACK数学库</li>
<li>检测OpenMP并行环境</li>
<li>检测MPI并行环境</li>
<li>检测Eigen库</li>
<li>检测Boost库</li>
<li>检测外部库:Ⅰ. 使用pkg-config</li>
<li>检测外部库:Ⅱ. 书写find模块</li>
</ul>
<p>我们的项目常常会依赖于其他项目和库。本章将演示，如何检测外部库、框架和项目，以及如何链接到这些库。CMake有一组预打包模块，用于检测常用库和程序，例如：Python和Boost。可以使用<code>cmake --help-module-list</code>获得现有模块的列表。但是，不是所有的库和程序都包含在其中，有时必须自己编写检测脚本。本章将讨论相应的工具，了解CMake的<code>find</code>族命令:</p>
<ul>
<li><strong>find_file</strong>：在相应路径下查找命名文件</li>
<li><strong>find_library</strong>：查找一个库文件</li>
<li><strong>find_package</strong>：从外部项目查找和加载设置</li>
<li><strong>find_path</strong>：查找包含指定文件的目录</li>
<li><strong>find_program</strong>：找到一个可执行程序</li>
</ul>
<p><strong>NOTE</strong>:<em>可以使用<code>--help-command</code>命令行显示CMake内置命令的打印文档。</em></p>
<h1 id="3-1-检测Python解释器"><a href="#3-1-检测Python解释器" class="headerlink" title="3.1 检测Python解释器"></a>3.1 检测Python解释器</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-01" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-01</a> 中找到。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>Python是一种非常流行的语言。许多项目用Python编写的工具，从而将主程序和库打包在一起，或者在配置或构建过程中使用Python脚本。这种情况下，确保运行时对Python解释器的依赖也需要得到满足。本示例将展示如何检测和使用Python解释器。</p>
<p>我们将介绍<code>find_package</code>命令，这个命令将贯穿本章。</p>
<h2 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h2><p>我们将逐步建立<code>CMakeLists.txt</code>文件:</p>
<ol>
<li><p>首先，定义CMake最低版本和项目名称。注意，这里不需要任何语言支持:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">01</span> LANGUAGES NONE)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，使用<code>find_package</code>命令找到Python解释器:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，执行Python命令并捕获它的输出和返回值:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="string">"-c"</span> <span class="string">"print('Hello, world!')"</span></span><br><span class="line">  RESULT_VARIABLE _status</span><br><span class="line">  OUTPUT_VARIABLE _hello_world</span><br><span class="line">  ERROR_QUIET</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，打印Python命令的返回值和输出:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"RESULT_VARIABLE is: $&#123;_status&#125;"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"OUTPUT_VARIABLE is: $&#123;_hello_world&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置项目:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line"></span><br><span class="line">-- Found <span class="string">PythonInterp:</span> <span class="regexp">/usr/</span>bin/python (found version <span class="string">"3.6.5"</span>)</span><br><span class="line">-- RESULT_VARIABLE <span class="string">is:</span> <span class="number">0</span></span><br><span class="line">-- OUTPUT_VARIABLE <span class="string">is:</span> Hello, world!</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written <span class="string">to:</span> <span class="regexp">/home/</span>user<span class="regexp">/cmake-cookbook/</span>chapter<span class="number">-03</span><span class="regexp">/recipe-01/</span>example/build</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>find_package</code>是用于发现和设置包的CMake模块的命令。这些模块包含CMake命令，用于标识系统标准位置中的包。CMake模块文件称为<code>Find&lt;name&gt;.cmake</code>，当调用<code>find_package(&lt;name&gt;)</code>时，模块中的命令将会运行。</p>
<p>除了在系统上实际查找包模块之外，查找模块还会设置了一些有用的变量，反映实际找到了什么，也可以在自己的<code>CMakeLists.txt</code>中使用这些变量。对于Python解释器，相关模块为<code>FindPythonInterp.cmake</code>附带的设置了一些CMake变量:</p>
<ul>
<li><strong>PYTHONINTERP_FOUND</strong>：是否找到解释器</li>
<li><strong>PYTHON_EXECUTABLE</strong>：Python解释器到可执行文件的路径</li>
<li><strong>PYTHON_VERSION_STRING</strong>：Python解释器的完整版本信息</li>
<li><strong>PYTHON_VERSION_MAJOR</strong>：Python解释器的主要版本号</li>
<li><strong>PYTHON_VERSION_MINOR</strong> ：Python解释器的次要版本号</li>
<li><strong>PYTHON_VERSION_PATCH</strong>：Python解释器的补丁版本号</li>
</ul>
<p>可以强制CMake，查找特定版本的包。例如，要求Python解释器的版本大于或等于2.7：<code>find_package(PythonInterp 2.7)</code></p>
<p>可以强制满足依赖关系:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
<p>如果在查找位置中没有找到适合Python解释器的可执行文件，CMake将中止配置。</p>
<p><strong>TIPS</strong>:<em>CMake有很多查找软件包的模块。我们建议在CMake在线文档中查询<code>Find&lt;package&gt;.cmake</code>模块，并在使用它们之前详细阅读它们的文档。<code>find_package</code>命令的文档可以参考 <a href="https://cmake.org/cmake/help/v3.5/command/find_ackage.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.5/command/find_ackage.html</a> 。在线文档的一个很好的替代方法是浏览 <a href="https://github.com/Kitware/CMake/tree/master/Modules" target="_blank" rel="noopener">https://github.com/Kitware/CMake/tree/master/Modules</a> 中的CMake模块源代码——它们记录了模块使用的变量，以及模块可以在<code>CMakeLists.txt</code>中使用的变量。</em></p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>软件包没有安装在标准位置时，CMake无法正确定位它们。用户可以使用CLI的<code>-D</code>参数传递相应的选项，告诉CMake查看特定的位置。Python解释器可以使用以下配置:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D <span class="attribute">PYTHON_EXECUTABLE</span>=/custom/location/python <span class="built_in">..</span></span><br></pre></td></tr></table></figure>
<p>这将指定非标准<code>/custom/location/python</code>安装目录中的Python可执行文件。</p>
<p><strong>NOTE</strong>:<em>每个包都是不同的，<code>Find&lt;package&gt;.cmake</code>模块试图提供统一的检测接口。当CMake无法找到模块包时，我们建议您阅读相应检测模块的文档，以了解如何正确地使用CMake模块。可以在终端中直接浏览文档，本例中可使用<code>cmake --help-module FindPythonInterp</code>查看。</em></p>
<p>除了检测包之外，我们还想提到一个便于打印变量的helper模块。本示例中，我们使用了以下方法:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"RESULT_VARIABLE is: $&#123;_status&#125;"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"OUTPUT_VARIABLE is: $&#123;_hello_world&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>使用以下工具进行调试:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(CMakePrintHelpers)</span></span></span><br><span class="line"><span class="function"><span class="title">cmake_print_variables</span><span class="params">(_status _hello_world)</span></span></span><br></pre></td></tr></table></figure>
<p>将产生以下输出:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="attribute">_status</span>=<span class="string">"0"</span> ; <span class="attribute">_hello_world</span>=<span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure>
<p>有关打印属性和变量的更多信息，请参考 <a href="https://cmake.org/cmake/help/v3.5/module/CMakePrintHelpers.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.5/module/CMakePrintHelpers.html</a> 。</p>
<h1 id="3-2-检测Python库"><a href="#3-2-检测Python库" class="headerlink" title="3.2 检测Python库"></a>3.2 检测Python库</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/devcafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-02" target="_blank" rel="noopener">https://github.com/devcafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-02</a> 中找到，有一个C示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>可以使用Python工具来分析和操作程序的输出。然而，还有更强大的方法可以将解释语言(如Python)与编译语言(如C或C++)组合在一起使用。一种是扩展Python，通过编译成共享库的C或C++模块在这些类型上提供新类型和新功能，这是第9章的主题。另一种是将Python解释器嵌入到C或C++程序中。两种方法都需要下列条件:</p>
<ul>
<li>Python解释器的工作版本</li>
<li>Python头文件Python.h的可用性</li>
<li>Python运行时库libpython</li>
</ul>
<p>三个组件所使用的Python版本必须相同。我们已经演示了如何找到Python解释器；本示例中，我们将展示另外两种方式。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将一个简单的Python代码，嵌入到C程序中，可以在Python文档页面上找到。源文件称为<code>hello-embedded-python.c</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  Py_SetProgramName(argv[<span class="number">0</span>]); <span class="comment">/* optional but recommended */</span></span><br><span class="line">  Py_Initialize();</span><br><span class="line">  PyRun_SimpleString(<span class="string">"from time import time,ctime\n"</span></span><br><span class="line">                     <span class="string">"print 'Today is',ctime(time())\n"</span>);</span><br><span class="line">  Py_Finalize();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码将在程序中初始化Python解释器的实例，并使用Python的<code>time</code>模块，打印日期。</p>
<p><strong>NOTE</strong>:<em>嵌入代码可以在Python文档页面的 <a href="https://docs.python.org/2/extending/embedding.html" target="_blank" rel="noopener">https://docs.python.org/2/extending/embedding.html</a> 和 <a href="https://docs.python.org/3/extending/embedding.html" target="_blank" rel="noopener">https://docs.python.org/3/extending/embedding.html</a> 中找到。</em></p>
<h2 id="具体实施-1"><a href="#具体实施-1" class="headerlink" title="具体实施"></a>具体实施</h2><p>以下是<code>CMakeLists.txt</code>中的步骤:</p>
<ol>
<li><p>包含CMake最低版本、项目名称和所需语言:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">02</span> LANGUAGES C)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>制使用C99标准，这不严格要求与Python链接，但有时你可能需要对Python进行连接:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_STANDARD <span class="number">99</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到Python解释器。这是一个<code>REQUIRED</code>依赖:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到Python头文件和库的模块，称为<code>FindPythonLibs.cmake</code>:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonLibs <span class="variable">$&#123;PYTHON_VERSION_MAJOR&#125;</span>.<span class="variable">$&#123;PYTHON_VERSION_MINOR&#125;</span> EXACT REQUIRED)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>hello-embedded-python.c</code>源文件，添加一个可执行目标:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(hello-embedded-python hello-embedded-python.c)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可执行文件包含<code>Python.h</code>头文件。因此，这个目标的<code>include</code>目录必须包含Python的<code>include</code>目录，可以通过<code>PYTHON_INCLUDE_DIRS</code>变量进行指定:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(hello-embedded-python</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;PYTHON_INCLUDE_DIRS&#125;</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，将可执行文件链接到Python库，通过<code>PYTHON_LIBRARIES</code>变量访问:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(hello-embedded-python</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;PYTHON_LIBRARIES&#125;</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，进行构建:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">-- Found <span class="symbol">PythonInterp:</span> /usr/bin/python (found version <span class="string">"3.6.5"</span>)</span><br><span class="line">-- Found <span class="symbol">PythonLibs:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libpython3</span>.6<span class="title">m</span>.<span class="title">so</span> (<span class="title">found</span> <span class="title">suitable</span> <span class="title">exact</span> <span class="title">version</span> "3.6.5")</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，执行构建，并运行可执行文件:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cmake <span class="comment">--build .</span></span><br><span class="line">$ ./hello-embedded-python</span><br><span class="line"></span><br><span class="line">Today <span class="keyword">is</span> Thu Jun <span class="number">7</span> <span class="number">22</span>:<span class="number">26</span>:<span class="number">02</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>FindPythonLibs.cmake</code>模块将查找Python头文件和库的标准位置。由于，我们的项目需要这些依赖项，如果没有找到这些依赖项，将停止配置，并报出错误。</p>
<p>注意，我们显式地要求CMake检测安装的Python可执行文件。这是为了确保可执行文件、头文件和库都有一个匹配的版本。这对于不同版本，可能在运行时导致崩溃。我们通过<code>FindPythonInterp.cmake</code>中定义的<code>PYTHON_VERSION_MAJOR</code>和<code>PYTHON_VERSION_MINOR</code>来实现:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonLibs $&#123;PYTHON_VERSION_MAJOR&#125;.$&#123;PYTHON_VERSION_MINOR&#125; EXACT REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
<p>使用<code>EXACT</code>关键字，限制CMake检测特定的版本，在本例中是匹配的相应Python版本的包括文件和库。我们可以使用<code>PYTHON_VERSION_STRING</code>变量，进行更接近的匹配:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonLibs $&#123;PYTHON_VERSION_STRING&#125; EXACT REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="更多信息-1"><a href="#更多信息-1" class="headerlink" title="更多信息"></a>更多信息</h2><p>当Python不在标准安装目录中，我们如何确定Python头文件和库的位置是正确的？对于Python解释器，可以通过CLI的<code>-D</code>选项传递<code>PYTHON_LIBRARY</code>和<code>PYTHON_INCLUDE_DIR</code>选项来强制CMake查找特定的目录。这些选项指定了以下内容:</p>
<ul>
<li><strong>PYTHON_LIBRARY</strong>：指向Python库的路径</li>
<li><strong>PYTHON_INCLUDE_DIR</strong>：Python.h所在的路径</li>
</ul>
<p>这样，就能获得所需的Python版本。</p>
<p><strong>TIPS</strong>:<em>有时需要将<code>-D PYTHON_EXECUTABLE</code>、<code>-D PYTHON_LIBRARY</code>和<code>-D PYTHON_INCLUDE_DIR</code>传递给CMake CLI，以便找到及定位相应的版本的组件。</em></p>
<p>要将Python解释器及其开发组件匹配为完全相同的版本可能非常困难，对于那些将它们安装在非标准位置或系统上安装了多个版本的情况尤其如此。CMake 3.12版本中增加了新的Python检测模块，旨在解决这个棘手的问题。我们<code>CMakeLists.txt</code>的检测部分也将简化为:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Python COMPONENTS Interpreter Development REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
<p>我们建议您阅读新模块的文档，地址是: <a href="https://cmake.org/cmake/help/v3.12/module/FindPython.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.12/module/FindPython.html</a></p>
<h1 id="3-3-检测Python模块和包"><a href="#3-3-检测Python模块和包" class="headerlink" title="3.3 检测Python模块和包"></a>3.3 检测Python模块和包</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/devcafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-03" target="_blank" rel="noopener">https://github.com/devcafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-03</a> 中找到，包含一个C++示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>前面的示例中，我们演示了如何检测Python解释器，以及如何编译一个简单的C程序(嵌入Python解释器)。通常，代码将依赖于特定的Python模块，无论是Python工具、嵌入Python的程序，还是扩展Python的库。例如，科学界非常流行使用NumPy处理矩阵问题。依赖于Python模块或包的项目中，确定满足对这些Python模块的依赖非常重要。本示例将展示如何探测用户的环境，以找到特定的Python模块和包。</p>
<h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将尝试在C++程序中嵌入一个稍微复杂一点的例子。这个示例再次引用<a href="https://docs.python.org/3.5/extending/embedding.html#pureembedded" target="_blank" rel="noopener">Python在线文档</a>，并展示了如何通过调用编译后的C++可执行文件，来执行用户定义的Python模块中的函数。</p>
<p>Python 3示例代码(<code>Py3-pure-embedding.cpp</code>)包含以下源代码(请参见<a href="https://docs.python.org/2/extending/embedding.html#pure-embedded" target="_blank" rel="noopener">https://docs.python.org/2/extending/embedding.html#pure-embedded</a> 与Python 2代码等效):</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;Python.h&gt;</span></span><br><span class="line">int main(int argc, char* argv[]) &#123;</span><br><span class="line">  PyObject* pName, * pModule, * pDict, * pFunc<span class="comment">;</span></span><br><span class="line">  PyObject* pArgs, * pValue<span class="comment">;</span></span><br><span class="line">  int i<span class="comment">;</span></span><br><span class="line">  if (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    fprintf(stderr, <span class="string">"Usage: pure-embedding pythonfile funcname [args]\n"</span>)<span class="comment">;</span></span><br><span class="line">    return <span class="number">1</span><span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  Py_Initialize()<span class="comment">;</span></span><br><span class="line">  PyRun_SimpleString(<span class="string">"import sys"</span>)<span class="comment">;</span></span><br><span class="line">  PyRun_SimpleString(<span class="string">"sys.path.append(\".\")"</span>)<span class="comment">;</span></span><br><span class="line">  pName = PyUnicode_DecodeFSDefault(argv[<span class="number">1</span>])<span class="comment">;</span></span><br><span class="line">  <span class="comment">/* Error checking of pName left out */</span></span><br><span class="line">  pModule = PyImport_Import(pName)<span class="comment">;</span></span><br><span class="line">  Py_DECREF(pName)<span class="comment">;</span></span><br><span class="line">  if (pModule != NULL) &#123;</span><br><span class="line">    pFunc = PyObject_GetAttrString(pModule, argv[<span class="number">2</span>])<span class="comment">;</span></span><br><span class="line">    <span class="comment">/* pFunc is a new reference */</span></span><br><span class="line">    if (pFunc &amp;&amp; PyCallable_Check(pFunc)) &#123;</span><br><span class="line">      pArgs = PyTuple_New(argc - <span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">      for (i = <span class="number">0</span><span class="comment">; i &lt; argc - 3; ++i) &#123;</span></span><br><span class="line">        pValue = PyLong_FromLong(atoi(argv[i + <span class="number">3</span>]))<span class="comment">;</span></span><br><span class="line">        if (!pValue) &#123;</span><br><span class="line">          Py_DECREF(pArgs)<span class="comment">;</span></span><br><span class="line">          Py_DECREF(pModule)<span class="comment">;</span></span><br><span class="line">          fprintf(stderr, <span class="string">"Cannot convert argument\n"</span>)<span class="comment">;</span></span><br><span class="line">          return <span class="number">1</span><span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* pValue reference stolen here: */</span></span><br><span class="line">        PyTuple_SetItem(pArgs, i, pValue)<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">      pValue = PyObject_CallObject(pFunc, pArgs)<span class="comment">;</span></span><br><span class="line">      Py_DECREF(pArgs)<span class="comment">;</span></span><br><span class="line">      if (pValue != NULL) &#123;</span><br><span class="line">        printf(<span class="string">"Result of call: %ld\n"</span>, PyLong_AsLong(pValue))<span class="comment">;</span></span><br><span class="line">        Py_DECREF(pValue)<span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">      else &#123;</span><br><span class="line">        Py_DECREF(pFunc)<span class="comment">;</span></span><br><span class="line">        Py_DECREF(pModule)<span class="comment">;</span></span><br><span class="line">        PyErr_Print()<span class="comment">;</span></span><br><span class="line">        fprintf(stderr, <span class="string">"Call failed\n"</span>)<span class="comment">;</span></span><br><span class="line">        return <span class="number">1</span><span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      if (PyErr_Occurred())</span><br><span class="line">        PyErr_Print()<span class="comment">;</span></span><br><span class="line">      fprintf(stderr, <span class="string">"Cannot find function \"%s\"\n"</span>, argv[<span class="number">2</span>])<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    Py_XDECREF(pFunc)<span class="comment">;</span></span><br><span class="line">    Py_DECREF(pModule)<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    PyErr_Print()<span class="comment">;</span></span><br><span class="line">    fprintf(stderr, <span class="string">"Failed to load \"%s\"\n"</span>, argv[<span class="number">1</span>])<span class="comment">;</span></span><br><span class="line">    return <span class="number">1</span><span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  Py_Finalize()<span class="comment">;</span></span><br><span class="line">  return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们希望嵌入的Python代码(<code>use_numpy.py</code>)使用NumPy设置一个矩阵，所有矩阵元素都为1.0:</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def <span class="built_in">print_ones</span>(<span class="built_in">rows</span>, <span class="built_in">cols</span>):</span><br><span class="line">  A = np.ones(shape=(<span class="built_in">rows</span>, <span class="built_in">cols</span>), dtype=float)</span><br><span class="line">  <span class="keyword">print</span>(A)</span><br><span class="line">  </span><br><span class="line">  <span class="meta"># we return the number of elements to verify</span></span><br><span class="line">  <span class="meta"># that the C++ code is able to receive return values</span></span><br><span class="line">  num_elements = <span class="built_in">rows</span>*<span class="built_in">cols</span></span><br><span class="line">  <span class="keyword">return</span>(num_elements)</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-2"><a href="#具体实施-2" class="headerlink" title="具体实施"></a>具体实施</h2><p>下面的代码中，我们能够使用CMake检查NumPy是否可用。我们需要确保Python解释器、头文件和库在系统上是可用的。然后，将再来确认NumPy的可用性：</p>
<ol>
<li><p>首先，我们定义了最低CMake版本、项目名称、语言和C++标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">03</span> LANGUAGES CXX)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找解释器、头文件和库的方法与前面的方法完全相同:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonLibs $&#123;PYTHON_VERSION_MAJOR&#125;.$&#123;PYTHON_VERSION_MINOR&#125; EXACT REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>正确打包的Python模块，指定安装位置和版本。可以在<code>CMakeLists.txt</code>中执行Python脚本进行探测:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="string">"-c"</span> <span class="string">"import re, numpy; print(re.compile('/__init__.py.*').sub('',numpy.__file__))"</span></span><br><span class="line">  RESULT_VARIABLE _numpy_status</span><br><span class="line">  OUTPUT_VARIABLE _numpy_location</span><br><span class="line">  ERROR_QUIET</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果找到NumPy，则<code>_numpy_status</code>变量为整数，否则为错误的字符串，而<code>_numpy_location</code>将包含NumPy模块的路径。如果找到NumPy，则将它的位置保存到一个名为<code>NumPy</code>的新变量中。注意，新变量被缓存，这意味着CMake创建了一个持久性变量，用户稍后可以修改该变量:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> _numpy_status)</span><br><span class="line">	<span class="keyword">set</span>(NumPy <span class="variable">$&#123;_numpy_location&#125;</span> CACHE <span class="keyword">STRING</span> <span class="string">"Location of NumPy"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>下一步是检查模块的版本。同样，我们在<code>CMakeLists.txt</code>中施加了一些Python魔法，将版本保存到<code>_numpy_version</code>变量中:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="string">"-c"</span> <span class="string">"import numpy; print(numpy.__version__)"</span></span><br><span class="line">  OUTPUT_VARIABLE _numpy_version</span><br><span class="line">  ERROR_QUIET</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，<code>FindPackageHandleStandardArgs</code>的CMake包以正确的格式设置<code>NumPy_FOUND</code>变量和输出信息:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">FindPackageHandleStandardArgs</span>)</span><br><span class="line">find_package_handle_standard_args(<span class="name">NumPy</span></span><br><span class="line">  FOUND_VAR NumPy_FOUND</span><br><span class="line">  REQUIRED_VARS NumPy</span><br><span class="line">  VERSION_VAR _numpy_version</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>一旦正确的找到所有依赖项，我们就可以编译可执行文件，并将其链接到Python库:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">pure-embedding</span> <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">target_sources(<span class="name">pure-embedding</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	Py$&#123;PYTHON_VERSION_MAJOR&#125;-pure-embedding.cpp</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_include_directories(<span class="name">pure-embedding</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&#123;PYTHON_INCLUDE_DIRS&#125;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_link_libraries(<span class="name">pure-embedding</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&#123;PYTHON_LIBRARIES&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们还必须保证<code>use_numpy.py</code>在<code>build</code>目录中可用:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy_if_different <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/use_numpy.py</span><br><span class="line"> 	 <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  DEPENDS</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="comment"># make sure building pure-embedding triggers the above custom command</span></span><br><span class="line"><span class="keyword">target_sources</span>(pure-embedding</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/use_numpy.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，我们可以测试嵌入的代码:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line"></span><br><span class="line">-- ...</span><br><span class="line">-- Found <span class="symbol">PythonInterp:</span> /usr/bin/python (found version <span class="string">"3.6.5"</span>)</span><br><span class="line">-- Found <span class="symbol">PythonLibs:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libpython3</span>.6<span class="title">m</span>.<span class="title">so</span> (<span class="title">found</span> <span class="title">suitable</span> <span class="title">exact</span> <span class="title">version</span> "3.6.5")</span></span><br><span class="line">-- Found <span class="symbol">NumPy:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.6/<span class="title">site</span>-<span class="title">packages</span>/<span class="title">numpy</span> (<span class="title">found</span> <span class="title">version</span> "1.14.3")</span></span><br><span class="line"></span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./pure-embedding use_numpy print_ones <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>. <span class="number">1</span>. <span class="number">1</span>.]</span><br><span class="line">[<span class="number">1</span>. <span class="number">1</span>. <span class="number">1</span>.]]</span><br><span class="line">Result <span class="keyword">of</span> <span class="symbol">call:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h2><p>例子中有三个新的CMake命令，需要<code>include(FindPackageHandleStandardArgs)</code>：</p>
<ul>
<li><code>execute_process</code></li>
<li><code>add_custom_command</code></li>
<li><code>find_package_handle_standard_args</code></li>
</ul>
<p><code>execute_process</code>将作为通过子进程执行一个或多个命令。最后，子进程返回值将保存到变量作为参数，传递给<code>RESULT_VARIABLE</code>，而管道标准输出和标准错误的内容将被保存到变量作为参数传递给<code>OUTPUT_VARIABLE</code>和<code>ERROR_VARIABLE</code>。<code>execute_process</code>可以执行任何操作，并使用它们的结果来推断系统配置。本例中，用它来确保NumPy可用，然后获得模块版本。</p>
<p><code>find_package_handle_standard_args</code>提供了，用于处理与查找相关程序和库的标准工具。引用此命令时，可以正确的处理与版本相关的选项(<code>REQUIRED</code>和<code>EXACT</code>)，而无需更多的CMake代码。稍后将介绍<code>QUIET</code>和<code>COMPONENTS</code>选项。本示例中，使用了以下方法:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">FindPackageHandleStandardArgs</span>)</span><br><span class="line">find_package_handle_standard_args(<span class="name">NumPy</span></span><br><span class="line">  FOUND_VAR NumPy_FOUND</span><br><span class="line">  REQUIRED_VARS NumPy</span><br><span class="line">  VERSION_VAR _numpy_version</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>所有必需的变量都设置为有效的文件路径(NumPy)后，发送到模块(<code>NumPy_FOUND</code>)。它还将版本保存在可传递的版本变量(<code>_numpy_version</code>)中并打印:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- Found <span class="symbol">NumPy:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">python3</span>.6/<span class="title">site</span>-<span class="title">packages</span>/<span class="title">numpy</span> (<span class="title">found</span> <span class="title">version</span> "1.14.3")</span></span><br></pre></td></tr></table></figure>
<p>目前的示例中，没有进一步使用这些变量。如果返回<code>NumPy_FOUND</code>为<code>FALSE</code>，则停止配置。</p>
<p>最后，将<code>use_numpy.py</code>复制到<code>build</code>目录，对代码进行注释:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add_custom_command(</span><br><span class="line">  OUTPUT</span><br><span class="line">  	$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/use_numpy.py</span><br><span class="line">  COMMAND</span><br><span class="line">  	$&#123;CMAKE_COMMAND&#125; -E copy_if_different $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/use_numpy.py</span><br><span class="line">  	$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/use_numpy.py</span><br><span class="line">  DEPENDS</span><br><span class="line">  	$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/use_numpy.py</span><br><span class="line">  )</span><br><span class="line">	</span><br><span class="line">target_sources(pure-embedding</span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/use_numpy.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>我们也可以使用<code>file(COPY…)</code>命令来实现复制。这里，我们选择使用<code>add_custom_command</code>，来确保文件在每次更改时都会被复制，而不仅仅是第一次运行配置时。我们将在第5章更详细地讨论<code>add_custom_command</code>。还要注意<code>target_sources</code>命令，它将依赖项添加到<code>${CMAKE_CURRENT_BINARY_DIR}/use_numpy.py</code>；这样做是为了确保构建目标，能够触发之前的命令。</p>
<h1 id="3-4-检测BLAS和LAPACK数学库"><a href="#3-4-检测BLAS和LAPACK数学库" class="headerlink" title="3.4 检测BLAS和LAPACK数学库"></a>3.4 检测BLAS和LAPACK数学库</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-04" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-04</a> 中找到，有一个C++示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>许多数据算法严重依赖于矩阵和向量运算。例如：矩阵-向量和矩阵-矩阵乘法，求线性方程组的解，特征值和特征向量的计算或奇异值分解。这些操作在代码库中非常普遍，因为操作的数据量比较大，因此高效的实现有绝对的必要。幸运的是，有专家库可用：基本线性代数子程序(BLAS)和线性代数包(LAPACK)，为许多线性代数操作提供了标准API。供应商有不同的实现，但都共享API。虽然，用于数学库底层实现，实际所用的编程语言会随着时间而变化(Fortran、C、Assembly)，但是也都是Fortran调用接口。考虑到调用街扩，本示例中的任务要链接到这些库，并展示如何用不同语言编写的库。</p>
<h2 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h2><p>为了展示数学库的检测和连接，我们编译一个C++程序，将矩阵的维数作为命令行输入，生成一个随机的方阵<strong>A</strong>，一个随机向量<strong>b</strong>，并计算线性系统方程: <strong>Ax = b</strong>。另外，将对向量<strong>b</strong>的进行随机缩放。这里，需要使用的子程序是BLAS中的DSCAL和LAPACK中的DGESV来求线性方程组的解。示例C++代码的清单( <code>linear-algebra.cpp</code>)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CxxBLAS.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CxxLAPACK.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Usage: ./linear-algebra dim"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Generate a uniform distribution of real number between -1.0 and 1.0</span></span><br><span class="line">  <span class="built_in">std</span>::random_device rd;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">double</span>&gt; dist(<span class="number">-1.0</span>, <span class="number">1.0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Allocate matrices and right-hand side vector</span></span><br><span class="line">  <span class="keyword">int</span> dim = <span class="built_in">std</span>::atoi(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; A(dim * dim);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; b(dim);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ipiv(dim);</span><br><span class="line">  <span class="comment">// Fill matrix and RHS with random numbers between -1.0 and 1.0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; dim; r++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; dim; c++) &#123;</span><br><span class="line">      A[r + c * dim] = dist(mt);</span><br><span class="line">    &#125;</span><br><span class="line">    b[r] = dist(mt);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Scale RHS vector by a random number between -1.0 and 1.0</span></span><br><span class="line">  C_DSCAL(dim, dist(mt), b.data(), <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C_DSCAL done"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Save matrix and RHS</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; A1(A);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; b1(b);</span><br><span class="line">  <span class="keyword">int</span> info;</span><br><span class="line">  info = C_DGESV(dim, <span class="number">1</span>, A.data(), dim, ipiv.data(), b.data(), dim);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"C_DGESV done"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"info is "</span> &lt;&lt; info &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">double</span> eps = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dim; ++i) &#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dim; ++j)</span><br><span class="line">      sum += A1[i + j * dim] * b[j];</span><br><span class="line">    eps += <span class="built_in">std</span>::<span class="built_in">abs</span>(b1[i] - sum);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"check is "</span> &lt;&lt; eps &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用C++11的随机库来生成-1.0到1.0之间的随机分布。<code>C_DSCAL</code>和<code>C_DGESV</code>分别是到BLAS和LAPACK库的接口。为了避免名称混淆，将在下面来进一步讨论CMake模块：</p>
<p>文件<code>CxxBLAS.hpp</code>用<code>extern &quot;C&quot;</code>封装链接BLAS:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fc_mangle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DSCAL</span><span class="params">(<span class="keyword">int</span> *n, <span class="keyword">double</span> *alpha, <span class="keyword">double</span> *vec, <span class="keyword">int</span> *inc)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C_DSCAL</span><span class="params">(<span class="keyword">size_t</span> length, <span class="keyword">double</span> alpha, <span class="keyword">double</span> *vec, <span class="keyword">int</span> inc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对应的实现文件<code>CxxBLAS.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"CxxBLAS.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// see http://www.netlib.no/netlib/blas/dscal.f</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C_DSCAL</span><span class="params">(<span class="keyword">size_t</span> length, <span class="keyword">double</span> alpha, <span class="keyword">double</span> *vec, <span class="keyword">int</span> inc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> big_blocks = (<span class="keyword">int</span>)(length / INT_MAX);</span><br><span class="line">  <span class="keyword">int</span> small_size = (<span class="keyword">int</span>)(length % INT_MAX);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> block = <span class="number">0</span>; block &lt;= big_blocks; block++) &#123;</span><br><span class="line">    <span class="keyword">double</span> *vec_s = &amp;vec[block * inc * (<span class="keyword">size_t</span>)INT_MAX];</span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> length_s = (block == big_blocks) ? small_size : INT_MAX;</span><br><span class="line">    ::DSCAL(&amp;length_s, &amp;alpha, vec_s, &amp;inc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CxxLAPACK.hpp</code>和<code>CxxLAPACK.cpp</code>为LAPACK调用执行相应的转换。</p>
<h2 id="具体实施-3"><a href="#具体实施-3" class="headerlink" title="具体实施"></a>具体实施</h2><p>对应的<code>CMakeLists.txt</code>包含以下构建块:</p>
<ol>
<li><p>我们定义了CMake最低版本，项目名称和支持的语言:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">04</span> LANGUAGES CXX C Fortran)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用C++11标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>此外，我们验证Fortran和C/C++编译器是否能协同工作，并生成头文件，这个文件可以处理名称混乱。两个功能都由<code>FortranCInterface</code>模块提供:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(FortranCInterface)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">FortranCInterface_VERIFY</span><span class="params">(CXX)</span></span></span><br><span class="line"></span><br><span class="line">FortranCInterface_HEADER(</span><br><span class="line">  fc_mangle.h</span><br><span class="line">  MACRO_NAMESPACE <span class="string">"FC_"</span></span><br><span class="line">  SYMBOLS DSCAL DGESV</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，找到BLAS和LAPACK:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(BLAS REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(LAPACK REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，添加一个库，其中包含BLAS和LAPACK包装器的源代码，并链接到<code>LAPACK_LIBRARIES</code>，其中也包含<code>BLAS_LIBRARIES</code>:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">math</span> <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">math</span></span><br><span class="line">  PRIVATE</span><br><span class="line">    CxxBLAS.cpp</span><br><span class="line">    CxxLAPACK.cpp</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意，目标的包含目录和链接库声明为<code>PUBLIC</code>，因此任何依赖于数学库的附加目标也将在其包含目录中。</p>
</li>
<li><p>最后，我们添加一个可执行目标并链接<code>math</code>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">linear-algebra</span> <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">target_sources(<span class="name">linear-algebra</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	linear-algebra.cpp</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_link_libraries(<span class="name">linear-algebra</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	math</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置时，我们可以关注相关的打印输出:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake <span class="built_in">..</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">-- Detecting Fortran/C Interface</span><br><span class="line">-- Detecting Fortran/C<span class="built_in"> Interface </span>- Found GLOBAL <span class="keyword">and</span> MODULE mangling</span><br><span class="line">-- Verifying Fortran/C Compiler Compatibility</span><br><span class="line">-- Verifying Fortran/C Compiler Compatibility - Success</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">-- Found BLAS: /usr/lib/libblas.so</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">-- A library with LAPACK API found.</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，构建并测试可执行文件:</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ ./linear-algebra 1000</span><br><span class="line"></span><br><span class="line">C_DSCAL done</span><br><span class="line">C_DGESV done</span><br><span class="line">info is 0</span><br><span class="line">check is 1.54284e-10</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>FindBLAS.cmake</code>和<code>FindLAPACK.cmake</code>将在标准位置查找BLAS和LAPACK库。对于前者，该模块有<code>SGEMM</code>函数的Fortran实现，一般用于单精度矩阵乘积。对于后者，该模块有<code>CHEEV</code>函数的Fortran实现，用于计算复杂厄米矩阵的特征值和特征向量。查找在CMake内部，通过编译一个小程序来完成，该程序调用这些函数，并尝试链接到候选库。如果失败，则表示相应库不存于系统上。</p>
<p>生成机器码时，每个编译器都会处理符号混淆，不幸的是，这种操作并不通用，而与编译器相关。为了解决这个问题，我们使用<code>FortranCInterface</code>模块( <a href="https://cmake.org/cmake/help/v3.5/module/FortranCInterface.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.5/module/FortranCInterface.html</a> )验证Fortran和C/C++能否混合编译，然后生成一个Fortran-C接口头文件<code>fc_mangle.h</code>，这个文件用来解决编译器性的问题。然后，必须将生成的<code>fc_mann .h</code>包含在接口头文件<code>CxxBLAS.hpp</code>和<code>CxxLAPACK.hpp</code>中。为了使用<code>FortranCInterface</code>，我们需要在<code>LANGUAGES</code>列表中添加C和Fortran支持。当然，也可以定义自己的预处理器定义，但是可移植性会差很多。</p>
<p>我们将在第9章中更详细地讨论Fortran和C的互操作性。</p>
<p><strong>NOTE</strong>:<em>目前，BLAS和LAPACK的许多实现已经在Fortran外附带了一层C包装。这些包装器多年来已经标准化，称为CBLAS和LAPACKE。</em></p>
<h2 id="更多信息-2"><a href="#更多信息-2" class="headerlink" title="更多信息"></a>更多信息</h2><p>许多算法代码比较依赖于矩阵代数运算，使用BLAS和LAPACK API的高性能实现就非常重要了。供应商为不同的体系结构和并行环境提供不同的库，<code>FindBLAS.cmake</code>和<code>FindLAPACK.cmake</code>可能的无法定位到当前库。如果发生这种情况，可以通过<code>-D</code>选项显式地从CLI对库进行设置。</p>
<h1 id="3-5-检测OpenMP的并行环境"><a href="#3-5-检测OpenMP的并行环境" class="headerlink" title="3.5 检测OpenMP的并行环境"></a>3.5 检测OpenMP的并行环境</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05</a> 中找到，有一个C++和一个Fortran示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。<a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-05</a> 中也有一个适用于CMake 3.5的示例。</em></p>
<p>目前，市面上的计算机几乎都是多核机器，对于性能敏感的程序，我们必须关注这些多核处理器，并在编程模型中使用并发。OpenMP是多核处理器上并行性的标准之一。为了从OpenMP并行化中获得性能收益，通常不需要修改或重写现有程序。一旦确定了代码中的性能关键部分，例如：使用分析工具，程序员就可以通过预处理器指令，指示编译器为这些区域生成可并行的代码。</p>
<p>本示例中，我们将展示如何编译一个包含OpenMP指令的程序(前提是使用一个支持OpenMP的编译器)。有许多支持OpenMP的Fortran、C和C++编译器。对于相对较新的CMake版本，为OpenMP提供了非常好的支持。本示例将展示如何在使用CMake 3.9或更高版本时，使用简单C++和Fortran程序来链接到OpenMP。</p>
<p><strong>NOTE</strong>:<em>根据Linux发行版的不同，Clang编译器的默认版本可能不支持OpenMP。使用或非苹果版本的Clang(例如，Conda提供的)或GNU编译器,除非单独安装libomp库(<a href="https://iscinumpy.gitlab.io/post/omp-on-high-sierra/" target="_blank" rel="noopener">https://iscinumpy.gitlab.io/post/omp-on-high-sierra/</a> )，否则本节示例将无法在macOS上工作。</em></p>
<h2 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h2><p>C和C++程序可以通过包含<code>omp.h</code>头文件和链接到正确的库，来使用OpenMP功能。编译器将在性能关键部分之前添加预处理指令，并生成并行代码。在本示例中，我们将构建以下示例源代码(<code>example.cpp</code>)。这段代码从1到N求和，其中N作为命令行参数:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"number of available processors: "</span> &lt;&lt; omp_get_num_procs()</span><br><span class="line">            &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"number of threads: "</span> &lt;&lt; omp_get_max_threads() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">auto</span> n = <span class="built_in">std</span>::stol(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"we will form sum of numbers from 1 to "</span> &lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// start timer</span></span><br><span class="line">  <span class="keyword">auto</span> t0 = omp_get_wtime();</span><br><span class="line">  <span class="keyword">auto</span> s = <span class="number">0L</span>L;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for reduction(+ : s)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    s += i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// stop timer</span></span><br><span class="line">  <span class="keyword">auto</span> t1 = omp_get_wtime();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum: "</span> &lt;&lt; s &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"elapsed wall clock time: "</span> &lt;&lt; t1 - t0 &lt;&lt; <span class="string">" seconds"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Fortran语言中，需要使用<code>omp_lib</code>模块并链接到库。在性能关键部分之前的代码注释中，可以再次使用并行指令。例如：<code>F90</code>需要包含以下内容:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> example</span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span> omp_lib</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">integer</span>(<span class="number">8</span>) :: i, n, s</span><br><span class="line">  <span class="keyword">character</span>(len=<span class="number">32</span>) :: arg</span><br><span class="line">  <span class="keyword">real</span>(<span class="number">8</span>) :: t0, t1</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">"number of available processors:"</span>, omp_get_num_procs()</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">"number of threads:"</span>, omp_get_max_threads()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">call</span> <span class="built_in">get_command_argument</span>(<span class="number">1</span>, arg)</span><br><span class="line">  read(arg , *) n</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">"we will form sum of numbers from 1 to"</span>, n</span><br><span class="line">  </span><br><span class="line">  <span class="comment">! start timer</span></span><br><span class="line">  t0 = omp_get_wtime()</span><br><span class="line">  </span><br><span class="line">  s = <span class="number">0</span></span><br><span class="line"><span class="comment">!$omp parallel do reduction(+:s)</span></span><br><span class="line">  <span class="keyword">do</span> i = <span class="number">1</span>, n</span><br><span class="line">  s = s + i</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">! stop timer</span></span><br><span class="line">  t1 = omp_get_wtime()</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">"sum:"</span>, s</span><br><span class="line">  <span class="built_in">print</span> *, <span class="string">"elapsed wall clock time (seconds):"</span>, t1 - t0</span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br></pre></td></tr></table></figure>
<h2 id="具体实施-4"><a href="#具体实施-4" class="headerlink" title="具体实施"></a>具体实施</h2><p>对于C++和Fortran的例子，<code>CMakeLists.txt</code>将遵循一个模板，该模板在这两种语言上很相似：</p>
<ol>
<li><p>两者都定义了CMake最低版本、项目名称和语言(CXX或Fortran；我们将展示C++版本):</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.9</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">05</span> LANGUAGES CXX)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用C++11标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用find_package来搜索OpenMP:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(OpenMP REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们定义可执行目标，并链接到FindOpenMP模块提供的导入目标(在Fortran的情况下，我们链接到<code>OpenMP::OpenMP_Fortran</code>):</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">example</span> example.cpp)</span><br><span class="line">target_link_libraries(<span class="name">example</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	OpenMP:<span class="symbol">:OpenMP_CXX</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，可以配置和构建代码了:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build .</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并行测试(在本例中使用了4个内核):</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./example 1000000000</span><br><span class="line"></span><br><span class="line">number of available processors: 4</span><br><span class="line">number of threads: 4</span><br><span class="line">we will form sum of numbers <span class="keyword">from</span> 1 <span class="keyword">to</span> 1000000000</span><br><span class="line">sum: 500000000500000000</span><br><span class="line">elapsed wall<span class="built_in"> clock </span>time: 1.08343 seconds</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了比较，我们可以重新运行这个例子，并将OpenMP线程的数量设置为1:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ env <span class="attribute">OMP_NUM_THREADS</span>=1 ./example 1000000000</span><br><span class="line"></span><br><span class="line">number of available processors: 4</span><br><span class="line">number of threads: 1</span><br><span class="line">we will form sum of numbers <span class="keyword">from</span> 1 <span class="keyword">to</span> 1000000000</span><br><span class="line">sum: 500000000500000000</span><br><span class="line">elapsed wall<span class="built_in"> clock </span>time: 2.96427 seconds</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h2><p>我们的示例很简单：编译代码，并运行在多个内核上时，我们会看到加速效果。加速效果并不是<code>OMP_NUM_THREADS</code>的倍数，不过本示例中并不关心，因为我们更关注的是如何使用CMake配置需要使用OpenMP的项目。我们发现链接到OpenMP非常简单，这要感谢<code>FindOpenMP</code>模块:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(<span class="name">example</span></span><br><span class="line">	PUBLIC</span><br><span class="line">		OpenMP:<span class="symbol">:OpenMP_CXX</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p>我们不关心编译标志或包含目录——这些设置和依赖项是在<code>OpenMP::OpenMP_CXX</code>中定义的(<code>IMPORTED</code>类型)。如第1章第3节中提到的，<code>IMPORTED</code>库是伪目标，它完全是我们自己项目的外部依赖项。要使用OpenMP，需要设置一些编译器标志，包括目录和链接库。所有这些都包含在<code>OpenMP::OpenMP_CXX</code>的属性上，并通过使用<code>target_link_libraries</code>命令传递给<code>example</code>。这使得在CMake中，使用库变得非常容易。我们可以使用<code>cmake_print_properties</code>命令打印接口的属性，该命令由<code>CMakePrintHelpers.CMake</code>模块提供:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">CMakePrintHelpers</span>)</span><br><span class="line">cmake_print_properties(</span><br><span class="line">	TARGETS</span><br><span class="line">		OpenMP:<span class="symbol">:OpenMP_CXX</span></span><br><span class="line">	PROPERTIES</span><br><span class="line">		INTERFACE_COMPILE_OPTIONS</span><br><span class="line">		INTERFACE_INCLUDE_DIRECTORIES</span><br><span class="line">		INTERFACE_LINK_LIBRARIES</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p>所有属性都有<code>INTERFACE_</code>前缀，因为这些属性对所需目标，需要以接口形式提供，并且目标以接口的方式使用OpenMP。</p>
<p>对于低于3.9的CMake版本:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">example</span> example.cpp)</span><br><span class="line"></span><br><span class="line">target_compile_options(<span class="name">example</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&#123;OpenMP_CXX_FLAGS&#125;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">set_target_properties(<span class="name">example</span></span><br><span class="line">  PROPERTIES</span><br><span class="line">  	LINK_FLAGS $&#123;OpenMP_CXX_FLAGS&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>对于低于3.5的CMake版本，我们需要为Fortran项目显式定义编译标志。</p>
<p>在这个示例中，我们讨论了C++和Fortran。相同的参数和方法对于C项目也有效。</p>
<h1 id="3-6-检测MPI的并行环境"><a href="#3-6-检测MPI的并行环境" class="headerlink" title="3.6 检测MPI的并行环境"></a>3.6 检测MPI的并行环境</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06</a> 中找到，包含一个C++和一个C的示例。该示例在CMake 3.9版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。<a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06</a> 中也有一个适用于CMake 3.5的C示例。</em></p>
<p>消息传递接口(Message Passing Interface, MPI)，可以作为OpenMP(共享内存并行方式)的补充，它也是分布式系统上并行程序的实际标准。尽管，最新的MPI实现也允许共享内存并行，但高性能计算中的一种典型方法就是，在计算节点上OpenMP与MPI结合使用。MPI标准的实施包括:</p>
<ol>
<li>运行时库</li>
<li>头文件和Fortran 90模块</li>
<li>编译器的包装器，用来调用编译器，使用额外的参数来构建MPI库，以处理目录和库。通常，包装器<code>mpic++/mpiCC/mpicxx</code>用于C++，<code>mpicc</code>用于C，<code>mpifort</code>用于Fortran。</li>
<li>启动MPI：应该启动程序，以编译代码的并行执行。它的名称依赖于实现，可以使用这几个命令启动：<code>mpirun</code>、<code>mpiexec</code>或<code>orterun</code>。</li>
</ol>
<p>本示例，将展示如何在系统上找到合适的MPI实现，从而编译一个简单的“Hello, World”MPI例程。</p>
<h2 id="准备工作-4"><a href="#准备工作-4" class="headerlink" title="准备工作"></a>准备工作</h2><p>示例代码(<code>hello-mpi.cpp</code>，可从<a href="http://www.mpitutorial.com/" target="_blank" rel="noopener">http://www.mpitutorial.com</a> 下载)将在本示例中进行编译，它将初始化MPI库，让每个进程打印其名称:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Initialize the MPI environment. The two arguments to MPI Init are not</span></span><br><span class="line">  <span class="comment">// currently used by MPI implementations, but are there in case future</span></span><br><span class="line">  <span class="comment">// implementations might need the arguments.</span></span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the number of processes</span></span><br><span class="line">  <span class="keyword">int</span> world_size;</span><br><span class="line">  MPI_Comm_size(MPI_COMM_WORLD, &amp;world_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the rank of the process</span></span><br><span class="line">  <span class="keyword">int</span> world_rank;</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD, &amp;world_rank);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the name of the processor</span></span><br><span class="line">  <span class="keyword">char</span> processor_name[MPI_MAX_PROCESSOR_NAME];</span><br><span class="line">  <span class="keyword">int</span> name_len;</span><br><span class="line">  MPI_Get_processor_name(processor_name, &amp;name_len);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print off a hello world message</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world from processor "</span> &lt;&lt; processor_name &lt;&lt; <span class="string">", rank "</span></span><br><span class="line">            &lt;&lt; world_rank &lt;&lt; <span class="string">" out of "</span> &lt;&lt; world_size &lt;&lt; <span class="string">" processors"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">  <span class="comment">// Finalize the MPI environment. No more MPI calls can be made after this</span></span><br><span class="line">  MPI_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-5"><a href="#具体实施-5" class="headerlink" title="具体实施"></a>具体实施</h2><p>这个示例中，我们先查找MPI实现：库、头文件、编译器包装器和启动器。为此，我们将用到<code>FindMPI.cmake</code>标准CMake模块:</p>
<ol>
<li><p>首先，定义了CMake最低版本、项目名称、支持的语言和语言标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.9</span> FATAL_ERROR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">06</span> LANGUAGES CXX)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，调用<code>find_package</code>来定位MPI:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(MPI REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与前面的配置类似，定义了可执行文件的的名称和相关源码，并链接到目标:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">hello-mpi</span> hello-mpi.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(<span class="name">hello-mpi</span></span><br><span class="line">  PUBLIC</span><br><span class="line"> 	  MPI:<span class="symbol">:MPI_CXX</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置和构建可执行文件:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake .. <span class="comment"># -D CMAKE_CXX_COMPILER=mpicxx C++例子中可加，加与不加对于构建结果没有影响╭(╯^╰)╮</span></span><br><span class="line"></span><br><span class="line">-- ...</span><br><span class="line">-- Found <span class="symbol">MPI_CXX:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">openmpi</span>/<span class="title">libmpi_cxx</span>.<span class="title">so</span> (<span class="title">found</span> <span class="title">version</span> "3.1")</span></span><br><span class="line">-- Found <span class="symbol">MPI:</span> TRUE (found version <span class="string">"3.1"</span>)</span><br><span class="line">-- ...</span><br><span class="line"></span><br><span class="line">$ cmake --build .</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了并行执行这个程序，我们使用<code>mpirun</code>启动器(本例中，启动了两个任务):</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mpirun -np <span class="number">2</span> ./hello-mpi</span><br><span class="line"></span><br><span class="line"><span class="type">Hello</span> world <span class="keyword">from</span> processor larry, rank <span class="number">1</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">2</span> processors</span><br><span class="line"><span class="type">Hello</span> world <span class="keyword">from</span> processor larry, rank <span class="number">0</span> <span class="keyword">out</span> <span class="keyword">of</span> <span class="number">2</span> processors</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h2><p>请记住，编译包装器是对MPI库编译器的封装。底层实现中，将会调用相同的编译器，并使用额外的参数(如成功构建并行程序所需的头文件包含路径和库)来扩充它。</p>
<p>编译和链接源文件时，包装器用了哪些标志？我们可以使用<code>--showme</code>选项来查看。要找出编译器的标志，我们可以这样使用:</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mpicxx <span class="comment">--showme:compile</span></span><br><span class="line"></span><br><span class="line">-pthread</span><br></pre></td></tr></table></figure>
<p>为了找出链接器标志，我们可以这样:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>mpicxx --<span class="symbol">showme:</span>link</span><br><span class="line"></span><br><span class="line">-pthread -Wl,-rpath -Wl,<span class="regexp">/usr/lib</span><span class="regexp">/openmpi -Wl,--enable-new-dtags -L/usr</span><span class="regexp">/lib/openmpi</span> -lmpi_cxx -lmpi</span><br></pre></td></tr></table></figure>
<p>与之前的OpenMP配置类似，我们发现到MPI的链接非常简单，这要归功于<code>FindMPI</code>模块提供的目标:</p>
<p>正如在前面的配方中所讨论的，对于CMake版本低于3.9，需要更多的工作量:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">hello-mpi</span> hello-mpi.c)</span><br><span class="line"></span><br><span class="line">target_compile_options(<span class="name">hello-mpi</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&#123;MPI_CXX_COMPILE_FLAGS&#125;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_include_directories(<span class="name">hello-mpi</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&#123;MPI_CXX_INCLUDE_PATH&#125;</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_link_libraries(<span class="name">hello-mpi</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&#123;MPI_CXX_LIBRARIES&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>本示例中，我们讨论了C++项目。其中的参数和方法对于C或Fortran项目同样有效。</p>
<h1 id="3-7-检测Eigen库"><a href="#3-7-检测Eigen库" class="headerlink" title="3.7 检测Eigen库"></a>3.7 检测Eigen库</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-07</a> 中找到，包含一个C++的示例。该示例在CMake 3.9版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。<a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-06</a> 中也有一个适用于CMake 3.5的C++示例。</em></p>
<p>BLAS库为矩阵和向量操作提供了标准化接口。不过，这个接口用Fortran语言书写。虽然已经展示了如何使用C++直接使用这些库，但在现代C++程序中，希望有更高级的接口。</p>
<p>纯头文件实现的Eigen库，使用模板编程来提供接口。矩阵和向量的计算，会在编译时进行数据类型检查，以确保兼容所有维度的矩阵。密集和稀疏矩阵的运算，也可使用表达式模板高效的进行实现，如：矩阵-矩阵乘积，线性系统求解器和特征值问题。从3.3版开始，Eigen可以链接到BLAS和LAPACK库中，这可以将某些操作实现进行卸载，使库的实现更加灵活，从而获得更多的性能收益。</p>
<p>本示例将展示如何查找Eigen库，使用OpenMP并行化，并将部分工作转移到BLAS库。</p>
<p>本示例中会实现，矩阵-向量乘法和LU分解，可以选择卸载BLAS和LAPACK库中的一些实现。这个示例中，只考虑将在BLAS库中卸载。</p>
<h2 id="准备工作-5"><a href="#准备工作-5" class="headerlink" title="准备工作"></a>准备工作</h2><p>本例中，我们编译一个程序，该程序会从命令行获取的随机方阵和维向量。然后我们将用LU分解来解线性方程组<strong>Ax=b</strong>。以下是源代码(<code>linear-algebra.cpp</code>):</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;chrono&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cmath&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iomanip&gt;</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;Eigen/Dense&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Usage: ./linear-algebra dim"</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">  &#125;</span><br><span class="line">  std::chrono::time_point&lt;std::chrono::system_clock&gt; start, <span class="keyword">end</span>;</span><br><span class="line">  std::chrono::duration&lt;double&gt; elapsed_seconds;</span><br><span class="line">  std::time_t end_time;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Number of threads used by Eigen: "</span> &lt;&lt; Eigen::nbThreads()</span><br><span class="line">            &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  /<span class="regexp">/ Allocate matrices and right-hand side vector</span></span><br><span class="line"><span class="regexp">  start = std::chrono::system_clock::now();</span></span><br><span class="line"><span class="regexp">  int dim = std::atoi(argv[1]);</span></span><br><span class="line"><span class="regexp">  Eigen::MatrixXd A = Eigen::MatrixXd::Random(dim, dim);</span></span><br><span class="line"><span class="regexp">  Eigen::VectorXd b = Eigen::VectorXd::Random(dim);</span></span><br><span class="line"><span class="regexp">  end = std::chrono::system_clock::now();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Report times</span></span><br><span class="line"><span class="regexp">  elapsed_seconds = end - start;</span></span><br><span class="line"><span class="regexp">  end_time = std::chrono::system_clock::to_time_t(end);</span></span><br><span class="line"><span class="regexp">  std::cout &lt;&lt; "matrices allocated and initialized "</span></span><br><span class="line"><span class="regexp">            &lt;&lt; std::put_time(std::localtime(&amp;end_time), "%a %b %d %Y</span></span><br><span class="line"><span class="regexp">  %r\n")</span></span><br><span class="line"><span class="regexp">            &lt;&lt; "elapsed time: " &lt;&lt; elapsed_seconds.count() &lt;&lt; "s\n";</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  start = std::chrono::system_clock::now();</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Save matrix and RHS</span></span><br><span class="line"><span class="regexp">  Eigen::MatrixXd A1 = A;</span></span><br><span class="line"><span class="regexp">  Eigen::VectorXd b1 = b;</span></span><br><span class="line"><span class="regexp">  end = std::chrono::system_clock::now();</span></span><br><span class="line"><span class="regexp">  end_time = std::chrono::system_clock::to_time_t(end);</span></span><br><span class="line"><span class="regexp">  std::cout &lt;&lt; "Scaling done, A and b saved "</span></span><br><span class="line"><span class="regexp">            &lt;&lt; std::put_time(std::localtime(&amp;end_time), "%a %b %d %Y %r\n")</span></span><br><span class="line"><span class="regexp">            &lt;&lt; "elapsed time: " &lt;&lt; elapsed_seconds.count() &lt;&lt; "s\n";</span></span><br><span class="line"><span class="regexp">  start = std::chrono::system_clock::now();</span></span><br><span class="line"><span class="regexp">  Eigen::VectorXd x = A.lu().solve(b);</span></span><br><span class="line"><span class="regexp">  end = std::chrono::system_clock::now();</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ Report times</span></span><br><span class="line"><span class="regexp">  elapsed_seconds = end - start;</span></span><br><span class="line"><span class="regexp">  end_time = std::chrono::system_clock::to_time_t(end);</span></span><br><span class="line"><span class="regexp">  double relative_error = (A * x - b).norm() /</span> b.norm();</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Linear system solver done "</span></span><br><span class="line">            &lt;&lt; std::put_time(std::localtime(&amp;end_time), <span class="string">"%a %b %d %Y %r\n"</span>)</span><br><span class="line">            &lt;&lt; <span class="string">"elapsed time: "</span> &lt;&lt; elapsed_seconds.count() &lt;&lt; <span class="string">"s\n"</span>;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"relative error is "</span> &lt;&lt; relative_error &lt;&lt; std::endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>矩阵-向量乘法和LU分解是在Eigen库中实现的，但是可以选择BLAS和LAPACK库中的实现。在这个示例中，我们只考虑BLAS库中的实现。</p>
<h2 id="具体实施-6"><a href="#具体实施-6" class="headerlink" title="具体实施"></a>具体实施</h2><p>这个示例中，我们将用到Eigen和BLAS库，以及OpenMP。使用OpenMP将Eigen并行化，并从BLAS库中卸载部分线性代数实现:</p>
<ol>
<li><p>首先声明CMake最低版本、项目名称和使用C++11语言标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.9</span> FATAL_ERROR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">07</span> LANGUAGES CXX)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为Eigen可以使用共享内存的方式，所以可以使用OpenMP并行处理计算密集型操作:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(OpenMP REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>find_package</code>来搜索Eigen(将在下一小节中讨论):</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Eigen3 <span class="number">3.3</span> REQUIRED CONFIG)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果找到Eigen，我们将打印状态信息。注意，使用的是<code>Eigen3::Eigen</code>，这是一个<code>IMPORT</code>目标，可通过提供的CMake脚本找到这个目标:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">TARGET</span> Eigen3:<span class="symbol">:Eigen</span>)</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"Eigen3 v$&#123;EIGEN3_VERSION_STRING&#125; found in $&#123;EIGEN3_INCLUDE_DIR&#125;"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，将源文件声明为可执行目标:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(linear-algebra linear-algebra.cpp)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，找到BLAS。注意，现在不需要依赖项:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(BLAS)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果找到BLAS，我们可为可执行目标，设置相应的宏定义和链接库:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">BLAS_FOUND</span>)</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"Eigen will use some subroutines from BLAS."</span>)</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"See: http://eigen.tuxfamily.org/dox-devel/TopicUsingBlasLapack.html"</span>)</span><br><span class="line">  target_compile_definitions(<span class="name">linear-algebra</span></span><br><span class="line">    PRIVATE</span><br><span class="line">    	EIGEN_USE_BLAS</span><br><span class="line">    )</span><br><span class="line">  target_link_libraries(<span class="name">linear-algebra</span></span><br><span class="line">    PUBLIC</span><br><span class="line">    	$&#123;BLAS_LIBRARIES&#125;</span><br><span class="line">    )</span><br><span class="line">else()</span><br><span class="line">	message(<span class="name">STATUS</span> <span class="string">"BLAS not found. Using Eigen own functions"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们链接到<code>Eigen3::Eigen</code>和<code>OpenMP::OpenMP_CXX</code>目标。这就可以设置所有必要的编译标示和链接标志:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(<span class="name">linear-algebra</span></span><br><span class="line">  PUBLIC</span><br><span class="line">    Eigen3:<span class="symbol">:Eigen</span></span><br><span class="line">    OpenMP:<span class="symbol">:OpenMP_CXX</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>开始配置:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line"></span><br><span class="line">-- ...</span><br><span class="line">-- Found <span class="symbol">OpenMP_CXX:</span> -fopenmp (found version <span class="string">"4.5"</span>)</span><br><span class="line">-- Found <span class="symbol">OpenMP:</span> TRUE (found version <span class="string">"4.5"</span>)</span><br><span class="line">-- Eigen3 v3.<span class="number">3.4</span> found in /usr/<span class="keyword">include</span>/eigen3</span><br><span class="line">-- ...</span><br><span class="line">-- Found <span class="symbol">BLAS:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libblas</span>.<span class="title">so</span></span></span><br><span class="line">-- Eigen will use some subroutines from BLAS.</span><br><span class="line">-- <span class="symbol">See:</span> <span class="symbol">http:</span>/<span class="regexp">/eigen.tuxfamily.org/dox</span>-devel/TopicUsingBlasLapack.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，编译并测试代码。注意，可执行文件使用四个线程运行:</p>
</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ ./linear-algebra 1000</span><br><span class="line"></span><br><span class="line">Number of threads used by Eigen: 4</span><br><span class="line">matrices allocated <span class="keyword">and</span> initialized Sun Jun 17 2018 11:04:20 AM</span><br><span class="line">elapsed time: 0.0492328s</span><br><span class="line">Scaling done, A <span class="keyword">and</span> b saved Sun Jun 17 2018 11:04:20 AM</span><br><span class="line">elapsed time: 0.0492328s</span><br><span class="line">Linear<span class="built_in"> system </span>solver done Sun Jun 17 2018 11:04:20 AM</span><br><span class="line">elapsed time: 0.483142s</span><br><span class="line">relative <span class="builtin-name">error</span> is 4.21946e-13</span><br></pre></td></tr></table></figure>
<h2 id="工作原理-6"><a href="#工作原理-6" class="headerlink" title="工作原理"></a>工作原理</h2><p>Eigen支持CMake查找，这样配置项目就会变得很容易。从3.3版开始，Eigen提供了CMake模块，这些模块将导出相应的目标<code>Eigen3::Eigen</code>。</p>
<p><code>find_package</code>可以通过选项传递，届时CMake将不会使用<code>FindEigen3.cmake</code>模块，而是通过特定的<code>Eigen3Config.cmake</code>，<code>Eigen3ConfigVersion.cmake</code>和<code>Eigen3Targets.cmake</code>提供Eigen3安装的标准位置(<code>&lt;installation-prefix&gt;/share/eigen3/cmake</code>)。这种包定位模式称为“Config”模式，比<code>Find&lt;package&gt;.cmake</code>方式更加通用。有关“模块”模式和“配置”模式的更多信息，可参考官方文档 <a href="https://cmake.org/cmake/help/v3.5/command/find_package.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.5/command/find_package.html</a> 。</p>
<p>虽然Eigen3、BLAS和OpenMP声明为<code>PUBLIC</code>依赖项，但<code>EIGEN_USE_BLAS</code>编译定义声明为<code>PRIVATE</code>。可以在单独的库目标中汇集库依赖项，而不是直接链接可执行文件。使用<code>PUBLIC/PRIVATE</code>关键字，可以根据库目标的依赖关系调整相应标志和定义。</p>
<h2 id="更多信息-3"><a href="#更多信息-3" class="headerlink" title="更多信息"></a>更多信息</h2><p>CMake将在预定义的位置层次结构中查找配置模块。首先是<code>CMAKE_PREFIX_PATH</code>，<code>&lt;package&gt;_DIR</code>是接下来的搜索路径。因此，如果Eigen3安装在非标准位置，可以使用这两个选项来告诉CMake在哪里查找它:</p>
<ol>
<li><p>通过将Eigen3的安装前缀传递给<code>CMAKE_PREFIX_PATH</code>:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D <span class="attribute">CMAKE_PREFIX_PATH</span>=&lt;installation-prefix&gt; <span class="built_in">..</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过传递配置文件的位置作为<code>Eigen3_DIR</code>:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D <span class="attribute">Eigen3_DIR</span>=&lt;installation-prefix&gt;/share/eigen3/cmake <span class="built_in">..</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="3-8-检测Boost库"><a href="#3-8-检测Boost库" class="headerlink" title="3.8 检测Boost库"></a>3.8 检测Boost库</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-08" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-08</a> 中找到，包含一个C++的示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>Boost是一组C++通用库。这些库提供了许多功能，这些功能在现代C++项目中不可或缺，但是还不能通过C++标准使用这些功能。例如，Boost为元编程、处理可选参数和文件系统操作等提供了相应的组件。这些库中有许多特性后来被C++11、C++14和C++17标准所采用，但是对于保持与旧编译器兼容性的代码库来说，许多Boost组件仍然是首选。</p>
<p>本示例将向您展示如何检测和链接Boost库的一些组件。</p>
<h2 id="准备工作-6"><a href="#准备工作-6" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将编译的源码是Boost提供的文件系统库与文件系统交互的示例。这个库可以跨平台使用，并将操作系统和文件系统之间的差异抽象为一致的API。下面的代码(<code>path-info.cpp</code>)将接受一个路径作为参数，并将其组件的报告打印到屏幕上:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/filesystem.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::filesystem;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">say_what</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="string">"true"</span> : <span class="string">"false"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span></span><br><span class="line">        &lt;&lt; <span class="string">"Usage: path_info path-element [path-element...]\n"</span></span><br><span class="line">           <span class="string">"Composes a path via operator/= from one or more path-element arguments\n"</span></span><br><span class="line">           <span class="string">"Example: path_info foo/bar baz\n"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BOOST_POSIX_API</span></span><br><span class="line">           <span class="string">" would report info about the composed path foo/bar/baz\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// BOOST_WINDOWS_API</span></span></span><br><span class="line">           <span class="string">" would report info about the composed path foo/bar\\baz\n"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  path p;</span><br><span class="line">  <span class="keyword">for</span> (; argc &gt; <span class="number">1</span>; --argc, ++argv)</span><br><span class="line">    p /= argv[<span class="number">1</span>]; <span class="comment">// compose path p from the command line arguments</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ncomposed path:\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" operator&lt;&lt;()---------: "</span> &lt;&lt; p &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" make_preferred()-----: "</span> &lt;&lt; p.make_preferred() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nelements:\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> element : p)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; element &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nobservers, native format:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> BOOST_POSIX_API</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" native()-------------: "</span> &lt;&lt; p.native() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" c_str()--------------: "</span> &lt;&lt; p.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// BOOST_WINDOWS_API</span></span></span><br><span class="line">  wcout &lt;&lt; <span class="string">L" native()-------------: "</span> &lt;&lt; p.native() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  wcout &lt;&lt; <span class="string">L" c_str()--------------: "</span> &lt;&lt; p.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" string()-------------: "</span> &lt;&lt; p.<span class="built_in">string</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  wcout &lt;&lt; <span class="string">L" wstring()------------: "</span> &lt;&lt; p.wstring() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nobservers, generic format:\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" generic_string()-----: "</span> &lt;&lt; p.generic_string() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  wcout &lt;&lt; <span class="string">L" generic_wstring()----: "</span> &lt;&lt; p.generic_wstring() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\ndecomposition:\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" root_name()----------: "</span> &lt;&lt; p.root_name() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" root_directory()-----: "</span> &lt;&lt; p.root_directory() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" root_path()----------: "</span> &lt;&lt; p.root_path() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" relative_path()------: "</span> &lt;&lt; p.relative_path() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" parent_path()--------: "</span> &lt;&lt; p.parent_path() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" filename()-----------: "</span> &lt;&lt; p.filename() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" stem()---------------: "</span> &lt;&lt; p.stem() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" extension()----------: "</span> &lt;&lt; p.extension() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nquery:\n"</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" empty()--------------: "</span> &lt;&lt; say_what(p.empty()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" is_absolute()--------: "</span> &lt;&lt; say_what(p.is_absolute()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" has_root_name()------: "</span> &lt;&lt; say_what(p.has_root_name()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" has_root_directory()-: "</span> &lt;&lt; say_what(p.has_root_directory()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" has_root_path()------: "</span> &lt;&lt; say_what(p.has_root_path()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" has_relative_path()--: "</span> &lt;&lt; say_what(p.has_relative_path()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" has_parent_path()----: "</span> &lt;&lt; say_what(p.has_parent_path()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" has_filename()-------: "</span> &lt;&lt; say_what(p.has_filename()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" has_stem()-----------: "</span> &lt;&lt; say_what(p.has_stem()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">" has_extension()------: "</span> &lt;&lt; say_what(p.has_extension()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-7"><a href="#具体实施-7" class="headerlink" title="具体实施"></a>具体实施</h2><p>Boost由许多不同的库组成，这些库可以独立使用。CMake可将这个库集合，表示为组件的集合。<code>FindBoost.cmake</code>模块不仅可以搜索库集合的完整安装，还可以搜索集合中的特定组件及其依赖项(如果有的话)。我们将逐步建立相应的<code>CMakeLists.txt</code>:</p>
<ol>
<li><p>首先，声明CMake最低版本、项目名称、语言，并使用C++11标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">08</span> LANGUAGES CXX)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，使用<code>find_package</code>搜索Boost。若需要对Boost强制性依赖，需要一个参数。这个例子中，只需要文件系统组件，所以将它作为参数传递给<code>find_package</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Boost <span class="number">1.54</span> REQUIRED COMPONENTS filesystem)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加可执行目标，编译源文件:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(path-info path-info.cpp)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，将目标链接到Boost库组件。由于依赖项声明为<code>PUBLIC</code>，依赖于Boost的目标将自动获取依赖项:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(<span class="name">path-info</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	Boost:<span class="symbol">:filesystem</span></span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-7"><a href="#工作原理-7" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>FindBoost.cmake</code>是本示例中所使用的CMake模块，其会在标准系统安装目录中找到Boost库。由于我们链接的是<code>Boost::filesystem</code>，CMake将自动设置包含目录并调整编译和链接标志。如果Boost库安装在非标准位置，可以在配置时使用<code>BOOST_ROOT</code>变量传递Boost安装的根目录，以便让CMake搜索非标准路径:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cmake -D BOOST_ROOT=<span class="regexp">/custom/boost</span></span><br></pre></td></tr></table></figure>
<p>或者，可以同时传递包含头文件的<code>BOOST_INCLUDEDIR</code>变量和库目录的<code>BOOST_LIBRARYDIR</code>变量:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cmake -D BOOST_INCLUDEDIR=<span class="regexp">/custom/boost</span><span class="regexp">/include -DBOOST_LIBRARYDIR=/custom</span><span class="regexp">/boost/lib</span></span><br></pre></td></tr></table></figure>
<h1 id="3-9-检测外部库-Ⅰ-使用pkg-config"><a href="#3-9-检测外部库-Ⅰ-使用pkg-config" class="headerlink" title="3.9 检测外部库:Ⅰ. 使用pkg-config"></a>3.9 检测外部库:Ⅰ. 使用pkg-config</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09</a> 中找到，包含一个C的示例。该示例在CMake 3.6版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。<a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-09</a> 中也有一个适用于CMake 3.5的示例。</em></p>
<p>目前为止，我们已经讨论了两种检测外部依赖关系的方法:</p>
<ul>
<li>使用CMake自带的<code>find-module</code>，但并不是所有的包在CMake的<code>find</code>模块都找得到。</li>
<li>使用<code>&lt;package&gt;Config.cmake</code>, <code>&lt;package&gt;ConfigVersion.cmake</code>和<code>&lt;package&gt;Targets.cmake</code>，这些文件由软件包供应商提供，并与软件包一起安装在标准位置的cmake文件夹下。</li>
</ul>
<p>如果某个依赖项既不提供查找模块，也不提供供应商打包的CMake文件，该怎么办?在这种情况下，我们只有两个选择:</p>
<ul>
<li>依赖<code>pkg-config</code>程序，来找到系统上的包。这依赖于包供应商在<code>.pc</code>配置文件中，其中有关于发行包的元数据。</li>
<li>为依赖项编写自己的<code>find-package</code>模块。</li>
</ul>
<p>本示例中，将展示如何利用CMake中的<code>pkg-config</code>来定位ZeroMQ消息库。下一个示例中，将编写一个find模块，展示如何为ZeroMQ编写属于自己<code>find</code>模块。</p>
<h2 id="准备工作-7"><a href="#准备工作-7" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们构建的代码来自ZeroMQ手册 <a href="http://zguide.zeromq.org/page:all" target="_blank" rel="noopener">http://zguide.zeromq.org/page:all</a> 的示例。由两个源文件<code>hwserver.c</code>和<code>hwclient.c</code>组成，这两个源文件将构建为两个独立的可执行文件。执行时，它们将打印“Hello, World”。</p>
<h2 id="具体实施-8"><a href="#具体实施-8" class="headerlink" title="具体实施"></a>具体实施</h2><p>这是一个C项目，我们将使用C99标准，逐步构建<code>CMakeLists.txt</code>文件:</p>
<ol>
<li><p>声明一个C项目，并要求符合C99标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.6</span> FATAL_ERROR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">09</span> LANGUAGES C)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_STANDARD <span class="number">99</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用CMake附带的find-module，查找<code>pkg-config</code>。这里在<code>find_package</code>中传递了<code>QUIET</code>参数。只有在没有找到<code>pkg-config</code>时，CMake才会报错:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PkgConfig REQUIRED QUIET)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>找到<code>pkg-config</code>时，我们将使用<code>pkg_search_module</code>函数，以搜索任何附带包配置<code>.pc</code>文件的库或程序。该示例中，我们查找ZeroMQ库:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pkg_search_module(</span><br><span class="line">  ZeroMQ</span><br><span class="line">  REQUIRED</span><br><span class="line">  	libzeromq libzmq lib0mq</span><br><span class="line">  IMPORTED_TARGET</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果找到ZeroMQ库，则打印状态消息:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">TARGET</span> PkgConfig:<span class="symbol">:ZeroMQ</span>)</span><br><span class="line">	message(<span class="name">STATUS</span> <span class="string">"Found ZeroMQ"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，添加两个可执行目标，并链接到ZeroMQ。这将自动设置包括目录和链接库:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(hwserver hwserver.c)</span></span></span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">(hwserver PkgConfig::ZeroMQ)</span></span></span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(hwclient hwclient.c)</span></span></span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">(hwclient PkgConfig::ZeroMQ)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，我们可以配置和构建示例:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build .</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在终端中，启动服务器，启动时会输出类似于本例的消息:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Current <span class="number">0</span>MQ version is <span class="number">4.2</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，在另一个终端启动客户端，它将打印如下内容:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Connecting to hello world server…</span><br><span class="line">Sending Hello <span class="number">0</span>…</span><br><span class="line">Received World <span class="number">0</span></span><br><span class="line">Sending Hello <span class="number">1</span>…</span><br><span class="line">Received World <span class="number">1</span></span><br><span class="line">Sending Hello <span class="number">2</span>…</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>当找到<code>pkg-config</code>时, CMake需要提供两个函数，来封装这个程序提供的功能:</p>
<ul>
<li><code>pkg_check_modules</code>，查找传递列表中的所有模块(库和/或程序)</li>
<li><code>pkg_search_module</code>，要在传递的列表中找到第一个工作模块</li>
</ul>
<p>与<code>find_package</code>一样，这些函数接受<code>REQUIRED</code>和<code>QUIET</code>参数。更详细地说，我们对<code>pkg_search_module</code>的调用如下:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pkg_search_module(</span><br><span class="line">  ZeroMQ</span><br><span class="line">  REQUIRED</span><br><span class="line">  	libzeromq libzmq lib0mq</span><br><span class="line">  IMPORTED_TARGET</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>这里，第一个参数是前缀，它将用于命名存储搜索ZeroMQ库结果的目标：<code>PkgConfig::ZeroMQ</code>。注意，我们需要为系统上的库名传递不同的选项：<code>libzeromq</code>、<code>libzmq</code>和<code>lib0mq</code>。这是因为不同的操作系统和包管理器，可为同一个包选择不同的名称。</p>
<p><strong>NOTE</strong>:<em><code>pkg_check_modules</code>和<code>pkg_search_module</code>函数添加了<code>IMPORTED_TARGET</code>选项，并在CMake 3.6中定义导入目标的功能。3.6之前的版本，只定义了变量<code>ZeroMQ_INCLUDE_DIRS</code>(用于include目录)和<code>ZeroMQ_LIBRARIES</code>(用于链接库)，供后续使用。</em></p>
<h1 id="3-10-检测外部库-Ⅱ-自定义find模块"><a href="#3-10-检测外部库-Ⅱ-自定义find模块" class="headerlink" title="3.10 检测外部库:Ⅱ. 自定义find模块"></a>3.10 检测外部库:Ⅱ. 自定义find模块</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-10" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-03/recipe-10</a> 中找到，包含一个C的示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>此示例补充了上一节的示例，我们将展示如何编写一个<code>find</code>模块来定位系统上的ZeroMQ消息库，以便能够在非Unix操作系统上检测该库。我们重用服务器-客户端示例代码。</p>
<h2 id="如何实施"><a href="#如何实施" class="headerlink" title="如何实施"></a>如何实施</h2><p>这是一个C项目，使用C99标准，并逐步构建CMakeLists.txt文件:</p>
<ol>
<li><p>声明一个C项目，并要求符合C99标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">10</span> LANGUAGES C)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_STANDARD <span class="number">99</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_C_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将当前源目录<code>CMAKE_CURRENT_SOURCE_DIR</code>，添加到CMake将查找模块的路径列表<code>CMAKE_MODULE_PATH</code>中。这样CMake就可以找到，我们自定义的<code>FindZeroMQ.cmake</code>模块:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">list</span>(<span class="keyword">APPEND</span> CMAKE_MODULE_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在<code>FindZeroMQ.cmake</code>模块是可用的，可以通过这个模块来搜索项目所需的依赖项。由于我们没有使用<code>QUIET</code>选项来查找<code>find_package</code>，所以当找到库时，状态消息将自动打印:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(ZeroMQ REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们继续添加<code>hwserver</code>可执行目标。头文件包含目录和链接库是使用<code>find_package</code>命令成功后，使用<code>ZeroMQ_INCLUDE_DIRS</code>和<code>ZeroMQ_LIBRARIES</code>变量进行指定的:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">hwserver</span> hwserver.c)</span><br><span class="line">target_include_directories(<span class="name">hwserver</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&#123;ZeroMQ_INCLUDE_DIRS&#125;</span><br><span class="line">  )</span><br><span class="line">target_link_libraries(<span class="name">hwserver</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&#123;ZeroMQ_LIBRARIES&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们对<code>hwclient</code>可执行目标执行相同的操作:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">hwclient</span> hwclient.c)</span><br><span class="line">target_include_directories(<span class="name">hwclient</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&#123;ZeroMQ_INCLUDE_DIRS&#125;</span><br><span class="line">  )</span><br><span class="line">target_link_libraries(<span class="name">hwclient</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&#123;ZeroMQ_LIBRARIES&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此示例的主<code>CMakeLists.txt</code>在使用<code>FindZeroMQ.cmake</code>时，与前一个示例中使用的<code>CMakeLists.txt</code>不同。这个模块使用<code>find_path</code>和<code>find_library</code> CMake内置命令，搜索ZeroMQ头文件和库，并使用<code>find_package_handle_standard_args</code>设置相关变量，就像我们在第3节中做的那样。</p>
<ol>
<li><p><code>FindZeroMQ.cmake</code>中，检查了<code>ZeroMQ_ROOT</code>变量是否设置。此变量可用于ZeroMQ库的检测，并引导到自定义安装目录。用户可能设置了<code>ZeroMQ_ROOT</code>作为环境变量，我们也会进行检查了:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT ZeroMQ_ROOT)</span></span></span><br><span class="line">	set(ZeroMQ_ROOT <span class="string">"$ENV&#123;ZeroMQ_ROOT&#125;"</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，搜索系统上<code>zmq.h</code>头文件的位置。这是基于<code>_ZeroMQ_ROOT</code>变量和<code>find_path</code>命令进行的:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT ZeroMQ_ROOT)</span></span></span><br><span class="line">	find_path(_ZeroMQ_ROOT NAMES include/zmq.h)</span><br><span class="line"><span class="function"><span class="title">else</span><span class="params">()</span></span></span><br><span class="line">	set(_ZeroMQ_ROOT <span class="string">"$&#123;ZeroMQ_ROOT&#125;"</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">find_path</span><span class="params">(ZeroMQ_INCLUDE_DIRS NAMES zmq.h HINTS $&#123;_ZeroMQ_ROOT&#125;/include)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果成功找到头文件，则将<code>ZeroMQ_INCLUDE_DIRS</code>设置为其位置。我们继续通过使用字符串操作和正则表达式，寻找相应版本的ZeroMQ库:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(_ZeroMQ_H $&#123;ZeroMQ_INCLUDE_DIRS&#125;/zmq.h)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">function</span><span class="params">(_zmqver_EXTRACT _ZeroMQ_VER_COMPONENT _ZeroMQ_VER_OUTPUT)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_MATCH_1 <span class="string">"0"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(_ZeroMQ_expr <span class="string">"^[ \\t]*#define[ \\t]+$&#123;_ZeroMQ_VER_COMPONENT&#125;[ \\t]+([0-9]+)$"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">file</span><span class="params">(STRINGS <span class="string">"$&#123;_ZeroMQ_H&#125;"</span> _ZeroMQ_ver REGEX <span class="string">"$&#123;_ZeroMQ_expr&#125;"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">string</span><span class="params">(REGEX MATCH <span class="string">"$&#123;_ZeroMQ_expr&#125;"</span> ZeroMQ_ver <span class="string">"$&#123;_ZeroMQ_ver&#125;"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">($&#123;_ZeroMQ_VER_OUTPUT&#125; <span class="string">"$&#123;CMAKE_MATCH_1&#125;"</span> PARENT_SCOPE)</span></span></span><br><span class="line"><span class="function"><span class="title">endfunction</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">_zmqver_EXTRACT(<span class="string">"ZMQ_VERSION_MAJOR"</span> ZeroMQ_VERSION_MAJOR)</span><br><span class="line">_zmqver_EXTRACT(<span class="string">"ZMQ_VERSION_MINOR"</span> ZeroMQ_VERSION_MINOR)</span><br><span class="line">_zmqver_EXTRACT(<span class="string">"ZMQ_VERSION_PATCH"</span> ZeroMQ_VERSION_PATCH)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，为<code>find_package_handle_standard_args</code>准备<code>ZeroMQ_VERSION</code>变量:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ZeroMQ_FIND_VERSION_COUNT GREATER 2)</span><br><span class="line">	<span class="builtin-name">set</span>(ZeroMQ_VERSION <span class="string">"<span class="variable">$&#123;ZeroMQ_VERSION_MAJOR&#125;</span>.<span class="variable">$&#123;ZeroMQ_VERSION_MINOR&#125;</span>.<span class="variable">$&#123;ZeroMQ_VERSION_PATCH&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="builtin-name">set</span>(ZeroMQ_VERSION <span class="string">"<span class="variable">$&#123;ZeroMQ_VERSION_MAJOR&#125;</span>.<span class="variable">$&#123;ZeroMQ_VERSION_MINOR&#125;</span>"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>find_library</code>命令搜索ZeroMQ库。因为库的命名有所不同，这里我们需要区分Unix的平台和Windows平台:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(NOT $&#123;CMAKE_C_PLATFORM_ID&#125; STREQUAL <span class="string">"Windows"</span>)</span><br><span class="line">  find_library(ZeroMQ_LIBRARIES</span><br><span class="line">    NAMES</span><br><span class="line">    	zmq</span><br><span class="line">    HINTS</span><br><span class="line">      $&#123;_ZeroMQ_ROOT&#125;/<span class="class"><span class="keyword">lib</span></span></span><br><span class="line">      $&#123;_ZeroMQ_ROOT&#125;/<span class="class"><span class="keyword">lib</span>/<span class="title">x86_64</span>-<span class="title">linux</span>-<span class="title">gnu</span></span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  find_library(ZeroMQ_LIBRARIES</span><br><span class="line">    NAMES</span><br><span class="line">    	libzmq</span><br><span class="line">      <span class="string">"libzmq-mt-$&#123;ZeroMQ_VERSION_MAJOR&#125;_$&#123;ZeroMQ_VERSION_MINOR&#125;_$&#123;ZeroMQ_VERSION_PATCH&#125;"</span></span><br><span class="line">      <span class="string">"libzmq-$&#123;CMAKE_VS_PLATFORM_TOOLSET&#125;-mt-$&#123;ZeroMQ_VERSION_MAJOR&#125;_$&#123;ZeroMQ_VERSION_MINOR&#125;_$&#123;ZeroMQ_VERSION_PATCH&#125;"</span></span><br><span class="line">      libzmq_d</span><br><span class="line">      <span class="string">"libzmq-mt-gd-$&#123;ZeroMQ_VERSION_MAJOR&#125;_$&#123;ZeroMQ_VERSION_MINOR&#125;_$&#123;ZeroMQ_VERSION_PATCH&#125;"</span></span><br><span class="line">      <span class="string">"libzmq-$&#123;CMAKE_VS_PLATFORM_TOOLSET&#125;-mt-gd-$&#123;ZeroMQ_VERSION_MAJOR&#125;_$&#123;ZeroMQ_VERSION_MINOR&#125;_$&#123;ZeroMQ_VERSION_PATCH&#125;"</span></span><br><span class="line">    HINTS</span><br><span class="line">    	$&#123;_ZeroMQ_ROOT&#125;/<span class="class"><span class="keyword">lib</span></span></span><br><span class="line">    )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，包含了标准<code>FindPackageHandleStandardArgs.cmake</code>，并调用相应的CMake命令。如果找到所有需要的变量，并且版本匹配，则将<code>ZeroMQ_FOUND</code>变量设置为<code>TRUE</code>:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">FindPackageHandleStandardArgs</span>)</span><br><span class="line"></span><br><span class="line">find_package_handle_standard_args(<span class="name">ZeroMQ</span></span><br><span class="line">  FOUND_VAR</span><br><span class="line">  	ZeroMQ_FOUND</span><br><span class="line">  REQUIRED_VARS</span><br><span class="line">  ZeroMQ_INCLUDE_DIRS</span><br><span class="line">  ZeroMQ_LIBRARIES</span><br><span class="line">  VERSION_VAR</span><br><span class="line">  ZeroMQ_VERSION</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>NOTE</strong>:<em>刚才描述的<code>FindZeroMQ.cmake</code>模块已经在 <a href="https://github.com/zeromq/azmq/blob/master/config/FindZeroMQ.cmake" target="_blank" rel="noopener">https://github.com/zeromq/azmq/blob/master/config/FindZeroMQ.cmake</a> 上进行了修改。</em></p>
<h2 id="工作原理-8"><a href="#工作原理-8" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>find-module</code>通常遵循特定的模式:</p>
<ol>
<li><p>检查用户是否为所需的包提供了自定义位置。</p>
</li>
<li><p>使用<code>find_</code>家族中的命令搜索所需包的必需组件，即头文件、库、可执行程序等等。我们使用<code>find_path</code>查找头文件的完整路径，并使用<code>find_library</code>查找库。CMake还提供<code>find_file</code>、<code>find_program</code>和<code>find_package</code>。这些命令的签名如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_path</span><span class="params">(&lt;VAR&gt; NAMES name PATHS paths)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果搜索成功，<code>&lt;VAR&gt;</code>将保存搜索结果；如果搜索失败，则会设置为<code>&lt;VAR&gt;-NOTFOUND</code>。<code>NAMES</code>和<code>PATHS</code>分别是CMake应该查找的文件的名称和搜索应该指向的路径。</p>
</li>
<li><p>初步搜索的结果中，可以提取版本号。示例中，ZeroMQ头文件包含库版本，可以使用字符串操作和正则表达式提取库版本信息。</p>
</li>
<li><p>最后，调用<code>find_package_handle_standard_args</code>命令。处理<code>find_package</code>命令的<code>REQUIRED</code>、<code>QUIET</code>和版本参数，并设置<code>ZeroMQ_FOUND</code>变量。</p>
</li>
</ol>
<p><strong>NOTE</strong>:<em>任何CMake命令的完整文档都可以从命令行获得。例如，<code>cmake --help-command find_file</code>将输出<code>find_file</code>命令的手册页。对于CMake标准模块的手册，可以在CLI使用<code>--help-module</code>看到。例如，<code>cmake --help-module FindPackageHandleStandardArgs</code>将输出<code>FindPackageHandleStandardArgs.cmake</code>的手册页面。</em></p>
<h2 id="更多信息-4"><a href="#更多信息-4" class="headerlink" title="更多信息"></a>更多信息</h2><p>总而言之，有四种方式可用于找到依赖包:</p>
<ol>
<li>使用由包供应商提供CMake文件<code>&lt;package&gt;Config.cmake</code> ，<code>&lt;package&gt;ConfigVersion.cmake</code>和<code>&lt;package&gt;Targets.cmake</code>，通常会在包的标准安装位置查找。</li>
<li>无论是由CMake还是第三方提供的模块，为所需包使用<code>find-module</code>。</li>
<li>使用<code>pkg-config</code>，如本节的示例所示。</li>
<li>如果这些都不可行，那么编写自己的<code>find</code>模块。</li>
</ol>
<p>这四种可选方案按相关性进行了排序，每种方法也都有其挑战。</p>
<p>目前，并不是所有的包供应商都提供CMake的Find文件，不过正变得越来越普遍。因为导出CMake目标，使得第三方代码很容易使用它所依赖的库和/或程序附加的依赖。</p>
<p>从一开始，<code>Find-module</code>就一直是CMake中定位依赖的主流手段。但是，它们中的大多数仍然依赖于设置依赖项使用的变量，比如<code>Boost_INCLUDE_DIRS</code>、<code>PYTHON_INTERPRETER</code>等等。这种方式很难在第三方发布自己的包时，确保依赖关系被满足。</p>
<p>使用<code>pkg-config</code>的方法可以很好地进行适配，因为它已经成为Unix系统的标准。然而，也由于这个原因，它不是一个完全跨平台的方法。此外，如CMake文档所述，在某些情况下，用户可能会意外地覆盖检测包，并导致<code>pkg-config</code>提供不正确的信息。</p>
<p>最后的方法是编写自己的查找模块脚本，就像本示例中那样。这是可行的，并且依赖于<code>FindPackageHandleStandardArgs.cmake</code>。然而，编写一个全面的查找模块脚本绝非易事；有需要考虑很多可能性，我们在Unix和Windows平台上，为查找ZeroMQ库文件演示了一个例子。</p>
<p>所有软件开发人员都非常清楚这些问题和困难，正如CMake邮件列表上讨论所示: <a href="https://cmake.org/pipermail/cmake/2018-May/067556.html" target="_blank" rel="noopener">https://cmake.org/pipermail/cmake/2018-May/067556.html</a> 。<code>pkg-config</code>在Unix包开发人员中是可以接受的，但是它不能很容易地移植到非Unix平台。CMake配置文件功能强大，但并非所有软件开发人员都熟悉CMake语法。公共包规范项目是统一用于包查找的<code>pkg-config</code>和CMake配置文件方法的最新尝试。您可以在项目的网站上找到更多信息: <a href="https://mwoehlke.github.io/cps/" target="_blank" rel="noopener">https://mwoehlke.github.io/cps/</a></p>
<p>在第10章中将讨论，如何使用前面讨论中概述的第一种方法，使第三方应用程序，找到自己的包：为项目提供自己的CMake查找文件。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2021/03/100655.html" class="pre-post btn btn-default" title='CMake 完整使用教程 之五 创建和运行测试'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之五 创建和运行测试</span>
        </a>
    
    
        <a href="/archives/2021/03/100653.html" class="next-post btn btn-default" title='CMake 完整使用教程 之三 检测环境'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之三 检测环境</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#3-1-检测Python解释器"><span class="toc-text">3.1 检测Python解释器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-2-检测Python库"><span class="toc-text">3.2 检测Python库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-1"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-1"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-1"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-3-检测Python模块和包"><span class="toc-text">3.3 检测Python模块和包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-1"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-2"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-2"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-4-检测BLAS和LAPACK数学库"><span class="toc-text">3.4 检测BLAS和LAPACK数学库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-2"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-3"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-3"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-2"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-5-检测OpenMP的并行环境"><span class="toc-text">3.5 检测OpenMP的并行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-3"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-4"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-4"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-6-检测MPI的并行环境"><span class="toc-text">3.6 检测MPI的并行环境</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-4"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-5"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-5"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-7-检测Eigen库"><span class="toc-text">3.7 检测Eigen库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-5"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-6"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-6"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-3"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-8-检测Boost库"><span class="toc-text">3.8 检测Boost库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-6"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-7"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-7"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-9-检测外部库-Ⅰ-使用pkg-config"><span class="toc-text">3.9 检测外部库:Ⅰ. 使用pkg-config</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-7"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-8"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作"><span class="toc-text">工作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-10-检测外部库-Ⅱ-自定义find模块"><span class="toc-text">3.10 检测外部库:Ⅱ. 自定义find模块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何实施"><span class="toc-text">如何实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-8"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-4"><span class="toc-text">更多信息</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2024&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>