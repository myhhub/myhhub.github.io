<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="qt,ctk">


    <meta name="description" content="CTK框架实际应用比较可靠，但网上资料很少。本教程围绕 CTK，探索 C++ 中的模块化技术，并能够基于 CTK 快速搭建 C++ 组件化框架，避免后来的人走弯路。本教程的源码下载地址：项目源代...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>CTK框架使用简明教程 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="CTK框架使用简明教程">
            
	            CTK框架使用简明教程
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/ctk/">ctk</a> <a class="tag-link" href="/tags/qt/">qt</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2021/03/01</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1232</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>CTK框架实际应用比较可靠，但网上资料很少。本教程围绕 CTK，探索 C++ 中的模块化技术，并能够基于 CTK 快速搭建 C++ 组件化框架，避免后来的人走弯路。本教程的源码下载地址：<a href="https://github.com/myhhub/ctkExample" target="_blank" rel="noopener">项目源代码</a>。</p>
<h1 id="CTK介绍"><a href="#CTK介绍" class="headerlink" title="CTK介绍"></a>CTK介绍</h1><p><a href="http://www.commontk.org/" target="_blank" rel="noopener">CTK</a> 为支持生物医学图像计算的公共开发包，其全称为 Common Toolkit。CTK插件框架的设计有很大的灵感来自OSGi并且使得应用程序由许多不同的组件组合成一个可扩展模型。这个模型允许通过那些组件间共享对象的服务通信。</p>
<p>当前，CTK 工作的主要范围包括：</p>
<ul>
<li><p><a href="http://www.commontk.org/index.php/Documentation/Dicom_Overview" target="_blank" rel="noopener">DICOM</a>：提供了从 PACS 和本地数据库中查询和检索的高级类。包含 Qt 部件，可以轻松地设置服务器连接，并发送查询和查看结果。</p>
</li>
<li><p><a href="http://www.commontk.org/index.php/Documentation/DicomApplicationHosting" target="_blank" rel="noopener">DICOM Application Hosting</a>：目标是创建 DICOM Part 19 Application Hosting specifications 的 C++ 参考实现。它提供了用于创建主机和托管应用程序的基础设。</p>
</li>
<li><p><a href="http://www.commontk.org/index.php/Documentation/Widgets" target="_blank" rel="noopener">Widgets</a>：用于生物医学成像应用的 Qt Widgets 集合。</p>
</li>
<li><p><a href="http://www.commontk.org/index.php/Documentation/Plugin_Framework" target="_blank" rel="noopener">Plugin Framework</a>：用于 C++ 的动态组件系统，以 OSGi 规范为模型。它支持一个开发模型，在这个模型中，应用程序（动态地）由许多不同（可重用的）组件组成，遵循面向服务的方法。</p>
</li>
<li><p><a href="http://www.commontk.org/index.php/Documentation/Command_Line_Interface" target="_blank" rel="noopener">Command Line Interfaces</a>：一种允许将算法编写为自包含可执行程序的技术，可以在多个终端用户应用程序环境中使用，而无需修改。</p>
<h2 id="使用-CTK-Plugin-Framework-的好处"><a href="#使用-CTK-Plugin-Framework-的好处" class="headerlink" title="使用 CTK Plugin Framework 的好处"></a>使用 CTK Plugin Framework 的好处</h2><p>由于 CTK Plugin Framework 基于 OSGi，因此它继承了一种非常成熟且完全设计的组件系统，这在 Java 中用于构建高度复杂的应用程序，它将这些好处带给了本地（基于 Qt 的）C++ 应用程序。以下内容摘自 <a href="https://www.osgi.org/developer/benefits-of-using-osgi/" target="_blank" rel="noopener">Benefits of Using OSGi</a>，并适应于 CTK Plugin Framework：</p>
</li>
<li><p>降低复杂性</p>
<p>使用 CTK Plugin Framework 开发意味着开发插件，它们隐藏了内部实现，并通过定义良好的服务来和其它插件通信。隐藏内部机制意味着以后可以自由地更改实现，这不仅有助于 Bug 数量的减少，还使得插件的开发变得更加简单，因为只需要实现已经定义好的一定数量的功能接口即可。</p>
</li>
<li><p>复用</p>
<p>标准化的组件模型，使得在应用程序中使用第三方组件变得非常容易。</p>
</li>
<li><p>现实情况</p>
<p>CTK Plugin Framework 是一个动态框架，它可以动态地更新插件和服务。在现实世界中，有很多场景都和动态服务模型相匹配。因此，应用程序可以在其所属的领域中重用 Service Registry 的强大基元（注册、获取、用富有表现力的过滤语言列表、等待服务的出现和消失）。这不仅节省了编写代码，还提供了全局可见性、调试工具以及比为专用解决方案实现的更多的功能。在这样的动态环境下编写代码听起来似乎是个噩梦，但幸运的是，有支持类和框架可以消除大部分（如果不是全部的话）痛苦。</p>
</li>
<li><p>开发简单</p>
<p>CTK Plugin Framework 不仅仅是组件的标准，它还指定了如何安装和管理组件。这个 API 可以被插件用来提供一个管理代理，这个管理代理可以非常简单，如命令 shell、图形桌面应用程序、Amazon EC2 的云计算接口、或 IBM Tivoli 管理系统。标准化的管理 API 使得在现有和未来的系统中集成 CTK Plugin Framework 变得非常容易。</p>
</li>
<li><p>动态更新</p>
<p>OSGi 组件模型是一个动态模型，插件可以在不关闭整个系统的情况下被安装、启动、停止、更新和卸载。</p>
</li>
<li><p>自适应</p>
<p>OSGi 组件模型是从头设计的，以允许组件的混合和匹配。这就要求必须指定组件的依赖关系，并且需要组件在其可选依赖性并不总是可用的环境中生存。Service Registry 是一个动态注册表，其中插件可以注册、获取和监听服务。这种动态服务模型允许插件找出系统中可用的功能，并调整它们所能提供的功能。这使得代码更加灵活，并且能够更好地适应变化。</p>
</li>
<li><p>透明性</p>
<p>插件和服务是 CTK 插件环境中的一等公民。管理 API 提供了对插件的内部状态的访问，以及插件之间的连接方式。可以停止部分应用程序来调试某个问题，或者可以引入诊断插件。</p>
</li>
<li><p>版本控制</p>
<p>在 CTK Plugin Framework 中，所有的插件都经过严格的版本控制，只有能够协作的插件才会被连接在一起。</p>
</li>
<li><p>简单</p>
<p>CTK 插件相关的 API 非常简单，核心 API 不到 25 个类。这个核心 API 足以编写插件、安装、启动、停止、更新和卸载它们，并且还包含了所有的监听类。</p>
</li>
<li><p>懒加载</p>
<p>懒加载是软件中一个很好的点，OSGi 技术有很多的机制来保证只有当类真正需要的时候才开始加载它们。例如，插件可以用饿汉式启动，但是也可以被配置为仅当其它插件使用它们时才启动。服务可以被注册，但只有在使用时才创建。这些懒加载场景，可以节省大量的运行时成本。</p>
</li>
<li><p>非独占性</p>
<p>CTK Plugin Framework 不会接管整个应用程序，你可以选择性地将所提供的功能暴露给应用程序的某些部分，或者甚至可以在同一个进程中运行该框架的多个实例。</p>
</li>
<li><p>非侵入</p>
<p>在一个 CTK 插件环境中，不同插件均有自己的环境。它们可以使用任何设施，框架对此并无限制。CTK 服务没有特殊的接口需求，每个 QObject 都可以作为一个服务，每个类（也包括非 QObject）都可以作为一个接口。</p>
</li>
</ul>
<h1 id="CTK编译"><a href="#CTK编译" class="headerlink" title="CTK编译"></a>CTK编译</h1><p>使用cmake编译出与系统版本相应的动态库。参见<a href="../02/100643.html">CTK编译教程(64位环境 Windows + Qt + MinGW或MSVC + CMake)</a>。</p>
<h1 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h1><p>由于每一个插件都要建一个子项目，本项目刚开始创建时在QtCreator中选择<em>新建-其他项目-子目录项目</em>，新建项目名称为ctkExample，然后建立主程序入口项目，这里建立一个<em>控制台项目</em>，取名叫console。</p>
<p>更改项目输出路径：<em>console.pro</em></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DESTDIR</span> = $<span class="variable">$PWD</span>/../bin</span><br></pre></td></tr></table></figure>
<p>主函数中加载插件，启动框架：<em>main.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ctkPluginFrameworkFactory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ctkPluginFramework.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ctkPluginException.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QCoreApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    a.setApplicationName(<span class="string">"ctkExample"</span>);<span class="comment">//给框架创建名称，Linux下没有这步会报错</span></span><br><span class="line">    ctkPluginFrameworkFactory factory;<span class="comment">//插件工厂类</span></span><br><span class="line">    QSharedPointer&lt;ctkPluginFramework&gt; framework;</span><br><span class="line">    framework = factory.getFramework();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        framework-&gt;init();</span><br><span class="line">        framework-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">const</span> ctkPluginException&amp; e)&#123;</span><br><span class="line">        qDebug() &lt;&lt; <span class="string">"framework init fail"</span>;</span><br><span class="line">        qDebug() &lt;&lt; e.message() &lt;&lt; e.getType();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想把CTK初始化、插件安装启动、获取等操作封装成一个类，那么要注意：需要把CTK相关的变量定义成类属性，不能是局部变量，否则会出现各种问题如获取不了服务、服务引用为空等。</p>
<p>没有报错的话及表示插件加载成功！</p>
<p> 其中QSharedPointer<ctkpluginframework> framework这个对象比较有意思，既可以作为对象也可以作为对象指针，但要作为插件框架使用必须要用指针方法调用，所以代码里使用“-&gt;”。</ctkpluginframework></p>
<h1 id="项目加载CTK框架插件"><a href="#项目加载CTK框架插件" class="headerlink" title="项目加载CTK框架插件"></a>项目加载CTK框架插件</h1><p>复制CTK安装目录到项目根目录，编译出的动态库就可以当普通动态库使用加载了，pro里面加载代码为：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LIBS += -L<span class="symbol">$</span><span class="symbol">$</span>PWD/../libs/ctk<span class="number">-0.1</span> -lCTKCore</span><br><span class="line">LIBS += -L<span class="symbol">$</span><span class="symbol">$</span>PWD/../libs/ctk<span class="number">-0.1</span>/ -lCTKPluginFramework</span><br><span class="line"></span><br><span class="line">INCLUDEPATH += <span class="symbol">$</span><span class="symbol">$</span>PWD/../includes/ctk<span class="number">-0.1</span></span><br><span class="line">DEPENDPATH += <span class="symbol">$</span><span class="symbol">$</span>PWD/../libs/ctk<span class="number">-0.1</span></span><br></pre></td></tr></table></figure>
<h1 id="CTK插件的接口处理"><a href="#CTK插件的接口处理" class="headerlink" title="CTK插件的接口处理"></a>CTK插件的接口处理</h1><p>CTK框架由一个一个可分离的插件组成，框架对插件识别有一定要求，目前网上很多一整块扔出来对新人不太友好，博主这里讲解是尽量拆。单个插件最基本的格式要求分成Activator，qrc文件，以及MANIFEST.MF，我们以生成一个主界面模块MainWindow为例。</p>
<h2 id="Activator注册器"><a href="#Activator注册器" class="headerlink" title="Activator注册器"></a>Activator注册器</h2><p>每个插件都有自己的注册器Activator。</p>
<p>右键项目选择<em>新建子项目-其他项目-Empty qmake Project</em>，项目名称为MainWindow，pro文件中添加代码：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">TEMPLATE = lib</span><br><span class="line">TARGET = MainWindow</span><br><span class="line">DESTDIR = $$PWD/../bin/plugins/$$TARGET</span><br><span class="line">QT       += core gui</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</span><br><span class="line"><span class="comment">#加载ctk库</span></span><br><span class="line">LIBS += -L$$PWD/../libs/ctk-0.1 -lCTKCore</span><br><span class="line">LIBS += -L$$PWD/../libs/ctk-0.1/ -lCTKPluginFramework</span><br><span class="line"></span><br><span class="line">INCLUDEPATH += $$PWD/../includes/ctk-0.1</span><br><span class="line"><span class="comment">#INCLUDEPATH += $$PWD/../libs/ctk-0.1</span></span><br><span class="line"></span><br><span class="line">DEPENDPATH += $$PWD/../libs/ctk-0.1</span><br></pre></td></tr></table></figure>
<p><strong><em>生成的插件名(TARGET)不要有下划线，因为CTK会默认将插件名中的下划线替换成点号，最后后就导致找不到插件。</em></strong></p>
<p>项目中添加C++类MainWindowActivator，代码如下：</p>
<p><em>mainwindowactivator.h</em></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOWACTIVATOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOWACTIVATOR_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ctkPluginActivator.h"</span></span></span><br><span class="line">class MainWindowActivator : <span class="keyword">public</span> QObject, <span class="keyword">public</span> ctkPluginActivator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PLUGIN_METADATA(IID <span class="string">"MainWindow"</span>)</span><br><span class="line">    <span class="comment">//向Qt的插件框架声明，希望将xxx插件放入到框架中。</span></span><br><span class="line">    Q_INTERFACES(ctkPluginActivator)</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MainWindowActivator();</span><br><span class="line">    <span class="keyword">void</span> start(ctkPluginContext *context);</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">stop</span>(ctkPluginContext *context);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOWACTIVATOR_H</span></span></span><br></pre></td></tr></table></figure>
<p><em>mainwindowactivator.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindowactivator.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QDebug&gt;</span></span></span><br><span class="line">MainWindowActivator::MainWindowActivator()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MainWindowActivator::start(ctkPluginContext *context)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mainwindow start"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MainWindowActivator::stop(ctkPluginContext *context)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"my plugin stop"</span>;</span><br><span class="line">    Q_UNUSED(context)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Q_UNUSED,如果一个函数的有些参数没有用到、某些变量只声明不使用，但是又不想编译器、编辑器报警报，其他没有什么实际性作用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>activator是标准的Qt插件类，它实现ctkPluginActivator的start、stop函数并对外提供接口。我这里是Qt5的版本，所以使用Q_PLUGIN_METADATA申明插件，Qt4需要用自己的方法实现插件。</p>
<h2 id="qrc文件"><a href="#qrc文件" class="headerlink" title="qrc文件"></a>qrc文件</h2><p>创建插件的资源文件，格式如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RCC</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">qresource</span> <span class="attr">prefix</span>=<span class="string">"/MainWindow/META-INF"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">file</span>&gt;</span>MANIFEST.MF<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">qresource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RCC</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>插件加载后会寻找<em>同名前缀/META-INF</em>，所以前缀格式固定，将MANIFEST.MF文件添加进来</p>
<p>MENIFEST.MF文件内容如下：</p>
<p>可直接在MF文件里添加自己特有的元数据</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Plugin</span>-SymbolicName:MainWindow</span><br><span class="line"><span class="keyword">Plugin</span>-<span class="keyword">Version</span>:1.0.0</span><br><span class="line"><span class="keyword">Plugin</span>-Number:100 #元数据</span><br></pre></td></tr></table></figure>
<p><strong><em>注意：Plugin-SymbolicName要满足这里的前缀是：TARGET/META-INF格式。TARGET的名字最好和工程名一致，不然可能出现device not open错误。</em></strong></p>
<h3 id="获取MANIFEST-MF中的数据"><a href="#获取MANIFEST-MF中的数据" class="headerlink" title="获取MANIFEST.MF中的数据"></a>获取MANIFEST.MF中的数据</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QHash<span class="params">&lt;QString, QString&gt;</span> headers = plugin-&gt;getHeaders();</span><br><span class="line">ctkVersion version = <span class="symbol">ctkVersion::</span>parseVersion(headers.value(<span class="symbol">ctkPluginConstants::</span>PLUGIN_VERSION)); </span><br><span class="line">QString name = headers.value(<span class="symbol">ctkPluginConstants::</span>PLUGIN_NAME);</span><br></pre></td></tr></table></figure>
<p>文件包含ctk插件的基本信息，只要ctk框架正常识别到文件中Plugin-SymbolicName等信息，则判定它是一个ctk插件，能够正常调用activator中的start、stop函数。这个文件需要拷到插件生成路径下，pro文件中添加代码：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file<span class="selector-class">.path</span> = $<span class="variable">$DESTDIR</span></span><br><span class="line">file<span class="selector-class">.files</span> = MANIFEST.MF</span><br><span class="line">INSTALLS += file</span><br></pre></td></tr></table></figure>
<h1 id="CTK插件启用"><a href="#CTK插件启用" class="headerlink" title="CTK插件启用"></a>CTK插件启用</h1><p>根据以上步骤，一个CTK插件接口定义基本完成，我们在console项目下调用观察插件是否能够正常加载。main函数中框架启动成功后添加以下代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="keyword">dir </span>= QCoreApplication::applicationDirPath()<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dir </span>+= <span class="string">"/plugins/MainWindow/libMainWindow.dll"</span><span class="comment">;</span></span><br><span class="line">    qDebug() &lt;&lt; <span class="keyword">dir;</span></span><br><span class="line"><span class="keyword"> </span>   QUrl url = QUrl::fromLocalFile(<span class="keyword">dir);</span></span><br><span class="line"><span class="keyword"> </span>   QSharedPointer&lt;ctkPlugin&gt; plugin<span class="comment">;</span></span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        plugin = framework-&gt;getPluginContext()-&gt;<span class="keyword">installPlugin(url);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;catch(ctkPluginException e)&#123;</span><br><span class="line">        qDebug() &lt;&lt; e.message() &lt;&lt; e.getType()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    try&#123;</span><br><span class="line">        plugin-&gt;start(ctkPlugin::START_TRANSIENT)<span class="comment">;</span></span><br><span class="line">    &#125;catch(ctkPluginException e)&#123;</span><br><span class="line">        qDebug() &lt;&lt; e.message() &lt;&lt; e.getType()<span class="comment">;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>控制台打印输出：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"C:/d/mmm/qt/ctk/ctkExample/bin/plugins/MainWindow/MainWindow.dll"</span></span><br><span class="line"> mainwindow <span class="literal">start</span></span><br></pre></td></tr></table></figure>
<p>成功调用MainWindow中start内打印输出，则表明ctk插件接口正常定义并能成功加载。其中<em>start</em>(ctkPlugin::START_TRANSIENT)表示立即启用插件，不设置参数的话加载后也不会立即打印输出。</p>
<h1 id="CTK插件间通信"><a href="#CTK插件间通信" class="headerlink" title="CTK插件间通信"></a>CTK插件间通信</h1><p>CTK框架插件化开发实现功能的隔离，插件通信需要参照固定标准，这里介绍两种插件间通信的方法。以上面的MainWindow为例，主程序中以接口调用的方法弹出插件中的界面。由于涉及到Qt的Widget界面，请先将main函数中的QCoreApplication改为QApplication。</p>
<h2 id="通信方法1-注册接口调用"><a href="#通信方法1-注册接口调用" class="headerlink" title="通信方法1-注册接口调用"></a>通信方法1-注册接口调用</h2><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><p>接口就是纯虚函数类，也就是最终的服务的前身。</p>
<p>上面我们已经编译出需要的动态库，首先确定我们需要插件向外部暴露的功能有什么，比如这里我们需要弹出窗口界面的操作，定义头文件如下：imainwindow.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> IMAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAINWINDOW_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iMainWindow</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">popMainWindow</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Q_DECLARE_INTERFACE(iMainWindow, <span class="string">"interface_mainwindow"</span>)</span><br><span class="line"><span class="comment">//此宏将当前这个接口类声明为接口，后面的一长串就是这个接口的唯一标识。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// IMAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>
<p> Q_DECLARE_INTERFACE将接口类向Qt系统申明，然后添加它的实现对象：</p>
<h3 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h3><p>插件就是实现这个接口类的实现类，所以理论上有多少个实现类就有多少个插件。</p>
<p><em>mainwindowplugin.h</em></p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAINWINDOWPLUGIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAINWINDOWPLUGIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"../includes/imainwindow.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"ctkPluginContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"mainwindowdlg.h"</span></span></span><br><span class="line">class MainWindowPlugin : public QObject, public iMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_INTERFACES(iMainWindow)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    此宏与Q_DECLARE_INTERFACE宏配合使用。</span></span><br><span class="line"><span class="comment">    Q_DECLARE_INTERFACE：声明一个接口类</span></span><br><span class="line"><span class="comment">    Q_INTERFACES：当一个类继承这个接口类，表明需要实现这个接口类</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="symbol">public:</span></span><br><span class="line">    MainWindowPlugin(ctkPluginContext *context);</span><br><span class="line">    virtual void popMainWindow();</span><br><span class="line"><span class="symbol">private:</span></span><br><span class="line">    ctkPluginContext *m_context;</span><br><span class="line">    MainWindowDlg* m_windowDlg;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOWPLUGIN_H</span></span></span><br></pre></td></tr></table></figure>
<p><em>mainwindowplugin.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindowplugin.h"</span></span></span><br><span class="line">MainWindowPlugin::MainWindowPlugin(ctkPluginContext *context)</span><br><span class="line">    :m_context(context)</span><br><span class="line">&#123;</span><br><span class="line">    m_windowDlg = <span class="keyword">new</span> MainWindowDlg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MainWindowPlugin::popMainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    m_windowDlg-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这仍是Qt的插件定义格式，但是不会作为插件导出，外部功能接口可以自定义。</p>
<h3 id="服务注册-Activator注册服务"><a href="#服务注册-Activator注册服务" class="headerlink" title="服务注册(Activator注册服务)"></a>服务注册(Activator注册服务)</h3><p>激活类里有一个独占智能指针，指向接口类【使用多态，指针都指向父类】，然后在start里new一个实现类，注册这个实现类为服务，功能是实现接口类的接口，然后将智能指针指向这个实现类。可以理解为以后向框架索取这个服务的时候，实际获取的就是这个new出来的实现类。如果不用智能指针，就需要在stop里手动delete这个实现类。</p>
<p>每个插件都有自己的注册器Activator，功能节接口完成后，在插件启动时注册到ctk框架的服务中，代码如下：<em>mainwindowactivator.cpp</em></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void MainWindowActivator::start(ctkPluginContext *<span class="built_in">context</span>)</span><br><span class="line">&#123;</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"mainwindow start"</span><span class="comment">;</span></span><br><span class="line">    m_plugin = new MainWindowPlugin(<span class="built_in">context</span>)<span class="comment">;</span></span><br><span class="line">    ctkDictionary <span class="keyword">dic;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">context</span>-&gt;registerService&lt;iMainWindow&gt;(m_plugin, <span class="keyword">dic);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h3><p><strong><em>CTK插件启用后，就可以调用接口。</em></strong></p>
<p>主函数框架及插件加载完成后，即可调用插件接口，代码如下：<em>main.cpp</em></p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">include</span> <span class="string">"../includes/imainwindow.h"</span></span><br><span class="line"> ……</span><br><span class="line"> ctkPluginContext* context = framework-&gt;getPluginContext<span class="literal">()</span>;</span><br><span class="line">    ctkServiceReference <span class="built_in">ref</span> =context-&gt;getServiceReference&lt;iMainWindow&gt;<span class="literal">()</span>;</span><br><span class="line">    iMainWindow* mainWindow;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ref</span>)</span><br><span class="line">        mainWindow = context-&gt;getService&lt;iMainWindow&gt;(<span class="built_in">ref</span>);</span><br><span class="line">    <span class="keyword">if</span>(mainWindow)</span><br><span class="line">        mainWindow-&gt;popMainWindow<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<p>在获取服务的时候，有两个重载方式【可直接使用的】</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、iMainWindow* ret = <span class="built_in">context</span>-&gt;getService&lt;iMainWindow&gt;(reference)<span class="comment">;</span></span><br><span class="line"><span class="number">2</span>、iMainWindow* ret = qobject_cast&lt;iMainWindow*&gt;(<span class="built_in">context</span>-&gt;getService(reference))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><strong><em>服务就是根据接口的实例，每生成一个服务就会调用一次注册器的start。把接口当做类，服务是根据类new出的对象，插件就是动态库dll。</em></strong></p>
<h3 id="小结：接口、插件、服务的关系"><a href="#小结：接口、插件、服务的关系" class="headerlink" title="小结：接口、插件、服务的关系"></a>小结：接口、插件、服务的关系</h3><p><strong>1、1对1</strong></p>
<p> 1个接口类由1个类实现，输出1个服务和1个插件。</p>
<p><strong>2、多对1</strong></p>
<p>1个类实现了2个接口类，输出2个服务和1个插件，无论想使用哪个服务最终都通过这同一个插件来实现。</p>
<p><strong>3、1对多</strong></p>
<p>1接口由2个类实现，也就是某一个问题提供了2种解决思路，输出1个服务和2个插件，通过ctkPluginConstants::SERVICE_RANKING和ctkPluginConstants::SERVICE_ID来调用不同的插件。这里虽然有两个插件，但都是被编译到同一个dll中的。</p>
<p>某插件每次调用另一个插件的时候，只会生成一个实例，然后把实例存到内存当中，不会因为多次调用而生成多个服务实例。</p>
<p>在使用1接口2插件的时候，虽然是两个插件，也会有两个激活类【从原理上来讲1个激活类就行了，但是在start里注册两次】，其中的IID只能有一个。从Qt插件基础上来说，一个dll只能有一个IID。</p>
<h2 id="通信方法2-事件监听"><a href="#通信方法2-事件监听" class="headerlink" title="通信方法2-事件监听"></a>通信方法2-事件监听</h2><p>CTK框架中的事件监听，即观察者模式流程上是这样：接收者注册监听事件-&gt;发送者发送事件-&gt;接收者接收到事件并响应；相比调用插件接口，监听事件插件间依赖关系更弱，不用指定事件的接收方和发送方是谁。</p>
<p>要使用CTK框架的事件服务，准备工作应该从cmake开始，编译出支持事件监听的动态库，名称为liborg_commontk_eventadmin.dll。现在要完成的内容是，从上面生成的主窗体中，以事件监听的方式调用一个子窗体。</p>
<p>1、通信主要用到了ctkEventAdmin结构体，主要定义了如下接口：</p>
<p>postEvent：类通信形式异步发送事件</p>
<p>sendEvent：类通信形式同步发送事件</p>
<p>publishSignal：信号与槽通信形式发送事件</p>
<p>unpublishSignal：取消发送事件</p>
<p>subscribeSlot：信号与槽通信形式订阅时间，返回订阅的ID</p>
<p>unsubscribeSlot：取消订阅事件</p>
<p>updateProperties：更新某个订阅ID的主题</p>
<p>2、通信的数据是：ctkDictionary</p>
<p>其实就是个hash表：typedef QHash&lt;QString,QVariant&gt; ctkDictionary</p>
<h3 id="加载EventAdmin动态库"><a href="#加载EventAdmin动态库" class="headerlink" title="加载EventAdmin动态库"></a>加载EventAdmin动态库</h3><p>添加动态库可以使用ctkPluginFrameworkLauncher，代码如下：<em>main.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctkPluginFrameworkLauncher::addSearchPath(<span class="string">"../libs/ctk-0.1/plugins"</span>);</span><br><span class="line">ctkPluginFrameworkLauncher::start(<span class="string">"org.commontk.eventadmin"</span>);</span><br><span class="line"> ……</span><br><span class="line"><span class="comment">// 停止插件</span></span><br><span class="line">ctkPluginFrameworkLauncher::stop();</span><br></pre></td></tr></table></figure>
<p>需要在框架加载前调用。</p>
<h3 id="事件注册监听-接收插件"><a href="#事件注册监听-接收插件" class="headerlink" title="事件注册监听(接收插件)"></a>事件注册监听(接收插件)</h3><p>首先编写我们需要的接收者模块，并注册监听事件，这里我们新建一个模块Client1，模块的接口处理参见上面“CTK插件的接口处理”。插件部分代码如下：</p>
<p><em>client1plugin.h</em> </p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CLIENT1PLUGIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT1PLUGIN_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ctkPluginContext.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"service/event/ctkEventAdmin.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"service/event/ctkEventHandler.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"client1dlg.h"</span></span></span><br><span class="line">class Client1Plugin : <span class="keyword">public</span> QObject, <span class="keyword">public</span> ctkEventHandler</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_INTERFACES(ctkEventHandler)</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Client1Plugin(ctkPluginContext *context);</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">void</span> handleEvent(<span class="keyword">const</span> ctkEvent&amp; event);</span><br><span class="line">signals:</span><br><span class="line">    <span class="keyword">void</span> openDlg();</span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="keyword">void</span> onOpenDlg();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> registToMainWindow();</span><br><span class="line">    ctkPluginContext *m_context;</span><br><span class="line">    Client1Dlg* m_clientDlg;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><em>client1plugin.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"client1plugin.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;service/event/ctkEventConstants.h&gt;</span></span></span><br><span class="line">Client1Plugin::Client1Plugin(ctkPluginContext *context)</span><br><span class="line">    :m_context(context)</span><br><span class="line">&#123;</span><br><span class="line">    m_clientDlg = <span class="keyword">new</span> Client1Dlg;</span><br><span class="line">    connect(<span class="keyword">this</span>, SIGNAL(openDlg()), <span class="keyword">this</span>, SLOT(onOpenDlg()),Qt::QueuedConnection);</span><br><span class="line">    <span class="comment">//注册监听信号"zhimakaimen"</span></span><br><span class="line">    ctkDictionary dic;</span><br><span class="line">    dic.insert(ctkEventConstants::EVENT_TOPIC, <span class="string">"zhimakaimen"</span>);</span><br><span class="line">    context-&gt;registerService&lt;ctkEventHandler&gt;(<span class="keyword">this</span>, dic);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Client1Plugin::handleEvent(<span class="keyword">const</span> ctkEvent&amp; event)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//接收监听事件接口</span></span><br><span class="line">    <span class="keyword">if</span>(event.getTopic() == <span class="string">"zhimakaimen"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">emit <span class="title">openDlg</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//这里用了信号槽异步，因为线程中不能调用界面元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与上面自定义接口不同，这里我们实例化ctkEventHandler对象，并实现<em>handleEvent</em>接口。构造函数中注册的服务对象是ctkEventHandler，在注册时指定触发的事件，当事件触发时调用该对象的<em>handleEvent</em>实现指定操作。</p>
<h3 id="事件发送-发送插件"><a href="#事件发送-发送插件" class="headerlink" title="事件发送(发送插件)"></a>事件发送(发送插件)</h3><p>监听对象完成后调用比较简单，比如我们直接在窗体的菜单栏中，点击actoin调用，代码如下：<em>mainwindowdlg.cpp</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mainwindowdlg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_mainwindowdlg.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"service/event/ctkEvent.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"service/event/ctkEventAdmin.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"service/event/ctkEventHandler.h"</span></span></span><br><span class="line">MainWindowDlg::MainWindowDlg(ctkPluginContext *context,QWidget *parent) :</span><br><span class="line">QMainWindow(parent),</span><br><span class="line">ui(<span class="keyword">new</span> Ui::MainWindowDlg),</span><br><span class="line">m_context(context)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    QAction* action = <span class="keyword">new</span> QAction(<span class="string">"用户1"</span>);</span><br><span class="line">    ui-&gt;menubar-&gt;addAction(action);</span><br><span class="line">    connect(action, SIGNAL(triggered(<span class="keyword">bool</span>)), <span class="keyword">this</span>, SLOT(action_clicked()));</span><br><span class="line">&#125;</span><br><span class="line">MainWindowDlg::~MainWindowDlg()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MainWindowDlg::action_clicked()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取事件服务接口</span></span><br><span class="line">    ctkServiceReference ref;</span><br><span class="line">    ctkEventAdmin* eventAdmin;</span><br><span class="line">    ref = m_context-&gt;getServiceReference&lt;ctkEventAdmin&gt;();</span><br><span class="line">    <span class="keyword">if</span>(ref)</span><br><span class="line">    &#123;</span><br><span class="line">        eventAdmin = m_context-&gt;getService&lt;ctkEventAdmin&gt;(ref);</span><br><span class="line">        m_context-&gt;ungetService(ref);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送事件</span></span><br><span class="line">    ctkDictionary message;</span><br><span class="line">    <span class="keyword">if</span>(eventAdmin)</span><br><span class="line">        eventAdmin-&gt;postEvent(ctkEvent(<span class="string">"zhimakaimen"</span>, message));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="事件发送二种方式：类通信、信号槽通信"><a href="#事件发送二种方式：类通信、信号槽通信" class="headerlink" title="事件发送二种方式：类通信、信号槽通信"></a>事件发送二种方式：类通信、信号槽通信</h3><p><strong>1、类通信</strong></p>
<p>原理就是直接将信息使用CTK的eventAdmin接口send/post出去。</p>
<p><strong>2、信号槽通信</strong></p>
<p>原理是将Qt自己的信号与CTK的发送事件绑定、槽与事件订阅绑定。</p>
<p>二种方式的区别：</p>
<p>1、通过event事件通信，是直接调用CTK的接口，把数据发送到CTK框架；通过信号槽方式，会先在Qt的信号槽机制中转一次，再发送到CTK框架。故效率上来讲，event方式性能高于信号槽方式。</p>
<p>2、两种方式发送数据到CTK框架，这个数据包含：主题+属性。主题就是topic，属性就是ctkDictionary。 一定要注意signal方式的信号定义，参数不能是自定义的，一定要是ctkDictionary，不然会报信号槽参数异常错误。</p>
<p>3、两种方式可以混用，如发送event事件，再通过槽去接收；发送signal事件，再通过event是接收。</p>
<p>4、同步：sendEvent、Qt::DirectConnection；异步：postEvent、Qt::QueuedConnection</p>
<p>这里的同步是指：发送事件之后，订阅了这个主题的数据便会处理数据【handleEvent、slot】，处理的过程是在发送者的线程完成的。可以理解为在发送了某个事件之后，会立即执行所有订阅此事件的回调函数。</p>
<p>异步：发送事件之后，发送者便会返回不管，订阅了此事件的所有插件会根据自己的消息循环，轮到了处理事件后才会去处理。不过如果长时间没处理，CTK也有自己的超时机制。如果事件处理程序花费的时间比配置的超时时间长，那么就会被列入黑名单。一旦处理程序被列入黑名单，它就不会再被发送任何事件。</p>
<h2 id="插件依赖"><a href="#插件依赖" class="headerlink" title="插件依赖"></a>插件依赖</h2><p>插件加载时一般根据首字母大小自动加载，所以在Client1启用时，MainWindow还没有被调用，所以发送的”event/registAction”事件没有接收方，这样就要考虑到插件依赖关系，在MANIFEST.MF中添加依赖：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Plugin</span>-SymbolicName:Client1</span><br><span class="line"><span class="keyword">Plugin</span>-<span class="keyword">Version</span>:1.0.0</span><br><span class="line">Require-<span class="keyword">Plugin</span>:MainWindow; <span class="keyword">plugin</span>-<span class="keyword">version</span>=<span class="string">"[1.0,2.0)"</span>; resolution:=<span class="string">"mandatory"</span></span><br></pre></td></tr></table></figure>
<p>MainWindow：为需要依赖的插件名【就是另一个插件在MANIFEST.MF里的Plugin-SymbolicName】；</p>
<p>[1.0,2.0)：为MainWindow的版本，这里是左闭右开区间，默认是1.0,；</p>
<p>resolution：有两个选择，optional、mandatory。前者是弱依赖，就算依赖的插件没有，当前插件也能正常使用，后者是强依赖，如果没有依赖的插件，就当前插件就不能被start。</p>
<p>这样就向框架申明了，该插件加载时需要先加载MainWindow插件，所有用户插件都应该有这样一份申明。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2021/03/100645.html" class="pre-post btn btn-default" title='CTK完整教程(OSGI for C++ 实现 C++ Qt 模块化)'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">CTK完整教程(OSGI for C++ 实现 C++ Qt 模块化)</span>
        </a>
    
    
        <a href="/archives/2021/02/100643.html" class="next-post btn btn-default" title='CTK编译教程(64位环境 Windows + Qt + MinGW或MSVC + CMake)'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">CTK编译教程(64位环境 Windows + Qt + MinGW或MSVC + CMake)</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#CTK介绍"><span class="toc-text">CTK介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-CTK-Plugin-Framework-的好处"><span class="toc-text">使用 CTK Plugin Framework 的好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CTK编译"><span class="toc-text">CTK编译</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#项目结构"><span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#项目加载CTK框架插件"><span class="toc-text">项目加载CTK框架插件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CTK插件的接口处理"><span class="toc-text">CTK插件的接口处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Activator注册器"><span class="toc-text">Activator注册器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qrc文件"><span class="toc-text">qrc文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#获取MANIFEST-MF中的数据"><span class="toc-text">获取MANIFEST.MF中的数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CTK插件启用"><span class="toc-text">CTK插件启用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CTK插件间通信"><span class="toc-text">CTK插件间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通信方法1-注册接口调用"><span class="toc-text">通信方法1-注册接口调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数接口"><span class="toc-text">函数接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口的实现"><span class="toc-text">接口的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#服务注册-Activator注册服务"><span class="toc-text">服务注册(Activator注册服务)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口调用"><span class="toc-text">接口调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结：接口、插件、服务的关系"><span class="toc-text">小结：接口、插件、服务的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通信方法2-事件监听"><span class="toc-text">通信方法2-事件监听</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加载EventAdmin动态库"><span class="toc-text">加载EventAdmin动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件注册监听-接收插件"><span class="toc-text">事件注册监听(接收插件)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件发送-发送插件"><span class="toc-text">事件发送(发送插件)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件发送二种方式：类通信、信号槽通信"><span class="toc-text">事件发送二种方式：类通信、信号槽通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插件依赖"><span class="toc-text">插件依赖</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2024&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>