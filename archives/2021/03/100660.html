<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="c++,cmake,qt">


    <meta name="description" content="本章的主要内容如下：

使用C/C++库构建Fortran项目
使用Fortran库构建C/C++项目
使用Cython构建C++和Python项目
使用Boost.Python构建C++和Py...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>CMake 完整使用教程 之十 语言混合项目 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="CMake 完整使用教程 之十 语言混合项目">
            
	            CMake 完整使用教程 之十 语言混合项目
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/c/">c++</a> <a class="tag-link" href="/tags/cmake/">cmake</a> <a class="tag-link" href="/tags/qt/">qt</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2021/03/29</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1060</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>本章的主要内容如下：</p>
<ul>
<li>使用C/C++库构建Fortran项目</li>
<li>使用Fortran库构建C/C++项目</li>
<li>使用Cython构建C++和Python项目</li>
<li>使用Boost.Python构建C++和Python项目</li>
<li>使用pybind11构建C++和Python项目</li>
<li>使用Python CFFI混合C，C++，Fortran和Python</li>
</ul>
<p>有很多的库比较适合特定领域的任务。我们的库直接使用这些专业库，是一中快捷的方式，这样就可以使用来自其他专家组的多年经验进行开发。随着计算机体系结构和编译器的发展，编程语言也在不断发展。几年前，大多数科学软件都是用Fortran语言编写的，而现在，C/C++和解释语言Python正占据着语言中心舞台。将编译语言代码与解释语言的代码集成在一起，变得确实越来越普遍，这样做有以下好处:</p>
<ul>
<li>用户可以需要进行定制和扩展功能，以满足需求。</li>
<li>可以将Python等语言的表达能力与编译语言的性能结合起来，后者在内存寻址方面效率接近于极致，达到两全其美的目的。</li>
</ul>
<p>正如之前的示例中展示的那样，可以使用<code>project</code>命令通过<code>LANGUAGES</code>关键字设置项目中使用的语言。CMake支持许多(但不是所有)编译的编程语言。从CMake 3.5开始，各种风格的汇编(如ASM-ATT，ASM，ASM-MASM和ASM- NASM)、C、C++、Fortran、Java、RC (Windows资源编译器)和Swift都可以选择。CMake 3.8增加了对另外两种语言的支持：C#和CUDA(请参阅发布说明:<a href="https://cmake.org/cmake/help/v3.8/release/3.8.html#languages" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.8/release/3.8.html#languages</a> )。</p>
<p>本章中，我们将展示如何以一种可移植且跨平台的方式集成用不同编译(C/C++和Fortran)和解释语言(Python)编写的代码。我们将展示如何利用CMake和一些工具集成不同编程语言。</p>
<h1 id="9-1-使用C-C-库构建Fortran项目"><a href="#9-1-使用C-C-库构建Fortran项目" class="headerlink" title="9.1 使用C/C++库构建Fortran项目"></a>9.1 使用C/C++库构建Fortran项目</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-01" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-01</a> 中找到，其中有两个示例：一个是Fortran与C的混例，另一个是Fortran和C++的混例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>Fortran作为高性能计算语言有着悠久的历史。目前，许多线性代数库仍然使用Fortran语言编写，许多大型的数字处理包也保持与过去几十年的代码兼容。而Fortran提出了一个很自然的语法处理数值数组，它缺乏与操作系统交互，所以为了编程的通用性，需要一个互操作性层(使用C实现)，才发布了Fortran 2003标准。本示例将展示如何用C系统库和自定义C代码来对接Fortran代码。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>第7章中，我们把项目结构列为一个树。每个子目录都有一个<code>CMakeLists.txt</code>文件，其中包含与该目录相关的指令。这使我们可以对子目录进行限制中，如这个例子：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">      ├── bt-randomgen-example.f90</span><br><span class="line">      ├── CMakeLists.txt</span><br><span class="line">      ├── interfaces</span><br><span class="line">      │ 		├── CMakeLists.txt</span><br><span class="line">      │ 		├── interface_backtrace.f90</span><br><span class="line">      │ 		├── interface_randomgen.f90</span><br><span class="line">      │ 		└── randomgen.c</span><br><span class="line">      └── utils</span><br><span class="line">      ├── CMakeLists.txt</span><br><span class="line">      └── util_strings.f90</span><br></pre></td></tr></table></figure>
<p>我们的例子中，<code>src</code>子目录中包括<code>bt-randomgen-example.f90</code>，会将源码编译成可执行文件。另外两个子目录<code>interface</code>和<code>utils</code>包含更多的源代码，这些源代码将被编译成库。</p>
<p><code>interfaces</code>子目录中的源代码展示了如何包装向后追踪的C系统库。例如，<code>interface_backtrace.f90</code>:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> interface_backtrace</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">interface</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span></span> backtrace(buffer, <span class="built_in">size</span>) result(bt) <span class="keyword">bind</span>(C, <span class="keyword">name</span>=<span class="string">"backtrace"</span>)</span><br><span class="line">      <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_int</span>, <span class="keyword">c_ptr</span></span><br><span class="line">      <span class="keyword">type</span>(<span class="keyword">c_ptr</span>) :: buffer</span><br><span class="line">      <span class="keyword">integer</span>(<span class="keyword">c_int</span>), <span class="keyword">value</span> :: <span class="built_in">size</span></span><br><span class="line">      <span class="keyword">integer</span>(<span class="keyword">c_int</span>) :: bt</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">subroutine</span></span> backtrace_symbols_fd(buffer, <span class="built_in">size</span>, fd) <span class="keyword">bind</span>(C, <span class="keyword">name</span>=<span class="string">"backtrace_symbols_fd"</span>)</span><br><span class="line">      <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_int</span>, <span class="keyword">c_ptr</span></span><br><span class="line">      <span class="keyword">type</span>(<span class="keyword">c_ptr</span>) :: buffer</span><br><span class="line">      <span class="keyword">integer</span>(<span class="keyword">c_int</span>), <span class="keyword">value</span> :: <span class="built_in">size</span>, fd</span><br><span class="line">    <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">interface</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure>
<p>上面的例子演示了：</p>
<ul>
<li>内置<code>iso_c_binding</code>模块，确保Fortran和C类型和函数的互操作性。</li>
<li><code>interface</code>声明，将函数在单独库中绑定到相应的符号上。</li>
<li><code>bind(C)</code>属性，为声明的函数进行命名修饰。</li>
</ul>
<p>这个子目录还包含两个源文件:</p>
<ul>
<li>randomgen.c：这是一个C源文件，它对外公开了一个函数，使用C标准<code>rand</code>函数在一个区间内生成随机整数。</li>
<li>interface_randomgen.f90：它将C函数封装在Fortran可执行文件中使用。</li>
</ul>
<h2 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h2><p>我们有4个<code>CMakeLists.txt</code>实例要查看——根目录下1个，子目录下3个。让我们从根目录的<code>CMakeLists.txt</code>开始:</p>
<ol>
<li><p>声明一个Fortran和C的混合语言项目:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">01</span> LANGUAGES Fortran C)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CMake将静态库和动态库保存在<code>build</code>目录下的<code>lib</code>目录中。可执行文件保存在<code>bin</code>目录下，Fortran编译模块文件保存在<code>modules</code>目录下:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/<span class="class"><span class="keyword">lib</span>)</span></span><br><span class="line">set(CMAKE_LIBRARY_OUTPUT_DIRECTORY $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/<span class="class"><span class="keyword">lib</span>)</span></span><br><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/bin)</span><br><span class="line">set(CMAKE_Fortran_MODULE_DIRECTORY</span><br><span class="line">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/modules)</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，我们进入第一个子<code>CMakeLists.txt</code>，添加<code>src</code>子目录:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(src)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>src/CMakeLists.txt</code>文件添加了两个子目录:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(interfaces)</span></span></span><br><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(utils)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在<code>interfaces</code>子目录中，我们将执行以下操作:</p>
<ol>
<li><p>包括<code>FortranCInterface.cmak</code>模块，并验证C和Fortran编译器可以正确地交互:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(FortranCInterface)</span></span></span><br><span class="line"><span class="function"><span class="title">FortranCInterface_VERIFY</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，我们找到Backtrace系统库，因为我们想在Fortran代码中使用它:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(Backtrace REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，创建一个共享库目标，其中包含Backtrace包装器、随机数生成器，以及Fortran包装器的源文件:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(bt-randomgen-wrap SHARED <span class="string">""</span>)</span></span></span><br><span class="line"></span><br><span class="line">target_sources(bt-randomgen-wrap</span><br><span class="line">  PRIVATE</span><br><span class="line">    interface_backtrace.f90</span><br><span class="line">    interface_randomgen.f90</span><br><span class="line">    randomgen.c</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们还为新生成的库目标设置了链接库。使用<code>PUBLIC</code>属性，以便连接到其他目标时，能正确地看到依赖关系:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">target_link_libraries</span>(<span class="keyword">bt-randomgen-wrap</span></span><br><span class="line"><span class="keyword"> </span> PUBLIC</span><br><span class="line">  	$&#123;<span class="keyword">Backtrace_LIBRARIES&#125;</span></span><br><span class="line"><span class="keyword"> </span> )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>utils</code>子目录中，还有一个<code>CMakeLists.txt</code>，其只有一单行程序：我们创建一个新的库目标，子目录中的源文件将被编译到这个目标库中。并与这个目标没有依赖关系:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(utils SHARED util_strings.f90)</span></span></span><br></pre></td></tr></table></figure>
<p>回到<code>src/CMakeLists.txt</code>:</p>
<ol>
<li><p>使用<code>bt-randomgen-example.f90</code>添加一个可执行目标:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_executable(bt-randomgen-<span class="built_in">example</span> bt-randomgen-<span class="built_in">example</span>.<span class="built_in">f90</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，将在子<code>CMakeLists.txt</code>中生成的库目标，并链接到可执行目标:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">target_link_libraries</span>(<span class="keyword">bt-randomgen-example</span></span><br><span class="line"><span class="keyword"> </span> PRIVATE</span><br><span class="line">  	<span class="keyword">bt-randomgen-wrap</span></span><br><span class="line"><span class="keyword"> </span> 	utils</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>确定链接了正确库之后，需要保证程序能够正确调用函数。每个编译器在生成机器码时都会执行命名检查。不过，这种操作的约定不是通用的，而是与编译器相关的。<code>FortranCInterface</code>，我们已经在第3章第4节时，检查所选C编译器与Fortran编译器的兼容性。对于当前的目的，命名检查并不是一个真正的问题。Fortran 2003标准提供了可选<code>name</code>参数的函数和子例程定义了<code>bind</code>属性。如果提供了这个参数，编译器将使用程序员指定的名称为这些子例程和函数生成符号。例如，backtrace函数可以从C语言中暴露给Fortran，并保留其命名:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function backtrace(<span class="name">buffer</span>, size) result(<span class="name">bt</span>) bind(<span class="name">C</span>, name=<span class="string">"backtrace"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p><code>interface/CMakeLists.txt</code>中的CMake代码还表明，可以使用不同语言的源文件创建库。CMake能够做到以下几点:</p>
<ul>
<li>列出的源文件中获取目标文件，并识别要使用哪个编译器。</li>
<li>选择适当的链接器，以便构建库(或可执行文件)。</li>
</ul>
<p>CMake如何决定使用哪个编译器？在<code>project</code>命令时使用参数<code>LANGUAGES</code>指定，这样CMake会检查系统上给定语言编译器。当使用源文件列表添加目标时，CMake将根据文件扩展名选择适当地编译器。因此，以<code>.c</code>结尾的文件使用C编译器编译，而以<code>.f90</code>结尾的文件(如果需要预处理，可以使用<code>.F90</code>)将使用Fortran编译器编译。类似地，对于C++， <code>.cpp</code>或<code>.cxx</code>扩展将触发<code>C++</code>编译器。我们只列出了C/C++和Fortran语言的一些可能的、有效的文件扩展名，但是CMake可以识别更多的扩展名。如果您的项目中的文件扩展名，由于某种原因不在可识别的扩展名之列，该怎么办？源文件属性可以用来告诉CMake在特定的源文件上使用哪个编译器，就像这样：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_source_files_properties(<span class="name">my_source_file</span>.axx</span><br><span class="line">  PROPERTIES</span><br><span class="line">  	LANGUAGE CXX</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>那链接器呢？CMake如何确定目标的链接器语言？对于不混合编程语言的目标很简单：通过生成目标文件的编译器命令调用链接器即可。如果目标混合了多个语言，就像示例中一样，则根据在语言混合中，优先级最高的语言来选择链接器语言。比如，我们的示例中混合了Fortran和C，因此Fortran语言比C语言具有更高的优先级，因此使用Fortran用作链接器语言。当混合使用Fortran和C++时，后者具有更高的优先级，因此C++被用作链接器语言。就像编译器语言一样，我们可以通过目标相应的<code>LINKER_LANGUAGE</code>属性，强制CMake为我们的目标使用特定的链接器语言:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(<span class="name">my_target</span></span><br><span class="line">  PROPERTIES</span><br><span class="line">  	LINKER_LANGUAGE Fortran</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h1 id="9-2-使用Fortran库构建C-C-项目"><a href="#9-2-使用Fortran库构建C-C-项目" class="headerlink" title="9.2 使用Fortran库构建C/C++项目"></a>9.2 使用Fortran库构建C/C++项目</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-02" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-02</a> 中找到，其中有一个示例：一个是C++、C和Fortran的混例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>第3章第4节，展示了如何检测Fortran编写的BLAS和LAPACK线性代数库，以及如何在C++代码中使用它们。这里，将重新讨论这个方式，但这次的角度有所不同：较少地关注检测外部库，会更深入地讨论混合C++和Fortran的方面，以及名称混乱的问题。</p>
<h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><p>本示例中，我们将重用第3章第4节源代码。虽然，我们不会修改源码或头文件，但我们会按照第7章“结构化项目”中，讨论的建议修改项目树结构，并得到以下源代码结构:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── README.md</span><br><span class="line">└── src</span><br><span class="line">      ├── CMakeLists.txt</span><br><span class="line">      ├── linear-algebra.cpp</span><br><span class="line">      └── math</span><br><span class="line">            ├── CMakeLists.txt</span><br><span class="line">            ├── CxxBLAS.cpp</span><br><span class="line">            ├── CxxBLAS.hpp</span><br><span class="line">            ├── CxxLAPACK.cpp</span><br><span class="line">            └── CxxLAPACK.hpp</span><br></pre></td></tr></table></figure>
<p>这里，收集了BLAS和LAPACK的所有包装器，它们提供了<code>src/math</code>下的数学库了，主要程序为<code>linear-algebra.cpp</code>。因此，所有源都在<code>src</code>子目录下。我们还将CMake代码分割为三个<code>CMakeLists.txt</code>文件，现在来讨论这些文件。</p>
<h2 id="具体实施-1"><a href="#具体实施-1" class="headerlink" title="具体实施"></a>具体实施</h2><p>这个项目混合了C++(作为该示例的主程序语言)和C(封装Fortran子例程所需的语言)。在根目录下的<code>CMakeLists.txt</code>文件中，我们需要做以下操作:</p>
<ol>
<li><p>声明一个混合语言项目，并选择C++标准：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">02</span> LANGUAGES CXX C Fortran)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>GNUInstallDirs</code>模块来设置CMake将静态和动态库，以及可执行文件保存的标准目录。我们还指示CMake将Fortran编译的模块文件放在<code>modules</code>目录下:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include(GNUInstallDirs)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_Fortran_MODULE_DIRECTORY <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/modules)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，进入下一个子目录:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(src)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>子文件<code>src/CMakeLists.txt</code>添加了另一个目录<code>math</code>，其中包含线性代数包装器。在<code>src/math/CMakeLists.txt</code>中，我们需要以下操作:</p>
<ol>
<li><p>调用<code>find_package</code>来获取BLAS和LAPACK库的位置:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(BLAS REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(LAPACK REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>包含<code>FortranCInterface.cmake</code>模块，并验证Fortran、C和C++编译器是否兼容:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(FortranCInterface)</span></span></span><br><span class="line"><span class="function"><span class="title">FortranCInterface_VERIFY</span><span class="params">(CXX)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们还需要生成预处理器宏来处理BLAS和LAPACK子例程的名称问题。同样，<code>FortranCInterface</code>通过在当前构建目录中生成一个名为<code>fc_mangl.h</code>的头文件来提供协助:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FortranCInterface_HEADER(</span><br><span class="line">  fc_mangle.h</span><br><span class="line">  MACRO_NAMESPACE <span class="string">"FC_"</span></span><br><span class="line">  SYMBOLS DSCAL DGESV</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，添加了一个库，其中包含BLAS和LAPACK包装器的源代码。我们还指定要找到头文件和库的目录。注意<code>PUBLIC</code>属性，它允许其他依赖于<code>math</code>的目标正确地获得它们的依赖关系:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">math</span> <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">math</span></span><br><span class="line">  PRIVATE</span><br><span class="line">    CxxBLAS.cpp</span><br><span class="line">    CxxLAPACK.cpp</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">math</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>回到<code>src/CMakeLists.txt</code>，我们最终添加了一个可执行目标，并将其链接到BLAS/LAPACK包装器的数学库:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">linear-algebra</span> <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">target_sources(<span class="name">linear-algebra</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	linear-algebra.cpp</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_link_libraries(<span class="name">linear-</span> algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">  	math</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h2><p>使用<code>find_package</code>确定了要链接到的库。方法和之前一样，需要确保程序能够正确地调用它们定义的函数。第3章第4节中，我们面临的问题是编译器的名称符号混乱。我们使用<code>FortranCInterface</code>模块来检查所选的C和C++编译器与Fortran编译器的兼容性。我们还使用<code>FortranCInterface_HEADER</code>函数生成带有宏的头文件，以处理Fortran子例程的名称混乱。并通过以下代码实现:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FortranCInterface_HEADER(</span><br><span class="line">  fc_mangle.h</span><br><span class="line">  MACRO_NAMESPACE <span class="string">"FC_"</span></span><br><span class="line">  SYMBOLS DSCAL DGESV</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这个命令将生成<code>fc_mangl.h</code>头文件，其中包含从Fortran编译器推断的名称混乱宏，并将其保存到当前二进制目录<code>CMAKE_CURRENT_BINARY_DIR</code>中。我们小心地将<code>CMAKE_CURRENT_BINARY_DIR</code>设置为数学目标的包含路径。生成的<code>fc_mangle.h</code>如下:</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#ifndef FC_HEADER_INCLUDED</span><br><span class="line">#define FC_HEADER_INCLUDED</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mangling for Fortran global symbols without underscores. */</span></span><br><span class="line">#define FC_GLOBAL(name,NAME) name##_</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mangling for Fortran global symbols with underscores. */</span></span><br><span class="line">#define FC_GLOBAL_(name,NAME) name##_</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mangling for Fortran module symbols without underscores. */</span></span><br><span class="line">#define FC_MODULE(mod_name,name, mod_NAME,NAME) __##mod_name##_MOD_##name</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mangling for Fortran module symbols with underscores. */</span></span><br><span class="line">#define FC_MODULE_(mod_name,name, mod_NAME,NAME) __##mod_name##_MOD_##name</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Mangle some symbols automatically. */</span></span><br><span class="line">#define DSCAL FC_GLOBAL(dscal, DSCAL)</span><br><span class="line">#define DGESV FC_GLOBAL(dgesv, DGESV)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>本例中的编译器使用下划线进行错误处理。由于Fortran不区分大小写，子例程可能以小写或大写出现，这就说明将这两种情况传递给宏的必要性。注意，CMake还将为隐藏在Fortran模块后面的符号生成宏。</p>
<p><strong>NOTE</strong>:<em>现在，BLAS和LAPACK的许多实现都在Fortran子例程附带了一个C的包装层。这些包装器已经标准化，分别称为CBLAS和LAPACKE。</em></p>
<p>由于已经将源组织成库目标和可执行目标，所以我们应该对目标的<code>PUBLIC</code>、<code>INTERFACE</code>和<code>PRIVATE</code>可见性属性的使用进行评论。与源文件一样，包括目录、编译定义和选项，当与<code>target_link_libraries</code>一起使用时，这些属性的含义是相同的:</p>
<ul>
<li>使用<code>PRIVATE</code>属性，库将只链接到当前目标，而不链接到使用它的任何其他目标。</li>
<li>使用<code>INTERFACE</code>属性，库将只链接到使用当前目标作为依赖项的目标。</li>
<li>使用<code>PUBLIC</code>属性，库将被链接到当前目标，以及将其作为依赖项使用的任何其他目标。</li>
</ul>
<h1 id="9-3-使用Cython构建C-和Python项目"><a href="#9-3-使用Cython构建C-和Python项目" class="headerlink" title="9.3 使用Cython构建C++和Python项目"></a>9.3 使用Cython构建C++和Python项目</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-03" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-03</a> 中找到，其中有一个C++示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>Cython是一个静态编译器，它允许为Python编写C扩展。Cython是一个非常强大的工具，使用Cython编程语言(基于Pyrex)。Cython的一个典型用例是加快Python代码的速度，它也可以用于通过Cython层使Python与C(++)接口对接。本示例中，我们将重点介绍后一种用例，并演示如何在CMake的帮助下使用Cython与C(++)和Python进行对接。</p>
<h2 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将使用以下C++代码(<code>account.cpp</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"account.hpp"</span></span></span><br><span class="line">Account::Account() : balance(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line">Account::~Account() &#123;&#125;</span><br><span class="line"><span class="keyword">void</span> Account::deposit(<span class="keyword">const</span> <span class="keyword">double</span> amount) &#123; balance += amount; &#125;</span><br><span class="line"><span class="keyword">void</span> Account::withdraw(<span class="keyword">const</span> <span class="keyword">double</span> amount) &#123; balance -= amount; &#125;</span><br><span class="line"><span class="keyword">double</span> Account::get_balance() <span class="keyword">const</span> &#123; <span class="keyword">return</span> balance; &#125;</span><br></pre></td></tr></table></figure>
<p>代码提供了以下接口(<code>account.hpp</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Account();</span><br><span class="line">  ~Account();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">get_balance</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> balance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用这个示例代码，我们可以创建余额为零的银行帐户。可以在帐户上存款和取款，还可以使用<code>get_balance()</code>查询帐户余额。余额本身是<code>Account</code>类的私有成员。</p>
<p>我们的目标是能够直接从Python与这个C++类进行交互。换句话说，在Python方面，我们希望能够做到这一点:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">account = Account()</span><br><span class="line"></span><br><span class="line">account.deposit(100.0)</span><br><span class="line">account.withdraw(50.0)</span><br><span class="line"></span><br><span class="line">balance = account.get_balance()</span><br></pre></td></tr></table></figure>
<p>为此，需要一个Cython接口文件(调用<code>account.pyx</code>):</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># describe the c++ interface</span></span><br><span class="line">cdef extern from <span class="string">"account.hpp"</span><span class="symbol">:</span></span><br><span class="line">  cdef cppclass <span class="symbol">Account:</span></span><br><span class="line">    Account() except +</span><br><span class="line">    void deposit(double)</span><br><span class="line">    void withdraw(double)</span><br><span class="line">    double get_balance()</span><br><span class="line"></span><br><span class="line"><span class="comment"># describe the python interface</span></span><br><span class="line">cdef <span class="class"><span class="keyword">class</span> <span class="title">pyAccount</span>:</span></span><br><span class="line">  cdef Account *thisptr</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__cinit__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">  	<span class="keyword">self</span>.thisptr = new Account()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__dealloc__</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">  	del <span class="keyword">self</span>.thisptr</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(<span class="keyword">self</span>, amount)</span></span><span class="symbol">:</span></span><br><span class="line">  	<span class="keyword">self</span>.thisptr.deposit(amount)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">self</span>, amount)</span></span><span class="symbol">:</span></span><br><span class="line">  	<span class="keyword">self</span>.thisptr.withdraw(amount)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_balance</span><span class="params">(<span class="keyword">self</span>)</span></span><span class="symbol">:</span></span><br><span class="line">  	<span class="keyword">return</span> <span class="keyword">self</span>.thisptr.get_balance()</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-2"><a href="#具体实施-2" class="headerlink" title="具体实施"></a>具体实施</h2><p>如何生成Python接口:</p>
<ol>
<li><code>CMakeLists.txt</code>定义CMake依赖项、项目名称和语言:</li>
</ol>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># define minimum cmake version</span><br><span class="line"><span class="title">cmake_minimum_required</span>(<span class="type">VERSION</span> <span class="number">3.5</span> <span class="type">FATAL_ERROR</span>)</span><br><span class="line"># project name and supported language</span><br><span class="line">project(recipe-03 <span class="type">LANGUAGES</span> <span class="type">CXX</span>)</span><br><span class="line"># require C++11</span><br><span class="line">set(<span class="type">CMAKE_CXX_STANDARD</span> 11)</span><br><span class="line">set(<span class="type">CMAKE_CXX_EXTENSIONS</span> <span class="type">OFF</span>)</span><br><span class="line">set(<span class="type">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="type">ON</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Windows上，最好不要保留未定义的构建类型，这样我们就可以将该项目的构建类型与Python环境的构建类型相匹配。这里我们默认为Release类型:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT CMAKE_BUILD_TYPE)</span></span></span><br><span class="line">	set(CMAKE_BUILD_TYPE Release CACHE STRING <span class="string">"Build type"</span> FORCE)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在示例中，还需要Python解释器:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的CMake代码将构建Python模块:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># directory cointaining UseCython.cmake and FindCython.cmake</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/cmake-cython)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this defines cython_add_module</span></span><br><span class="line"><span class="keyword">include</span>(UseCython)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tells UseCython to compile this file as a c++ file</span></span><br><span class="line"><span class="keyword">set_source_files_properties</span>(account.pyx PROPERTIES CYTHON_IS_CXX <span class="keyword">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create python module</span></span><br><span class="line">cython_add_module(account account.pyx account.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># location of account.hpp</span></span><br><span class="line"><span class="keyword">target_include_directories</span>(account</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一个测试：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># turn on testing</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># define test</span></span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME</span><br><span class="line">  	python_test</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env ACCOUNT_MODULE_PATH=$&lt;TARGET_FILE_DIR:account&gt;</span><br><span class="line">  	<span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>python_test</code>执行<code>test.py</code>，这里进行一些存款和取款操作，并验证余额:</p>
<figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">os</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="built_in">os</span>.getenv(<span class="string">'ACCOUNT_MODULE_PATH'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> account <span class="keyword">import</span> pyAccount as Account</span><br><span class="line"></span><br><span class="line">account1 = Account()</span><br><span class="line"></span><br><span class="line">account1.deposit(<span class="number">100.0</span>)</span><br><span class="line">account1.deposit(<span class="number">100.0</span>)</span><br><span class="line"></span><br><span class="line">account2 = Account()</span><br><span class="line"></span><br><span class="line">account2.deposit(<span class="number">200.0</span>)</span><br><span class="line">account2.deposit(<span class="number">200.0</span>)</span><br><span class="line"></span><br><span class="line">account1.withdraw(<span class="number">50.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert</span> account1.get_balance() == <span class="number">150.0</span></span><br><span class="line"><span class="built_in">assert</span> account2.get_balance() == <span class="number">400.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>有了这个，我们就可以配置、构建和测试代码了:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake <span class="built_in">..</span></span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ctest</span><br><span class="line"></span><br><span class="line">Start 1: python_test</span><br><span class="line">1/1 Test #1: python_test <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span> Passed 0.03 sec</span><br><span class="line">100% tests passed, 0 tests failed out of 1</span><br><span class="line">Total Test time (real) = 0.03 sec</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h2><p>本示例中，使用一个相对简单的<code>CMakeLists.txt</code>文件对接了Python和C++，但是是通过使用<code>FindCython.cmake</code>进行的实现。<code>UseCython.cmake</code>模块，放置在<code>cmake-cython</code>下。这些模块包括使用以下代码:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># directory contains UseCython.cmake and FindCython.cmake</span></span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/cmake-cython)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this defines cython_add_module</span></span><br><span class="line"><span class="keyword">include</span>(UseCython)</span><br></pre></td></tr></table></figure>
<p><code>FindCython.cmake</code>包含在<code>UseCython.cmake</code>中，并定义了<code>${CYTHON_EXECUTABLE}</code>变量。后一个模块定义了<code>cython_add_module</code>和<code>cython_add_standalone_executable</code>函数，它们分别用于创建Python模块和独立的可执行程序。这两个模块都可从 <a href="https://github.com/thewtex/cython-cmake-example/tree/master/cmake" target="_blank" rel="noopener">https://github.com/thewtex/cython-cmake-example/tree/master/cmake</a> 下载。</p>
<p>这个示例中，使用<code>cython_add_module</code>创建一个Python模块库。注意，将使用非标准的<code>CYTHON_IS_CXX</code>源文件属性设置为<code>TRUE</code>，以便<code>cython_add_module</code>函数知道如何将<code>pyx</code>作为<code>C++</code>文件进行编译:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tells UseCython to compile this file as a c++ file</span></span><br><span class="line"><span class="keyword">set_source_files_properties</span>(account.pyx PROPERTIES CYTHON_IS_CXX <span class="keyword">TRUE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create python module</span></span><br><span class="line">cython_add_module(account account.pyx account.cpp)</span><br></pre></td></tr></table></figure>
<p>Python模块在<code>${CMAKE_CURRENT_BINARY_DIR}</code>中创建，为了让Python的<code>test.py</code>脚本找到它，我们使用一个自定义环境变量传递相关的路径，该环境变量用于在<code>test.py</code>中设置<code>path</code>变量。请注意，如何将命令设置为调用CMake可执行文件本身，以便在执行Python脚本之前设置本地环境。这为我们提供了平台独立性，并避免了环境污染:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME</span><br><span class="line">  	python_test</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env ACCOUNT_MODULE_PATH=$&lt;TARGET_FILE_DIR:account&gt;</span><br><span class="line">  	<span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>我们来看看<code>account.pyx</code>文件，这是Python与C++之间的接口文件，并对C++接口进行描述:</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># describe the c++ interface</span></span><br><span class="line">cdef <span class="keyword">extern</span> <span class="keyword">from</span> <span class="string">"account.hpp"</span>:</span><br><span class="line">  cdef cppclass Account:</span><br><span class="line">    Account() except +</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deposit</span>(<span class="params"><span class="keyword">double</span></span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">withdraw</span>(<span class="params"><span class="keyword">double</span></span>)</span></span><br><span class="line"><span class="function">    <span class="keyword">double</span> <span class="title">get_balance</span>(<span class="params"></span>)</span></span><br></pre></td></tr></table></figure>
<p>可以看到<code>cinit</code>构造函数、<code>__dealloc__</code>析构函数以及<code>deposit</code>和<code>withdraw</code>方法是如何与对应的C++实现相匹配的。</p>
<p>总之，发现了一种机制，通过引入对Cython模块的依赖来耦合Python和C++。该模块可以通过<code>pip</code>安装到虚拟环境或Pipenv中，或者使用Anaconda来安装。</p>
<h2 id="更多信息-1"><a href="#更多信息-1" class="headerlink" title="更多信息"></a>更多信息</h2><p>C语言可以进行类似地耦合。如果希望利用构造函数和析构函数，我们可以在C接口之上封装一个C++层。</p>
<p>类型化Memoryview提供了有趣的功能，可以映射和访问由C/C++直接在Python中分配的内存，而不需要任何创建：<a href="http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html" target="_blank" rel="noopener">http://cython.readthedocs.io/en/latest/src/userguide/memoryviews.html</a> 。它们使得将NumPy数组直接映射为C++数组成为可能。</p>
<h1 id="9-4-使用Boost-Python构建C-和Python项目"><a href="#9-4-使用Boost-Python构建C-和Python项目" class="headerlink" title="9.4 使用Boost.Python构建C++和Python项目"></a>9.4 使用Boost.Python构建C++和Python项目</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-04" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-04</a> 中找到，其中有一个C++示例。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>Boost库为C++代码提供了Python接口。本示例将展示如何在依赖于Boost的C++项目中使用CMake，之后将其作为Python模块发布。我们将重用前面的示例，并尝试用Cython示例中的C++实现(<code>account.cpp</code>)进行交互。</p>
<h2 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h2><p>保持<code>account.cpp</code>不变的同时，修改前一个示例中的接口文件(<code>account.hpp</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_PYTHON_STATIC_LIB</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/python.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Account();</span><br><span class="line">  ~Account();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">get_balance</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> balance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> py = boost::python;</span><br><span class="line"></span><br><span class="line">BOOST_PYTHON_MODULE(account)</span><br><span class="line">&#123;</span><br><span class="line">  py::class_&lt;Account&gt;(<span class="string">"Account"</span>)</span><br><span class="line">      .def(<span class="string">"deposit"</span>, &amp;Account::deposit)</span><br><span class="line">      .def(<span class="string">"withdraw"</span>, &amp;Account::withdraw)</span><br><span class="line">      .def(<span class="string">"get_balance"</span>, &amp;Account::get_balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-3"><a href="#具体实施-3" class="headerlink" title="具体实施"></a>具体实施</h2><p>如何在C++项目中使用Boost.Python的步骤：</p>
<ol>
<li><p>和之前一样，首先定义最低版本、项目名称、支持语言和默认构建类型:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define minimum cmake version</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># project name and supported language</span></span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">04</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># require C++11</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we default to Release build type</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">	<span class="keyword">set</span>(CMAKE_BUILD_TYPE Release CACHE <span class="keyword">STRING</span> <span class="string">"Build type"</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>本示例中，依赖Python和Boost库，以及使用Python进行测试。Boost.Python组件依赖于Boost版本和Python版本，因此需要对这两个组件的名称进行检测：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for testing we will need the python interpreter</span></span><br><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># we require python development headers</span></span><br><span class="line"><span class="keyword">find_package</span>(PythonLibs <span class="variable">$&#123;PYTHON_VERSION_MAJOR&#125;</span>.<span class="variable">$&#123;PYTHON_VERSION_MINOR&#125;</span> EXACT REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># now search for the boost component</span></span><br><span class="line"><span class="comment"># depending on the boost version it is called either python,</span></span><br><span class="line"><span class="comment"># python2, python27, python3, python36, python37, ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">list</span>(</span><br><span class="line">  APPEND _components</span><br><span class="line">    python<span class="variable">$&#123;PYTHON_VERSION_MAJOR&#125;</span><span class="variable">$&#123;PYTHON_VERSION_MINOR&#125;</span></span><br><span class="line">    python<span class="variable">$&#123;PYTHON_VERSION_MAJOR&#125;</span></span><br><span class="line">    python</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="keyword">set</span>(_boost_component_found <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(_component IN ITEMS <span class="variable">$&#123;_components&#125;</span>)</span><br><span class="line">  <span class="keyword">find_package</span>(Boost COMPONENTS <span class="variable">$&#123;_component&#125;</span>)</span><br><span class="line">  <span class="keyword">if</span>(Boost_FOUND)</span><br><span class="line">  	<span class="keyword">set</span>(_boost_component_found <span class="variable">$&#123;_component&#125;</span>)</span><br><span class="line">  	<span class="keyword">break</span>()</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(_boost_component_found <span class="keyword">STREQUAL</span> <span class="string">""</span>)</span><br><span class="line">	<span class="keyword">message</span>(FATAL_ERROR <span class="string">"No matching Boost.Python component found"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用以下命令，定义Python模块及其依赖项:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create python module</span></span><br><span class="line">add_library(account</span><br><span class="line">  MODULE</span><br><span class="line">  	account.cpp</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_link_libraries(account</span><br><span class="line">  PUBLIC</span><br><span class="line">  	Boost::<span class="variable">$&#123;_boost_component_found&#125;</span></span><br><span class="line">  <span class="variable">$&#123;PYTHON_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_include_directories(account</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;PYTHON_INCLUDE_DIRS&#125;</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="comment"># prevent cmake from creating a "lib" prefix</span></span><br><span class="line">set_target_properties(account</span><br><span class="line">  PROPERTIES</span><br><span class="line">  <span class="built_in">	PREFIX </span><span class="string">""</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">  # python will <span class="keyword">not</span> import dll but expects pyd</span><br><span class="line">  set_target_properties(account</span><br><span class="line">    PROPERTIES</span><br><span class="line">    	SUFFIX <span class="string">".pyd"</span></span><br><span class="line">  )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，定义了一个测试:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># turn on testing</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># define test</span></span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME</span><br><span class="line">  	python_test</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env ACCOUNT_MODULE_PATH=$&lt;TARGET_FILE_DIR:account&gt;</span><br><span class="line">  	<span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">test</span>.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置、编译和测试:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake <span class="built_in">..</span></span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ctest</span><br><span class="line"></span><br><span class="line">Start 1: python_test</span><br><span class="line">1/1 Test #1: python_test <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span> Passed 0.10 sec</span><br><span class="line">100% tests passed, 0 tests failed out of 1</span><br><span class="line">Total Test time (real) = 0.11 sec</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h2><p>现在，不依赖于Cython模块，而是依赖于在系统上的Boost库，以及Python的开发头文件和库。</p>
<p>Python的开发头文件和库的搜索方法如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonLibs $&#123;PYTHON_VERSION_MAJOR&#125;.$&#123;PYTHON_VERSION_MINOR&#125; EXACT REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
<p>首先搜索解释器，然后搜索开发头和库。此外，对<code>PythonLibs</code>的搜索要求开发头文件和库的主版本和次版本，与解释器的完全相同。但是，命令组合不能保证找到完全匹配的版本。</p>
<p>定位Boost.Python时，我们试图定位的组件的名称既依赖于Boost版本，也依赖于我们的Python环境。根据Boost版本的不同，可以调用python、python2、python3、python27、python36、python37等等。我们从特定的名称搜索到更通用的名称，已经解决了这个问题，只有在没有找到匹配的名称时才会失败：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">list(</span><br><span class="line">  APPEND _components</span><br><span class="line">    python$&#123;PYTHON_VERSION_MAJOR&#125;$&#123;PYTHON_VERSION_MINOR&#125;</span><br><span class="line">    python$&#123;PYTHON_VERSION_MAJOR&#125;</span><br><span class="line">    python</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">set(<span class="name">_boost_component_found</span> <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">foreach(<span class="name">_component</span> IN ITEMS $&#123;_components&#125;)</span><br><span class="line">	find_package(<span class="name">Boost</span> COMPONENTS $&#123;_component&#125;)</span><br><span class="line">	if(<span class="name">Boost_FOUND</span>)</span><br><span class="line">		set(<span class="name">_boost_component_found</span> $&#123;_component&#125;)</span><br><span class="line">		break()</span><br><span class="line">	endif()</span><br><span class="line">endforeach()</span><br><span class="line"></span><br><span class="line">if(<span class="name">_boost_component_found</span> STREQUAL <span class="string">""</span>)</span><br><span class="line">	message(<span class="name">FATAL_ERROR</span> <span class="string">"No matching Boost.Python component found"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p>可以通过设置额外的CMake变量，来调整Boost库的使用方式。例如，CMake提供了以下选项:</p>
<ul>
<li><strong>Boost_USE_STATIC_LIBS</strong>:设置为ON之后，可以使用静态版本的Boost库。</li>
<li><strong>Boost_USE_MULTITHREADED</strong>:设置为ON之后，可以切换成多线程版本。</li>
<li><strong>Boost_USE_STATIC_RUNTIME</strong>:设置为ON之后，可以在C++运行时静态的连接不同版本的Boost库。</li>
</ul>
<p>此示例的另一个特点是使用<code>add_library</code>的模块选项。我们已经从第1章第3节了解到，CMake接受以下选项作为<code>add_library</code>的第二个有效参数:</p>
<ul>
<li><strong>STATIC</strong>:创建静态库，也就是对象文件的存档，用于链接其他目标时使用，例如：可执行文件</li>
<li><strong>SHARED</strong>:创建共享库，也就是可以动态链接并在运行时加载的库</li>
<li><strong>OBJECT</strong>:创建对象库，也就是对象文件不需要将它们归档到静态库中，也不需要将它们链接到共享对象中</li>
</ul>
<p><code>MODULE</code>选项将生成一个插件库，也就是动态共享对象(DSO)，没有动态链接到任何可执行文件，但是仍然可以在运行时加载。由于我们使用C++来扩展Python，所以Python解释器需要能够在运行时加载我们的库。使用<code>MODULE</code>选项进行<code>add_library</code>，可以避免系统在库名前添加前缀(例如：Unix系统上的lib)。后一项操作是通过设置适当的目标属性来执行的，如下所示:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(account</span><br><span class="line">  PROPERTIES</span><br><span class="line">  <span class="built_in">	PREFIX </span><span class="string">""</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>完成Python和C++接口的示例，需要向Python代码描述如何连接到C++层，并列出对Python可见的符号，我们也有可能重新命名这些符号。在上一个示例中，我们在另一个单独的<code>account.pyx</code>文件这样用过。当使用Boost.Python时，我们直接用C++代码描述接口，理想情况下接近期望的接口类或函数定义:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">BOOST_PYTHON_MODULE</span>(<span class="selector-tag">account</span>) &#123;</span><br><span class="line">  <span class="attribute">py</span>::class_&lt;Account&gt;(<span class="string">"Account"</span>)</span><br><span class="line">    .<span class="built_in">def</span>(<span class="string">"deposit"</span>, &amp;Account::deposit)</span><br><span class="line">    .<span class="built_in">def</span>(<span class="string">"withdraw"</span>, &amp;Account::withdraw)</span><br><span class="line">    .<span class="built_in">def</span>(<span class="string">"get_balance"</span>, &amp;Account::get_balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>BOOST_PYTHON_MODULE</code>模板包含在<code>&lt;boost/python&gt;</code>中，负责创建Python接口。该模块将公开一个<code>Account</code> Python类，该类映射到C++类。这种情况下，我们不需要显式地声明构造函数和析构函数——编译器会有默认实现，并在创建Python对象时自动调用:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">myaccount</span> = Account()</span><br></pre></td></tr></table></figure>
<p>当对象超出范围并被回收时，将调用析构函数。另外，观察<code>BOOST_PYTHON_MODULE</code>如何声明<code>deposit</code>、<code>withdraw</code>和<code>get_balance</code>函数，并将它们映射为相应的C++类方法。</p>
<p>这样，Python可以在<code>PYTHONPATH</code>中找到编译后的模块。这个示例中，我们实现了Python和C++层之间相对干净的分离。Python代码的功能不受限制，不需要类型注释或重写名称，并保持Python风格:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">from account import Account</span><br><span class="line"></span><br><span class="line">account1 = Account()</span><br><span class="line"></span><br><span class="line">account1.deposit(<span class="number">100.0</span>)</span><br><span class="line">account1.deposit(<span class="number">100.0</span>)</span><br><span class="line"></span><br><span class="line">account2 = Account()</span><br><span class="line"></span><br><span class="line">account2.deposit(<span class="number">200.0</span>)</span><br><span class="line">account2.deposit(<span class="number">200.0</span>)</span><br><span class="line"></span><br><span class="line">account1.withdraw(<span class="number">50.0</span>)</span><br><span class="line"></span><br><span class="line">assert account1.get_balance() == <span class="number">150.0</span></span><br><span class="line">assert account2.get_balance() == <span class="number">400.0</span></span><br></pre></td></tr></table></figure>
<h2 id="更多信息-2"><a href="#更多信息-2" class="headerlink" title="更多信息"></a>更多信息</h2><p>这个示例中，我们依赖于系统上安装的Boost，因此CMake代码会尝试检测相应的库。或者，可以将Boost源与项目一起提供，并将此依赖项，作为项目的一部分构建。Boost使用的是一种可移植的方式将Python与C(++)进行连接。然而，与编译器支持和C++标准相关的可移植性是有代价的，因为Boost.Python不是轻量级依赖项。在接下来的示例中，我们将讨论Boost.Python的轻量级替代方案。</p>
<h1 id="9-5-使用pybind11构建C-和Python项目"><a href="#9-5-使用pybind11构建C-和Python项目" class="headerlink" title="9.5 使用pybind11构建C++和Python项目"></a>9.5 使用pybind11构建C++和Python项目</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-05" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-05</a> 中找到，其中有一个C++示例。该示例在CMake 3.11版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>前面的示例中，我们使用Boost.Python与C(C++)接口。本示例中，我们将尝试使用pybind11将Python与C++接口。其实现利用了C++11的特性，因此需要支持C++11的编译器。我们将演示在配置时如何获取pybind11依赖和构建我们的项目，包括一个使用FetchContent方法的Python接口，我们在第4章第3节和第8章第4节中有过讨论。在第11章第2节时，会通过PyPI发布一个用CMake/pybind11构建的C++/Python项目。届时将重新讨论这个例子，并展示如何打包它，使它可以用pip安装。</p>
<h2 id="准备工作-4"><a href="#准备工作-4" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将保持<code>account.cpp</code>不变，只修改<code>account.cpp</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Account();</span><br><span class="line">  ~Account();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">get_balance</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> balance;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> py = pybind11;</span><br><span class="line">PYBIND11_MODULE(account, m)</span><br><span class="line">&#123;</span><br><span class="line">  py::class_&lt;Account&gt;(m, <span class="string">"Account"</span>)</span><br><span class="line">      .def(py::init())</span><br><span class="line">      .def(<span class="string">"deposit"</span>, &amp;Account::deposit)</span><br><span class="line">      .def(<span class="string">"withdraw"</span>, &amp;Account::withdraw)</span><br><span class="line">      .def(<span class="string">"get_balance"</span>, &amp;Account::get_balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照pybind11文档的方式，通过CMake构建(<a href="https://pybind11.readthedocs.io/en/stable/compile" target="_blank" rel="noopener">https://pybind11.readthedocs.io/en/stable/compile</a> )。并使用<code>add_subdirectory</code>将pybind11导入项目。但是，不会将pybind11源代码显式地放到项目目录中，而是演示如何在配置时使用<code>FetchContent</code> (<a href="https://cmake.org/cmake/help/v3.11/module/FetchContent.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.11/module/FetchContent.html</a> )。</p>
<p>为了在下一个示例中更好地重用代码，我们还将把所有源代码放到子目录中，并使用下面的项目布局:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── account</span><br><span class="line">│    ├── account.cpp</span><br><span class="line">│    ├── account.hpp</span><br><span class="line">│    ├── CMakeLists.txt</span><br><span class="line">│    └── test.py</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-4"><a href="#具体实施-4" class="headerlink" title="具体实施"></a>具体实施</h2><p>让我们详细分析一下这个项目中，各个<code>CMakeLists.txt</code>文件的内容:</p>
<ol>
<li><p>主<code>CMakeLists.txt</code>文件:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># define minimum cmake version</span><br><span class="line"><span class="title">cmake_minimum_required</span>(<span class="type">VERSION</span> <span class="number">3.11</span> <span class="type">FATAL_ERROR</span>)</span><br><span class="line"></span><br><span class="line"># project name and supported language</span><br><span class="line">project(recipe-05 <span class="type">LANGUAGES</span> <span class="type">CXX</span>)</span><br><span class="line"></span><br><span class="line"># require C++11</span><br><span class="line">set(<span class="type">CMAKE_CXX_STANDARD</span> 11)</span><br><span class="line">set(<span class="type">CMAKE_CXX_EXTENSIONS</span> <span class="type">OFF</span>)</span><br><span class="line">set(<span class="type">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="type">ON</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个文件中，查询了用于测试的Python解释器:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，包含<code>account</code>子目录:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(account)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义单元测试:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># turn on testing</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># define test</span></span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME</span><br><span class="line">    python_test</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env ACCOUNT_MODULE_PATH=$&lt;TARGET_FILE_DIR:account&gt;</span><br><span class="line">    <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/account/<span class="keyword">test</span>.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>account/CMakeLists.txt</code>中，在配置时获取pybind11的源码：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">FetchContent</span>)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  pybind11_sources</span><br><span class="line">  GIT_REPOSITORY https<span class="symbol">://github</span>.com/pybind/pybind11.git</span><br><span class="line">  GIT_TAG v2.<span class="number">2</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">FetchContent_GetProperties(<span class="name">pybind11_sources</span>)</span><br><span class="line"></span><br><span class="line">if(<span class="name">NOT</span> pybind11_sources_POPULATED)</span><br><span class="line">  FetchContent_Populate(<span class="name">pybind11_sources</span>)</span><br><span class="line"></span><br><span class="line">  add_subdirectory(</span><br><span class="line">    $&#123;pybind11_sources_SOURCE_DIR&#125;</span><br><span class="line">    $&#123;pybind11_sources_BINARY_DIR&#125;</span><br><span class="line">    )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，定义Python模块。再次使用模块选项<code>add_library</code>。并将库目标的前缀和后缀属性设置为<code>PYTHON_MODULE_PREFIX</code>和<code>PYTHON_MODULE_EXTENSION</code>，这两个值由pybind11适当地推断出来:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add_library(account</span><br><span class="line">  MODULE</span><br><span class="line">    account.cpp</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_link_libraries(account</span><br><span class="line">  PUBLIC</span><br><span class="line">    pybind11::module</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">set_target_properties(account</span><br><span class="line">  PROPERTIES</span><br><span class="line">   <span class="built_in"> PREFIX </span><span class="string">"<span class="variable">$&#123;PYTHON_MODULE_PREFIX&#125;</span>"</span></span><br><span class="line">    SUFFIX <span class="string">"<span class="variable">$&#123;PYTHON_MODULE_EXTENSION&#125;</span>"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行测试：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake <span class="built_in">..</span></span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ctest</span><br><span class="line"></span><br><span class="line">Start 1: python_test</span><br><span class="line">1/1 Test #1: python_test <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span> Passed 0.04 sec</span><br><span class="line">100% tests passed, 0 tests failed out of 1</span><br><span class="line">Total Test time (real) = 0.04 sec</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h2><p>pybind11的功能和使用与Boost.Python非常类似。pybind11是一个更轻量级的依赖——不过需要编译器支持C++11。<code>account.hpp</code>中的接口定义与之前的示例非常类似:</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pybind11/pybind11.h&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">namespace py = pybind11;</span><br><span class="line">PYBIND11_MODULE(account, m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="symbol">  py:</span>:class_<span class="params">&lt;Account&gt;</span>(m, <span class="string">"Account"</span>)</span><br><span class="line">      .def(<span class="symbol">py::</span>init())</span><br><span class="line">      .def(<span class="string">"deposit"</span>, &amp;<span class="symbol">Account::</span>deposit)</span><br><span class="line">      .def(<span class="string">"withdraw"</span>, &amp;<span class="symbol">Account::</span>withdraw)</span><br><span class="line">      .def(<span class="string">"get_balance"</span>, &amp;<span class="symbol">Account::</span>get_balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，我们可以了解到Python方法是如何映射到C++函数的。解释<code>PYBIND11_MODULE</code>库是在导入的目标<code>pybind11::module</code>中定义，使用以下代码包括了这个模块:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(</span><br><span class="line">  <span class="variable">$&#123;pybind11_sources_SOURCE_DIR&#125;</span></span><br><span class="line">  <span class="variable">$&#123;pybind11_sources_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>与之前的示例有两个不同之处:</p>
<ul>
<li>不需要在系统上安装pybind11</li>
<li><code>${pybind11_sources_SOURCE_DIR}</code>子目录，包含pybind11的<code>CMakelist.txt</code>中，在我们开始构建项目时，这个目录并不存在</li>
</ul>
<p>这个挑战的解决方案是用<code>FetchContent</code>，在配置时获取pybind11源代码和CMake模块，以便可以使用<code>add_subdirectory</code>引用。使用<code>FetchContent</code>模式，可以假设pybind11在构建树中可用，并允许构建和链接Python模块:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_library(<span class="name">account</span></span><br><span class="line">  MODULE</span><br><span class="line">  	account.cpp</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_link_libraries(<span class="name">account</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	pybind11:<span class="symbol">:module</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>使用下面的命令，确保Python模块库得到一个定义良好的前缀和后缀，并与Python环境兼容:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(account</span><br><span class="line">  PROPERTIES</span><br><span class="line">   <span class="built_in"> PREFIX </span><span class="variable">$&#123;PYTHON_MODULE_PREFIX&#125;</span></span><br><span class="line">    SUFFIX <span class="variable">$&#123;PYTHON_MODULE_EXTENSION&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>主<code>CMakeLists.txt</code>文件的其余部分，都在执行测试(与前一个示例使用相同的<code>test.py</code>)。</p>
<h2 id="更多信息-3"><a href="#更多信息-3" class="headerlink" title="更多信息"></a>更多信息</h2><p>我们可以将pybind11源代码包含在项目源代码存储库中，这将简化CMake结构，并消除在编译时对pybind11源代码进行网络访问的要求。或者，我们可以将pybind11源路径定义为一个Git子模块(<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank" rel="noopener">https://git-scm.com/book/en/v2/Git-Tools-Submodules</a> )，以应对pybind11源依赖项的更新。</p>
<p>在示例中，我们使用<code>FetchContent</code>解决了这个问题，它提供了一种非常紧凑的方法来引用CMake子项目，而不是显式地跟踪它的源代码。同样，我们也可以使用超级构建的方法来解决这个问题(参见第8章)。</p>
<p>要查看如何简单函数、定义文档注释、映射内存缓冲区等进阶阅读，请参考pybind11文档:<a href="https://pybind11.readthedocs.io/" target="_blank" rel="noopener">https://pybind11.readthedocs.io</a></p>
<h1 id="9-6-使用Python-CFFI混合C，C-，Fortran和Python"><a href="#9-6-使用Python-CFFI混合C，C-，Fortran和Python" class="headerlink" title="9.6 使用Python CFFI混合C，C++，Fortran和Python"></a>9.6 使用Python CFFI混合C，C++，Fortran和Python</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-06" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-9/recipe-06</a> 中找到，其中有一个C++示例和一个Fortran示例。该示例在CMake 3.11版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>前面的三个示例中，我们使用Cython、Boost.Python和pybind11作为连接Python和C++的工具。之前的示例中，主要连接的是C++接口。然而，可能会遇到这样的情况：将Python与Fortran或其他语言进行接口。</p>
<p>本示例中，我们将使用Python C的外部函数接口(CFFI，参见<a href="https://cffi.readthedocs.io" target="_blank" rel="noopener">https://cffi.readthedocs.io)。由于C是通用语言，大多数编程语言(包括Fortran)都能够与C接口进行通信，所以Python</a>。由于c是通用语言，大多数编程语言(包括fortran)都能够与c接口进行通信，所以python/) CFFI是将Python与大量语言结合在一起的工具。Python CFFI的特性是，生成简单且非侵入性的C接口，这意味着它既不限制语言特性中的Python层，也不会对C层以下的代码有任何限制。</p>
<p>本示例中，将使用前面示例的银行帐户示例，通过C接口将Python CFFI应用于Python和C++。我们的目标是实现一个上下文感知的接口。接口中，我们可以实例化几个银行帐户，每个帐户都带有其内部状态。我们将通过讨论如何使用Python CFFI来连接Python和Fortran来结束本教程。</p>
<p>第11章第3节中，通过PyPI分发一个用CMake/CFFI构建的C/Fortran/Python项目，届时我们将重新讨论这个例子，并展示如何打包它，使它可以用<code>pip</code>安装。</p>
<h2 id="准备工作-5"><a href="#准备工作-5" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们从C++实现和接口开始，把它们放在名为<code>account/implementation</code>的子目录中。实现文件(<code>cpp_implementation.cpp</code>)类似于之前的示例，但是包含有断言，因为我们将对象的状态保持在一个不透明的句柄中，所以必须确保对象在访问时已经创建：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cpp_implementation.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line">Account::Account()</span><br><span class="line">&#123;</span><br><span class="line">  balance = <span class="number">0.0</span>;</span><br><span class="line">  is_initialized = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">Account::~Account()</span><br><span class="line">&#123;</span><br><span class="line">  assert(is_initialized);</span><br><span class="line">  is_initialized = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Account::deposit(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span><br><span class="line">&#123;</span><br><span class="line">  assert(is_initialized);</span><br><span class="line">  balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Account::withdraw(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span><br><span class="line">&#123;</span><br><span class="line">  assert(is_initialized);</span><br><span class="line">  balance -= amount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> Account::get_balance() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(is_initialized);</span><br><span class="line">  <span class="keyword">return</span> balance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口文件(<code>cpp_implementation.hpp</code>)包含如下内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Account();</span><br><span class="line">  ~Account();</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deposit</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">get_balance</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> balance;</span><br><span class="line">  <span class="keyword">bool</span> is_initialized;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此外，我们隔离了C-C++接口(<code>c_cpp_interface.cpp</code>)。这将是我们与Python CFFI连接的接口：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"account.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cpp_implementation.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AS_TYPE(Type, Obj) reinterpret_cast<span class="meta-string">&lt;Type *&gt;(Obj)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AS_CTYPE(Type, Obj) reinterpret_cast<span class="meta-string">&lt;const Type *&gt;(Obj)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">account_context_t</span> *account_new()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> AS_TYPE(<span class="keyword">account_context_t</span>, <span class="keyword">new</span> Account());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">account_free</span><span class="params">(<span class="keyword">account_context_t</span> *context)</span> </span>&#123; <span class="function"><span class="keyword">delete</span> <span class="title">AS_TYPE</span><span class="params">(Account, context)</span></span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">account_deposit</span><span class="params">(<span class="keyword">account_context_t</span> *context, <span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> AS_TYPE(Account, context)-&gt;deposit(amount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">account_withdraw</span><span class="params">(<span class="keyword">account_context_t</span> *context, <span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> AS_TYPE(Account, context)-&gt;withdraw(amount);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">account_get_balance</span><span class="params">(<span class="keyword">const</span> <span class="keyword">account_context_t</span> *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> AS_CTYPE(Account, context)-&gt;get_balance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>account</code>目录下，我们声明了C接口(<code>account.h</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ACCOUNT_API</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"account_export.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACCOUNT_API ACCOUNT_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">account_context</span>;</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">account_context</span> <span class="title">account_context_t</span>;</span></span><br><span class="line">  ACCOUNT_API</span><br><span class="line">  <span class="keyword">account_context_t</span> *account_new();</span><br><span class="line">  ACCOUNT_API</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">account_free</span><span class="params">(<span class="keyword">account_context_t</span> *context)</span></span>;</span><br><span class="line">  ACCOUNT_API</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">account_deposit</span><span class="params">(<span class="keyword">account_context_t</span> *context, <span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  ACCOUNT_API</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">account_withdraw</span><span class="params">(<span class="keyword">account_context_t</span> *context, <span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line">  ACCOUNT_API</span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">account_get_balance</span><span class="params">(<span class="keyword">const</span> <span class="keyword">account_context_t</span> *context)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ACCOUNT_H_INCLUDED */</span></span></span><br></pre></td></tr></table></figure>
<p>我们还描述了Python接口，将在稍后对此进行讨论(<code>__init_ _.py</code>):</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess import check_output</span><br><span class="line"><span class="keyword">from</span> cffi import FFI</span><br><span class="line">import os</span><br><span class="line">import sys</span><br><span class="line"><span class="keyword">from</span> configparser import ConfigParser</span><br><span class="line"><span class="keyword">from</span> pathlib import Path</span><br><span class="line"></span><br><span class="line">def get_lib_handle(definitions, header_file, library_file):</span><br><span class="line">  ffi = FFI()</span><br><span class="line">  command = [<span class="string">'cc'</span>, <span class="string">'-E'</span>] + definitions + [header_file]</span><br><span class="line">  interface = check_output(command).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="meta"># remove possible \r characters on windows which</span></span><br><span class="line">  <span class="meta"># would confuse cdef</span></span><br><span class="line">  <span class="variable">_interface</span> = [l.strip(<span class="string">'\r'</span>) <span class="keyword">for</span> l <span class="built_in">in</span> interface.split(<span class="string">'\n'</span>)]</span><br><span class="line">  ffi.cdef(<span class="string">'\n'</span>.<span class="built_in">join</span>(<span class="variable">_interface</span>))</span><br><span class="line">  lib = ffi.dlopen(library_file)</span><br><span class="line">  return lib</span><br><span class="line"></span><br><span class="line"><span class="meta"># this interface requires the header file and library file</span></span><br><span class="line"><span class="meta"># and these can be either provided by interface_file_names.cfg</span></span><br><span class="line"><span class="meta"># in the same path as this file</span></span><br><span class="line"><span class="meta"># or <span class="meta-keyword">if</span> this is not found then using environment variables</span></span><br><span class="line"><span class="variable">_this_path</span> = Path(os.path.dirname(os.path.realpath(<span class="variable">__file__</span>)))</span><br><span class="line"><span class="variable">_cfg_file</span> = <span class="variable">_this_path</span> / <span class="string">'interface_file_names.cfg'</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">_cfg_file</span>.exists():</span><br><span class="line">  config = ConfigParser()</span><br><span class="line">  config.read(<span class="variable">_cfg_file</span>)</span><br><span class="line">  header_file_name = config.get(<span class="string">'configuration'</span>, <span class="string">'header_file_name'</span>)</span><br><span class="line">  <span class="variable">_header_file</span> = <span class="variable">_this_path</span> / <span class="string">'include'</span> / header_file_name</span><br><span class="line">  <span class="variable">_header_file</span> = <span class="built_in">str</span>(<span class="variable">_header_file</span>)</span><br><span class="line">  library_file_name = config.get(<span class="string">'configuration'</span>, <span class="string">'library_file_name'</span>)</span><br><span class="line">  <span class="variable">_library_file</span> = <span class="variable">_this_path</span> / <span class="string">'lib'</span> / library_file_name</span><br><span class="line">  <span class="variable">_library_file</span> = <span class="built_in">str</span>(<span class="variable">_library_file</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="variable">_header_file</span> = os.getenv(<span class="string">'ACCOUNT_HEADER_FILE'</span>)</span><br><span class="line">  <span class="built_in">assert</span> <span class="variable">_header_file</span> is <span class="built_in">not</span> None</span><br><span class="line">  <span class="variable">_library_file</span> = os.getenv(<span class="string">'ACCOUNT_LIBRARY_FILE'</span>)</span><br><span class="line">  <span class="built_in">assert</span> <span class="variable">_library_file</span> is <span class="built_in">not</span> None</span><br><span class="line"></span><br><span class="line"><span class="variable">_lib</span> = get_lib_handle(definitions=[<span class="string">'-DACCOUNT_API='</span>, <span class="string">'-DACCOUNT_NOINCLUDE'</span>],</span><br><span class="line">                      header_file=<span class="variable">_header_file</span>,</span><br><span class="line">                      library_file=<span class="variable">_library_file</span>)</span><br><span class="line"><span class="meta"># we change names to obtain a more pythonic API</span></span><br><span class="line">new = <span class="variable">_lib</span>.account_new</span><br><span class="line">free = <span class="variable">_lib</span>.account_free</span><br><span class="line">deposit = <span class="variable">_lib</span>.account_deposit</span><br><span class="line">withdraw = <span class="variable">_lib</span>.account_withdraw</span><br><span class="line">get_balance = <span class="variable">_lib</span>.account_get_balance</span><br><span class="line"></span><br><span class="line"><span class="variable">__all__</span> = [</span><br><span class="line">    <span class="string">'__version__'</span>,</span><br><span class="line">    <span class="string">'new'</span>,</span><br><span class="line">    <span class="string">'free'</span>,</span><br><span class="line">    <span class="string">'deposit'</span>,</span><br><span class="line">    <span class="string">'withdraw'</span>,</span><br><span class="line">    <span class="string">'get_balance'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>我们看到，这个接口的大部分工作是通用的和可重用的，实际的接口相当薄。</p>
<p>项目的布局为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── account</span><br><span class="line">│    ├── account.h</span><br><span class="line">│    ├── CMakeLists.txt</span><br><span class="line">│    ├── implementation</span><br><span class="line">│    │    ├── c_cpp_interface.cpp</span><br><span class="line">│    │    ├── cpp_implementation.cpp</span><br><span class="line">│    │    └── cpp_implementation.hpp</span><br><span class="line">│    ├── __init__.py</span><br><span class="line">│    └── test.py</span><br><span class="line">└── CMakeLists.txt</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-5"><a href="#具体实施-5" class="headerlink" title="具体实施"></a>具体实施</h2><p>现在使用CMake来组合这些文件，形成一个Python模块:</p>
<ol>
<li><p>主<code>CMakeLists.txt</code>文件包含一个头文件。此外，根据GNU标准，设置编译库的位置:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># define minimum cmake version</span><br><span class="line"><span class="title">cmake_minimum_required</span>(<span class="type">VERSION</span> <span class="number">3.5</span> <span class="type">FATAL_ERROR</span>)</span><br><span class="line"></span><br><span class="line"># project name and supported language</span><br><span class="line">project(recipe-06 <span class="type">LANGUAGES</span> <span class="type">CXX</span>)</span><br><span class="line"></span><br><span class="line"># require C++11</span><br><span class="line">set(<span class="type">CMAKE_CXX_STANDARD</span> 11)</span><br><span class="line">set(<span class="type">CMAKE_CXX_EXTENSIONS</span> <span class="type">OFF</span>)</span><br><span class="line">set(<span class="type">CMAKE_CXX_STANDARD_REQUIRED</span> <span class="type">ON</span>)</span><br><span class="line"></span><br><span class="line"># specify <span class="keyword">where</span> to place libraries</span><br><span class="line">include(<span class="type">GNUInstallDirs</span>)</span><br><span class="line">set(<span class="type">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span></span><br><span class="line">$&#123;<span class="type">CMAKE_BINARY_DIR</span>&#125;/$&#123;<span class="type">CMAKE_INSTALL_LIBDIR</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，是在<code>account</code>子目录下包含接口和实现的定义：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">interface</span> <span class="keyword">and</span> sources</span><br><span class="line">add_subdirectory(account)</span><br></pre></td></tr></table></figure>
</li>
<li><p>主<code>CMakeLists.txt</code>文件以测试定义(需要Python解释器)结束：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># turn on testing</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># require python</span></span><br><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># define test</span></span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME</span><br><span class="line">    python_test</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env ACCOUNT_MODULE_PATH=<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">                        ACCOUNT_HEADER_FILE=<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/account/account.h</span><br><span class="line">                        ACCOUNT_LIBRARY_FILE=$&lt;TARGET_FILE:account&gt;</span><br><span class="line">   <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/account/<span class="keyword">test</span>.py</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>account/CMakeLists.txt</code>中定义了动态库目标：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(account</span><br><span class="line">  SHARED</span><br><span class="line">    plementation/c_cpp_interface.cpp</span><br><span class="line">    implementation/cpp_implementation.cpp</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(account</span><br><span class="line">  PRIVATE</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出一个可移植的头文件:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">GenerateExportHeader</span>)</span><br><span class="line">generate_export_header(<span class="name">account</span></span><br><span class="line">  BASE_NAME account</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Python-C接口进行对接:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake <span class="built_in">..</span></span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ctest</span><br><span class="line"></span><br><span class="line">Start 1: python_test</span><br><span class="line">1/1 Test #1: python_test <span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span> Passed 0.14 sec</span><br><span class="line">100% tests passed, 0 tests failed out of 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h2><p>虽然，之前的示例要求我们显式地声明Python-C接口，并将Python名称映射到C(++)符号，但Python CFFI从C头文件(示例中是<code>account.h</code>)推断出这种映射。我们只需要向Python CFFI层提供描述C接口的头文件和包含符号的动态库。在主<code>CMakeLists.txt</code>文件中使用了环境变量集来实现这一点，这些环境变量可以在<code>__init__.py</code>中找到:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_lib_handle</span><span class="params">(definitions, header_file, library_file)</span>:</span></span><br><span class="line">  ffi = FFI()</span><br><span class="line">  command = [<span class="string">'cc'</span>, <span class="string">'-E'</span>] + definitions + [header_file]</span><br><span class="line">  interface = check_output(command).decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># remove possible \r characters on windows which</span></span><br><span class="line">  <span class="comment"># would confuse cdef</span></span><br><span class="line">  _interface = [l.strip(<span class="string">'\r'</span>) <span class="keyword">for</span> l <span class="keyword">in</span> interface.split(<span class="string">'\n'</span>)]</span><br><span class="line"></span><br><span class="line">  ffi.cdef(<span class="string">'\n'</span>.join(_interface))</span><br><span class="line">  lib = ffi.dlopen(library_file)</span><br><span class="line">  <span class="keyword">return</span> lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">_this_path = Path(os.path.dirname(os.path.realpath(__file__)))</span><br><span class="line">_cfg_file = _this_path / <span class="string">'interface_file_names.cfg'</span></span><br><span class="line"><span class="keyword">if</span> _cfg_file.exists():</span><br><span class="line">    <span class="comment"># we will discuss this section in chapter 11, recipe 3</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  _header_file = os.getenv(<span class="string">'ACCOUNT_HEADER_FILE'</span>)</span><br><span class="line">  <span class="keyword">assert</span> _header_file <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">  _library_file = os.getenv(<span class="string">'ACCOUNT_LIBRARY_FILE'</span>)</span><br><span class="line">  <span class="keyword">assert</span> _library_file <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">  _lib = get_lib_handle(definitions=[<span class="string">'-DACCOUNT_API='</span>, <span class="string">'-DACCOUNT_NOINCLUDE'</span>],</span><br><span class="line">  header_file=_header_file,</span><br><span class="line">  library_file=_library_file)</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p><code>get_lib_handle</code>函数打开头文件(使用<code>ffi.cdef</code>)并解析加载库(使用<code>ffi.dlopen</code>)。并返回库对象。前面的文件是通用的，可以在不进行修改的情况下重用，用于与Python和C或使用Python CFFI的其他语言进行接口的其他项目。</p>
<p><code>_lib</code>库对象可以直接导出，这里有一个额外的步骤，使Python接口在使用时，感觉更像Python:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># we change names to obtain a more pythonic API</span></span><br><span class="line">new = _lib.account_new</span><br><span class="line">free = _lib.account_free</span><br><span class="line">deposit = _lib.account_deposit</span><br><span class="line">withdraw = _lib.account_withdraw</span><br><span class="line">get_balance = _lib.account_get_balance</span><br><span class="line"></span><br><span class="line">__all__ = [</span><br><span class="line">  '__version__',</span><br><span class="line">  'new',</span><br><span class="line">  'free',</span><br><span class="line">  'deposit',</span><br><span class="line">  'withdraw',</span><br><span class="line">  'get_balance',</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>有了这个变化，可以将例子写成下面的方式:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> account</span><br><span class="line">account1 = account.<span class="keyword">new</span><span class="type"></span>()</span><br><span class="line">account.deposit(account1, <span class="number">100.0</span>)</span><br></pre></td></tr></table></figure>
<p>另一种选择则不那么直观:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from account import <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">account1 = <span class="class"><span class="keyword">lib</span>.<span class="title">account_new</span>()</span></span><br><span class="line"><span class="class"><span class="keyword">lib</span>.<span class="title">account_deposit</span>(<span class="title">account1</span>, 100.0)</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，如何使用API来实例化和跟踪上下文:</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">account1 = account.<span class="keyword">new</span><span class="type"></span>()</span><br><span class="line">account.deposit(account1, <span class="number">10.0</span>)</span><br><span class="line"></span><br><span class="line">account2 = account.<span class="keyword">new</span><span class="type"></span>()</span><br><span class="line">account.withdraw(account1, <span class="number">5.0</span>)</span><br><span class="line">account.deposit(account2, <span class="number">5.0</span>)</span><br></pre></td></tr></table></figure>
<p>为了导入<code>account</code>的Python模块，需要提供<code>ACCOUNT_HEADER_FILE</code>和<code>ACCOUNT_LIBRARY_FILE</code>环境变量，就像测试中那样：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_test(</span><br><span class="line">  NAME</span><br><span class="line">    python_test</span><br><span class="line">  COMMAND</span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env <span class="attribute">ACCOUNT_MODULE_PATH</span>=<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span></span><br><span class="line">                        <span class="attribute">ACCOUNT_HEADER_FILE</span>=<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/account/account.h</span><br><span class="line">                        <span class="attribute">ACCOUNT_LIBRARY_FILE</span>=$&lt;TARGET_FILE:account&gt;</span><br><span class="line">    <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/account/test.py</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>第11章中，将讨论如何创建一个可以用<code>pip</code>安装的Python包，其中头文件和库文件将安装在定义良好的位置，这样就不必定义任何使用Python模块的环境变量。</p>
<p>讨论了Python方面的接口之后，现在看下C的接口。<code>account.h</code>内容为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">account_context</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">account_context</span> <span class="title">account_context_t</span>;</span></span><br><span class="line"></span><br><span class="line">ACCOUNT_API</span><br><span class="line"><span class="keyword">account_context_t</span> *account_new();</span><br><span class="line"></span><br><span class="line">ACCOUNT_API</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">account_free</span><span class="params">(<span class="keyword">account_context_t</span> *context)</span></span>;</span><br><span class="line"></span><br><span class="line">ACCOUNT_API</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">account_deposit</span><span class="params">(<span class="keyword">account_context_t</span> *context, <span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line"></span><br><span class="line">ACCOUNT_API</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">account_withdraw</span><span class="params">(<span class="keyword">account_context_t</span> *context, <span class="keyword">const</span> <span class="keyword">double</span> amount)</span></span>;</span><br><span class="line"></span><br><span class="line">ACCOUNT_API</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">account_get_balance</span><span class="params">(<span class="keyword">const</span> <span class="keyword">account_context_t</span> *context)</span></span>;</span><br></pre></td></tr></table></figure>
<p>黑盒句柄<code>account_context</code>会保存对象的状态。<code>ACCOUNT_API</code>定义在<code>account_export.h</code>中，由<code>account/interface/CMakeLists.txt</code>生成：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">GenerateExportHeader</span>)</span><br><span class="line">generate_export_header(<span class="name">account</span></span><br><span class="line">  BASE_NAME account</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><code>account_export.h</code>头文件定义了接口函数的可见性，并确保这是以一种可移植的方式完成的，实现可以在<code>cpp_implementation.cpp</code>中找到。它包含<code>is_initialized</code>布尔变量，可以检查这个布尔值确保API函数按照预期的顺序调用：上下文在创建之前或释放之后都不应该被访问。</p>
<h2 id="更多信息-4"><a href="#更多信息-4" class="headerlink" title="更多信息"></a>更多信息</h2><p>设计Python-C接口时，必须仔细考虑在哪一端分配数组：数组可以在Python端分配并传递给C(++)实现，也可以在返回指针的C(++)实现上分配。后一种方法适用于缓冲区大小事先未知的情况。但返回到分配给C(++)端的数组指针可能会有问题，因为这可能导致Python垃圾收集导致内存泄漏，而Python垃圾收集不会“查看”分配给它的数组。我们建议设计C API，使数组可以在外部分配并传递给C实现。然后，可以在<code>__init__.py</code>中分配这些数组，如下例所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> cffi <span class="keyword">import</span> FFI</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">_ffi = FFI()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_array</span><span class="params">(context, array_len)</span>:</span></span><br><span class="line">  <span class="comment"># create numpy array</span></span><br><span class="line">  array_np = np.zeros(array_len, dtype=np.float64)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># cast a pointer to its data</span></span><br><span class="line">  array_p = _ffi.cast(<span class="string">"double *"</span>, array_np.ctypes.data)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># pass the pointer</span></span><br><span class="line">  _lib.mylib_myfunction(context, array_len, array_p)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># return the array as a list</span></span><br><span class="line">  <span class="keyword">return</span> array_np.tolist()</span><br></pre></td></tr></table></figure>
<p><code>return_array</code>函数返回一个Python列表。因为在Python端完成了所有的分配工作，所以不必担心内存泄漏，可以将清理工作留给垃圾收集。</p>
<p>对于Fortran示例，读者可以参考以下Git库:<a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter09/recipe06/Fortran-example" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter09/recipe06/Fortran-example</a> 。与C++实现的主要区别在于，account库是由Fortran 90源文件编译而成的，我们在<code>account/CMakeLists.txt</code>中使用了Fortran 90源文件:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_library(<span class="name">account</span></span><br><span class="line">  SHARED</span><br><span class="line">  	implementation/fortran_implementation.f90</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>上下文保存在用户定义的类型中:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> :: account</span><br><span class="line">  <span class="keyword">private</span></span><br><span class="line">  <span class="keyword">real</span>(<span class="keyword">c_double</span>) :: balance</span><br><span class="line">  <span class="keyword">logical</span> :: is_initialized = .false.</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">type</span></span><br></pre></td></tr></table></figure>
<p>Fortran实现可以使用<code>iso_c_binding</code>模块解析<code>account.h</code>中定义的符号和方法:</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> account_implementation</span><br><span class="line"></span><br><span class="line">  <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_double</span>, <span class="keyword">c_ptr</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> account_new</span><br><span class="line">  <span class="keyword">public</span> account_free</span><br><span class="line">  <span class="keyword">public</span> account_deposit</span><br><span class="line">  <span class="keyword">public</span> account_withdraw</span><br><span class="line">  <span class="keyword">public</span> account_get_balance</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> :: account</span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">c_double</span>) :: balance</span><br><span class="line">    <span class="keyword">logical</span> :: is_initialized = .false.</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span>(<span class="keyword">c_ptr</span>) <span class="function"><span class="keyword">function</span></span> account_new() <span class="keyword">bind</span> (c)</span><br><span class="line">    <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_loc</span></span><br><span class="line">    <span class="keyword">type</span>(account), <span class="keyword">pointer</span> :: f_context</span><br><span class="line">    <span class="keyword">type</span>(<span class="keyword">c_ptr</span>) :: context</span><br><span class="line"></span><br><span class="line">    <span class="built_in">allocate</span>(f_context)</span><br><span class="line">    context = <span class="keyword">c_loc</span>(f_context)</span><br><span class="line">    account_new = context</span><br><span class="line">    f_context%balance = <span class="number">0.0d0</span></span><br><span class="line">    f_context%is_initialized = .true.</span><br><span class="line">  <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">subroutine</span></span> account_free(context) <span class="keyword">bind</span> (c)</span><br><span class="line">    <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_f_pointer</span></span><br><span class="line">    <span class="keyword">type</span>(<span class="keyword">c_ptr</span>), <span class="keyword">value</span> :: context</span><br><span class="line">    <span class="keyword">type</span>(account), <span class="keyword">pointer</span> :: f_context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">call</span> <span class="keyword">c_f_pointer</span>(context, f_context)</span><br><span class="line">    <span class="keyword">call</span> check_valid_context(f_context)</span><br><span class="line">    f_context%balance = <span class="number">0.0d0</span></span><br><span class="line">    f_context%is_initialized = .false.</span><br><span class="line">    <span class="built_in">deallocate</span>(f_context)</span><br><span class="line">  <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">subroutine</span></span> check_valid_context(f_context)</span><br><span class="line">    <span class="keyword">type</span>(account), <span class="keyword">pointer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: f_context</span><br><span class="line">    <span class="keyword">if</span> (.not. <span class="built_in">associated</span>(f_context)) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span> *, <span class="string">'ERROR: context is not associated'</span></span><br><span class="line">        <span class="keyword">stop</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">    <span class="keyword">if</span> (.not. f_context%is_initialized) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">print</span> *, <span class="string">'ERROR: context is not initialized'</span></span><br><span class="line">        <span class="keyword">stop</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">if</span></span><br><span class="line">  <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">subroutine</span></span> account_withdraw(context, amount) <span class="keyword">bind</span> (c)</span><br><span class="line">  <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_f_pointer</span></span><br><span class="line">  <span class="keyword">type</span>(<span class="keyword">c_ptr</span>), <span class="keyword">value</span> :: context</span><br><span class="line">  <span class="keyword">real</span>(<span class="keyword">c_double</span>), <span class="keyword">value</span> :: amount</span><br><span class="line">  <span class="keyword">type</span>(account), <span class="keyword">pointer</span> :: f_context</span><br><span class="line"></span><br><span class="line">  <span class="keyword">call</span> <span class="keyword">c_f_pointer</span>(context, f_context)</span><br><span class="line">  <span class="keyword">call</span> check_valid_context(f_context)</span><br><span class="line">  f_context%balance = f_context%balance - amount</span><br><span class="line">  <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">subroutine</span></span> account_deposit(context, amount) <span class="keyword">bind</span> (c)</span><br><span class="line">    <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_f_pointer</span></span><br><span class="line">    <span class="keyword">type</span>(<span class="keyword">c_ptr</span>), <span class="keyword">value</span> :: context</span><br><span class="line">    <span class="keyword">real</span>(<span class="keyword">c_double</span>), <span class="keyword">value</span> :: amount</span><br><span class="line">    <span class="keyword">type</span>(account), <span class="keyword">pointer</span> :: f_context</span><br><span class="line"></span><br><span class="line">    <span class="keyword">call</span> <span class="keyword">c_f_pointer</span>(context, f_context)</span><br><span class="line">    <span class="keyword">call</span> check_valid_context(f_context)</span><br><span class="line">    f_context%balance = f_context%balance + amount</span><br><span class="line">  <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">real</span>(<span class="keyword">c_double</span>) <span class="function"><span class="keyword">function</span></span> account_get_balance(context) <span class="keyword">bind</span> (c)</span><br><span class="line">    <span class="keyword">use</span>, <span class="keyword">intrinsic</span> :: <span class="keyword">iso_c_binding</span>, <span class="keyword">only</span>: <span class="keyword">c_f_pointer</span></span><br><span class="line">    <span class="keyword">type</span>(<span class="keyword">c_ptr</span>), <span class="keyword">value</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>) :: context</span><br><span class="line">    <span class="keyword">type</span>(account), <span class="keyword">pointer</span> :: f_context</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">call</span> <span class="keyword">c_f_pointer</span>(context, f_context)</span><br><span class="line">    <span class="keyword">call</span> check_valid_context(f_context)</span><br><span class="line">    account_get_balance = f_context%balance</span><br><span class="line">  <span class="keyword">end</span> <span class="function"><span class="keyword">function</span></span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">module</span></span><br></pre></td></tr></table></figure>
<p>这个示例和解决方案的灵感来自Armin Ronacher的帖子“Beautiful Native Libraries”： <a href="http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/" target="_blank" rel="noopener">http://lucumr.pocoo.org/2013/8/18/beautiful-native-libraries/</a></p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2021/03/100661.html" class="pre-post btn btn-default" title='CMake 完整使用教程 之十一 编写安装程序'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之十一 编写安装程序</span>
        </a>
    
    
        <a href="/archives/2021/03/100659.html" class="next-post btn btn-default" title='CMake 完整使用教程 之九 超级构建模式'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之九 超级构建模式</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#9-1-使用C-C-库构建Fortran项目"><span class="toc-text">9.1 使用C/C++库构建Fortran项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-2-使用Fortran库构建C-C-项目"><span class="toc-text">9.2 使用Fortran库构建C/C++项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-1"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-1"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-1"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3-使用Cython构建C-和Python项目"><span class="toc-text">9.3 使用Cython构建C++和Python项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-2"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-2"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-2"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-1"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-4-使用Boost-Python构建C-和Python项目"><span class="toc-text">9.4 使用Boost.Python构建C++和Python项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-3"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-3"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-3"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-2"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-5-使用pybind11构建C-和Python项目"><span class="toc-text">9.5 使用pybind11构建C++和Python项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-4"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-4"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-4"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-3"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-6-使用Python-CFFI混合C，C-，Fortran和Python"><span class="toc-text">9.6 使用Python CFFI混合C，C++，Fortran和Python</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-5"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-5"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-5"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-4"><span class="toc-text">更多信息</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2024&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>