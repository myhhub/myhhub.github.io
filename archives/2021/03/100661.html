<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="c++,cmake,qt">


    <meta name="description" content="本章主要内容：

安装项目
生成输出头文件
输出目标
安装超级构建

前几章中，我们展示了如何使用CMake配置、构建和测试项目。安装项目是很重要的一部分，本章将演示如何实现这一点。
我们将指导...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>CMake 完整使用教程 之十一 编写安装程序 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="CMake 完整使用教程 之十一 编写安装程序">
            
	            CMake 完整使用教程 之十一 编写安装程序
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/c/">c++</a> <a class="tag-link" href="/tags/cmake/">cmake</a> <a class="tag-link" href="/tags/qt/">qt</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2021/03/29</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1060</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>本章主要内容：</p>
<ul>
<li>安装项目</li>
<li>生成输出头文件</li>
<li>输出目标</li>
<li>安装超级构建</li>
</ul>
<p>前几章中，我们展示了如何使用CMake配置、构建和测试项目。安装项目是很重要的一部分，本章将演示如何实现这一点。</p>
<p>我们将指导完成各个步骤，直到完成安装一个简单的C++项目：从项目中构建的文件，并复制到正确的目录，确保其他项目使用CMake时可以找到该工程的输出目标。本章中的4个示例将建立在第1章第3节的示例基础上。之前，我们试图构建一个非常简单的库，并将其链接到一个可执行文件中。我们还展示了如何使用相同的源文件构建静态库和动态库。本章中，我们将会讨论安装时所发生的事情。</p>
<h1 id="10-1-安装项目"><a href="#10-1-安装项目" class="headerlink" title="10.1 安装项目"></a>10.1 安装项目</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-01</a> 中找到，其中有一个C++示例和一个Fortran示例。该示例在CMake 3.6版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>第一个示例中，将介绍我们的小项目和一些基本概念，这些概念也将在后面的示例中使用。安装文件、库和可执行文件是一项非常基础的任务，但是也可能会带来一些缺陷。我们将带您了解这些问题，并展示如何使用CMake有效地避开这些缺陷。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>第1章第3节的示例，几乎复用：只添加对UUID库的依赖。这个依赖是有条件的，如果没有找到UUID库，我们将通过预处理程序排除使用UUID库的代码。项目布局如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── src</span><br><span class="line">│    ├── CMakeLists.txt</span><br><span class="line">│    ├── hello-world.cpp</span><br><span class="line">│    ├── Message.cpp</span><br><span class="line">│    └── Message.hpp</span><br><span class="line">└── tests</span><br><span class="line">    └── CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>我们已经看到，有三个<code>CMakeLists.txt</code>，一个是主<code>CMakeLists.txt</code>，另一个是位于<code>src</code>目录下的，还有一个是位于<code>test</code>目录下的。</p>
<p><code>Message.hpp</code>头文件包含以下内容:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iosfwd&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Message(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;m) : message_(m) &#123;&#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, Message &amp;obj)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.printObject(os);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> message_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">printObject</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getUUID</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>Message.cpp</code>中有相应的实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Message.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_UUID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;uuid/uuid.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="built_in">std</span>::ostream &amp;Message::printObject(<span class="built_in">std</span>::ostream &amp;os)</span><br><span class="line">&#123;</span><br><span class="line">  os &lt;&lt; <span class="string">"This is my very nice message: "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  os &lt;&lt; message_ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  os &lt;&lt; <span class="string">"...and here is its UUID: "</span> &lt;&lt; getUUID();</span><br><span class="line">  <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_UUID</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getUUID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uuid_t</span> uuid;</span><br><span class="line">  uuid_generate(uuid);</span><br><span class="line">  <span class="keyword">char</span> uuid_str[<span class="number">37</span>];</span><br><span class="line">  uuid_unparse_lower(uuid, uuid_str);</span><br><span class="line">  uuid_clear(uuid);</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">uuid_cxx</span><span class="params">(uuid_str)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> uuid_cxx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getUUID</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Ooooops, no UUID for you!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>最后，示例<code>hello-world.cpp</code>内容如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Message.hpp"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Message <span class="title">say_hello</span><span class="params">(<span class="string">"Hello, CMake World!"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; say_hello &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="function">Message <span class="title">say_goodbye</span><span class="params">(<span class="string">"Goodbye, CMake World"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; say_goodbye &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h2><p>我们先来看一下主<code>CMakeLists.txt</code>:</p>
<ol>
<li><p>声明CMake最低版本，并定义一个C++11项目。请注意，我们已经为我们的项目设置了一个版本，在<code>project</code>中使用<code>VERSION</code>进行指定:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># CMake 3.6 needed for IMPORTED_TARGET option</span></span><br><span class="line"><span class="comment"># to pkg_search_module</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.6</span> FATAL_ERROR)</span><br><span class="line"><span class="keyword">project</span>(recipe-<span class="number">01</span></span><br><span class="line">LANGUAGES CXX</span><br><span class="line">VERSION <span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">)</span><br><span class="line"><span class="comment"># &lt;&lt;&lt; General set up &gt;&gt;&gt;</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户可以通过<code>CMAKE_INSTALL_PREFIX</code>变量定义安装目录。CMake会给这个变量设置一个默认值：Windows上的<code>C:\Program Files</code>和Unix上的<code>/usr/local</code>。我们将会打印安装目录的信息：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"Project will be installed to $&#123;CMAKE_INSTALL_PREFIX&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，我们更喜欢以Release的方式配置项目。用户可以通过<code>CMAKE_BUILD_TYPE</code>设置此变量，从而改变配置类型，我们将检查是否存在这种情况。如果没有，将设置为默认值:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT CMAKE_BUILD_TYPE)</span></span></span><br><span class="line">	set(CMAKE_BUILD_TYPE Release CACHE STRING <span class="string">"Build type"</span> FORCE)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"Build type set to $&#123;CMAKE_BUILD_TYPE&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，告诉CMake在何处构建可执行、静态和动态库目标。便于在用户不打算安装项目的情况下，访问这些构建目标。这里使用标准CMake的<code>GNUInstallDirs.cmake</code>模块。这将确保的项目布局的合理性和可移植性：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">include(GNUInstallDirs)</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然，前面的命令配置了构建目录中输出的位置，但是需要下面的命令来配置可执行程序、库以及安装前缀中包含的文件的位置。它们大致遵循相同的布局，但是我们定义了新的<code>INSTALL_LIBDIR</code>、<code>INSTALL_BINDIR</code>、<code>INSTALL_INCLUDEDIR</code>和<code>INSTALL_CMAKEDIR</code>变量。当然，也可以覆盖这些变量：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Offer the user the choice of overriding the installation directories</span></span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_LIBDIR <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for libraries"</span>)</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_BINDIR <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for executables"</span>)</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_INCLUDEDIR <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for header files"</span>)</span><br><span class="line"><span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> CYGWIN)</span><br><span class="line">	<span class="builtin-name">set</span>(DEF_INSTALL_CMAKEDIR CMake)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="builtin-name">set</span>(DEF_INSTALL_CMAKEDIR share/cmake/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line">endif()</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_CMAKEDIR <span class="variable">$&#123;DEF_INSTALL_CMAKEDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for CMake files"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>报告组件安装的路径:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Report to user</span></span><br><span class="line"><span class="keyword">foreach</span>(p LIB BIN <span class="keyword">INCLUDE</span> CMAKE)</span><br><span class="line">  <span class="keyword">file</span>(TO_NATIVE_PATH <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_$&#123;p&#125;</span>DIR&#125; _path )</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">"Installing $&#123;p&#125; components to $&#123;_path&#125;"</span>)</span><br><span class="line">  <span class="keyword">unset</span>(_path)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>主<code>CMakeLists.txt</code>文件中的最后一个指令添加<code>src</code>子目录，启用测试，并添加<code>tests</code>子目录：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(src)</span></span></span><br><span class="line"><span class="function"><span class="title">enable_testing</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(tests)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在我们继续分析<code>src/CMakeLists.txt</code>，其定义了构建的实际目标：</p>
<ol>
<li><p>我们的项目依赖于UUID库：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Search for pkg-config and UUID</span><br><span class="line">find_package(<span class="name">PkgConfig</span> QUIET)</span><br><span class="line">if(<span class="name">PKG_CONFIG_FOUND</span>)</span><br><span class="line">  pkg_search_module(<span class="name">UUID</span> uuid IMPORTED_TARGET)</span><br><span class="line">  if(<span class="name">TARGET</span> PkgConfig:<span class="symbol">:UUID</span>)</span><br><span class="line">    message(<span class="name">STATUS</span> <span class="string">"Found libuuid"</span>)</span><br><span class="line">    set(<span class="name">UUID_FOUND</span> TRUE)</span><br><span class="line">  endif()</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们希望建立一个动态库，将该目标声明为<code>message-shared</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(message-shared SHARED <span class="string">""</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个目标由<code>target_sources</code>命令指定:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们为目标声明编译时定义和链接库。请注意，所有这些都是<code>PUBLIC</code>，以确保所有依赖的目标将正确继承它们:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  target_compile_definitions(message-shared</span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;UUID_FOUND&#125;&gt;<span class="symbol">:HAVE_UUID&gt;</span></span><br><span class="line">  )</span><br><span class="line">target_link_libraries(message-shared</span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;UUID_FOUND&#125;&gt;<span class="symbol">:PkgConfig</span><span class="symbol">:</span><span class="symbol">:UUID&gt;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后设置目标的附加属性:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PROPERTIES</span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    SOVERSION <span class="variable">$&#123;PROJECT_VERSION_MAJOR&#125;</span></span><br><span class="line">    OUTPUT_NAME <span class="string">"message"</span></span><br><span class="line">    DEBUG_POSTFIX <span class="string">"_d"</span></span><br><span class="line">    PUBLIC_HEADER <span class="string">"Message.hpp"</span></span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    WINDOWS_EXPORT_ALL_SYMBOLS <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，为“Hello, world”程序添加可执行目标:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(hello-world_wDSO hello-world.cpp)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>hello-world_wDSO</code>可执行目标，会链接到动态库：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(hello-world_wDSO</span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="keyword">message</span>-shared</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>src/CMakeLists.txt</code>文件中，还包含安装指令。考虑这些之前，我们需要设置可执行文件的<code>RPATH</code>：</p>
<ol>
<li><p>使用CMake路径操作，我们可以设置<code>message_RPATH</code>变量。这将为GNU/Linux和macOS设置适当的<code>RPATH</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RPATH</span><br><span class="line"><span class="function"><span class="title">file</span><span class="params">(RELATIVE_PATH _rel $&#123;CMAKE_INSTALL_PREFIX&#125;/$&#123;INSTALL_BINDIR&#125; $&#123;CMAKE_INSTALL_PREFIX&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(APPLE)</span></span></span><br><span class="line">	set(_rpath <span class="string">"@loader_path/$&#123;_rel&#125;"</span>)</span><br><span class="line"><span class="function"><span class="title">else</span><span class="params">()</span></span></span><br><span class="line">	set(_rpath <span class="string">"\$ORIGIN/$&#123;_rel&#125;"</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">file</span><span class="params">(TO_NATIVE_PATH <span class="string">"$&#123;_rpath&#125;/$&#123;INSTALL_LIBDIR&#125;"</span> message_RPATH)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，可以使用这个变量来设置可执行目标<code>hello-world_wDSO</code>的<code>RPATH</code>(通过目标属性实现)。我们也可以设置额外的属性，稍后会对此进行更多的讨论:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(hello-world_wDSO</span><br><span class="line">  PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">"$&#123;message_RPATH&#125;"</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>终于可以安装库、头文件和可执行文件了！使用CMake提供的<code>install</code>命令来指定安装位置。注意，路径是相对的，我们将在后续进一步讨论这一点:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">install(</span><br><span class="line">  TARGETS</span><br><span class="line">    message-shared</span><br><span class="line">    hello-world_wDSO</span><br><span class="line">  ARCHIVE</span><br><span class="line">    DESTINATION $&#123;INSTALL_LIBDIR&#125;</span><br><span class="line">    COMPONENT <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">  RUNTIME</span><br><span class="line">    DESTINATION $&#123;INSTALL_BINDIR&#125;</span><br><span class="line">    COMPONENT bin</span><br><span class="line">  LIBRARY</span><br><span class="line">    DESTINATION $&#123;INSTALL_LIBDIR&#125;</span><br><span class="line">    COMPONENT <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">  PUBLIC_HEADER</span><br><span class="line">    DESTINATION $&#123;INSTALL_INCLUDEDIR&#125;/message</span><br><span class="line">    COMPONENT dev</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>tests</code>目录中的<code>CMakeLists.txt</code>文件包含简单的指令，以确保“Hello, World”可执行文件能够正确运行：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add_test(</span><br><span class="line">  NAME test_shared</span><br><span class="line">  COMMAND $&lt;TARGET_FILE<span class="symbol">:hello-world_wDSO&gt;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>现在让我们配置、构建和安装项目，并查看结果。添加安装指令时，CMake就会生成一个名为<code>install</code>的新目标，该目标将运行安装规则:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -G<span class="string">"Unix Makefiles"</span> -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/Software/recipe-01</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build . --target install</span></span><br></pre></td></tr></table></figure>
<p>GNU/Linux构建目录的内容如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">build</span><br><span class="line">├── bin</span><br><span class="line">│    └── hello-world_wDSO</span><br><span class="line">├── CMakeCache.txt</span><br><span class="line">├── CMakeFiles</span><br><span class="line">├── cmake_install.cmake</span><br><span class="line">├── CTestTestfile.cmake</span><br><span class="line">├── install_manifest.txt</span><br><span class="line">├── lib64</span><br><span class="line">│    ├── libmessage<span class="selector-class">.so</span> -&gt; libmessage<span class="selector-class">.so</span>.<span class="number">1</span></span><br><span class="line">│    └── libmessage<span class="selector-class">.so</span>.<span class="number">1</span></span><br><span class="line">├── Makefile</span><br><span class="line">├── src</span><br><span class="line">├── Testing</span><br><span class="line">└── tests</span><br></pre></td></tr></table></figure>
<p>另一方面，在安装位置，可以找到如下的目录结构:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/Software/recipe-<span class="number">01</span>/</span><br><span class="line">├── bin</span><br><span class="line">│    └── hello-world_wDSO</span><br><span class="line">├── include</span><br><span class="line">│    └── message</span><br><span class="line">│        └── Message.hpp</span><br><span class="line">└── lib64</span><br><span class="line">    ├── libmessage<span class="selector-class">.so</span> -&gt; libmessage<span class="selector-class">.so</span>.<span class="number">1</span></span><br><span class="line">    └── libmessage<span class="selector-class">.so</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这意味着安装指令中给出的位置，是相对于用户给定的<code>CMAKE_INSTALL_PREFIX</code>路径。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>这个示例有三个要点我们需要更详细地讨论：</p>
<ul>
<li>使用<code>GNUInstallDirs.cmake</code>定义目标安装的标准位置</li>
<li>在动态库和可执行目标上设置的属性，特别是<code>RPATH</code>的处理</li>
<li>安装指令</li>
</ul>
<p>###安装到标准位置</p>
<p>对于项目的安装来说，什么是好的布局呢？如果只有自己使用该项目，那就无所谓好或坏的布局。然而，一旦向外部发布产品，和他人共用该项目，就应该在安装项目时提供一个合理的布局。幸运的是，我们可以遵循一些标准，CMake可以帮助我们做到这一点。实际上，<code>GNUInstallDirs.cmake</code>模块所做的就是定义这样一组变量，这些变量是安装不同类型文件的子目录的名称。在例子中，使用了以下内容:</p>
<ul>
<li><strong>*CMAKE_INSTALL_BINDIR</strong>：这将用于定义用户可执行文件所在的子目录，即所选安装目录下的<code>bin</code>目录。</li>
<li><strong>CMAKE_INSTALL_LIBDIR</strong>：这将扩展到目标代码库(即静态库和动态库)所在的子目录。在64位系统上，它是<code>lib64</code>，而在32位系统上，它只是<code>lib</code>。</li>
<li><strong>CMAKE_INSTALL_INCLUDEDIR</strong>：最后，我们使用这个变量为C头文件获取正确的子目录，该变量为<code>include</code>。</li>
</ul>
<p>然而，用户可能希望覆盖这些选项。我们允许在主<code>CMakeLists.txt</code>文件中使用以下方式覆盖选项:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Offer the user the choice</span></span><br><span class="line">of overriding the installation directories</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_LIBDIR <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span> CACHE PATH</span><br><span class="line"><span class="string">"Installation directory for libraries"</span>)</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_BINDIR <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> CACHE PATH</span><br><span class="line"><span class="string">"Installation directory for executables"</span>)</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_INCLUDEDIR <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span> CACHE</span><br><span class="line">PATH <span class="string">"Installation directory for header files"</span>)</span><br></pre></td></tr></table></figure>
<p>这重新定义了在项目中使用的<code>INSTALL_BINDIR</code>、<code>INSTALL_LIBDIR</code>和<code>INSTALL_INCLUDEDIR</code>变量。我们还定义了<code>INSTALL_CMAKEDIR</code>变量，但它所扮演的角色将在接下来的几个示例中详细讨论。</p>
<p><strong>TIPS</strong>:<em><code>GNUInstallDirs.cmake</code>模块定义了额外的变量，这些变量将有助于，将已安装的文件放置到所选安装前缀的子目录中。请参考CMake在线文档:<a href="https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.6/module/GNUInstallDirs.html</a></em></p>
<h3 id="目标属性和RPATH处理"><a href="#目标属性和RPATH处理" class="headerlink" title="目标属性和RPATH处理"></a>目标属性和RPATH处理</h3><p>让我们更仔细地看看在动态库目标上设置的属性，需要设置以下内容:</p>
<ul>
<li><code>POSITION_INDEPENDENT_CODE 1</code>：设置生成位置无关代码所需的编译器标志。有关更多信息，请参考<a href="https://en.wikipedia.org/wiki/position-independentent_code" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/position-independentent_code</a></li>
<li><code>SOVERSION ${PROJECT_VERSION_MAJOR}</code> : 这是动态库提供的应用程序编程接口(API)版本。在设置语义版本之后，将其设置为与项目的主版本一致。CMake目标也有一个版本属性，可以用来指定目标的构建版本。注意，<code>SOVERSION</code>和<code>VERSION</code>有所不同：随着时间的推移，提供相同API的多个构建版本。本例中，我们不关心这种的粒度控制：仅使用<code>SOVERSION</code>属性设置API版本就足够了，CMake将为我们将<code>VERSION</code>设置为相同的值。相关详细信息，请参考官方文档:<a href="https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/latest/prop_tgt/SOVERSION.html</a></li>
<li><code>OUTPUT_NAME &quot;message&quot;</code>：这告诉CMake库的名称<code>message</code>，而不是目标<code>message-shared</code>的名称，<code>libmessage.so.1</code>将在构建时生成。从前面给出的构建目录和安装目录的也可以看出，<code>libmessage.so</code>的符号链接也将生成。</li>
<li><code>DEBUG_POSTFIX &quot;_d&quot;</code>：这告诉CMake，如果我们以Debug配置构建项目，则将<code>_d</code>后缀添加到生成的动态库。</li>
<li><code>PUBLIC_HEADER &quot;Message.hpp&quot;</code>：我们使用这个属性来设置头文件列表(本例中只有一个头文件)，声明提供的API函数。这主要用于macOS上的动态库目标，也可以用于其他操作系统和目标。有关详细信息，请参见官方文档:<a href="https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.6/prop_tgt/PUBLIC_HEADER.html</a></li>
<li><code>MACOSX_RPATH ON</code>：这将动态库的<code>install_name</code>部分(目录)设置为macOS上的<code>@rpath</code>。</li>
<li><code>WINDOWS_EXPORT_ALL_SYMBOLS ON</code>：这将强制在Windows上编译以导出所有符号。注意，这通常不是一个好的方式，我们将在第2节中展示如何生成导出头文件，以及如何在不同的平台上保证符号的可见性。</li>
</ul>
<p>现在讨论一下<code>RPATH</code>。我们将<code>hello-world_wDSO</code>可执行文件链接到<code>libmessage.so.1</code>，这意味着在执行时，将加载动态库。因此，有关库位置的信息需要在某个地方进行编码，以便加载程序能够成功地完成其工作。库的定位有两种方法:</p>
<ul>
<li>通过设置环境变量通知链接器:<ul>
<li>GNU/Linux上，这需要将路径附加到<code>LD_LIBRARY_PATH</code>环境变量中。注意，这很可能会污染系统中所有应用程序的链接器路径，并可能导致符号冲突( <a href="https://gms.tf/ld_library_path-considered-harmful.htm" target="_blank" rel="noopener">https://gms.tf/ld_library_path-considered-harmful.htm</a> )。</li>
<li>macOS上，可以设置<code>DYLD_LIBRARY_PATH</code>变量。这与GNU/Linux上的<code>LD_LIBRARY_PATH</code>有相同的问题，可以通过使用<code>DYLD_FALLBACK_LIBRARY_PATH</code>变量来(部分的)改善这种情况。请看下面的链接，获取相关例子: <a href="https://stackoverflow.com/a/3172515/2528668" target="_blank" rel="noopener">https://stackoverflow.com/a/3172515/2528668</a></li>
</ul>
</li>
<li>可被编码到可执行文件中，使用<code>RPATH</code>可以设置可执行文件的运行时搜索路径</li>
</ul>
<p>后一种方法更健壮。但是，设置动态对象的<code>RPATH</code>时，应该选择哪个路径？我们需要确保可执行文件总是找到正确的动态库，不管它是在构建树中运行还是在安装树中运行。这需要通过设置<code>hello-world_wDSO</code>目标的<code>RPATH</code>相关属性来实现的，通过<code>$ORIGIN</code>(在GNU/Linux上)或<code>@loader_path</code>(在macOS上)变量来查找与可执行文件本身位置相关的路径:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prepare RPATH</span></span><br><span class="line">file(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">	<span class="builtin-name">set</span>(_rpath <span class="string">"@loader_path/<span class="variable">$&#123;_rel&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="builtin-name">set</span>(_rpath <span class="string">"\$ORIGIN/<span class="variable">$&#123;_rel&#125;</span>"</span>)</span><br><span class="line">endif()</span><br><span class="line">file(TO_NATIVE_PATH <span class="string">"<span class="variable">$&#123;_rpath&#125;</span>/<span class="variable">$&#123;INSTALL_LIBDIR&#125;</span>"</span> message_RPATH)</span><br></pre></td></tr></table></figure>
<p>当设置了<code>message_RPATH</code>变量，目标属性将完成剩下的工作:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(hello-world_wDSO</span><br><span class="line">    PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">"$&#123;message_RPATH&#125;"</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>让我们详细研究一下这个命令：</p>
<ul>
<li><code>SKIP_BUILD_RPATH OFF</code>：告诉CMake生成适当的<code>RPATH</code>，以便能够在构建树中运行可执行文件。</li>
<li><code>UILD_WITH_INSTALL_RPATH OFF</code>：关闭生成可执行目标，使其<code>RPATH</code>调整为与安装树的<code>RPATH</code>相同。在构建树中不运行可执行文件。</li>
<li><code>INSTALL_RPATH &quot;${message_RPATH}&quot;</code>：将已安装的可执行目标的<code>RPATH</code>设置为先前的路径。</li>
<li><code>INSTALL_RPATH_USE_LINK_PATH ON</code>：告诉CMake将链接器搜索路径附加到可执行文件的<code>RPATH</code>中。</li>
</ul>
<p><strong>NOTE</strong>:<em>加载器在Unix系统上如何工作的更多信息，可参见:<a href="http://longwei.github.io/rpath_origin/" target="_blank" rel="noopener">http://longwei.github.io/rpath_origin/</a></em></p>
<h3 id="安装指令"><a href="#安装指令" class="headerlink" title="安装指令"></a>安装指令</h3><p>最后，看一下安装指令。我们需要安装一个可执行文件、一个库和一个头文件。可执行文件和库是构建目标，因此我们使用安装命令的<code>TARGETS</code>选项。可以同时设置多个目标的安装规则：CMake知道它们是什么类型的目标，无论其是可执行程序库、动态库，还是静态库:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS</span><br><span class="line">    <span class="keyword">message</span>-shared</span><br><span class="line">    hello-world_wDSO</span><br></pre></td></tr></table></figure>
<p>可执行文件将安装在<code>RUNTIME DESTINATION</code>，将其设置为<code>${INSTALL_BINDIR}</code>。动态库安装到<code>LIBRARY_DESTINATION</code>，将其设置为<code>${INSTALL_LIBDIR}</code>。静态库将安装到<code>ARCHIVE DESTINATION</code>，将其设置为<code>${INSTALL_LIBDIR}</code>:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ARCHIVE</span><br><span class="line">  DESTINATION $&#123;INSTALL_LIBDIR&#125;</span><br><span class="line">  COMPONENT <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">RUNTIME</span><br><span class="line">  DESTINATION $&#123;INSTALL_BINDIR&#125;</span><br><span class="line">  COMPONENT bin</span><br><span class="line">LIBRARY</span><br><span class="line">  DESTINATION $&#123;INSTALL_LIBDIR&#125;</span><br><span class="line">  COMPONENT <span class="class"><span class="keyword">lib</span></span></span><br></pre></td></tr></table></figure>
<p>注意，这里不仅指定了<code>DESTINATION</code>，还指定了<code>COMPONENT</code>。使用<code>cmake --build . --target install</code>安装命令，所有组件会按预期安装完毕。然而，有时只安装其中一些可用的。这就是<code>COMPONENT</code>关键字帮助我们做的事情。例如，当只要求安装库，我们可以执行以下步骤:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake -D COMPONENT=<span class="class"><span class="keyword">lib</span> -<span class="title">P</span> <span class="title">cmake_install</span>.<span class="title">cmake</span></span></span><br></pre></td></tr></table></figure>
<p>自从<code>Message.hpp</code>头文件设置为项目的公共头文件，我们可以使用<code>PUBLIC_HEADER</code>关键字将其与其他目标安装到选择的目的地:<code>${INSTALL_INCLUDEDIR}/message</code>。库用户现在可以包含头文件：<code>#include &lt;message/Message.hpp&gt;</code>，这需要在编译时，使用<code>-I</code>选项将正确的头文件查找路径位置传递给编译器。</p>
<p>安装指令中的各种目标地址会被解释为相对路径，除非使用绝对路径。但是相对于哪里呢？根据不同的安装工具而不同，而CMake可以去计算目标地址的绝对路径。当使用<code>cmake --build . --target install</code>，路径将相对于<code>CMAKE_INSTALL_PREFIX</code>计算。但当使用CPack时，绝对路径将相对于<code>CPACK_PACKAGING_INSTALL_PREFIX</code>计算。CPack的用法将在第11章中介绍。</p>
<p><strong>NOTE</strong>:<em>Unix Makefile和Ninja生成器还提供了另一种机制:<code>DESTDIR</code>。可以在<code>DESTDIR</code>指定的目录下重新定位整个安装树。也就是说，<code>env DESTDIR=/tmp/stage cmake --build . --target install</code>将安装相对于<code>CMAKE_INSTALL_PREFIX</code>和<code>/tmp/stage</code>目录。可以在这里阅读更多信息:<a href="https://www.gnu.org/prep/standards/html_node/DESTDIR.html" target="_blank" rel="noopener">https://www.gnu.org/prep/standards/html_node/DESTDIR.html</a></em></p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>正确设置<code>RPATH</code>可能相当麻烦，但这对于用户来说无法避免。默认情况下，CMake设置可执行程序的<code>RPATH</code>，假设它们将从构建树运行。但是，安装之后<code>RPATH</code>被清除，当用户想要运行<code>hello-world_wDSO</code>时，就会出现问题。使用Linux上的<code>ldd</code>工具，我们可以检查构建树中的<code>hello-world_wDSO</code>可执行文件，运行<code>ldd hello-world_wDSO</code>将得到以下结果:</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libmessage.so<span class="number">.1</span> =&gt; /home/user/cmake-cookbook/chapter<span class="number">-10</span>/recipe<span class="number">-01</span>/cxx-example/build/lib64/libmessage.so<span class="number">.1</span>(<span class="number">0x00007f7a92e44000</span>)</span><br></pre></td></tr></table></figure>
<p>在安装目录中运行<code>ldd hello-world_wDSO</code>将得到以下结果:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">libmessage.so.1</span> =&gt; Not found</span><br></pre></td></tr></table></figure>
<p>这显然是不行的。但是，总是硬编码<code>RPATH</code>来指向构建树或安装目录也是错误的：这两个位置中的任何一个都可能被删除，从而导致可执行文件的损坏。这里给出的解决方案为构建树和安装目录中的可执行文件设置了不同的<code>RPATH</code>，因此它总是指向“有意义”的位置；也就是说，尽可能接近可执行文件。在构建树中运行<code>ldd</code>显示相同的输出:</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libmessage.so<span class="number">.1</span> =&gt; <span class="meta-keyword">/home/</span>roberto/Workspace<span class="meta-keyword">/robertodr/</span>cmake-</span><br><span class="line">cookbook<span class="meta-keyword">/chapter-10/</span>recipe<span class="number">-01</span><span class="meta-keyword">/cxx-example/</span>build<span class="meta-keyword">/lib64/</span>libmessage.so<span class="number">.1</span></span><br><span class="line">(<span class="number">0x00007f7a92e44000</span>)</span><br></pre></td></tr></table></figure>
<p>另外，在安装目录下，我们得到:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">libmessage.so.<span class="number">1</span> =&gt; <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>ch10r01<span class="regexp">/bin/</span>..<span class="regexp">/lib64/</span>libmessage.so.<span class="number">1</span> (<span class="number">0</span>x00007fbd2a725000)</span><br></pre></td></tr></table></figure>
<p>我们使用了带有目标参数的CMake安装命令，因为我们需要安装构建目标。而该命令还有另外4个参数:</p>
<ul>
<li><strong>FILES</strong>和<strong>PROGRAMS</strong>，分别用于安装文件或程序。安装后，并设置安装文件适当的权限。对于文件，对所有者具有读和写权限，对组以及其他用户和组具有读权限。对于程序，将授予执行权限。注意，<code>PROGRAMS</code>要与非构建目标的可执行程序一起使用。参见: <a href="https://cmake.org/cmake/help/v3.6/command/install.html#installing-files" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.6/command/install.html#installing-files</a></li>
<li><strong>DIRECTORY</strong>，用于安装目录。当只给出一个目录名时，它通常被理解为相对于当前源目录。可以对目录的安装粒度进行控制。请参考在线文档： <a href="https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.6/command/install.html#installing-directories</a></li>
<li><strong>SCRIPT</strong>，可以使用它在CMake脚本中定义自定义安装规则。参见： <a href="https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.6/command/install.html#custom-installation-logic</a></li>
<li><strong>EXPORT</strong>，我们将此参数的讨论推迟到第3节，该参数用于导出目标。</li>
</ul>
<h1 id="10-2-生成输出头文件"><a href="#10-2-生成输出头文件" class="headerlink" title="10.2 生成输出头文件"></a>10.2 生成输出头文件</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-02" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-02</a> 中找到，其中有一个C++示例。该示例在CMake 3.6版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>设想一下，当我们的小型库非常受欢迎时，许多人都在使用它。然而，一些客户希望在安装时使用静态库，而另一些客户也注意到所有符号在动态库中都是可见的。最佳方式是规定动态库只公开最小的符号，从而限制代码中定义的对象和函数对外的可见性。我们希望在默认情况下，动态库定义的所有符号都对外隐藏。这将使得项目的贡献者，能够清楚地划分库和外部代码之间的接口，因为他们必须显式地标记所有要在项目外部使用的符号。因此，我们需要完成以下工作：</p>
<ul>
<li>使用同一组源文件构建动态库和静态库</li>
<li>确保正确分隔动态库中符号的可见性</li>
</ul>
<p>第1章第3节中，已经展示了CMake提供了与平台无关的方式实现的功能。但是，没有处理符号可见性的问题。我们将用当前的配方重新讨论这两点。</p>
<h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们仍将使用与前一个示例中基本相同的代码，但是我们需要修改<code>src/CMakeLists.txt</code>和<code>Message.hpp</code>头文件。后者将包括新的、自动生成的头文件<code>messageExport.h</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"messageExport.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">message_EXPORT</span> <span class="title">Message</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Message(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;m) : message_(m) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;os, Message &amp;obj)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.printObject(os);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> message_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">ostream &amp;<span class="title">printObject</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">getUUID</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>Message</code>类的声明中引入了<code>message_EXPORT</code>预处理器指令，这个指令将让编译器生成对库的用户可见的符号。</p>
<h2 id="具体实施-1"><a href="#具体实施-1" class="headerlink" title="具体实施"></a>具体实施</h2><p>除了项目的名称外，主<code>CMakeLists.txt</code>文件没有改变。首先，看看<code>src</code>子目录中的<code>CMakeLists.txt</code>文件，所有工作实际上都在这里进行。我们将重点展示对之前示例的修改之处:</p>
<ol>
<li><p>为消息传递库声明<code>SHARED</code>库目标及其源。注意，编译定义和链接库没有改变:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-shared SHARED <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_definitions</span>(<span class="keyword">message</span>-shared</span><br><span class="line">	PUBLIC</span><br><span class="line">  	$&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:HAVE_UUID&gt;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:PkgConfig::UUID&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置目标属性。将<code>${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}/messageExport.h</code>头文件添加到公共头列表中，作为<code>PUBLIC_HEADER</code>目标属性的参数。<code>CXX_VISIBILITY_PRESET</code>置和<code>VISIBILITY_INLINES_HIDDEN</code>属性将在下一节中讨论:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PROPERTIES</span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    CXX_VISIBILITY_PRESET hidden</span><br><span class="line">    VISIBILITY_INLINES_HIDDEN <span class="number">1</span></span><br><span class="line">    SOVERSION <span class="variable">$&#123;PROJECT_VERSION_MAJOR&#125;</span></span><br><span class="line">    OUTPUT_NAME <span class="string">"message"</span></span><br><span class="line">    DEBUG_POSTFIX <span class="string">"_d"</span></span><br><span class="line">    PUBLIC_HEADER <span class="string">"Message.hpp;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h"</span></span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>包含<code>GenerateExportHeader.cmake</code>模块并调用<code>generate_export_header</code>函数，这将在构建目录的子目录中生成<code>messageExport.h</code>头文件。我们将稍后会详细讨论这个函数和生成的头文件:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">GenerateExportHeader</span>)</span><br><span class="line">generate_export_header(<span class="name">message-shared</span></span><br><span class="line">  BASE_NAME <span class="string">"message"</span></span><br><span class="line">  EXPORT_MACRO_NAME <span class="string">"message_EXPORT"</span></span><br><span class="line">  EXPORT_FILE_NAME <span class="string">"$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h"</span></span><br><span class="line">  DEPRECATED_MACRO_NAME <span class="string">"message_DEPRECATED"</span></span><br><span class="line">  NO_EXPORT_MACRO_NAME <span class="string">"message_NO_EXPORT"</span></span><br><span class="line">  STATIC_DEFINE <span class="string">"message_STATIC_DEFINE"</span></span><br><span class="line">  NO_DEPRECATED_MACRO_NAME <span class="string">"message_NO_DEPRECATED"</span></span><br><span class="line">  DEFINE_NO_DEPRECATED</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>当要更改符号的可见性(从其默认值-隐藏值)时，都应该包含导出头文件。我们已经在<code>Message.hpp</code>头文件例这样做了，因为想在库中公开一些符号。现在将<code>${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}</code>目录作为<code>message-shared</code>目标的<code>PUBLIC</code>包含目录列出：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在，可以将注意力转向静态库的生成：</p>
<ol>
<li><p>添加一个库目标来生成静态库。将编译与静态库相同的源文件，以获得此动态库目标：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-static STATIC <span class="string">""</span>)</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">message</span>-static</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置编译器定义，包含目录和链接库，就像我们为动态库目标所做的一样。但请注意，我们添加了<code>message_STATIC_DEFINE</code>编译时宏定义，为了确保我们的符号可以适当地暴露:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">target_compile_definitions(message-static</span><br><span class="line">  PUBLIC</span><br><span class="line">  	message_STATIC_DEFINE</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;UUID_FOUND&#125;&gt;<span class="symbol">:HAVE_UUID&gt;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_include_directories(message-static</span><br><span class="line">  	PUBLIC</span><br><span class="line">  	$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_link_libraries(message-static</span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;UUID_FOUND&#125;&gt;<span class="symbol">:PkgConfig</span><span class="symbol">:</span><span class="symbol">:UUID&gt;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>还设置了<code>message-static</code>目标的属性:</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set_target_properties(message-<span class="keyword">static</span></span><br><span class="line">  PROPERTIES</span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    ARCHIVE_OUTPUT_NAME <span class="string">"message"</span></span><br><span class="line">    DEBUG_POSTFIX <span class="string">"_sd"</span></span><br><span class="line">    RELEASE_POSTFIX <span class="string">"_s"</span></span><br><span class="line">    PUBLIC_HEADER <span class="string">"Message.hpp;<span class="subst">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="subst">$&#123;INSTALL_INCLUDEDIR&#125;</span>/messageExport.h"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了链接到消息动态库目标的<code>hello-world_wDSO</code>可执行目标之外，还定义了另一个可执行目标<code>hello-world_wAR</code>，这个链接指向静态库:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">hello-world_wAR</span> hello-world.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(<span class="name">hello-world_wAR</span></span><br><span class="line">	PUBLIC</span><br><span class="line">		message-static</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装指令现在多了<code>message-static</code>和<code>hello-world_wAR</code>目标，其他没有改变:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">install(</span><br><span class="line">  TARGETS</span><br><span class="line">    message-shared</span><br><span class="line">    message-static</span><br><span class="line">    hello-world_wDSO</span><br><span class="line">    hello-world_wAR</span><br><span class="line">  ARCHIVE</span><br><span class="line">    DESTINATION $&#123;INSTALL_LIBDIR&#125;</span><br><span class="line">    COMPONENT <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">  RUNTIME</span><br><span class="line">    DESTINATION $&#123;INSTALL_BINDIR&#125;</span><br><span class="line">    COMPONENT bin</span><br><span class="line">  LIBRARY</span><br><span class="line">    DESTINATION $&#123;INSTALL_LIBDIR&#125;</span><br><span class="line">    COMPONENT <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">  PUBLIC_HEADER</span><br><span class="line">    DESTINATION $&#123;INSTALL_INCLUDEDIR&#125;/message</span><br><span class="line">    COMPONENT dev</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h2><p>此示例演示了，如何设置动态库的符号可见性。最好的方式是在默认情况下隐藏所有符号，显式地只公开那些需要使用的符号。这需要分为两步实现。首先，需要指示编译器隐藏符号。当然，不同的编译器将有不同的可用选项，并且直接在<code>CMakeLists.txt</code>中设置这些选项并不是是跨平台的。CMake通过在动态库目标上设置两个属性，提供了一种健壮的跨平台方法来设置符号的可见性：</p>
<ul>
<li><code>CXX_VISIBILITY_PRESET hidden</code>：这将隐藏所有符号，除非显式地标记了其他符号。当使用GNU编译器时，这将为目标添加<code>-fvisibility=hidden</code>标志。</li>
<li><code>VISIBILITY_INLINES_HIDDEN 1</code>：这将隐藏内联函数的符号。如果使用GNU编译器，这对应于<code>-fvisibility-inlines-hidden</code></li>
</ul>
<p>Windows上，这都是默认行为。实际上，我们需要在前面的示例中通过设置<code>WINDOWS_EXPORT_ALL_SYMBOLS</code>属性为<code>ON</code>来覆盖它。</p>
<p>如何标记可见的符号？这由预处理器决定，因此需要提供相应的预处理宏，这些宏可以扩展到所选平台上，以便编译器能够理解可见性属性。CMake中有现成的<code>GenerateExportHeader.cmake</code>模块。这个模块定义了<code>generate_export_header</code>函数，我们调用它的过程如下：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">include(<span class="name">GenerateExportHeader</span>)</span><br><span class="line">generate_export_header(<span class="name">message-shared</span></span><br><span class="line">  BASE_NAME <span class="string">"message"</span></span><br><span class="line">  EXPORT_MACRO_NAME <span class="string">"message_EXPORT"</span></span><br><span class="line">  EXPORT_FILE_NAME <span class="string">"$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h"</span></span><br><span class="line">  DEPRECATED_MACRO_NAME <span class="string">"message_DEPRECATED"</span></span><br><span class="line">  NO_EXPORT_MACRO_NAME <span class="string">"message_NO_EXPORT"</span></span><br><span class="line">  STATIC_DEFINE <span class="string">"message_STATIC_DEFINE"</span></span><br><span class="line">  NO_DEPRECATED_MACRO_NAME <span class="string">"message_NO_DEPRECATED"</span></span><br><span class="line">  DEFINE_NO_DEPRECATED</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>该函数生成<code>messageExport.h</code>头文件，其中包含预处理器所需的宏。根据<code>EXPORT_FILE_NAME</code>选项的请求，在目录<code>${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}</code>中生成该文件。如果该选项为空，则头文件将在当前二进制目录中生成。这个函数的第一个参数是现有的目标(示例中是<code>message- shared</code>)，函数的基本调用只需要传递现有目标的名称即可。可选参数，用于细粒度的控制所有生成宏，也可以传递：</p>
<ul>
<li>BASE_NAME：设置生成的头文件和宏的名称。</li>
<li>EXPORT_MACRO_NAME：设置导出宏的名称。</li>
<li>EXPORT_FILE_NAME：设置导出头文件的名称。</li>
<li>DEPRECATED_MACRO_NAME：设置弃用宏的名称。这是用来标记将要废弃的代码，如果客户使用该宏定义，编译器将发出一个将要废弃的警告。</li>
<li>NO_EXPORT_MACRO_NAME：设置不导出宏的名字。</li>
<li>STATIC_DEFINE：用于定义宏的名称，以便使用相同源编译静态库时使用。</li>
<li>NO_DEPRECATED_MACRO_NAME：设置宏的名称，在编译时将“将要废弃”的代码排除在外。</li>
<li>DEFINE_NO_DEPRECATED：指示CMake生成预处理器代码，以从编译中排除“将要废弃”的代码。</li>
</ul>
<p>GNU/Linux上，使用GNU编译器，CMake将生成以下<code>messageExport.h</code>头文件:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> message_EXPORT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> message_EXPORT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> message_STATIC_DEFINE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_EXPORT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_NO_EXPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> message_EXPORT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> message_shared_EXPORTS</span></span><br><span class="line"><span class="comment">/* We are building this library */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_EXPORT __attribute__((visibility(<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/* We are using this library */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_EXPORT __attribute__((visibility(<span class="meta-string">"default"</span>)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> message_NO_EXPORT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_NO_EXPORT __attribute__((visibility(<span class="meta-string">"hidden"</span>)))</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> message_DEPRECATED</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_DEPRECATED __attribute__ ((__deprecated__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> message_DEPRECATED_EXPORT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_DEPRECATED_EXPORT message_EXPORT message_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> message_DEPRECATED_NO_EXPORT</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_DEPRECATED_NO_EXPORT message_NO_EXPORT message_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1 <span class="comment">/* DEFINE_NO_DEPRECATED */</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifndef</span> message_NO_DEPRECATED</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> message_NO_DEPRECATED</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以使用<code>message_EXPORT</code>宏，预先处理用户公开类和函数。弃用可以通过在前面加上<code>message_DEPRECATED</code>宏来实现。</p>
<p>从<code>messageExport.h</code>头文件的内容可以看出，所有符号都应该在静态库中可见，这就是<code>message_STATIC_DEFINE</code>宏起了作用。当声明了目标，我们就将其设置为编译时定义。静态库的其他目标属性如下:</p>
<ul>
<li><code>ARCHIVE_OUTPUT_NAME &quot;message&quot;</code>：这将确保库文件的名称是<code>message</code>，而不是<code>message-static</code>。</li>
<li><code>DEBUG_POSTFIX &quot;_sd&quot;</code>：这将把给定的后缀附加到库名称中。当目标构建类型为Release时，为静态库添加”_sd”后缀。</li>
<li><code>RELEASE_POSTFIX &quot;_s&quot;</code>：这与前面的属性类似，当目标构建类型为Release时，为静态库添加后缀“_s”。</li>
</ul>
<h2 id="更多信息-1"><a href="#更多信息-1" class="headerlink" title="更多信息"></a>更多信息</h2><p>构建动态库时，隐藏内部符号是一个很好的方式。这意味着库会缩小，因为向用户公开的内容要小于库中的内容。这定义了应用程序二进制接口(ABI)，通常情况下应该与应用程序编程接口(API)一致。这分两个阶段进行：</p>
<ol>
<li>使用适当的编译器标志。</li>
<li>使用预处理器变量(示例中是<code>message_EXPORT</code>)标记要导出的符号。编译时，将解除这些符号(类和函数)的隐藏。</li>
</ol>
<p>静态库只是目标文件的归档。因此，可以将源代码编译成目标文件，然后归档器将它们捆绑到归档文件中。这时没有ABI的概念：所有符号在默认情况下都是可见的，编译器的可见标志不影响静态归档。但是，如果要从相同的源文件构建动态和静态库，则需要一种方法来赋予<code>message_EXPORT</code>预处理变量意义，这两种情况都会出现在代码中。这里使用<code>GenerateExportHeader.cmake</code>模块，它定义一个包含所有逻辑的头文件，用于给出这个预处理变量的正确定义。对于动态库，它将给定的平台与编译器相组合。注意，根据构建或使用动态库，宏定义也会发生变化。幸运的是，CMake为我们解决了这个问题。对于静态库，它将扩展为一个空字符串，执行我们期望的操作——什么也不做。</p>
<p>细心的读者会注意到，构建此处所示的静态和共享库实际上需要编译源代码两次。对于我们的简单示例来说，这不是一个很大的开销，但会显得相当麻烦，即使对于只比示例稍大一点的项目来说，也是如此。为什么我们选择这种方法，而不是使用第1章第3节的方式呢？<code>OBJECT</code>库负责编译库的第一步：从源文件到对象文件。该步骤中，预处理器将介入并计算<code>message_EXPORT</code>。由于对象库的编译只发生一次，<code>message_EXPORT</code>被计算为构建动态库库或静态库兼容的值。因此，为了避免歧义，我们选择了更健壮的方法，即编译两次，为的就是让预处理器正确地评估变量的可见性。</p>
<p><strong>NOTE</strong>:<em>有关动态共享对象、静态存档和符号可见性的更多细节，建议阅读:<a href="http://people.redhat.com/drepper/dsohowto.pdf" target="_blank" rel="noopener">http://people.redhat.com/drepper/dsohowto.pdf</a></em></p>
<h1 id="10-3-输出目标"><a href="#10-3-输出目标" class="headerlink" title="10.3 输出目标"></a>10.3 输出目标</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-03" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-03</a> 中找到，其中有一个C++示例。该示例在CMake 3.6版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>可以假设，消息库在开源社区取得了巨大的成功。人们非常喜欢它，并在自己的项目中使用它将消息打印到屏幕上。用户特别喜欢每个打印的消息都有惟一的标识符。但用户也希望，当他们编译并安装了库，库就能更容易找到。这个示例将展示CMake如何让我们导出目标，以便其他使用CMake的项目可以轻松地获取它们。</p>
<h2 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h2><p>源代码与之前的示例一致，项目结构如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cmake</span><br><span class="line">│    └── messageConfig<span class="selector-class">.cmake</span><span class="selector-class">.in</span></span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── src</span><br><span class="line">│    ├── CMakeLists.txt</span><br><span class="line">│    ├── hello- world.cpp</span><br><span class="line">│    ├── Message.cpp</span><br><span class="line">│    └── Message.hpp</span><br><span class="line">└── tests</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── use_target</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        └── use_message.cpp</span><br></pre></td></tr></table></figure>
<p>注意，cmake子目录中添加了一个<code>messageConfig.cmake.in</code>。这个文件将包含导出的目标，还添加了一个测试来检查项目的安装和导出是否按预期工作。</p>
<h2 id="具体实施-2"><a href="#具体实施-2" class="headerlink" title="具体实施"></a>具体实施</h2><p>同样，主<code>CMakeLists.txt</code>文件相对于前一个示例来说没有变化。移动到包含我们的源代码的子目录<code>src</code>中：</p>
<ol>
<li><p>需要找到UUID库，可以重用之前示例中的代码：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Search for pkg-config and UUID</span><br><span class="line">find_package(<span class="name">PkgConfig</span> QUIET)</span><br><span class="line">if(<span class="name">PKG_CONFIG_FOUND</span>)</span><br><span class="line">	pkg_search_module(<span class="name">UUID</span> uuid IMPORTED_TARGET)</span><br><span class="line">	if(<span class="name">TARGET</span> PkgConfig:<span class="symbol">:UUID</span>)</span><br><span class="line">		message(<span class="name">STATUS</span> <span class="string">"Found libuuid"</span>)</span><br><span class="line">		set(<span class="name">UUID_FOUND</span> TRUE)</span><br><span class="line">	endif()</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，设置动态库目标并生成导出头文件：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(<span class="keyword">message</span>-shared SHARED <span class="string">""</span>)</span><br><span class="line"><span class="keyword">include</span>(GenerateExportHeader)</span><br><span class="line"></span><br><span class="line">generate_export_header(<span class="keyword">message</span>-shared</span><br><span class="line">  BASE_NAME <span class="string">"message"</span></span><br><span class="line">  EXPORT_MACRO_NAME <span class="string">"message_EXPORT"</span></span><br><span class="line">  EXPORT_FILE_NAME <span class="string">"$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h"</span></span><br><span class="line">  DEPRECATED_MACRO_NAME <span class="string">"message_DEPRECATED"</span></span><br><span class="line">  NO_EXPORT_MACRO_NAME <span class="string">"message_NO_EXPORT"</span></span><br><span class="line">  STATIC_DEFINE <span class="string">"message_STATIC_DEFINE"</span></span><br><span class="line">  NO_DEPRECATED_MACRO_NAME <span class="string">"message_NO_DEPRECATED"</span></span><br><span class="line">  DEFINE_NO_DEPRECATED</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">message</span>-shared</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/<span class="keyword">Message</span>.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>为目标设置了<code>PUBLIC</code>和<code>INTERFACE</code>编译定义。注意<code>$&lt;INSTALL_INTERFACE:...&gt;</code>生成器表达式的使用：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target_compile_definitions(message-shared</span><br><span class="line">PUBLIC</span><br><span class="line">	$&lt;$&lt;BOOL:<span class="variable">$&#123;UUID_FOUND&#125;</span>&gt;:HAVE_UUID&gt;</span><br><span class="line">INTERFACE</span><br><span class="line">	$&lt;INSTALL_INTERFACE:USING_message&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>链接库和目标属性与前一个示例一样：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(message-static</span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;UUID_FOUND&#125;&gt;<span class="symbol">:PkgConfig</span><span class="symbol">:</span><span class="symbol">:UUID&gt;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">set_target_properties(message-static</span><br><span class="line">    PROPERTIES</span><br><span class="line">    POSITION_INDEPENDENT_CODE <span class="number">1</span></span><br><span class="line">    ARCHIVE_OUTPUT_NAME <span class="string">"message"</span></span><br><span class="line">    DEBUG_POSTFIX <span class="string">"_sd"</span></span><br><span class="line">    RELEASE_POSTFIX <span class="string">"_s"</span></span><br><span class="line">    PUBLIC_HEADER <span class="string">"Message.hpp;$&#123;CMAKE_BINARY_DIR&#125;/$&#123;INSTALL_INCLUDEDIR&#125;/messageExport.h"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>可执行文件的生成，与前一个示例中使用的命令完全相同：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(hello-world_wDSO hello-world.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world_wDSO</span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="keyword">message</span>-shared</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Prepare RPATH</span></span><br><span class="line"><span class="keyword">file</span>(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">	<span class="keyword">set</span>(_rpath <span class="string">"@loader_path/$&#123;_rel&#125;"</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="keyword">set</span>(_rpath <span class="string">"\$ORIGIN/$&#123;_rel&#125;"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">"$&#123;_rpath&#125;/$&#123;INSTALL_LIBDIR&#125;"</span> message_RPATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(hello-world_wDSO</span><br><span class="line">  PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">"$&#123;message_RPATH&#125;"</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="keyword">add_executable</span>(hello-world_wAR hello-world.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(hello-world_wAR</span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="keyword">message</span>-static</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在，来看看安装规则：</p>
<ol>
<li><p>因为CMake可以正确地将每个目标放在正确的地方，所以把目标的安装规则都列在一起。这次，添加了<code>EXPORT</code>关键字，这样CMake将为目标生成一个导出的目标文件：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">install(</span><br><span class="line">  TARGETS</span><br><span class="line">    message-shared</span><br><span class="line">    message-static</span><br><span class="line">    hello-world_wDSO</span><br><span class="line">    hello-world_wAR</span><br><span class="line">  EXPORT</span><br><span class="line">  	messageTargets</span><br><span class="line">  ARCHIVE</span><br><span class="line">    DESTINATION $&#123;INSTALL_LIBDIR&#125;</span><br><span class="line">    COMPONENT <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">  RUNTIME</span><br><span class="line">    DESTINATION $&#123;INSTALL_BINDIR&#125;</span><br><span class="line">    COMPONENT bin</span><br><span class="line">  LIBRARY</span><br><span class="line">    DESTINATION $&#123;INSTALL_LIBDIR&#125;</span><br><span class="line">    COMPONENT <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">  PUBLIC_HEADER</span><br><span class="line">    DESTINATION $&#123;INSTALL_INCLUDEDIR&#125;/message</span><br><span class="line">    COMPONENT dev</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动生成的导出目标文件称为<code>messageTargets.cmake</code>，需要显式地指定它的安装规则。这个文件的目标是<code>INSTALL_CMAKEDIR</code>，在主<code>CMakeLists.txt</code>文件中定义:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  <span class="keyword">EXPORT</span></span><br><span class="line">  	messageTargets</span><br><span class="line">  NAMESPACE</span><br><span class="line">  	<span class="string">"message::"</span></span><br><span class="line">  DESTINATION</span><br><span class="line">  	<span class="variable">$&#123;INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">  COMPONENT</span><br><span class="line">  	dev</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，需要生成正确的CMake配置文件。这些将确保下游项目能够找到消息库导出的目标。为此，首先包括<code>CMakePackageConfigHelpers.cmake</code>标准模块：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(CMakePackageConfigHelpers)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>让CMake为我们的库，生成一个包含版本信息的文件:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">write_basic_package_version_file(</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/messageConfigVersion.cmake</span><br><span class="line">  <span class="keyword">VERSION</span> <span class="variable">$&#123;PROJECT_VERSION&#125;</span></span><br><span class="line">  	COMPATIBILITY SameMajorVersion</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>configure_package_config_file</code>函数，我们生成了实际的CMake配置文件。这是基于模板<code>cmake/messageConfig.cmake.in</code>文件:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure_package_config_file(</span><br><span class="line">  $&#123;PROJECT_SOURCE_DIR&#125;/cmake/messageConfig<span class="selector-class">.cmake</span><span class="selector-class">.in</span></span><br><span class="line">  $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/messageConfig.cmake</span><br><span class="line">  INSTALL_DESTINATION $&#123;INSTALL_CMAKEDIR&#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，为这两个自动生成的配置文件设置了安装规则:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  FILES</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/messageConfig.cmake</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/messageConfigVersion.cmake</span><br><span class="line">  DESTINATION</span><br><span class="line">  	<span class="variable">$&#123;INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>cmake/messageConfig.cmake</code>的内容是什么？该文件的顶部有相关的说明，可以作为用户文档供使用者查看。让我们看看实际的CMake命令:</p>
<ol>
<li><p>占位符将使用<code>configure_package_config_file</code>命令进行替换:</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PACKAGE</span>_INIT@</span><br></pre></td></tr></table></figure>
</li>
<li><p>包括为目标自动生成的导出文件:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(<span class="string">"$&#123;CMAKE_CURRENT_LIST_DIR&#125;/messageTargets.cmake"</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检查静态库和动态库，以及两个“Hello, World”可执行文件是否带有CMake提供的<code>check_required_components</code>函数：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">check_required_components</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"message-shared"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"message-static"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"message-hello-world_wDSO"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"message-hello-world_wAR"</span></span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检查目标<code>PkgConfig::UUID</code>是否存在。如果没有，我们再次搜索UUID库(只在非Windows操作系统下有效):</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">NOT</span> WIN32)</span><br><span class="line">  if(<span class="name">NOT</span> TARGET PkgConfig:<span class="symbol">:UUID</span>)</span><br><span class="line">    find_package(<span class="name">PkgConfig</span> REQUIRED QUIET)</span><br><span class="line">    pkg_search_module(<span class="name">UUID</span> REQUIRED uuid IMPORTED_TARGET)</span><br><span class="line">  endif()</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>测试一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/Software/recipe-03 ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build . --target install</span></span><br></pre></td></tr></table></figure>
<p>安装树应该如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/Software/recipe-<span class="number">03</span>/</span><br><span class="line">├── bin</span><br><span class="line">│    ├── hello-world_wAR</span><br><span class="line">│    └── hello-world_wDSO</span><br><span class="line">├── include</span><br><span class="line">│    └── message</span><br><span class="line">│        ├── messageExport.h</span><br><span class="line">│        └── Message.hpp</span><br><span class="line">├── lib64</span><br><span class="line">│    ├── libmessage_s.a</span><br><span class="line">│    ├── libmessage<span class="selector-class">.so</span> -&gt; libmessage<span class="selector-class">.so</span>.<span class="number">1</span></span><br><span class="line">│    └── libmessage<span class="selector-class">.so</span>.<span class="number">1</span></span><br><span class="line">└── share</span><br><span class="line">    └── cmake</span><br><span class="line">        └── recipe-<span class="number">03</span></span><br><span class="line">            ├── messageConfig.cmake</span><br><span class="line">            ├── messageConfigVersion.cmake</span><br><span class="line">            ├── messageTargets.cmake</span><br><span class="line">            └── messageTargets-release.cmake</span><br></pre></td></tr></table></figure>
<p>出现了一个<code>share</code>子目录，其中包含我们要求CMake自动生成的所有文件。现在开始，消息库的用户可以在他们自己的<code>CMakeLists.txt</code>文件中找到消息库，只要他们设置<code>message_DIR</code>的CMake变量，指向安装树中的<code>share/cmake/message</code>目录:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(message 1<span class="built_in"> CONFIG </span>REQUIRED)</span><br></pre></td></tr></table></figure>
<h2 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h2><p>这个示例涵盖了很多领域。对于构建系统将要执行的操作，CMake目标是一个非常有用的抽象概念。使用<code>PRIVATE</code>、<code>PUBLIC</code>和<code>INTERFACE</code>关键字，我们可以设置项目中的目标进行交互。在实践中，这允许我们定义目标A的依赖关系，将如何影响目标B(依赖于A)。如果库维护人员提供了适当的CMake配置文件，那么只需很少的CMake命令就可以轻松地解决所有依赖关系。</p>
<p>这个问题可以通过遵循<code>message-static</code>、<code>message-shared</code>、<code>hello-world_wDSO</code>和<code>hello-world_wAR</code>目标概述的模式来解决。我们将单独分析<code>message-shared</code>目标的CMake命令，这里只是进行一般性讨论：</p>
<ol>
<li><p>生成目标在项目构建中列出其依赖项。对UUID库的链接是 <code>message-shared</code>的<code>PUBLIC</code>需求，因为它将用于在项目中构建目标和在下游项目中构建目标。编译时宏定义和包含目录需要在<code>PUBLIC</code>级或<code>INTERFACE</code>级目标上进行设置。它们实际上是在项目中构建目标时所需要的，其他的只与下游项目相关。此外，其中一些只有在项目安装之后才会相关联。这里使用了<code>$&lt;BUILD_INTERFACE:...&gt;</code>和<code>$&lt;INSTALL_INTERFACE:...&gt;</code>生成器表达式。只有消息库外部的下游目标才需要这些，也就是说，只有在安装了目标之后，它们才会变得可见。我们的例子中，应用如下:</p>
<ul>
<li>只有在项目中使用了<code>message-shared</code>库，那么<code>$&lt;BUILD_INTERFACE:${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}&gt;</code>才会扩展成<code>${CMAKE_BINARY_DIR}/${INSTALL_INCLUDEDIR}</code></li>
<li>只有在<code>message-shared</code>库在另一个构建树中，作为一个已导出目标，那么<code>$&lt;INSTALL_INTERFACE:${INSTALL_INCLUDEDIR}&gt;</code>将会扩展成<code>${INSTALL_INCLUDEDIR}</code></li>
</ul>
</li>
<li><p>描述目标的安装规则，包括生成文件的名称。</p>
</li>
<li><p>描述CMake生成的导出文件的安装规则<code>messageTargets.cmake</code>文件将安装到<code>INSTALL_CMAKEDIR</code>。目标导出文件的安装规则的名称空间选项，将把给定字符串前置到目标的名称中，这有助于避免来自不同项目的目标之间的名称冲突。<code>INSTALL_CMAKEDIR</code>变量是在主<code>CMakeLists.txt</code>文件中设置的:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> CYGWIN)</span><br><span class="line">	<span class="builtin-name">set</span>(DEF_INSTALL_CMAKEDIR CMake)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="builtin-name">set</span>(DEF_INSTALL_CMAKEDIR share/cmake/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line">endif()</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_CMAKEDIR <span class="variable">$&#123;DEF_INSTALL_CMAKEDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for CMake files"</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>CMakeLists.txt</code>的最后一部分生成配置文件。包括<code>CMakePackageConfigHelpers.cmake</code>模块，分三步完成:</p>
<ol>
<li>调用<code>write_basic_package_version_file</code>函数生成一个版本文件包。宏的第一个参数是版本控制文件的路径：<code>messageConfigVersion.cmake</code>。版本格式为<code>Major.Minor.Patch</code>，并使用<code>PROJECT_VERSION</code>指定版本，还可以指定与库的新版本的兼容性。例子中，当库具有相同的主版本时，为了保证兼容性，使用了相同的<code>SameMajorVersion</code>参数。</li>
<li>接下来，配置模板文件<code>messageConfig.cmake.in</code>，该文件位于<code>cmake</code>子目录中。</li>
<li>最后，为新生成的文件设置安装规则。两者都将安装在<code>INSTALL_CMAKEDIR</code>下。</li>
</ol>
<h2 id="更多信息-2"><a href="#更多信息-2" class="headerlink" title="更多信息"></a>更多信息</h2><p>消息库的客户现在非常高兴，因为终于可以在自己的系统上安装这个库，对自己的<code>CMakeLists.txt</code>进行简单的修改，就能找到消息库：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(message VERSION <span class="number">1</span> REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
<p>客户可以用以下方式配置他们的项目:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cmake -Dmessage_DIR=<span class="regexp">/path/to</span><span class="regexp">/message/share</span><span class="regexp">/cmake/message</span> ..</span><br></pre></td></tr></table></figure>
<p>我们示例中包含的测试，显示了如何检查目标的安装是否按照计划进行。看看<code>tests</code>文件夹的结构，我们注意到<code>use_target</code>子目录：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tests/</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── use_target</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── use_message.cpp</span><br></pre></td></tr></table></figure>
<p>这个目录包含一个使用导出目标的小项目。有趣的部分是在CMakeLists.txt文件中指定的测试:</p>
<ol>
<li><p>我们测试小项目，可以配置为使用已安装的库。这是<code>use-target</code>测试固件的设置步骤，可以参考第4章第10节:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME use-target_configure</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -H<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/use_target</span><br><span class="line">                      -B<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/build_use-<span class="keyword">target</span></span><br><span class="line">                      -G<span class="variable">$&#123;CMAKE_GENERATOR&#125;</span></span><br><span class="line">                      -Dmessage_DIR=<span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;</span></span><br><span class="line"><span class="variable">                      INSTALL_CMAKEDIR&#125;</span></span><br><span class="line">                      -DCMAKE_BUILD_TYPE=$&lt;CONFIGURATION&gt;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_tests_properties</span>(use-target_configure</span><br><span class="line">  PROPERTIES</span><br><span class="line">    FIXTURES_SETUP use-<span class="keyword">target</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试了小项目可以构建:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME use-target_build</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> --build <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/build_use-<span class="keyword">target</span></span><br><span class="line">                      --config $&lt;CONFIGURATION&gt;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_tests_properties</span>(use-target_build</span><br><span class="line">  PROPERTIES</span><br><span class="line">    FIXTURES_REQUIRED use-<span class="keyword">target</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>小项目的测试也会运行:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_test_target)</span><br><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">  <span class="keyword">set</span>(_test_target <span class="string">"RUN_TESTS"</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">set</span>(_test_target <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME use-target_test</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> --build <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/build_use-<span class="keyword">target</span></span><br><span class="line">                      --<span class="keyword">target</span> <span class="variable">$&#123;_test_target&#125;</span></span><br><span class="line">                      --config $&lt;CONFIGURATION&gt;</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">set_tests_properties</span>(use-target_test</span><br><span class="line">  PROPERTIES</span><br><span class="line">    FIXTURES_REQUIRED use-<span class="keyword">target</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">unset</span>(_test_target)</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们拆除固件:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME use-target_cleanup</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E remove_directory <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/build_use-<span class="keyword">target</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_tests_properties</span>(use-target_cleanup</span><br><span class="line">  PROPERTIES</span><br><span class="line">    FIXTURES_CLEANUP use-<span class="keyword">target</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>注意，这些测试只能在项目安装之后运行。</p>
<h1 id="10-4-安装超级构建"><a href="#10-4-安装超级构建" class="headerlink" title="10.4 安装超级构建"></a>10.4 安装超级构建</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-04" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-10/recipe-04</a> 中找到，其中有一个C++示例。该示例在CMake 3.6版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>我们的消息库取得了巨大的成功，许多其他程序员都使用它，并且非常满意。也希望在自己的项目中使用它，但是不确定如何正确地管理依赖关系。可以用自己的代码附带消息库的源代码，但是如果该库已经安装在系统上了应该怎么做呢？第8章，展示了超级构建的场景，但是不确定如何安装这样的项目。本示例将带您了解安装超级构建的安装细节。</p>
<h2 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h2><p>此示例将针对消息库，构建一个简单的可执行链接。项目布局如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">├── cmake</span><br><span class="line">│    ├── install_hook<span class="selector-class">.cmake</span><span class="selector-class">.in</span></span><br><span class="line">│    └── print_rpath.py</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── external</span><br><span class="line">│    └── upstream</span><br><span class="line">│        ├── CMakeLists.txt</span><br><span class="line">│        └── message</span><br><span class="line">│            └── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── use_message.cpp</span><br></pre></td></tr></table></figure>
<p>主<code>CMakeLists.txt</code>文件配合超级构建，<code>external</code>子目录包含处理依赖项的CMake指令。<code>cmake</code>子目录包含一个Python脚本和一个模板CMake脚本。这些将用于安装方面的微调，CMake脚本首先进行配置，然后调用Python脚本打印<code>use_message</code>可执行文件的<code>RPATH</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">  patcher = sys.argv[<span class="number">1</span>]</span><br><span class="line">  elfobj = sys.argv[<span class="number">2</span>]</span><br><span class="line">  tools = &#123;<span class="string">'patchelf'</span>: <span class="string">'--print-rpath'</span>, <span class="string">'chrpath'</span>: <span class="string">'--list'</span>, <span class="string">'otool'</span>: <span class="string">'-L'</span>&#125;</span><br><span class="line">  <span class="keyword">if</span> patcher <span class="keyword">not</span> <span class="keyword">in</span> tools.keys():</span><br><span class="line">  <span class="keyword">raise</span> RuntimeError(<span class="string">'Unknown tool &#123;&#125;'</span>.format(patcher))</span><br><span class="line">  cmd = shlex.split(<span class="string">'&#123;:s&#125; &#123;:s&#125; &#123;:s&#125;'</span>.format(patcher, tools[patcher], elfobj))</span><br><span class="line">  rpath = subprocess.run(</span><br><span class="line">      cmd,</span><br><span class="line">      bufsize=<span class="number">1</span>,</span><br><span class="line">      stdout=subprocess.PIPE,</span><br><span class="line">      stderr=subprocess.PIPE,</span><br><span class="line">      universal_newlines=<span class="literal">True</span>)</span><br><span class="line">  print(rpath.stdout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  main()</span><br></pre></td></tr></table></figure>
<p>使用平台原生工具可以轻松地打印<code>RPATH</code>，稍后我们将在本示例中讨论这些工具。</p>
<p>最后，<code>src</code>子目录包含项目的<code>CMakeLists.txt</code>和源文件。<code>use_message.cpp</code>源文件包含以下内容:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USING_message</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;message/Message.hpp&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">messaging</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Message <span class="title">say_hello</span><span class="params">(<span class="string">"Hello, World! From a client of yours!"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; say_hello &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="function">Message <span class="title">say_goodbye</span><span class="params">(<span class="string">"Goodbye, World! From a client of yours!"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; say_goodbye &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">messaging</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello, World! From a client of yours!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Goodbye, World! From a client of yours!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  messaging();</span><br><span class="line">  <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-3"><a href="#具体实施-3" class="headerlink" title="具体实施"></a>具体实施</h2><p>我们将从主<code>CMakeLists.txt</code>文件开始，它用来协调超级构建:</p>
<ol>
<li><p>与之前的示例相同。首先声明一个C++11项目，设置了默认安装路径、构建类型、目标的输出目录，以及安装树中组件的布局:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.6 FATAL_ERROR)</span><br><span class="line"></span><br><span class="line">project(recipe-04</span><br><span class="line">  LANGUAGES CXX</span><br><span class="line">  VERSION 1.0.0</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;&lt;&lt; General set up &gt;&gt;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_CXX_STANDARD 11)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_CXX_EXTENSIONS OFF)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_CXX_STANDARD_REQUIRED ON)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> CMAKE_BUILD_TYPE)</span><br><span class="line">  <span class="builtin-name">set</span>(CMAKE_BUILD_TYPE Release CACHE STRING <span class="string">"Build type"</span> FORCE)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">message(STATUS <span class="string">"Build type set to <span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">message(STATUS <span class="string">"Project will be installed to <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">include(GNUInstallDirs)</span><br><span class="line"></span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">  <span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Offer the user the choice of overriding the installation directories</span></span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_LIBDIR <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for libraries"</span>)</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_BINDIR <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for executables"</span>)</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_INCLUDEDIR <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for header files"</span>)</span><br><span class="line"><span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> CYGWIN)</span><br><span class="line">  <span class="builtin-name">set</span>(DEF_INSTALL_CMAKEDIR CMake)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="builtin-name">set</span>(DEF_INSTALL_CMAKEDIR share/cmake/<span class="variable">$&#123;PROJECT_NAME&#125;</span>)</span><br><span class="line">endif()</span><br><span class="line"><span class="builtin-name">set</span>(INSTALL_CMAKEDIR <span class="variable">$&#123;DEF_INSTALL_CMAKEDIR&#125;</span> CACHE PATH <span class="string">"Installation directory for CMake files"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Report to user</span></span><br><span class="line"><span class="keyword">foreach</span>(p LIB BIN INCLUDE CMAKE)</span><br><span class="line">  file(TO_NATIVE_PATH <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_$&#123;p&#125;</span>DIR&#125; _path )</span><br><span class="line">  message(STATUS <span class="string">"Installing <span class="variable">$&#123;p&#125;</span> components to <span class="variable">$&#123;_path&#125;</span>"</span>)</span><br><span class="line">  unset(_path)</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置了<code>EP_BASE</code>目录属性，这将为超构建中的子项目设置布局。所有子项目都将在<code>CMAKE_BINARY_DIR</code>的子项目文件夹下生成:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_property(DIRECTORY <span class="keyword">PROPERTY</span><span class="title"> </span>EP_BASE $&#123;CMAKE_BINARY_DIR&#125;/subprojects)</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，声明<code>STAGED_INSTALL_PREFIX</code>变量。这个变量指向构建目录下的<code>stage</code>子目录，项目将在构建期间安装在这里。这是一种沙箱安装过程，让我们有机会检查整个超级构建的布局:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(STAGED_INSTALL_PREFIX $&#123;CMAKE_BINARY_DIR&#125;/stage)</span></span></span><br><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"$&#123;PROJECT_NAME&#125; staged install: $&#123;STAGED_INSTALL_PREFIX&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加<code>external/upstream</code>子目录。其中包括使用CMake指令来管理我们的上游依赖关系，在我们的例子中，就是消息库:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(external/upstream)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，包含<code>ExternalProject.cmake</code>标准模块:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(ExternalProject)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将自己的项目作为外部项目添加，调用<code>ExternalProject_Add</code>命令。<code>SOURCE_DIR</code>用于指定源位于<code>src</code>子目录中。我们会选择适当的CMake参数来配置我们的项目。这里，使用<code>STAGED_INSTALL_PREFIX</code>作为子项目的安装目录:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ExternalProject_Add(<span class="variable">$&#123;PROJECT_NAME&#125;</span>_core</span><br><span class="line">  DEPENDS</span><br><span class="line">    message_external</span><br><span class="line">  SOURCE_DIR</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src</span><br><span class="line">  CMAKE_ARGS</span><br><span class="line">    <span class="attribute">-DCMAKE_INSTALL_PREFIX</span>=<span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span></span><br><span class="line">    <span class="attribute">-DCMAKE_BUILD_TYPE</span>=<span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span></span><br><span class="line">    <span class="attribute">-DCMAKE_CXX_COMPILER</span>=<span class="variable">$&#123;CMAKE_CXX_COMPILER&#125;</span></span><br><span class="line">    <span class="attribute">-DCMAKE_CXX_FLAGS</span>=<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span></span><br><span class="line">    <span class="attribute">-DCMAKE_CXX_STANDARD</span>=<span class="variable">$&#123;CMAKE_CXX_STANDARD&#125;</span></span><br><span class="line">    <span class="attribute">-DCMAKE_CXX_EXTENSIONS</span>=<span class="variable">$&#123;CMAKE_CXX_EXTENSIONS&#125;</span></span><br><span class="line">    <span class="attribute">-DCMAKE_CXX_STANDARD_REQUIRED</span>=<span class="variable">$&#123;CMAKE_CXX_STANDARD_REQUIRED&#125;</span></span><br><span class="line">    <span class="attribute">-Dmessage_DIR</span>=<span class="variable">$&#123;message_DIR&#125;</span></span><br><span class="line">  CMAKE_CACHE_ARGS</span><br><span class="line">    -DCMAKE_PREFIX_PATH:<span class="attribute">PATH</span>=<span class="variable">$&#123;CMAKE_PREFIX_PATH&#125;</span></span><br><span class="line">  BUILD_ALWAYS</span><br><span class="line">    1</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，为<code>use_message</code>添加一个测试，并由<code>recipe-04_core</code>构建。这将运行<code>use_message</code>可执行文件的安装，即位于构建树中的安装:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_test</span>(</span><br><span class="line">  NAME</span><br><span class="line">  	check_use_message</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;INSTALL_BINDIR&#125;</span>/use_message</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，可以声明安装规则。因为所需要的东西都已经安装在暂存区域中，我们只要将暂存区域的内容复制到安装目录即可:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/</span><br><span class="line">  DESTINATION</span><br><span class="line">  	.</span><br><span class="line">  USE_SOURCE_PERMISSIONS</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>SCRIPT</code>参数声明一个附加的安装规则。CMake脚本的<code>install_hook.cmake</code>将被执行，但只在GNU/Linux和macOS上执行。这个脚本将打印已安装的可执行文件的<code>RPATH</code>，并运行它。我们将在下一节详细地讨论这个问题：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(UNIX)</span><br><span class="line">  <span class="builtin-name">set</span>(PRINT_SCRIPT <span class="string">"<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/cmake/print_rpath.py"</span>)</span><br><span class="line">  configure_file(cmake/install_hook.cmake.<span class="keyword">in</span> install_hook.cmake @ONLY)</span><br><span class="line">  install(</span><br><span class="line">    SCRIPT</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/install_hook.cmake</span><br><span class="line">    )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>-Dmessage_DIR=${message_DIR}</code>已作为CMake参数传递给项目，这将正确设置消息库依赖项的位置。<code>message_DIR</code>的值在<code>external/upstream/message</code>目录下的<code>CMakeLists.txt</code>文件中定义。这个文件处理依赖于消息库，让我们看看是如何处理的:</p>
<ol>
<li><p>首先，搜索并找到包。用户可能已经在系统的某个地方安装了，并在配置时传递了<code>message_DIR</code>:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find_package(message 1<span class="built_in"> CONFIG </span>QUIET)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果找到了消息库，我们将向用户报告目标的位置和版本，并添加一个虚拟的<code>message_external</code>目标。这里，需要虚拟目标来正确处理超构建的依赖关系:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">message_FOUND</span>)</span><br><span class="line">  get_property(<span class="name">_loc</span> TARGET message:<span class="symbol">:message-shared</span> PROPERTY LOCATION)</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"Found message: $&#123;_loc&#125; (found version $&#123;message_VERSION&#125;)"</span>)</span><br><span class="line">  add_library(<span class="name">message_external</span> INTERFACE) # dummy</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果没有找到这个库，我们将把它添加为一个外部项目，从在线Git存储库下载它，然后编译它。安装路径、构建类型和安装目录布局都是由主<code>CMakeLists.txt</code>文件设置，C++编译器和标志也是如此。项目将安装到<code>STAGED_INSTALL_PREFIX</code>下，然后进行测试:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">include</span>(ExternalProject)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">"Suitable message could not be located, Building message instead."</span>)</span><br><span class="line">  ExternalProject_Add(message_external</span><br><span class="line">    GIT_REPOSITORY</span><br><span class="line">      https://github.com/dev-cafe/<span class="keyword">message</span>.git</span><br><span class="line">    GIT_TAG</span><br><span class="line">      master</span><br><span class="line">    UPDATE_COMMAND</span><br><span class="line">      <span class="string">""</span></span><br><span class="line">    CMAKE_ARGS</span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=<span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span></span><br><span class="line">      -DCMAKE_BUILD_TYPE=<span class="variable">$&#123;CMAKE_BUILD_TYPE&#125;</span></span><br><span class="line">      -DCMAKE_CXX_COMPILER=<span class="variable">$&#123;CMAKE_CXX_COMPILER&#125;</span></span><br><span class="line">    CMAKE_CACHE_ARGS</span><br><span class="line">      -DCMAKE_CXX_FLAGS:<span class="keyword">STRING</span>=<span class="variable">$&#123;CMAKE_CXX_FLAGS&#125;</span></span><br><span class="line">    TEST_AFTER_INSTALL</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    DOWNLOAD_NO_PROGRESS</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    LOG_CONFIGURE</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    LOG_BUILD</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    LOG_INSTALL</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，将<code>message_DIR</code>目录进行设置，为指向新构建的<code>messageConfig.cmake</code>文件指明安装路径。注意，这些路径被保存到<code>CMakeCache</code>中:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span>(WIN32 <span class="keyword">AND</span> <span class="keyword">NOT</span> CYGWIN)</span><br><span class="line">    <span class="keyword">set</span>(DEF_message_DIR <span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/CMake)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">    <span class="keyword">set</span>(DEF_message_DIR <span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/share/cmake/<span class="keyword">message</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line">  <span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">"$&#123;DEF_message_DIR&#125;"</span> DEF_message_DIR)</span><br><span class="line">  <span class="keyword">set</span>(message_DIR <span class="variable">$&#123;DEF_message_DIR&#125;</span></span><br><span class="line">    CACHE PATH <span class="string">"Path to internally built messageConfig.cmake"</span> FORCE)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们终于准备好编译我们自己的项目，并成功地将其链接到消息库(无论是系统上已有的消息库，还是新构建的消息库)。由于这是一个超级构建，<code>src</code>子目录下的代码是一个完全独立的CMake项目:</p>
<ol>
<li><p>声明一个C++11项目：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(<span class="name">VERSION</span> <span class="number">3.6</span> FATAL_ERROR)</span><br><span class="line"></span><br><span class="line">project(<span class="name">recipe-04_core</span></span><br><span class="line">  LANGUAGES CXX</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">set(<span class="name">CMAKE_CXX_STANDARD</span> <span class="number">11</span>)</span><br><span class="line">set(<span class="name">CMAKE_CXX_EXTENSIONS</span> OFF)</span><br><span class="line">set(<span class="name">CMAKE_CXX_STANDARD_REQUIRED</span> ON)</span><br><span class="line"></span><br><span class="line">include(<span class="name">GNUInstallDirs</span>)</span><br><span class="line"></span><br><span class="line">set(<span class="name">CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span></span><br><span class="line">  $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CMAKE_INSTALL_LIBDIR&#125;)</span><br><span class="line">set(<span class="name">CMAKE_LIBRARY_OUTPUT_DIRECTORY</span></span><br><span class="line">  $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CMAKE_INSTALL_LIBDIR&#125;)</span><br><span class="line">set(<span class="name">CMAKE_RUNTIME_OUTPUT_DIRECTORY</span></span><br><span class="line">  $&#123;CMAKE_BINARY_DIR&#125;/$&#123;CMAKE_INSTALL_BINDIR&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>尝试找到消息库。超级构建中，正确设置<code>message_DIR</code>:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find_package(message 1<span class="built_in"> CONFIG </span>REQUIRED)</span><br><span class="line">get_property(_loc TARGET message::message-shared PROPERTY LOCATION)</span><br><span class="line">message(STATUS <span class="string">"Found message: <span class="variable">$&#123;_loc&#125;</span> (found version <span class="variable">$&#123;message_VERSION&#125;</span>)"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加可执行目标<code>use_message</code>，该目标由<code>use_message.cpp</code>源文件创建，并连接到<code>message::message-shared</code>目标:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">use_message</span> use_message.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(<span class="name">use_message</span></span><br><span class="line">  PUBLIC</span><br><span class="line">  	message:<span class="symbol">:message-shared</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>use_message</code>设置目标属性。再次对<code>RPATH</code>进行设置:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prepare RPATH</span></span><br><span class="line"><span class="keyword">file</span>(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">  <span class="keyword">set</span>(_rpath <span class="string">"@loader_path/$&#123;_rel&#125;"</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">set</span>(_rpath <span class="string">"\$ORIGIN/$&#123;_rel&#125;"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">"$&#123;_rpath&#125;/$&#123;CMAKE_INSTALL_LIBDIR&#125;"</span> use_message_RPATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(use_message</span><br><span class="line">  PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">"$&#123;use_message_RPATH&#125;"</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，为<code>use_message</code>目标设置了安装规则:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS</span><br><span class="line">  	use_message</span><br><span class="line">  RUNTIME</span><br><span class="line">    DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span></span><br><span class="line">    COMPONENT bin</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>现在瞧瞧CMake脚本模板<code>install_hook.cmake.in</code>的内容：</p>
<ol>
<li><p>CMake脚本在我们的主项目范围之外执行，因此没有定义变量或目标的概念。因此，需要设置变量来保存已安装的<code>use_message</code>可执行文件的完整路径。注意使用<code>@INSTALL_BINDIR@</code>，它将由<code>configure_file</code>解析：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_executable <span class="comment">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/@INSTALL_BINDIR@/<span class="comment">use_message)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要找到平台本机可执行工具，使用该工具打印已安装的可执行文件的<code>RPATH</code>。我们将搜索<code>chrpath</code>、<code>patchelf</code>和<code>otool</code>。当找到已安装的程序时，向用户提供有用的状态信息，并且退出搜索：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set(<span class="name">_patcher</span>)</span><br><span class="line">list(<span class="name">APPEND</span> _patchers chrpath patchelf otool)</span><br><span class="line">foreach(<span class="name">p</span> IN LISTS _patchers)</span><br><span class="line">  find_program($&#123;p&#125;_FOUND</span><br><span class="line">    NAMES</span><br><span class="line">      $&#123;p&#125;</span><br><span class="line">    )</span><br><span class="line">  if($&#123;p&#125;_FOUND)</span><br><span class="line">    set(<span class="name">_patcher</span> $&#123;p&#125;)</span><br><span class="line">    message(<span class="name">STATUS</span> <span class="string">"ELF patching tool $&#123;_patcher&#125; FOUND"</span>)</span><br><span class="line">    break()</span><br><span class="line">  endif()</span><br><span class="line">endforeach()</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查<code>_patcher</code>变量是否为空，这意味着PatchELF工具是否可用。当为空时，我们要进行的操作将会失败，所以会发出一个致命错误，提醒用户需要安装PatchELF工具:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">NOT</span> _patcher)</span><br><span class="line">	message(<span class="name">FATAL_ERROR</span> <span class="string">"ELF patching tool NOT FOUND!\nPlease install one of chrpath, patchelf or otool"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>当PatchELF工具找到了，则继续。我们调用Python脚本<code>print_rpath.py</code>，将<code>_executable</code>变量作为参数传递给<code>execute_process</code>：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PythonInterp REQUIRED QUIET)</span><br><span class="line"><span class="keyword">execute_process</span>(</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span> @PRINT_SCRIPT@ <span class="string">"$&#123;_patcher&#125;"</span></span><br><span class="line">  <span class="string">"$&#123;_executable&#125;"</span></span><br><span class="line">  RESULT_VARIABLE _res</span><br><span class="line">  OUTPUT_VARIABLE _out</span><br><span class="line">  ERROR_VARIABLE _err</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>检查<code>_res</code>变量的返回代码。如果执行成功，将打印<code>_out</code>变量中捕获的标准输出流。否则，打印退出前捕获的标准输出和错误流:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  if(<span class="name">_res</span> EQUAL <span class="number">0</span>)</span><br><span class="line">    message(<span class="name">STATUS</span> <span class="string">"RPATH for $&#123;_executable&#125; is $&#123;_out&#125;"</span>)</span><br><span class="line">  else()</span><br><span class="line">    message(<span class="name">STATUS</span> <span class="string">"Something went wrong!"</span>)</span><br><span class="line">    message(<span class="name">STATUS</span> <span class="string">"Standard output from print_rpath.py: $&#123;_out&#125;"</span>)</span><br><span class="line">    message(<span class="name">STATUS</span> <span class="string">"Standard error from print_rpath.py: $&#123;_err&#125;"</span>)</span><br><span class="line">    message(<span class="name">FATAL_ERROR</span> <span class="string">"$&#123;_patcher&#125; could NOT obtain RPATH for $&#123;_executable&#125;"</span>)</span><br><span class="line">  endif()</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>再使用<code>execute_process</code>来运行已安装的<code>use_message</code>可执行目标:</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execute_process(</span><br><span class="line">  COMMAND $&#123;<span class="variable">_executable</span>&#125;</span><br><span class="line">  RESULT_VARIABLE <span class="variable">_res</span></span><br><span class="line">  OUTPUT_VARIABLE <span class="variable">_out</span></span><br><span class="line">  ERROR_VARIABLE <span class="variable">_err</span></span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，向用户报告<code>execute_process</code>的结果:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">_res</span> EQUAL <span class="number">0</span>)</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"Running $&#123;_executable&#125;:\n $&#123;_out&#125;"</span>)</span><br><span class="line">else()</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"Something went wrong!"</span>)</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"Standard output from running $&#123;_executable&#125;:\n $&#123;_out&#125;"</span>)</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"Standard error from running $&#123;_executable&#125;:\n $&#123;_err&#125;"</span>)</span><br><span class="line">  message(<span class="name">FATAL_ERROR</span> <span class="string">"Something went wrong with $&#123;_executable&#125;"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h2><p>CMake工具箱中，超级构建是非常有用的模式。它通过将复杂的项目划分为更小、更容易管理的子项目来管理它们。此外，可以使用CMake作为构建项目的包管理器。CMake可以搜索依赖项，如果在系统上找不到依赖项，则重新构建它们。这里需要三个<code>CMakeLists.txt</code>文件：</p>
<ul>
<li>主<code>CMakeLists.txt</code>文件包含项目和依赖项共享的设置，还包括我们自己的项目(作为外部项目)。本例中，我们选择的名称为<code>${PROJECT_NAME}_core</code>；也就是<code>recipe-04_core</code>，因为项目名称<code>recipe-04</code>用于超级构建。</li>
<li>外部<code>CMakeLists.txt</code>文件将尝试查找上游依赖项，并在导入目标和构建目标之间进行切换，这取决于是否找到了依赖项。对于每个依赖项，最好有单独的子目录，其中包含一个<code>CMakeLists.txt</code>文件。</li>
<li>最后，我们项目的<code>CMakeLists.txt</code>文件，可以构建一个独立的CMake项目。在原则上，我们可以自己配置和构建它，而不需要超级构建提供的依赖关系管理工具。</li>
</ul>
<p>当对消息库的依赖关系未得到满足时，将首先考虑超级构建:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake -DCMAKE_INSTALL_PREFIX=<span class="variable">$HOME</span>/Software/recipe-04 ..</span></span><br></pre></td></tr></table></figure>
<p>让CMake查找库，这是我们得到的输出:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- The CXX compiler identification is GNU <span class="number">7.3</span><span class="number">.0</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /nix/store/gqg2vrcq7krqi9rrl6pphvsg81sb8pjw-gcc-wrapper<span class="number">-7.3</span><span class="number">.0</span>/bin/g++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /nix/store/gqg2vrcq7krqi9rrl6pphvsg81sb8pjw-gcc-wrapper<span class="number">-7.3</span><span class="number">.0</span>/bin/g++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Project will be installed to /home/roberto/Software/recipe<span class="number">-04</span></span><br><span class="line">-- Build type <span class="keyword">set</span> to <span class="comment">Release</span></span><br><span class="line">-- Installing <span class="comment">LIB components to</span> /home/<span class="comment">roberto</span>/Software/<span class="comment">recipe-04</span>/lib64</span><br><span class="line">-- Installing BIN components to /<span class="comment">home</span>/roberto/<span class="comment">Software</span>/recipe<span class="number">-04</span>/<span class="comment">bin</span></span><br><span class="line">-- Installing <span class="comment">INCLUDE components to</span> /home/<span class="comment">roberto</span>/Software/<span class="comment">recipe-04</span>/include</span><br><span class="line">-- Installing CMAKE components to /<span class="comment">home</span>/roberto/<span class="comment">Software</span>/recipe<span class="number">-04</span>/<span class="comment">share</span>/cmake/<span class="comment">recipe-04</span></span><br><span class="line">-- recipe-04 staged <span class="comment">install:</span> /home/<span class="comment">roberto</span>/Workspace/<span class="comment">robertodr</span>/cmake-cookbook/<span class="comment">chapter-10</span>/recipe<span class="number">-04</span>/<span class="comment">cxx-example</span>/build/<span class="comment">stage</span></span><br><span class="line">-- Suitable <span class="comment">message could not be located, Building message instead.</span></span><br><span class="line">-- Configuring <span class="comment">done</span></span><br><span class="line">-- Generating <span class="comment">done</span></span><br><span class="line">-- Build <span class="comment">files have been written to:</span> /home/<span class="comment">roberto</span>/Workspace/<span class="comment">robertodr</span>/cmake-cookbook/<span class="comment">chapter-10</span>/recipe<span class="number">-04</span>/<span class="comment">cxx-example</span>/build</span><br></pre></td></tr></table></figure>
<p>根据指令，CMake报告如下:</p>
<ul>
<li>安装将分阶段进入构建树。分阶段安装是对实际安装过程进行沙箱化的一种方法。作为开发人员，这对于在运行安装命令之前检查所有库、可执行程序和文件是否安装在正确的位置非常有用。对于用户来说，可在构建目录中给出了相同的结构。这样，即使没有运行正确的安装，我们的项目也可以立即使用。</li>
<li>系统上没有找到合适的消息库。然后，CMake将运行在构建项目之前构建库所提供的命令，以满足这种依赖性。</li>
</ul>
<p>如果库已经位于系统的已知位置，我们可以将<code>-Dmessage_DIR</code>选项传递给CMake:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake <span class="attribute">-DCMAKE_INSTALL_PREFIX</span>=<span class="variable">$HOME</span>/Software/use_message <span class="attribute">-Dmessage_DIR</span>=<span class="variable">$HOME</span>/Software/message/share/cmake/message <span class="built_in">..</span></span><br></pre></td></tr></table></figure>
<p>事实上，这个库已经找到并导入。我们对自己的项目进行建造操作:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- The CXX compiler identification is GNU <span class="number">7.3</span><span class="number">.0</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX <span class="string">compiler:</span> <span class="regexp">/nix/</span>store<span class="regexp">/gqg2vrcq7krqi9rrl6pphvsg81sb8pjw-gcc-wrapper-7.3.0/</span>bin/g++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX <span class="string">compiler:</span> <span class="regexp">/nix/</span>store<span class="regexp">/gqg2vrcq7krqi9rrl6pphvsg81sb8pjw-gcc-wrapper-7.3.0/</span>bin/g++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - done</span><br><span class="line">-- Project will be installed to <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span></span><br><span class="line">-- Build type set to Release</span><br><span class="line">-- Installing LIB components to <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span>/lib64</span><br><span class="line">-- Installing BIN components to <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span>/bin</span><br><span class="line">-- Installing INCLUDE components to <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span>/include</span><br><span class="line">-- Installing CMAKE components to <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/share/</span>cmake/recipe<span class="number">-04</span></span><br><span class="line">-- recipe<span class="number">-04</span> staged <span class="string">install:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Workspace/</span>robertodr<span class="regexp">/cmake-cookbook/</span>chapter<span class="number">-10</span><span class="regexp">/recipe-04/</span>cxx-example<span class="regexp">/build/</span>stage</span><br><span class="line">-- Checking <span class="keyword">for</span> one of the modules <span class="string">'uuid'</span></span><br><span class="line">-- Found <span class="string">message:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>message<span class="regexp">/lib64/</span>libmessage.so<span class="number">.1</span> (found version <span class="number">1.0</span><span class="number">.0</span>)</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written <span class="string">to:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Workspace/</span>robertodr<span class="regexp">/cmake-cookbook/</span>chapter<span class="number">-10</span><span class="regexp">/recipe-04/</span>cxx-example/build</span><br></pre></td></tr></table></figure>
<p>项目的最终安装规则是，将安装文件复制到<code>CMAKE_INSTALL_PREFIX</code>:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;STAGED_INSTALL_PREFIX&#125;</span>/</span><br><span class="line">  DESTINATION</span><br><span class="line">  	.</span><br><span class="line">  USE_SOURCE_PERMISSIONS</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>注意使用<code>.</code>而不是绝对路径<code>${CMAKE_INSTALL_PREFIX}</code>，这样CPack工具就可以正确理解该规则。CPack的用法将在第11章中介绍。</p>
<p><code>recipe-04_core</code>项目构建一个简单的可执行目标，该目标链接到消息动态库。正如本章前几节所讨论，为了让可执行文件正确运行，需要正确设置<code>RPATH</code>。本章的第1节展示了，如何在CMake的帮助下实现这一点，同样的模式在<code>CMakeLists.txt</code>中被重用，用于创建<code>use_message</code>的可执行目标:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(RELATIVE_PATH _rel <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span> <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line"><span class="keyword">if</span>(APPLE)</span><br><span class="line">  <span class="keyword">set</span>(_rpath <span class="string">"@loader_path/$&#123;_rel&#125;"</span>)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">set</span>(_rpath <span class="string">"\$ORIGIN/$&#123;_rel&#125;"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">file</span>(TO_NATIVE_PATH <span class="string">"$&#123;_rpath&#125;/$&#123;CMAKE_INSTALL_LIBDIR&#125;"</span> use_message_RPATH)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set_target_properties</span>(use_message</span><br><span class="line">  PROPERTIES</span><br><span class="line">    MACOSX_RPATH <span class="keyword">ON</span></span><br><span class="line">    SKIP_BUILD_RPATH <span class="keyword">OFF</span></span><br><span class="line">    BUILD_WITH_INSTALL_RPATH <span class="keyword">OFF</span></span><br><span class="line">    INSTALL_RPATH <span class="string">"$&#123;use_message_RPATH&#125;"</span></span><br><span class="line">    INSTALL_RPATH_USE_LINK_PATH <span class="keyword">ON</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>为了检查这是否合适，可以使用本机工具打印已安装的可执行文件的<code>RPATH</code>。我们将对该工具的调用，封装到Python脚本中，并将其进一步封装到CMake脚本中。最后，使用<code>SCRIPT</code>关键字将CMake脚本作为安装规则调用:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(UNIX)</span><br><span class="line">  <span class="builtin-name">set</span>(PRINT_SCRIPT <span class="string">"<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/cmake/print_rpath.py"</span>)</span><br><span class="line">  configure_file(cmake/install_hook.cmake.<span class="keyword">in</span> install_hook.cmake @ONLY)</span><br><span class="line">  install(</span><br><span class="line">    SCRIPT</span><br><span class="line">      <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/install_hook.cmake</span><br><span class="line">    )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p>脚本是在安装最后进行执行:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --<span class="keyword">build </span><span class="keyword">build </span>--target install</span><br></pre></td></tr></table></figure>
<p>GNU/Linux系统上，我们将看到以下输出:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Install the project...</span><br><span class="line">-- Install <span class="string">configuration:</span> <span class="string">"Release"</span></span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span>/.</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>lib64</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>lib64/libmessage.so</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>lib64/libmessage_s.a</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>lib64/libmessage.so<span class="number">.1</span></span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>include</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>include/message</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>include<span class="regexp">/message/</span>Message.hpp</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>include<span class="regexp">/message/</span>messageExport.h</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>share</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>share/cmake</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>share<span class="regexp">/cmake/</span>message</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>share<span class="regexp">/cmake/</span>message/messageTargets-release.cmake</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>share<span class="regexp">/cmake/</span>message/messageConfigVersion.cmake</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>share<span class="regexp">/cmake/</span>message/messageConfig.cmake</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>share<span class="regexp">/cmake/</span>message/messageTargets.cmake</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>bin</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>bin/hello-world_wAR</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>bin/use_message</span><br><span class="line">-- <span class="string">Installing:</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/./</span>bin/hello-world_wDSO</span><br><span class="line">-- ELF patching tool chrpath FOUND</span><br><span class="line">-- RPATH <span class="keyword">for</span> <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/bin/</span>use_message is <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/bin/</span><span class="string">use_message:</span> RUNPATH=$ORIGIN<span class="regexp">/../</span><span class="string">lib64:</span><span class="regexp">/home/</span>roberto<span class="regexp">/Workspace/</span>robertodr<span class="regexp">/cmake-cookbook/</span>chapter<span class="number">-10</span><span class="regexp">/recipe-04/</span>cxx-example<span class="regexp">/build/</span>stage<span class="regexp">/lib64:/</span>nix<span class="regexp">/store/</span>di389pfcw2krnmh8nmkn55d1rnzmba37-CMake-Cookbook<span class="regexp">/lib64:/</span>nix<span class="regexp">/store/</span>di389pfcw2krnmh8nmkn55d1rnzmba37-CMake-Cookbook<span class="regexp">/lib:/</span>nix<span class="regexp">/store/</span>mjs2b8mmid86lvbzibzdlz8w5yrjgcnf-util-linux<span class="number">-2.31</span><span class="number">.1</span><span class="regexp">/lib:/</span>nix<span class="regexp">/store/</span><span class="number">2</span>kcrj1ksd2a14bm5sky182fv2xwfhfap-glibc<span class="number">-2.26</span><span class="number">-131</span><span class="regexp">/lib:/</span>nix<span class="regexp">/store/</span><span class="number">4</span>zd34747fz0ggzzasy4icgn3lmy89pra-gcc<span class="number">-7.3</span><span class="number">.0</span>-lib/lib</span><br><span class="line">-- Running <span class="regexp">/home/</span>roberto<span class="regexp">/Software/</span>recipe<span class="number">-04</span><span class="regexp">/bin/</span><span class="string">use_message:</span></span><br><span class="line">This is my very nice <span class="string">message:</span></span><br><span class="line">Hello, World! From a client of yours!</span><br><span class="line">...and here is its <span class="string">UUID:</span> a8014bf7<span class="number">-5</span>dfa<span class="number">-45e2</span><span class="number">-8408</span><span class="number">-12e9</span>a5941825</span><br><span class="line">This is my very nice <span class="string">message:</span></span><br><span class="line">Goodbye, World! From a client of yours!</span><br><span class="line">...and here is its <span class="string">UUID:</span> ac971ef4<span class="number">-7606</span><span class="number">-460</span>f<span class="number">-9144</span><span class="number">-1</span>ad96f713647</span><br></pre></td></tr></table></figure>
<p><strong>NOTE</strong>:<em>我们建议使用的工具是PatchELF (<a href="https://nixos.org/patchelf.html" target="_blank" rel="noopener">https://nixos.org/patchelf.html</a> )、chrpath (<a href="https://linux.die.net/man/1/chrpath" target="_blank" rel="noopener">https://linux.die.net/man/1/chrpath</a> )和otool (<a href="http://www.manpagez.com/man/1/otool/" target="_blank" rel="noopener">http://www.manpagez.com/man/1/otool/</a> )。第一种方法适用于GNU/Linux和macOS，而chrpath和otool分别适用于GNU/Linux和macOS。</em></p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2021/03/100662.html" class="pre-post btn btn-default" title='CMake 完整使用教程 之十二 打包项目'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之十二 打包项目</span>
        </a>
    
    
        <a href="/archives/2021/03/100660.html" class="next-post btn btn-default" title='CMake 完整使用教程 之十 语言混合项目'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之十 语言混合项目</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#10-1-安装项目"><span class="toc-text">10.1 安装项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理"><span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#目标属性和RPATH处理"><span class="toc-text">目标属性和RPATH处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装指令"><span class="toc-text">安装指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-2-生成输出头文件"><span class="toc-text">10.2 生成输出头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-1"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-1"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-1"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-1"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-3-输出目标"><span class="toc-text">10.3 输出目标</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-2"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-2"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-2"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-2"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-4-安装超级构建"><span class="toc-text">10.4 安装超级构建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-3"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-3"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-3"><span class="toc-text">工作原理</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2024&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>