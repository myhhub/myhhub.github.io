<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="c++,cmake,qt">


    <meta name="description" content="在本书的最后一章中，我们将结合前几章中讨论过的许多不同的构建块，并将它们应用到实际项目中。我们的目标是一步一步地演示如何将一个重要的项目使用CMake进行构建。提供关于移植项目或将CMake添加...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>CMake 完整使用教程 之十六 使用CMake构建已有项目 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="CMake 完整使用教程 之十六 使用CMake构建已有项目">
            
	            CMake 完整使用教程 之十六 使用CMake构建已有项目
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/c/">c++</a> <a class="tag-link" href="/tags/cmake/">cmake</a> <a class="tag-link" href="/tags/qt/">qt</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2021/03/29</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>904</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>在本书的最后一章中，我们将结合前几章中讨论过的许多不同的构建块，并将它们应用到实际项目中。我们的目标是一步一步地演示如何将一个重要的项目使用CMake进行构建。提供关于移植项目或将CMake添加到遗留代码的建议(无论是来自Autotools、手工编写的配置脚本和Makefile，还是来自Visual Studio)。</p>
<p>为了得到一个实际示例，我们将使用Vim编辑器(<a href="https://www.vim.org/" target="_blank" rel="noopener">https://www.vim.org</a> )的源代码，并尝试将配置和编译，从Autotools迁移到CMake。</p>
<p>为了使讨论和示例相对简单，我们不会将整个Vim项目迁移到CMake，而是挑出最重要的部分。只构建Vim的核心版本，不支持图形用户界面(GUI)。我们将获取能够编译的Vim源码版本，并使用CMake，用书中介绍的其他工具进行配置、构建和测试。</p>
<p>本章主要有以下内容：</p>
<ul>
<li>如何开始迁移项目</li>
<li>生成文件并编写平台检查</li>
<li>检测所需的依赖关系和链接</li>
<li>复制编译标志</li>
<li>移植测试</li>
<li>移植安装目标</li>
<li>项目转换为CMake的常见问题</li>
</ul>
<h1 id="15-1-如何开始迁移项目"><a href="#15-1-如何开始迁移项目" class="headerlink" title="15.1 如何开始迁移项目"></a>15.1 如何开始迁移项目</h1><p>我们将首先说明，在哪里可以找到我们的示例，然后对移植，进行逐步的讨论。</p>
<h2 id="复制要移植的示例"><a href="#复制要移植的示例" class="headerlink" title="复制要移植的示例"></a>复制要移植的示例</h2><p>我们将从Vim源代码库的v8.1.0290发行标记开始(<a href="https://github.com/vim/vim" target="_blank" rel="noopener">https://github.com/vim/vim</a>) ，我们的工作基于Git提交哈希值b476cb7进行。 通过克隆Vim的源代码库并检出特定版本的代码，可以复制以下步骤:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --single-branch -<span class="keyword">b</span> v8.<span class="number">1.0290</span> http<span class="variable">s:</span>//github.<span class="keyword">com</span>/<span class="keyword">vim</span>/<span class="keyword">vim</span>.git</span><br></pre></td></tr></table></figure>
<p>或者，我们的解决方案可以在<code>cmake-support</code>分支上找到，网址是 <a href="https://github.com/dev-cafe/vim" target="_blank" rel="noopener">https://github.com/dev-cafe/vim</a> ，并使用以下方法克隆下来:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">clone</span> <span class="title">--single-branch</span> -b cmake-support https://github.com/dev-cafe/vim</span><br></pre></td></tr></table></figure>
<p>在本例中，我们将使用CMake模拟<code>./configure --enable-gui=no</code>的配置方式。</p>
<p>为了与后面的解决方案进行比较，建议读者也可以研究以下Neovim项目(<a href="https://github.com/neovim/neovim" target="_blank" rel="noopener">https://github.com/neovim/neovim</a> )，这是传统Vi编辑器的一个分支，提供了一个CMake构建系统。</p>
<h2 id="创建一个主CMakeLists-txt"><a href="#创建一个主CMakeLists-txt" class="headerlink" title="创建一个主CMakeLists.txt"></a>创建一个主CMakeLists.txt</h2><p>首先，我们在源代码存储库的根目录中创建主<code>CMakeLists.txt</code>，在这里我们设置了最低CMake版本、项目名称和支持的语言，在本例中是C：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(<span class="name">VERSION</span></span><br><span class="line"><span class="number">3.5</span> FATAL_ERROR)</span><br><span class="line">project(<span class="name">vim</span> LANGUAGES C)</span><br></pre></td></tr></table></figure>
<p>添加任何目标或源之前，可以设置默认的构建类型。本例中，我们默认为Release配置，这将打开某些编译器优化选项:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT CMAKE_BUILD_TYPE)</span></span></span><br><span class="line">	set(CMAKE_BUILD_TYPE Release CACHE STRING <span class="string">"Build type"</span> FORCE)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>我们也使用可移植的安装目录变量：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include(GNUInstallDirs)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>)</span><br><span class="line"><span class="builtin-name">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY</span><br><span class="line">	<span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>作为一个完整性检查，我们可以尝试配置和构建项目，但到目前为止还没有目标，所以构建步骤的输出是空的:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir -p build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake ..</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmake --build .</span></span><br></pre></td></tr></table></figure>
<p>我们一会儿就要开始添加目标了。</p>
<h2 id="如何让常规和CMake配置共存"><a href="#如何让常规和CMake配置共存" class="headerlink" title="如何让常规和CMake配置共存"></a>如何让常规和CMake配置共存</h2><p>CMake的一个特性是在源代码之外构建，构建目录可以是任何目录，而不必是项目目录的子目录。这意味着，我们可以将一个项目移植到CMake，而不影响以前/现在的配置和构建机制。对于一个重要项目的迁移，CMake文件可以与其他构建框架共存，从而允许一个渐进的迁移，包括选项、特性和可移植性，并允许开发社区人员适应新的框架。为了允许传统配置和CMake配置共存一段时间，一个典型的策略是收集<code>CMakeLists.txt</code>文件中的所有CMake代码，以及CMake子目录下的所有辅助CMake源文件的示例中，我们不会引入CMake子目录，而是保持辅助文件要求他们接近目标和来源，但会顾及使用的传统Autotools构建修改的所有文件，但有一个例外：我们将一些修改自动生成文件构建目录下，而不是在源代码树中。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> ./configure --enable-gui=<span class="keyword">no</span></span><br><span class="line"></span><br><span class="line">... lot of output ...</span><br><span class="line"></span><br><span class="line"><span class="symbol">$</span> make &gt; build.<span class="built-in">log</span></span><br></pre></td></tr></table></figure>
<p>我们的示例中(这里没有显示build.log的内容)，我们能够验证编译了哪些源文件以及使用了哪些编译标志(<code>-I. -Iproto -DHAVE_CONFIG_H -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1</code>)。日志文件中，我们可以做如下推断:</p>
<ul>
<li>所有对象文件都链接到二进制文件中</li>
<li>不生成库</li>
<li>可执行目标与下列库进行连接:<code>-lSM -lICE -lXpm -lXt -lX11 -lXdmcp -lSM -lICE -lm -ltinfo -lelf -lnsl -lacl -lattr -lgpm -ldl</code></li>
</ul>
<p>通过在使用<code>message</code>对工程进行调试时，选择添加选项、目标、源和依赖项，我们将逐步实现一个可工作的构建。</p>
<h2 id="获取传统构建的记录"><a href="#获取传统构建的记录" class="headerlink" title="获取传统构建的记录"></a>获取传统构建的记录</h2><p>向配置添加任何目标之前，通常有必要看看传统构建的行为，并将配置和构建步骤的输出保存到日志文件中。对于我们的Vim示例，可以使用以下方法实现:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> ./configure --enable-gui=<span class="keyword">no</span></span><br><span class="line"></span><br><span class="line">... lot of output ...</span><br><span class="line"></span><br><span class="line"><span class="symbol">$</span> make &gt; build.<span class="built-in">log</span></span><br></pre></td></tr></table></figure>
<p>示例中(这里没有显示build.log的完整内容)，我们能够验证编译了哪些源文件以及使用了哪些编译标志(<code>-I.-Iproto -DHAVE_CONFIG_H -g -O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1</code>)。从日志文件中，推断如下:</p>
<ul>
<li>所有对象文件都链接到一个二进制文件中</li>
<li>没有生成库</li>
<li>可执行目标链接到以下库:<code>-lSM -lXpm -lXt -lX11 -lXdmcp -lSM -lSM - linfo -lelf -lnsl -lacl -lattr -lgpm -ldl</code></li>
</ul>
<h2 id="调试迁移项目"><a href="#调试迁移项目" class="headerlink" title="调试迁移项目"></a>调试迁移项目</h2><p>当目标和命令逐渐移动到CMake端时，使用<code>message</code>命令打印变量的值就非常有用了:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"for debugging printing the value of $&#123;some_variable&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>在使用消息进行调试时，添加选项、目标、源和依赖项，我们将逐步实现一个可工作的构建。</p>
<h2 id="实现选项"><a href="#实现选项" class="headerlink" title="实现选项"></a>实现选项</h2><p>找出传统配置为用户提供的选项(例如，通过<code>./configure --help</code>)。Vim项目提供了一个非常长的选项和标志列表，为了使本章的讨论保持简单，我们只在CMake端实现四个选项:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--disable-netbeans <span class="builtin-name">Disable</span> NetBeans integration support.</span><br><span class="line">--disable-channel <span class="builtin-name">Disable</span> process communication support.</span><br><span class="line">--enable-terminal <span class="builtin-name">Enable</span> terminal emulation support.</span><br><span class="line"><span class="attribute">--with-features</span>=TYPE tiny, small, normal, big <span class="keyword">or</span> huge (default: huge)</span><br></pre></td></tr></table></figure>
<p>我们还将忽略任何GUI支持和模拟<code>--enable-gui=no</code>，因为它将使示例复杂化。</p>
<p>我们将在CMakeLists.txt中添加以下选项(有默认值)：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">option</span><span class="params">(ENABLE_NETBEANS <span class="string">"Enable netbeans"</span> ON)</span></span></span><br><span class="line"><span class="function"><span class="title">option</span><span class="params">(ENABLE_CHANNEL <span class="string">"Enable channel"</span> ON)</span></span></span><br><span class="line"><span class="function"><span class="title">option</span><span class="params">(ENABLE_TERMINAL <span class="string">"Enable terminal"</span> ON)</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以用<code>cmake -D FEATURES=value</code>定义的变量<code>FEATURES</code>来模拟<code>--with-features</code>标志。如果不进行设置，它默认值为”huge”:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT FEATURES)</span></span></span><br><span class="line">	set(FEATURES <span class="string">"huge"</span> CACHE STRING</span><br><span class="line"><span class="string">"FEATURES chosen by the user at CMake configure time"</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>我们为使用者提供了一个值<code>FEATURES</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">list</span><span class="params">(APPEND _available_features <span class="string">"tiny"</span> <span class="string">"small"</span> <span class="string">"normal"</span> <span class="string">"big"</span> <span class="string">"huge"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT FEATURES IN_LIST _available_features)</span></span></span><br><span class="line">	message(FATAL_ERROR <span class="string">"Unknown features: \"$&#123;FEATURES&#125;\". Allowed values are: $&#123;_available_features&#125;."</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">set_property</span><span class="params">(CACHE FEATURES PROPERTY STRINGS $&#123;_available_features&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>最后一行<code>set_property(CACHE FEATURES PROPERTY STRINGS ${_available_features})</code>，当使用<code>cmake-gui</code>配置项目，则有有不错的效果，用户可根据选择字段清单，选择已经定义了的<code>FEATURES</code>(参见<a href="https://blog.kitware.com/constraining-values-with-comboboxes-in-cmake-cmake-gui/" target="_blank" rel="noopener">https://blog.kitware.com/constraining-values-with-comboboxes-in-cmake-cmake-gui/</a> )。</p>
<p>选项可以放在主<code>CMakeLists.txt</code>中，也可以在查询<code>ENABLE_NETBEANS</code>、<code>ENABLE_CHANNEL</code>、<code>ENABLE_TERMINAL</code>和<code>FEATURES</code>的定义附近。前一种策略的优点是，选项列在一个地方，不需要遍历<code>CMakeLists.txt</code>文件来查找选项的定义。因为我们还没有定义任何目标，所以可以先将选项保存在一个文件中，但是稍后会将选项移到离目标更近的地方，通过本地化作用域，得到可重用的CMake构建块。</p>
<h2 id="从可执行的目标开始，进行本地化"><a href="#从可执行的目标开始，进行本地化" class="headerlink" title="从可执行的目标开始，进行本地化"></a>从可执行的目标开始，进行本地化</h2><p>让我们添加一些源码。在Vim示例中，源文件位于<code>src</code>下，为了保持主<code>CMakeLists.txt</code>的可读性和可维持性，我们将创建一个新文件<code>src/CMakeLists.txt</code>，并将其添加到主<code>CMakeLists.txt</code>中，从而可以在自己的目录范围内处理该文件:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(src)</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>src/CMakeLists.txt</code>中，可以定义可执行目标，并列出从<code>build.log</code>中获取所有源码:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_executable(vim</span><br><span class="line">  arabic.<span class="keyword">c</span> beval.<span class="keyword">c</span> buffer.<span class="keyword">c</span> blowfish.<span class="keyword">c</span> crypt.<span class="keyword">c</span> crypt_zip.<span class="keyword">c</span> dict.<span class="keyword">c</span> diff.<span class="keyword">c</span> digraph.<span class="keyword">c</span> edit.<span class="keyword">c</span> eval.<span class="keyword">c</span> evalfunc.<span class="keyword">c</span> ex_cmds.<span class="keyword">c</span> ex_cmds<span class="number">2</span>.<span class="keyword">c</span> ex_docmd.<span class="keyword">c</span> ex_eval.<span class="keyword">c</span> ex_getln.<span class="keyword">c</span> farsi.<span class="keyword">c</span> fileio.<span class="keyword">c</span> fold.<span class="keyword">c</span> getchar.<span class="keyword">c</span> hardcopy.<span class="keyword">c</span> hashtab.<span class="keyword">c</span> if_cscope.<span class="keyword">c</span> if_xcmdsrv.<span class="keyword">c</span> list.<span class="keyword">c</span> mark.<span class="keyword">c</span> memline.<span class="keyword">c</span> menu.<span class="keyword">c</span> misc<span class="number">1</span>.<span class="keyword">c</span> misc<span class="number">2</span>.<span class="keyword">c</span> move.<span class="keyword">c</span> mbyte.<span class="keyword">c</span> normal.<span class="keyword">c</span> ops.<span class="keyword">c</span> option.<span class="keyword">c</span> os_unix.<span class="keyword">c</span> auto/pathdef.<span class="keyword">c</span> popupmnu.<span class="keyword">c</span> pty.<span class="keyword">c</span> quickfix.<span class="keyword">c</span> regexp.<span class="keyword">c</span> screen.<span class="keyword">c</span> search.<span class="keyword">c</span> sha<span class="number">256</span>.<span class="keyword">c</span> spell.<span class="keyword">c</span> spellfile.<span class="keyword">c</span> syntax.<span class="keyword">c</span> tag.<span class="keyword">c</span> term.<span class="keyword">c</span> terminal.<span class="keyword">c</span> ui.<span class="keyword">c</span> undo.<span class="keyword">c</span> userfunc.<span class="keyword">c</span> window.<span class="keyword">c</span> libvterm/src/encoding.<span class="keyword">c</span> libvterm/src/keyboard.<span class="keyword">c</span> libvterm/src/mouse.<span class="keyword">c</span> libvterm/src/parser.<span class="keyword">c</span> libvterm/src/pen.<span class="keyword">c</span> libvterm/src/screen.<span class="keyword">c</span> libvterm/src/state.<span class="keyword">c</span> libvterm/src/unicode.<span class="keyword">c</span> libvterm/src/vterm.<span class="keyword">c</span> netbeans.<span class="keyword">c</span> channel.<span class="keyword">c</span> charset.<span class="keyword">c</span> json.<span class="keyword">c</span> main.<span class="keyword">c</span> memfile.<span class="keyword">c</span> message.<span class="keyword">c</span> version.<span class="keyword">c</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>这是一个开始。这种情况下，代码甚至不会配置，因为源列表包含生成的文件。讨论生成文件和链接依赖项之前，我们把这一长列表拆分一下，以限制目标依赖项的范围，并使项目更易于管理。如果我们将它们分组到目标，这将使CMake更容易地找到源文件依赖项，并避免很长的链接行。</p>
<p>对于Vim示例，我们可以进一步了解来自<code>src/Makefile</code>和<code>src/configure.ac</code>的源码文件进行分组。这些文件中，大多数源文件都是必需的。有些源文件是可选的(<code>netbeans.c</code>应该只在<code>ENABLE_NETBEANS</code>打开时构建，而<code>channel.c</code>应该只在<code>ENABLE_CHANNEL</code>打开时构建)。此外，我们可以将所有源代码分组到<code>src/libvterm/</code>下，并使用<code>ENABLE_TERMINAL</code>可选地编译它们。</p>
<p>这样，我们将CMake结构重组，构成如下的树结构：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── libvterm</span><br><span class="line">        └── CMakeLists.txt</span><br></pre></td></tr></table></figure>
<p>顶层文件使用<code>add_subdirectory(src)</code>添加<code>src/CMakeLists.txt</code>。<code>src/CMakeLists.txt</code>文件包含三个目标(一个可执行文件和两个库)，每个目标都带有编译定义和包含目录。首先定义可执行文件：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">vim</span></span><br><span class="line">  main.c</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_compile_definitions(<span class="name">vim</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="string">"HAVE_CONFIG_H"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>然后，定义一些需要源码文件的目标:</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">add_library(basic_sources <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">target_sources(basic_sources</span><br><span class="line">  PRIVATE</span><br><span class="line">    arabic.<span class="keyword">c</span> beval.<span class="keyword">c</span> blowfish.<span class="keyword">c</span> buffer.<span class="keyword">c</span> charset.<span class="keyword">c</span></span><br><span class="line">    crypt.<span class="keyword">c</span> crypt_zip.<span class="keyword">c</span> dict.<span class="keyword">c</span> diff.<span class="keyword">c</span> digraph.<span class="keyword">c</span></span><br><span class="line">    edit.<span class="keyword">c</span> eval.<span class="keyword">c</span> evalfunc.<span class="keyword">c</span> ex_cmds.<span class="keyword">c</span> ex_cmds<span class="number">2</span>.<span class="keyword">c</span></span><br><span class="line">    ex_docmd.<span class="keyword">c</span> ex_eval.<span class="keyword">c</span> ex_getln.<span class="keyword">c</span> farsi.<span class="keyword">c</span> fileio.<span class="keyword">c</span></span><br><span class="line">    fold.<span class="keyword">c</span> getchar.<span class="keyword">c</span> hardcopy.<span class="keyword">c</span> hashtab.<span class="keyword">c</span> if_cscope.<span class="keyword">c</span></span><br><span class="line">    if_xcmdsrv.<span class="keyword">c</span> json.<span class="keyword">c</span> list.<span class="keyword">c</span> main.<span class="keyword">c</span> mark.<span class="keyword">c</span></span><br><span class="line">    memfile.<span class="keyword">c</span> memline.<span class="keyword">c</span> menu.<span class="keyword">c</span> message.<span class="keyword">c</span> misc<span class="number">1</span>.<span class="keyword">c</span></span><br><span class="line">    misc<span class="number">2</span>.<span class="keyword">c</span> move.<span class="keyword">c</span> mbyte.<span class="keyword">c</span> normal.<span class="keyword">c</span> ops.<span class="keyword">c</span></span><br><span class="line">    option.<span class="keyword">c</span> os_unix.<span class="keyword">c</span> auto/pathdef.<span class="keyword">c</span> popupmnu.<span class="keyword">c</span> pty.<span class="keyword">c</span></span><br><span class="line">    quickfix.<span class="keyword">c</span> regexp.<span class="keyword">c</span> screen.<span class="keyword">c</span> search.<span class="keyword">c</span> sha<span class="number">256</span>.<span class="keyword">c</span></span><br><span class="line">    spell.<span class="keyword">c</span> spellfile.<span class="keyword">c</span> syntax.<span class="keyword">c</span> tag.<span class="keyword">c</span> term.<span class="keyword">c</span></span><br><span class="line">    terminal.<span class="keyword">c</span> ui.<span class="keyword">c</span> undo.<span class="keyword">c</span> userfunc.<span class="keyword">c</span> version.<span class="keyword">c</span></span><br><span class="line">    window.<span class="keyword">c</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_include_directories(basic_sources</span><br><span class="line">  PRIVATE</span><br><span class="line">    $&#123;CMAKE_CURRENT_LIST_DIR&#125;/proto</span><br><span class="line">    $&#123;CMAKE_CURRENT_LIST_DIR&#125;</span><br><span class="line">    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_compile_definitions(basic_sources</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="string">"HAVE_CONFIG_H"</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_link_libraries(vim</span><br><span class="line">  PUBLIC</span><br><span class="line">  	basic_sources</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>然后，定义一些可选源码文件的目标:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(extra_sources <span class="string">""</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(ENABLE_NETBEANS)</span></span></span><br><span class="line">  target_sources(extra_sources</span><br><span class="line">    PRIVATE</span><br><span class="line">    	netbeans.c</span><br><span class="line">    )</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(ENABLE_CHANNEL)</span></span></span><br><span class="line">  target_sources(extra_sources</span><br><span class="line">    PRIVATE</span><br><span class="line">    	channel.c</span><br><span class="line">    )</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">target_include_directories(extra_sources</span><br><span class="line">  PUBLIC</span><br><span class="line">    $&#123;CMAKE_CURRENT_LIST_DIR&#125;/proto</span><br><span class="line">    $&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_compile_definitions(extra_sources</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="string">"HAVE_CONFIG_H"</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_link_libraries(vim</span><br><span class="line">  PUBLIC</span><br><span class="line">  	extra_sources</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>使用以下代码，对连接<code>src/libvterm/</code>子目录进行选择:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">ENABLE_TERMINAL</span>)</span><br><span class="line">  add_subdirectory(<span class="name">libvterm</span>)</span><br><span class="line">  </span><br><span class="line">  target_link_libraries(<span class="name">vim</span></span><br><span class="line">    PUBLIC</span><br><span class="line">    	libvterm</span><br><span class="line">    )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p>对应的<code>src/libvterm/CMakeLists.txt</code>包含以下内容:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_library</span><span class="params">(libvterm <span class="string">""</span>)</span></span></span><br><span class="line"></span><br><span class="line">target_sources(libvterm</span><br><span class="line">  PRIVATE</span><br><span class="line">    src/encoding.c</span><br><span class="line">    src/keyboard.c</span><br><span class="line">    src/mouse.c</span><br><span class="line">    src/parser.c</span><br><span class="line">    src/pen.c</span><br><span class="line">    src/screen.c</span><br><span class="line">    src/state.c</span><br><span class="line">    src/unicode.c</span><br><span class="line">    src/vterm.c</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_include_directories(libvterm</span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&#123;CMAKE_CURRENT_LIST_DIR&#125;/include</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_compile_definitions(libvterm</span><br><span class="line">  PRIVATE</span><br><span class="line">    <span class="string">"HAVE_CONFIG_H"</span></span><br><span class="line">    <span class="string">"INLINE="</span></span><br><span class="line">    <span class="string">"VSNPRINTF=vim_vsnprintf"</span></span><br><span class="line">    <span class="string">"IS_COMBINING_FUNCTION=utf_iscomposing_uint"</span></span><br><span class="line">    <span class="string">"WCWIDTH_FUNCTION=utf_uint2cells"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>我们已经从<code>build.log</code>中获取了编译信息。树结构的优点是，目标的定义靠近源的位置。如果我们决定重构代码并重命名或移动目录，描述目标的CMake文件就会随着源文件一起移动。</p>
<p>我们的示例代码还没有配置(除非在成功的Autotools构建之后尝试配置)，现在来试试:</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ <span class="keyword">cd</span> build</span><br><span class="line">$ cmake <span class="string">..</span></span><br><span class="line"></span><br><span class="line">-- The C compiler identification is GNU 8.2.0</span><br><span class="line">-- Check for working C compiler: <span class="string">/usr/bin/cc</span></span><br><span class="line">-- Check for working C compiler: <span class="string">/usr/bin/cc</span> -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - done</span><br><span class="line">-- Configuring done</span><br><span class="line">CMake Error at src/CMakeLists.txt<span class="function">:12</span> <span class="params">(add_library)</span>:</span><br><span class="line">Cannot find source file:</span><br><span class="line">auto/pathdef.c</span><br><span class="line">Tried extensions <span class="string">.c</span> <span class="string">.C</span> <span class="string">.c</span>++ <span class="string">.cc</span> <span class="string">.cpp</span> <span class="string">.cxx</span> <span class="string">.cu</span> <span class="string">.m</span> <span class="string">.M</span> <span class="string">.mm</span> <span class="string">.h</span> <span class="string">.hh</span> <span class="string">.h</span>++ <span class="string">.hm</span></span><br><span class="line"><span class="string">.hpp</span> <span class="string">.hxx</span> <span class="string">.in</span> <span class="string">.txx</span></span><br></pre></td></tr></table></figure>
<p>这里需要生成<code>auto/pathdef.c</code>(和其他文件)，我们将在下一节中考虑这些文件。</p>
<h1 id="15-2-生成文件并编写平台检查"><a href="#15-2-生成文件并编写平台检查" class="headerlink" title="15.2 生成文件并编写平台检查"></a>15.2 生成文件并编写平台检查</h1><p>对于Vim示例，我们需要在配置时生成三个文件，<code>src/auto/pathdef.c</code>、<code>src/auto/config.h</code>和<code>src/auto/osdef.h</code>:</p>
<ul>
<li>pathdef.c：记录安装路径、编译/链接标志、当前用户和主机名</li>
<li>config.h：编译系统的环境</li>
<li>osdef.h：由<code>src/osdef.sh</code>生成的文件</li>
</ul>
<p>这种情况相当普遍。需要CMake配置文件，配置时执行一个脚本，执行许多平台检查命令，来生成<code>config.h</code>。特别是，对于那些可移植的项目，平台检查非常普遍。</p>
<p>在原始目录树中，文件在<code>src</code>文件夹下生成。而我们将使用不同的方法：这些文件会生成在<code>build</code>目录中。这样做的原因是生成的文件通常依赖于所选择的选项、编译器或构建类型，我们希望保持同一个源，可以适配多个构建。要在<code>build</code>目录中启用生成，我们必须对生成文件的脚本进行改动。</p>
<h2 id="构造文件"><a href="#构造文件" class="headerlink" title="构造文件"></a>构造文件</h2><p>我们将把与生成文件相关的函数集中放在<code>src/autogenerate.cmake</code>中。在定义可执行目标之前，在<code>src/CMakeLists.txt</code>中调用这些函数:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">generate</span> <span class="keyword">config</span><span class="variable">.h</span>, pathdef<span class="variable">.c</span>, <span class="keyword">and</span> osdef<span class="variable">.h</span></span><br><span class="line"><span class="keyword">include</span>(autogenerate<span class="variable">.cmake</span>)</span><br><span class="line">generate_config_h()</span><br><span class="line">generate_pathdef_c()</span><br><span class="line">generate_osdef_h()</span><br><span class="line"></span><br><span class="line">add_executable(vim</span><br><span class="line">  	main<span class="variable">.c</span></span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>
<p><code>src/autogenerate.cmake</code>中包含了其他检测头文件、函数和库等几个函数:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">include(CheckTypeSize)</span><br><span class="line">include(CheckFunctionExists)</span><br><span class="line">include(CheckIncludeFiles)</span><br><span class="line">include(CheckLibraryExists)</span><br><span class="line">include(CheckCSourceCompiles)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(generate_config_h)</span></span></span><br><span class="line">	# ... <span class="keyword">to</span> <span class="keyword">be</span> written</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(generate_pathdef_c)</span></span></span><br><span class="line">	# ... <span class="keyword">to</span> <span class="keyword">be</span> written</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(generate_osdef_h)</span></span></span><br><span class="line">	# ... <span class="keyword">to</span> <span class="keyword">be</span> written</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>
<p>我们选择了一些用于生成文件的函数，而不是用宏或“裸”CMake代码。在前几章中讨论过的，这是避免了一些问题：</p>
<ul>
<li>避免多次生成文件，以防多次包含模块。我们可以使用一个包含保护来防止意外地多次运行代码。</li>
<li>保证了对函数中变量范围的完全控制。这避免了这些定义溢出，从而出现变量污染的情况。</li>
</ul>
<h2 id="根据系统配置预处理宏定义"><a href="#根据系统配置预处理宏定义" class="headerlink" title="根据系统配置预处理宏定义"></a>根据系统配置预处理宏定义</h2><p><code>config.h</code>文件以<code>src/config.h.in</code>为目标所生成的，其中包含根据系统功能配置的预处理标志:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define if we have EBCDIC code */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> EBCDIC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define unless no X support found */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> HAVE_X11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define when terminfo support found */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> TERMINFO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define when termcap.h contains ospeed */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> HAVE_OSPEED</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
<p>生成的<code>src/config.h</code>示例类似如下情况(定义可以根据环境的不同而不同):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define if we have EBCDIC code */</span></span><br><span class="line"><span class="comment">/* #undef EBCDIC */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define unless no X support found */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_X11 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define when terminfo support found */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TERMINFO 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Define when termcap.h contains ospeed */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* #undef HAVE_OSPEED */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>
<p>这个页面是一个很好的平台检查示例: <a href="https://gitlab.kitware.com/cmake/community/wikis/doc/tutorials/How-To-Write-Platform-Checks" target="_blank" rel="noopener">https://gitlab.kitware.com/cmake/community/wikis/doc/tutorials/How-To-Write-Platform-Checks</a></p>
<p>在<code>src/configure.ac</code>中，我们可以检查需要执行哪些平台检查，从而来设置相应的预处理定义。</p>
<p>我们将使用<code>#cmakedefine</code>(<a href="https://cmake.org/cmake/help/v3.5/command/configure_file.html?highlight=cmakedefine" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.5/command/configure_file.html?highlight=cmakedefine</a> )为了确保不破坏现有的Autotools构建，我们将复制<code>config.h.in</code>为<code>config.h.cmake.in</code>，并将所有<code>#undef SOME_DEFINITION</code>更改为<code>#cmakedefine SOME_DEFINITION @SOME_DEFINITION@</code>。</p>
<p>在<code>generate_config_h</code>函数中，先定义两个变量：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span>(TERMINFO 1)</span><br><span class="line"><span class="builtin-name">set</span>(UNIX 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># this is hardcoded to keep the discussion in the book chapter</span></span><br><span class="line"><span class="comment"># which describes the migration to CMake simpler</span></span><br><span class="line"><span class="builtin-name">set</span>(TIME_WITH_SYS_TIME 1)</span><br><span class="line"><span class="builtin-name">set</span>(RETSIGTYPE void)</span><br><span class="line"><span class="builtin-name">set</span>(SIGRETURN return)</span><br><span class="line"></span><br><span class="line">find_package(X11)</span><br><span class="line"><span class="builtin-name">set</span>(HAVE_X11 <span class="variable">$&#123;X11_FOUND&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>然后，我们执行几个类型检查:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">check_type_size</span><span class="params">(<span class="string">"int"</span> VIM_SIZEOF_INT)</span></span></span><br><span class="line"><span class="function"><span class="title">check_type_size</span><span class="params">(<span class="string">"long"</span> VIM_SIZEOF_LONG)</span></span></span><br><span class="line"><span class="function"><span class="title">check_type_size</span><span class="params">(<span class="string">"time_t"</span> SIZEOF_TIME_T)</span></span></span><br><span class="line"><span class="function"><span class="title">check_type_size</span><span class="params">(<span class="string">"off_t"</span> SIZEOF_OFF_T)</span></span></span><br></pre></td></tr></table></figure>
<p>然后，我们对函数进行循环，检查系统是否能够解析:</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">foreach</span>(</span><br><span class="line">  _<span class="meta">function</span> IN <span class="keyword">ITEMS</span></span><br><span class="line"><span class="keyword"> </span> fchdir fchown fchmod fsync getcwd getpseudotty</span><br><span class="line">  getpwent getpwnam getpwuid getrlimit gettimeofday getwd lstat</span><br><span class="line">  memset mkdtemp nanosleep opendir putenv qsort readlink <span class="keyword">select </span>setenv</span><br><span class="line">  getpgid setpgid setsid sigaltstack sigstack sigset sigsetjmp sigaction</span><br><span class="line">  sigprocmask sigvec <span class="keyword">strcasecmp </span><span class="keyword">strerror </span><span class="keyword">strftime </span><span class="keyword">stricmp </span><span class="keyword">strncasecmp</span></span><br><span class="line"><span class="keyword"> </span> <span class="keyword">strnicmp </span><span class="keyword">strpbrk </span><span class="keyword">strtol </span>towlower towupper iswupper</span><br><span class="line">  usleep utime utimes mblen ftruncate</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">string(TOUPPER </span><span class="string">"$&#123;_function&#125;"</span> _function_uppercase)</span><br><span class="line">  check_function_exists($&#123;_<span class="meta">function</span>&#125; HAVE_$&#123;_function_uppercase&#125;)</span><br><span class="line"><span class="symbol">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>验证库是否包含特定函数:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">check_library_exists</span><span class="params">(tinfo tgetent <span class="string">""</span> HAVE_TGETENT)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT HAVE_TGETENT)</span></span></span><br><span class="line">	message(FATAL_ERROR <span class="string">"Could not find the tgetent() function. You need to install a terminal library; for example ncurses."</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>然后，我们循环头文件，检查它们是否可用:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">foreach(</span><br><span class="line">  _header IN ITEMS</span><br><span class="line">  setjmp<span class="selector-class">.h</span> dirent.h</span><br><span class="line">  stdint<span class="selector-class">.h</span> stdlib<span class="selector-class">.h</span> string.h</span><br><span class="line">  sys/select<span class="selector-class">.h</span> sys/utsname<span class="selector-class">.h</span> termcap<span class="selector-class">.h</span> fcntl.h</span><br><span class="line">  sgtty<span class="selector-class">.h</span> sys/ioctl<span class="selector-class">.h</span> sys/<span class="selector-tag">time</span><span class="selector-class">.h</span> sys/types.h</span><br><span class="line">  termio<span class="selector-class">.h</span> iconv<span class="selector-class">.h</span> inttypes<span class="selector-class">.h</span> langinfo<span class="selector-class">.h</span> math.h</span><br><span class="line">  unistd<span class="selector-class">.h</span> stropts<span class="selector-class">.h</span> errno<span class="selector-class">.h</span> sys/resource.h</span><br><span class="line">  sys/systeminfo<span class="selector-class">.h</span> locale<span class="selector-class">.h</span> sys/stream<span class="selector-class">.h</span> termios.h</span><br><span class="line">  libc<span class="selector-class">.h</span> sys/statfs<span class="selector-class">.h</span> poll<span class="selector-class">.h</span> sys/poll<span class="selector-class">.h</span> pwd.h</span><br><span class="line">  utime<span class="selector-class">.h</span> sys/param<span class="selector-class">.h</span> libintl<span class="selector-class">.h</span> libgen.h</span><br><span class="line">  util/debug<span class="selector-class">.h</span> util/msg18n<span class="selector-class">.h</span> frame<span class="selector-class">.h</span> sys/acl.h</span><br><span class="line">  sys/access<span class="selector-class">.h</span> sys/sysinfo<span class="selector-class">.h</span> wchar<span class="selector-class">.h</span> wctype.h</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  string(TOUPPER <span class="string">"$&#123;_header&#125;"</span> _header_uppercase)</span><br><span class="line">  string(REPLACE <span class="string">"/"</span> <span class="string">"_"</span> _header_normalized <span class="string">"$&#123;_header_uppercase&#125;"</span>)</span><br><span class="line">  string(REPLACE <span class="string">"."</span> <span class="string">"_"</span> _header_normalized <span class="string">"$&#123;_header_normalized&#125;"</span>)</span><br><span class="line">  check_include_files($&#123;_header&#125; HAVE_$&#123;_header_normalized&#125;)</span><br><span class="line"><span class="function"><span class="title">endforeach</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>然后，我们将CMake选项从转换为预处理定义:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">string</span><span class="params">(TOUPPER <span class="string">"$&#123;FEATURES&#125;"</span> _features_upper)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(FEAT_$&#123;_features_upper&#125; <span class="number">1</span>)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(FEAT_NETBEANS_INTG $&#123;ENABLE_NETBEANS&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(FEAT_JOB_CHANNEL $&#123;ENABLE_CHANNEL&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(FEAT_TERMINAL $&#123;ENABLE_TERMINAL&#125;)</span></span></span><br></pre></td></tr></table></figure>
<p>最后，我们检查是否能够编译一个特定的代码片段:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">check_c_source_compiles(</span><br><span class="line">  "</span><br><span class="line">  #<span class="keyword">include</span> &lt;sys/types.<span class="keyword">h</span>&gt;</span><br><span class="line">  #<span class="keyword">include</span> &lt;sys/stat.<span class="keyword">h</span>&gt;</span><br><span class="line">  </span><br><span class="line">  int</span><br><span class="line">  main ()</span><br><span class="line">  &#123;</span><br><span class="line">    struct stat <span class="keyword">st</span>;</span><br><span class="line">    int <span class="keyword">n</span>;</span><br><span class="line">    stat(\<span class="string">"/\"</span>, &amp;<span class="keyword">st</span>);</span><br><span class="line">    <span class="keyword">n</span> = (int)<span class="keyword">st</span>.st_blksize;</span><br><span class="line">    ;</span><br><span class="line">    <span class="keyword">return</span> 0;</span><br><span class="line">  &#125;</span><br><span class="line">  "</span><br><span class="line">  HAVE_ST_BLKSIZE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>然后，使用定义的变量配置<code>src/config.h.cmake.in</code>生成<code>config.h</code>，其中包含<code>generate_config_h</code>函数：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure_file(</span><br><span class="line">  $&#123;CMAKE_CURRENT_LIST_DIR&#125;/config.h.cmake.<span class="keyword">in</span></span><br><span class="line">  $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/auto/config.h</span><br><span class="line">  @ONLY</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h2 id="使用路径和编译器标志配置文件"><a href="#使用路径和编译器标志配置文件" class="headerlink" title="使用路径和编译器标志配置文件"></a>使用路径和编译器标志配置文件</h2><p>从<code>src/pathdef.c.in</code>生成<code>pathdef.c</code>:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "vim.h"</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">char_u</span> *default_vim_dir = (char_u *)<span class="string">"<span class="variable">@_default_vim_dir</span>@"</span>;</span><br><span class="line"><span class="attribute">char_u</span> *default_vimruntime_dir = (char_u *)<span class="string">"<span class="variable">@_default_vimruntime_dir</span>@"</span>;</span><br><span class="line"><span class="attribute">char_u</span> *all_cflags = (char_u *)<span class="string">"<span class="variable">@_all_cflags</span>@"</span>;</span><br><span class="line"><span class="attribute">char_u</span> *all_lflags = (char_u *)<span class="string">"<span class="variable">@_all_lflags</span>@"</span>;</span><br><span class="line"><span class="attribute">char_u</span> *compiled_user = (char_u *)<span class="string">"<span class="variable">@_compiled_user</span>@"</span>;</span><br><span class="line"><span class="attribute">char_u</span> *compiled_sys = (char_u *)<span class="string">"<span class="variable">@_compiled_sys</span>@"</span>;</span><br></pre></td></tr></table></figure>
<p><code>generate_pathdef_c</code>函数在<code>src/pathdef.c.in</code>进行配置。为了简单起见，我们省略了链接标志:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function(generate_pathdef_c)</span><br><span class="line">  <span class="builtin-name">set</span>(_default_vim_dir <span class="variable">$&#123;CMAKE_INSTALL_PREFIX&#125;</span>)</span><br><span class="line">  <span class="builtin-name">set</span>(_default_vimruntime_dir <span class="variable">$&#123;_default_vim_dir&#125;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="builtin-name">set</span>(_all_cflags <span class="string">"<span class="variable">$&#123;CMAKE_C_COMPILER&#125;</span> <span class="variable">$&#123;CMAKE_C_FLAGS&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">if</span>(CMAKE_BUILD_TYPE STREQUAL <span class="string">"Release"</span>)</span><br><span class="line">  	<span class="builtin-name">set</span>(_all_cflags <span class="string">"<span class="variable">$&#123;_all_cflags&#125;</span> <span class="variable">$&#123;CMAKE_C_FLAGS_RELEASE&#125;</span>"</span>)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">  	<span class="builtin-name">set</span>(_all_cflags <span class="string">"<span class="variable">$&#123;_all_cflags&#125;</span> <span class="variable">$&#123;CMAKE_C_FLAGS_DEBUG&#125;</span>"</span>)</span><br><span class="line">  endif()</span><br><span class="line"></span><br><span class="line">  # it would require a bit more work <span class="keyword">and</span> execute commands at build time</span><br><span class="line">  # <span class="keyword">to</span> <span class="builtin-name">get</span> the link line into the binary</span><br><span class="line">  <span class="builtin-name">set</span>(_all_lflags <span class="string">"undefined"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(WIN32)</span><br><span class="line">  	<span class="builtin-name">set</span>(_compiled_user <span class="variable">$ENV</span>&#123;USERNAME&#125;)</span><br><span class="line">  <span class="keyword">else</span>()</span><br><span class="line">  	<span class="builtin-name">set</span>(_compiled_user <span class="variable">$ENV</span>&#123;USER&#125;)</span><br><span class="line">  endif()</span><br><span class="line"></span><br><span class="line">  cmake_host_system_information(RESULT _compiled_sys QUERY HOSTNAME)</span><br><span class="line"></span><br><span class="line">  configure_file(</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/pathdef.c.<span class="keyword">in</span></span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/auto/pathdef.c</span><br><span class="line">    @ONLY</span><br><span class="line">    )</span><br><span class="line">endfunction()</span><br></pre></td></tr></table></figure>
<h2 id="配置时执行shell脚本"><a href="#配置时执行shell脚本" class="headerlink" title="配置时执行shell脚本"></a>配置时执行shell脚本</h2><p>最后，我们使用以下函数生成<code>osdef.h</code>:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(generate_osdef_h)</span><br><span class="line">  <span class="keyword">find_program</span>(BASH_EXECUTABLE bash)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">execute_process</span>(</span><br><span class="line">    <span class="keyword">COMMAND</span></span><br><span class="line">    <span class="variable">$&#123;BASH_EXECUTABLE&#125;</span> osdef.sh <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">    WORKING_DIRECTORY</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>
<p>为了在<code>${CMAKE_CURRENT_BINARY_DIR}/src/auto</code>而不是<code>src/auto</code>中生成<code>osdef.h</code>，我们必须调整<code>osdef.sh</code>以接受<code>${CMAKE_CURRENT_BINARY_DIR}</code>作为命令行参数。</p>
<p><code>osdef.sh</code>中，我们会检查是否给定了这个参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 0 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="comment"># there are no arguments</span></span><br><span class="line">  <span class="comment"># assume the target directory is current directory</span></span><br><span class="line">  target_directory=<span class="variable">$PWD</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># target directory is provided as argument</span></span><br><span class="line">  target_directory=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>然后，生成<code>${target_directory}/auto/osdef.h</code>。为此，我们还必须在<code>osdef.sh</code>中调整以下行:</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$CC -<span class="keyword">I</span>. -<span class="keyword">I</span>$srcdir -</span><br><span class="line"><span class="keyword">I</span>$&#123;target_directory&#125; -<span class="keyword">E</span> osdef0.c &gt;osdef0.cc</span><br></pre></td></tr></table></figure>
<h1 id="15-3-检测所需的链接和依赖关系"><a href="#15-3-检测所需的链接和依赖关系" class="headerlink" title="15.3 检测所需的链接和依赖关系"></a>15.3 检测所需的链接和依赖关系</h1><p>现在已经生成了所有文件，让我们重新构建。我们应该能够配置和编译源代码，不过不能链接:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake <span class="comment">--build .</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Scanning dependencies <span class="keyword">of</span> target vim</span><br><span class="line">[ <span class="number">98</span>%] Building C object src/CMakeFiles/vim.dir/main.c.o</span><br><span class="line">[<span class="number">100</span>%] Linking C executable ../bin/vim</span><br><span class="line">../lib64/libbasic_sources.a(term.c.o): In function `set_shellsize.part<span class="number">.12</span>':</span><br><span class="line">term.c:(.<span class="built_in">text</span>+<span class="number">0x2bd</span>): undefined <span class="keyword">reference</span> <span class="keyword">to</span> `tputs'</span><br><span class="line">../lib64/libbasic_sources.a(term.c.o): In function `getlinecol':</span><br><span class="line">term.c:(.<span class="built_in">text</span>+<span class="number">0x902</span>): undefined <span class="keyword">reference</span> <span class="keyword">to</span> `tgetent'</span><br><span class="line">term.c:(.<span class="built_in">text</span>+<span class="number">0x915</span>): undefined <span class="keyword">reference</span> <span class="keyword">to</span> `tgetent'</span><br><span class="line">term.c:(.<span class="built_in">text</span>+<span class="number">0x935</span>): undefined <span class="keyword">reference</span> <span class="keyword">to</span> `tgetnum'</span><br><span class="line">term.c:(.<span class="built_in">text</span>+<span class="number">0x948</span>): undefined <span class="keyword">reference</span> <span class="keyword">to</span> `tgetnum'</span><br><span class="line">... many other undefined references ...</span><br></pre></td></tr></table></figure>
<p>同样，可以从Autotools编译中获取日志文件，特别是链接行，通过在<code>src/CMakeLists.txt</code>中添加以下代码来解决缺少的依赖关系:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find X11 and link to it</span></span><br><span class="line"><span class="keyword">find_package</span>(X11 REQUIRED)</span><br><span class="line"><span class="keyword">if</span>(X11_FOUND)</span><br><span class="line">  <span class="keyword">target_link_libraries</span>(vim</span><br><span class="line">    PUBLIC</span><br><span class="line">    	<span class="variable">$&#123;X11_LIBRARIES&#125;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># a couple of more system libraries that the code requires</span></span><br><span class="line"><span class="keyword">foreach</span>(_library IN ITEMS Xt SM m tinfo acl gpm dl)</span><br><span class="line">  <span class="keyword">find_library</span>(_<span class="variable">$&#123;_library&#125;</span>_found <span class="variable">$&#123;_library&#125;</span> REQUIRED)</span><br><span class="line">  <span class="keyword">if</span>(_<span class="variable">$&#123;_library&#125;</span>_found)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(vim</span><br><span class="line">      PUBLIC</span><br><span class="line">        <span class="variable">$&#123;_library&#125;</span></span><br><span class="line">      )</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>我们可以添加一个库的依赖目标，并且不需要构建，以及不需要将库目标放在一个列表变量中，否则将破坏CMake代码的自变量，特别是对于较大的项目而言。</p>
<p>修改之后，编译和链接:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Scanning dependencies <span class="keyword">of</span> target vim</span><br><span class="line">[ <span class="number">98</span><span class="comment">%] Building C object src/CMakeFiles/vim.dir/main.c.o</span></span><br><span class="line">[<span class="number">100</span><span class="comment">%] Linking C executable ../bin/vim</span></span><br><span class="line">[<span class="number">100</span><span class="comment">%] Built target vim</span></span><br></pre></td></tr></table></figure>
<p>现在，我们可以执行编译后的二进制文件，我们新编译的Vim就可使用了!</p>
<h1 id="15-4-复制编译标志"><a href="#15-4-复制编译标志" class="headerlink" title="15.4 复制编译标志"></a>15.4 复制编译标志</h1><p>现在，让我们尝试调整编译器标志来进行引用构建。</p>
<h2 id="定义编译器标志"><a href="#定义编译器标志" class="headerlink" title="定义编译器标志"></a>定义编译器标志</h2><p>目前为止，我们还没有定义任何自定义编译器标志，参考Autotools构建中，代码是使用的编译标志有<code>-g -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 -O2</code>，这些标示都是GNU C编译器可以识别的。</p>
<p>我们的第一个定义如下:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(CMAKE_C_COMPILER_ID MATCHES GNU)</span></span></span><br><span class="line">	set(CMAKE_C_FLAGS <span class="string">"$&#123;CMAKE_C_FLAGS&#125; -g -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=1 -O2"</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>并且，在生成源文件之前，我们将把这段代码放在<code>src/CMakeLists.txt</code>的顶部(因为<code>pathdef.c</code>有使用到<code>${CMAKE_C_FLAGS}</code>):</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># &lt;- we will define flags right here</span><br><span class="line">include(<span class="name">autogenerate</span>.cmake)</span><br><span class="line">generate_config_h()</span><br><span class="line">generate_pathdef_c()</span><br><span class="line">generate_osdef_h()</span><br></pre></td></tr></table></figure>
<p>编译器标志定义的一个小修改是将<code>-O2</code>定义为Release配置标志，并关闭Debug的配置:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">CMAKE_C_COMPILER_ID</span> MATCHES GNU)</span><br><span class="line">  set(<span class="name">CMAKE_C_FLAGS</span> <span class="string">"$&#123;CMAKE_C_FLAGS&#125; -g -U_FORTIFY_SOURCE</span></span><br><span class="line"><span class="string">  -D_FORTIFY_SOURCE=1"</span>)</span><br><span class="line">  set(<span class="name">CMAKE_C_FLAGS_RELEASE</span> <span class="string">"-O2"</span>)</span><br><span class="line">  set(<span class="name">CMAKE_C_FLAGS_DEBUG</span> <span class="string">"-O0"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p>请使用<code>make VERBOSE=1</code>验证，构建是否使用了预期的标志。</p>
<h2 id="编译器标志的作用域"><a href="#编译器标志的作用域" class="headerlink" title="编译器标志的作用域"></a>编译器标志的作用域</h2><p>在这个特殊的示例项目中，所有源文件都使用相同的编译标志。对于其他项目，我们可能不希望像上面那样全局定义编译标志，而是使用<code>target_compile_options</code>为每个目标分别定义编译标志。这样做的好处是更灵活、范围更小。在我们的例子中，这能减少不必要的代码复制。</p>
<h1 id="15-5-移植测试"><a href="#15-5-移植测试" class="headerlink" title="15.5 移植测试"></a>15.5 移植测试</h1><p>现在，来讨论如何将测试从引用构建移植到CMake。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>如果移植的项目包含测试目标，或任何形式的自动化测试，以及测试脚本。第一步，运行传统的测试步骤，并记录所使用的命令。对于Vim项目，可以从<code>src/testdir/Makefile</code>开始。在<code>src/testdir/Makefile</code>和测试脚本中的一些对于测试的定义，我们将在<code>src/testdir/CMakeLists.txt</code>中进行相应的定义。所以，我们必须在<code>src/CMakeLists.txt</code>中引用它:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(testdir)</span></span></span><br></pre></td></tr></table></figure>
<p>处理<code>src/CMakeLists.txt</code>之前，我们还应该在主<code>CMakeLists.txt</code>中启用测试:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># enable the test target</span></span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># process src/CMakeLists.txt in its own scope</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br></pre></td></tr></table></figure>
<p>目前为止，使用<code>add_test</code>填充<code>src/testdir/CMakeLists.txt</code>之前，测试目标为空。在<code>add_test</code>中指定要运行的测试名称和命令。该命令可以用任何语言编写。CMake的关键部分是，如果测试成功，脚本返回零；如果测试失败，脚本返回非零。对于Vim，我们需要多步骤测试，这将在下一节中讨论。</p>
<h2 id="实现多步测试"><a href="#实现多步测试" class="headerlink" title="实现多步测试"></a>实现多步测试</h2><p>在<code>src/testdir/Makefile</code>的目标表明，Vim代码运行测试多步测试：</p>
<ol>
<li>Vim脚本可执行测试流程，产生一个输出文件</li>
<li>输出文件是与参考文件进行比，,如果这些文件相同，测试成功</li>
<li>删除临时文件</li>
</ol>
<p>由于<code>add_test</code>只能执行一个命令，因此无法以可移植的方式将其放到单个<code>add_test</code>中。一种解决方案是在Python脚本中定义测试步骤，并使用一些参数执行Python脚本。这里提供的另一种选择，也是跨平台的，在单独的CMake脚本中定义测试步骤，并使用<code>add_test</code>执行这个脚本。我们将在<code>src/testdir/test.cmake</code>中定义测试步骤:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(execute_test _vim_executable _working_dir _test_script)</span><br><span class="line">  <span class="comment"># generates test.out</span></span><br><span class="line">  <span class="keyword">execute_process</span>(</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;_vim_executable&#125;</span> -f -u unix.vim -U NONE --noplugin --<span class="keyword">not</span>-a-term -s dotest.in <span class="variable">$&#123;_test_script&#125;</span>.in</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;_working_dir&#125;</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># compares test*.ok and test.out</span></span><br><span class="line">  <span class="keyword">execute_process</span>(</span><br><span class="line">    <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E compare_files <span class="variable">$&#123;_test_script&#125;</span>.ok <span class="keyword">test</span>.out</span><br><span class="line">    WORKING_DIRECTORY <span class="variable">$&#123;_working_dir&#125;</span></span><br><span class="line">    RESULT_VARIABLE files_differ</span><br><span class="line">    OUTPUT_QUIET</span><br><span class="line">    ERROR_QUIET</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">  <span class="comment"># removes leftovers</span></span><br><span class="line">  <span class="keyword">file</span>(<span class="keyword">REMOVE</span> <span class="variable">$&#123;_working_dir&#125;</span>/Xdotest)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># we let the test fail if the files differ</span></span><br><span class="line">  <span class="keyword">if</span>(files_differ)</span><br><span class="line">  	<span class="keyword">message</span>(SEND_ERROR <span class="string">"test $&#123;_test_script&#125; failed"</span>)</span><br><span class="line">  <span class="keyword">endif</span>()</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line">execute_test(<span class="variable">$&#123;VIM_EXECUTABLE&#125;</span> <span class="variable">$&#123;WORKING_DIR&#125;</span> <span class="variable">$&#123;TEST_SCRIPT&#125;</span>)</span><br></pre></td></tr></table></figure>
<p>同样，我们选择函数而不是宏，为的是使得变量不会超出函数作用域。它将调用<code>execute_test</code>函数，处理这个脚本。但是，我们必须确保<code>${VIM_EXECUTABLE}</code>、<code>${WORKING_DIR}</code>和<code>${TEST_SCRIPT}</code>是在外部定义。<code>src/testdir/CMakeLists.txt</code>中定义:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add_test(</span><br><span class="line">  NAME</span><br><span class="line">  	test1</span><br><span class="line">  COMMAND</span><br><span class="line">    <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -D <span class="attribute">VIM_EXECUTABLE</span>=$&lt;TARGET_FILE:vim&gt;</span><br><span class="line">    -D <span class="attribute">WORKING_DIR</span>=<span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span></span><br><span class="line">    -D <span class="attribute">TEST_SCRIPT</span>=test1</span><br><span class="line">    -P <span class="variable">$&#123;CMAKE_CURRENT_LIST_DIR&#125;</span>/test.cmake</span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>Vim项目有很多测试，但是在这个例子中，我们只移植了一个(test1)。</p>
<h2 id="测试建议"><a href="#测试建议" class="headerlink" title="测试建议"></a>测试建议</h2><p>对于移植测试，我们可以给出至少两个建议。</p>
<ol>
<li>要确保测试并不总是报告成功，如果破坏了代码或修改了验证数据，请验证测试是否失败。</li>
<li>添加测试的成本估算，以便在并行运行时，首先启动较长的测试，以最小化总测试时间。</li>
</ol>
<h1 id="15-6-移植安装目标"><a href="#15-6-移植安装目标" class="headerlink" title="15.6 移植安装目标"></a>15.6 移植安装目标</h1><p>现在可以配置、编译、链接和测试代码，但是没有测试安装目标。我们将在本节中添加这个目标。</p>
<p>Autotools的构建和安装方式:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> ./configure --prefix=/some/install/path</span><br><span class="line"><span class="symbol">$</span> make</span><br><span class="line"><span class="symbol">$</span> make install</span><br></pre></td></tr></table></figure>
<p>以下是CMake的方式：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ <span class="keyword">cd</span> build</span><br><span class="line">$ cmake -D CMAKE_INSTALL_PREFIX=<span class="string">/some/install/path</span> <span class="string">..</span></span><br><span class="line">$ cmake <span class="params">--build</span> .</span><br><span class="line">$ cmake <span class="params">--build</span> . <span class="params">--target</span> install</span><br></pre></td></tr></table></figure>
<p>要添加安装目标，需要在<code>src/CMakeLists.txt</code>中添加以下代码:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">install</span>(</span><br><span class="line">  TARGETS</span><br><span class="line">  	vim</span><br><span class="line">  RUNTIME DESTINATION</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>本例中，只安装了可执行文件。Vim项目需要安装大量文件(符号链接和文档文件)，为了使本节易于理解，我们就没有迁移示例中所有的安装目标。对于自己的项目而言，应该验证安装步骤的结果是否匹配之前构建框架的安装目标。</p>
<h1 id="15-7-进一步迁移的措施"><a href="#15-7-进一步迁移的措施" class="headerlink" title="15.7 进一步迁移的措施"></a>15.7 进一步迁移的措施</h1><p>成功地移植到CMake之后，下一步应该本地化目标和变量的范围：考虑将选项、目标和变量移到更靠近使用和修改它们的地方。避免全局变量，因为它们将按CMake命令顺序进行创建，而这个顺序可能不明显，从而会导致CMake代码变得混乱。强制分离变量范围的一种方法是将较大的项目划分为CMake项目，这些项目使用超构建块组成。从而，可考虑将大型<code>CMakeLists.txt</code>文件分割成更小的模块。</p>
<p>接下来的步骤，可以是在其他平台和操作系统上进行配置和编译，以便增强CMake代码的鲁棒性，使其更具可移植性。</p>
<p>最后，将项目迁移到新的构建框架时，开发人员社区也需要去适应。为了帮助您的同事进行培训、文档编制和代码评审。将代码移植到CMake中最困难的部分，可能是改变相关人员的使用习惯。</p>
<h1 id="15-8-项目转换为CMake的常见问题"><a href="#15-8-项目转换为CMake的常见问题" class="headerlink" title="15.8 项目转换为CMake的常见问题"></a>15.8 项目转换为CMake的常见问题</h1><p>我们总结一下，在这一章中所所学到的知识。</p>
<h2 id="代码修改总结"><a href="#代码修改总结" class="headerlink" title="代码修改总结"></a>代码修改总结</h2><p>在本章中，讨论了如何将项目移植到CMake进行构建。我们以Vim项目为例，添加了以下文件:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">└── src</span><br><span class="line">    ├── autogenerate.cmake</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── config<span class="selector-class">.h</span><span class="selector-class">.cmake</span><span class="selector-class">.in</span></span><br><span class="line">    ├── libvterm</span><br><span class="line">    │    └── CMakeLists.txt</span><br><span class="line">    ├── pathdef<span class="selector-class">.c</span><span class="selector-class">.in</span></span><br><span class="line">    └── testdir</span><br><span class="line">        ├── CMakeLists.txt</span><br><span class="line">        └── test.cmake</span><br></pre></td></tr></table></figure>
<p>可以在线查看修改： <a href="https://github.com/dev-cafe/vim/compare/b476cb7...cmake-support" target="_blank" rel="noopener">https://github.com/dev-cafe/vim/compare/b476cb7...cmake-support</a></p>
<p>为了简单起见，我们省略了许多选项和调整，并将重点放在最重要的步骤上。</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>在结束讨论之前，我们想指出一些迁移到CMake时常见的问题。</p>
<ul>
<li><strong>全局变量代码异味</strong>：这点适用于任何编程语言，CMake也不例外。跨CMake文件的变量，特别是从子到父<code>CMakeLists.txt</code>文件的“向上”传递的变量，这是明显的“异味代码”。通常，会有一种更好的方法来传输依赖关系。理想情况下，依赖项应该通过目标导入。与其将库列表组装成一个变量并在文件之间携带该变量，不如逐个链接到定义库的地方。不是将源文件组装成变量，而是使用<code>target_sources</code>添加源文件。当链接到库时，在可用时使用导入的目标，而不是变量。</li>
<li><strong>最小化顺序的影响</strong>：CMake不是一种声明性语言，但是也不应该使用命令式范式进行处理。执行严格命令的代码往往是脆弱的，这也与变量有关(见上一段)。一些语句和模块的顺序是必要的，但是为了实现健壮的CMake框架，我们应该避免不必要的顺序强制。应该多使用<code>target_sources</code>、<code>target_compile_definition</code>、<code>target_include_directory</code>和<code>target_link_libraries</code>。避免使用全局范围语句，如<code>add_definition</code>、<code>include_directory</code>和<code>link_libraries</code>，从而避免定义全局编译标志。如果可能，为每个目标定义编译标志。</li>
<li><strong>不在build目录之外生成文件</strong>：强烈建议不要将生成的文件放在构建目录之外。原因是生成的文件通常依赖于所选择的选项、编译器或构建类型。如果写入原目录树，我们就放弃了用同一套源码维护多个构建的可能性，并且会使构建步骤的重现复杂化。</li>
<li><strong>尽可能使用函数，而不是宏</strong>：它们的作用范围不同，功能范围也有限定。所有变量修改都需要显式标记，这也向读者展示了重新定义的变量。如果可以最好使用函数，必要时再使用宏。</li>
<li><strong>避免shell命令</strong>：Shell可能不能移植到其他平台(如Windows)。可以使用CMake中的命令或函数。如果没有可用的CMake等效函数，请考虑调用Python脚本。</li>
<li><strong>Fortran中，注意后缀</strong>：需要预处理的Fortran源文件是大写的<code>.F90</code>后缀。无预处理的源文件应该以<code>.f90</code>为后缀。</li>
<li><strong>避免显式路径</strong>：这条建议在定义目标和引用文件时都适用。当引用当前路径时，可使用<code>CMAKE_CURRENT_LIST_DIR</code>。这样做的好处是，当移动或重命名一个目录时，构建不会出问题。</li>
<li><strong>不应该在函数调用中进行模块包含</strong>：将CMake代码模块化是一个很好的策略，但是包含模块不应该执行CMake代码。相反，将CMake代码封装到函数和宏中，并在包含模块之后显式地调用这些函数和宏。当意外地多次包含模块时，这条建议可以防止意外的副作用，并使执行CMake代码模块的操作更易读。</li>
</ul>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2021/03/100667.html" class="pre-post btn btn-default" title='CMake 完整使用教程'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">CMake 完整使用教程</span>
        </a>
    
    
        <a href="/archives/2021/03/100665.html" class="next-post btn btn-default" title='CMake 完整使用教程 之十五 测试面板'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之十五 测试面板</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#15-1-如何开始迁移项目"><span class="toc-text">15.1 如何开始迁移项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#复制要移植的示例"><span class="toc-text">复制要移植的示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个主CMakeLists-txt"><span class="toc-text">创建一个主CMakeLists.txt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何让常规和CMake配置共存"><span class="toc-text">如何让常规和CMake配置共存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取传统构建的记录"><span class="toc-text">获取传统构建的记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#调试迁移项目"><span class="toc-text">调试迁移项目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现选项"><span class="toc-text">实现选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#从可执行的目标开始，进行本地化"><span class="toc-text">从可执行的目标开始，进行本地化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-2-生成文件并编写平台检查"><span class="toc-text">15.2 生成文件并编写平台检查</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#构造文件"><span class="toc-text">构造文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#根据系统配置预处理宏定义"><span class="toc-text">根据系统配置预处理宏定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用路径和编译器标志配置文件"><span class="toc-text">使用路径和编译器标志配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置时执行shell脚本"><span class="toc-text">配置时执行shell脚本</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-3-检测所需的链接和依赖关系"><span class="toc-text">15.3 检测所需的链接和依赖关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-4-复制编译标志"><span class="toc-text">15.4 复制编译标志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义编译器标志"><span class="toc-text">定义编译器标志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译器标志的作用域"><span class="toc-text">编译器标志的作用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-5-移植测试"><span class="toc-text">15.5 移植测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现多步测试"><span class="toc-text">实现多步测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试建议"><span class="toc-text">测试建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-6-移植安装目标"><span class="toc-text">15.6 移植安装目标</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-7-进一步迁移的措施"><span class="toc-text">15.7 进一步迁移的措施</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-8-项目转换为CMake的常见问题"><span class="toc-text">15.8 项目转换为CMake的常见问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#代码修改总结"><span class="toc-text">代码修改总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见问题"><span class="toc-text">常见问题</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2023&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>