<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="cmake,qt,c++">


    <meta name="description" content="本章的主要内容有：

使用平台无关的文件操作
配置时运行自定义命令
构建时运行自定义命令:Ⅰ. 使用add_custom_command
构建时运行自定义命令:Ⅱ. 使用add_custom_t...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>CMake 完整使用教程 之六 配置时和构建时的操作 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="CMake 完整使用教程 之六 配置时和构建时的操作">
            
	            CMake 完整使用教程 之六 配置时和构建时的操作
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/c/">c++</a> <a class="tag-link" href="/tags/cmake/">cmake</a> <a class="tag-link" href="/tags/qt/">qt</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2021/03/29</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>742</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <p>本章的主要内容有：</p>
<ul>
<li>使用平台无关的文件操作</li>
<li>配置时运行自定义命令</li>
<li>构建时运行自定义命令:Ⅰ. 使用add_custom_command</li>
<li>构建时运行自定义命令:Ⅱ. 使用add_custom_target</li>
<li>构建时为特定目标运行自定义命令</li>
<li>探究编译和链接命令</li>
<li>探究编译器标志命令</li>
<li>探究可执行命令</li>
<li>使用生成器表达式微调配置和编译</li>
</ul>
<p>我们将学习如何在配置和构建时，执行自定义操作。先简单回顾一下，与CMake工作流程相关的时序:</p>
<ol>
<li><strong>CMake时</strong>或<strong>构建时</strong>：CMake正在运行，并处理项目中的<code>CMakeLists.txt</code>文件。</li>
<li><strong>生成时</strong>：生成构建工具(如Makefile或Visual Studio项目文件)。</li>
<li><strong>构建时</strong>：由CMake生成相应平台的原生构建脚本，在脚本中调用原生工具构建。此时，将调用编译器在特定的构建目录中构建目标(可执行文件和库)。</li>
<li><strong>CTest时</strong>或<strong>测试时</strong>：运行测试套件以检查目标是否按预期执行。</li>
<li><strong>CDash时</strong>或<strong>报告时</strong>：当测试结果上传到仪表板上，与其他开发人员共享测试报告。</li>
<li><strong>安装时</strong>：当目标、源文件、可执行程序和库，从构建目录安装到相应位置。</li>
<li><strong>CPack时</strong>或<strong>打包时</strong>：将项目打包用以分发时，可以是源码，也可以是二进制。</li>
<li><strong>包安装时</strong>：新生成的包在系统范围内安装。</li>
</ol>
<p>本章会介绍在配置和构建时的自定义行为，我们将学习如何使用这些命令:</p>
<ul>
<li><strong>execute_process</strong>，从CMake中执行任意进程，并检索它们的输出。</li>
<li><strong>add_custom_target</strong>，创建执行自定义命令的目标。</li>
<li><strong>add_custom_command</strong>，指定必须执行的命令，以生成文件或在其他目标的特定生成事件中生成。</li>
</ul>
<h1 id="5-1-使用平台无关的文件操作"><a href="#5-1-使用平台无关的文件操作" class="headerlink" title="5.1 使用平台无关的文件操作"></a>5.1 使用平台无关的文件操作</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-01" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-01</a> 中找到，其中包含一个C++例子。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>有些项目构建时，可能需要与平台的文件系统进行交互。也就是检查文件是否存在、创建新文件来存储临时信息、创建或提取打包文件等等。使用CMake不仅能够在不同的平台上生成构建系统，还能够在不复杂的逻辑情况下，进行文件操作，从而独立于操作系统。本示例将展示，如何以可移植的方式下载库文件。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将展示如何提取Eigen库文件，并使用提取的源文件编译我们的项目。这个示例中，将重用第3章第7节的线性代数例子<code>linear-algebra.cpp</code>，用来检测外部库和程序、检测特征库。这里，假设已经包含Eigen库文件，已在项目构建前下载。</p>
<h2 id="具体实施"><a href="#具体实施" class="headerlink" title="具体实施"></a>具体实施</h2><p>项目需要解压缩Eigen打包文件，并相应地为目标设置包含目录:</p>
<ol>
<li><p>首先，使能C++11项目:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">01</span> LANGUAGES CXX)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们将自定义目标添加到构建系统中，自定义目标将提取构建目录中的库文件:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(unpack-eigen</span><br><span class="line">  ALL</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/eigen-eigen-<span class="number">5</span>a0156e40feb.tar.gz</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E rename eigen-eigen-<span class="number">5</span>a0156e40feb eigen-<span class="number">3.3</span>.<span class="number">4</span></span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  COMMENT</span><br><span class="line">  	<span class="string">"Unpacking Eigen3 in $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/eigen-3.3.4"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>为源文件添加了一个可执行目标:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(linear-algebra linear-algebra.cpp)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>由于源文件的编译依赖于Eigen头文件，需要显式地指定可执行目标对自定义目标的依赖关系:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_dependencies</span><span class="params">(linear-algebra unpack-eigen)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，指定包含哪些目录:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(linear-algebra</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/eigen-<span class="number">3.3</span>.<span class="number">4</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>细看<code>add_custom_target</code>这个命令：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(unpack-eigen</span><br><span class="line">  ALL</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/eigen-eigen-<span class="number">5</span>a0156e40feb.tar.gz</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E rename eigen-eigen-<span class="number">5</span>a0156e40feb eigen-<span class="number">3.3</span>.<span class="number">4</span></span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  COMMENT</span><br><span class="line">  	<span class="string">"Unpacking Eigen3 in $&#123;CMAKE_CURRENT_BINARY_DIR&#125;/eigen-3.3.4"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>构建系统中引入了一个名为<code>unpack-eigen</code>的目标。因为我们传递了<code>ALL</code>参数，目标将始终被执行。<code>COMMAND</code>参数指定要执行哪些命令。本例中，我们希望提取存档并将提取的目录重命名为<code>egan -3.3.4</code>，通过以下两个命令实现:</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;CMAKE_COMMAND&#125; -<span class="keyword">E</span> tar xzf $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/eigen-eigen-</span><br><span class="line"><span class="number">5</span>a0156e40feb.tar.gz</span><br><span class="line">$&#123;CMAKE_COMMAND&#125; -<span class="keyword">E</span> rename eigen-eigen<span class="number">-5</span>a0156e40feb eigen<span class="number">-3.3</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>
<p>注意，使用<code>-E</code>标志调用CMake命令本身来执行实际的工作。对于许多常见操作，CMake实现了一个对所有操作系统都通用的接口，这使得构建系统独立于特定的平台。<code>add_custom_target</code>命令中的下一个参数是工作目录。我们的示例中，它对应于构建目录：<code>CMAKE_CURRENT_BINARY_DIR</code>。最后一个参数<code>COMMENT</code>，用于指定CMake在执行自定义目标时输出什么样的消息。</p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>构建过程中必须执行一系列没有输出的命令时，可以使用<code>add_custom_target</code>命令。正如我们在本示例中所示，可以将自定义目标指定为项目中其他目标的依赖项。此外，自定义目标还可以依赖于其他目标。</p>
<p>使用<code>-E</code>标志可以以与操作系统无关的方式，运行许多公共操作。运行<code>cmake -E</code>或<code>cmake -E help</code>可以获得特定操作系统的完整列表。例如，这是Linux系统上命令的摘要:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Usage: cmake -E &lt;<span class="keyword">command</span>&gt; [<span class="title">arguments</span>...]</span><br><span class="line">Available commands:</span><br><span class="line">  capabilities              - Report capabilities built <span class="keyword">into</span> cmake <span class="keyword">in</span> JSON <span class="built_in">format</span></span><br><span class="line">  chdir dir cmd [args...]   - run <span class="keyword">command</span> <span class="title">in</span> <span class="title">a</span> <span class="title">given</span> <span class="title">directory</span></span><br><span class="line">  compare_files file1 file2 - check <span class="keyword">if</span> file1 is same <span class="keyword">as</span> file2</span><br><span class="line">  copy &lt;<span class="built_in">file</span>&gt;... destination  - copy <span class="built_in">files</span> <span class="built_in">to</span> destination (either <span class="built_in">file</span> <span class="keyword">or</span> <span class="built_in">directory</span>)</span><br><span class="line">  copy_directory &lt;dir&gt;... destination   - copy content <span class="keyword">of</span> &lt;dir&gt;... <span class="built_in">directories</span> <span class="built_in">to</span> <span class="string">'destination'</span> <span class="built_in">directory</span></span><br><span class="line">  copy_if_different &lt;<span class="built_in">file</span>&gt;... destination  - copy <span class="built_in">files</span> <span class="keyword">if</span> <span class="keyword">it</span> has changed</span><br><span class="line">  echo [&lt;<span class="keyword">string</span>&gt;...]        - displays arguments <span class="keyword">as</span> <span class="keyword">text</span></span><br><span class="line">  echo_append [&lt;<span class="keyword">string</span>&gt;...] - displays arguments <span class="keyword">as</span> <span class="keyword">text</span> but no <span class="built_in">new</span> <span class="built_in">line</span></span><br><span class="line">  env [<span class="comment">--unset=NAME]... [NAME=VALUE]... COMMAND [ARG]...</span></span><br><span class="line">                            - run <span class="keyword">command</span> <span class="title">in</span> <span class="title">a</span> <span class="title">modified</span> <span class="title">environment</span></span><br><span class="line">  environment               - display <span class="keyword">the</span> current environment</span><br><span class="line">  make_directory &lt;dir&gt;...   - <span class="built_in">create</span> parent <span class="keyword">and</span> &lt;dir&gt; <span class="built_in">directories</span></span><br><span class="line">  md5sum &lt;<span class="built_in">file</span>&gt;...          - <span class="built_in">create</span> MD5 checksum <span class="keyword">of</span> <span class="built_in">files</span></span><br><span class="line">  sha1sum &lt;<span class="built_in">file</span>&gt;...         - <span class="built_in">create</span> SHA1 checksum <span class="keyword">of</span> <span class="built_in">files</span></span><br><span class="line">  sha224sum &lt;<span class="built_in">file</span>&gt;...       - <span class="built_in">create</span> SHA224 checksum <span class="keyword">of</span> <span class="built_in">files</span></span><br><span class="line">  sha256sum &lt;<span class="built_in">file</span>&gt;...       - <span class="built_in">create</span> SHA256 checksum <span class="keyword">of</span> <span class="built_in">files</span></span><br><span class="line">  sha384sum &lt;<span class="built_in">file</span>&gt;...       - <span class="built_in">create</span> SHA384 checksum <span class="keyword">of</span> <span class="built_in">files</span></span><br><span class="line">  sha512sum &lt;<span class="built_in">file</span>&gt;...       - <span class="built_in">create</span> SHA512 checksum <span class="keyword">of</span> <span class="built_in">files</span></span><br><span class="line">  remove [-f] &lt;<span class="built_in">file</span>&gt;...     - remove <span class="keyword">the</span> <span class="built_in">file</span>(s), use -f <span class="built_in">to</span> force <span class="keyword">it</span></span><br><span class="line">  remove_directory dir      - remove <span class="keyword">a</span> <span class="built_in">directory</span> <span class="keyword">and</span> its contents</span><br><span class="line">  <span class="built_in">rename</span> oldname newname    - <span class="built_in">rename</span> <span class="keyword">a</span> <span class="built_in">file</span> <span class="keyword">or</span> <span class="built_in">directory</span> (<span class="keyword">on</span> <span class="title">one</span> <span class="title">volume</span>)</span><br><span class="line">  server                    - <span class="built_in">start</span> cmake <span class="keyword">in</span> server mode</span><br><span class="line">  sleep &lt;<span class="built_in">number</span>&gt;...         - sleep <span class="keyword">for</span> given <span class="built_in">number</span> <span class="keyword">of</span> <span class="built_in">seconds</span></span><br><span class="line">  tar [cxt][vf][zjJ] <span class="built_in">file</span>.tar [<span class="built_in">file</span>/dir1 <span class="built_in">file</span>/dir2 ...]</span><br><span class="line">                            - <span class="built_in">create</span> <span class="keyword">or</span> extract <span class="keyword">a</span> tar <span class="keyword">or</span> zip archive</span><br><span class="line">  <span class="built_in">time</span> <span class="keyword">command</span> [<span class="title">args</span>...]    - <span class="title">run</span> <span class="title">command</span> <span class="title">and</span> <span class="title">display</span> <span class="title">elapsed</span> <span class="title">time</span></span><br><span class="line">  touch <span class="built_in">file</span>                - touch <span class="keyword">a</span> <span class="built_in">file</span>.</span><br><span class="line">  touch_nocreate <span class="built_in">file</span>       - touch <span class="keyword">a</span> <span class="built_in">file</span> but <span class="built_in">do</span> <span class="keyword">not</span> <span class="built_in">create</span> <span class="keyword">it</span>.</span><br><span class="line">Available <span class="keyword">on</span> <span class="title">UNIX</span> <span class="title">only</span>:</span><br><span class="line">  create_symlink old <span class="built_in">new</span>    - <span class="built_in">create</span> <span class="keyword">a</span> symbolic link <span class="built_in">new</span> -&gt; old</span><br></pre></td></tr></table></figure>
<h1 id="5-2-配置时运行自定义命令"><a href="#5-2-配置时运行自定义命令" class="headerlink" title="5.2 配置时运行自定义命令"></a>5.2 配置时运行自定义命令</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-05/recipe-02</a> 中找到。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>运行CMake生成构建系统，从而指定原生构建工具必须执行哪些命令，以及按照什么顺序执行。我们已经了解了CMake如何在配置时运行许多子任务，以便找到工作的编译器和必要的依赖项。本示例中，我们将讨论如何使用<code>execute_process</code>命令在配置时运行定制化命令。</p>
<h2 id="具体实施-1"><a href="#具体实施-1" class="headerlink" title="具体实施"></a>具体实施</h2><p>第3章第3节中，我们已经展示了<code>execute_process</code>查找Python模块NumPy时的用法。本例中，我们将使用<code>execute_process</code>命令来确定，是否存在特定的Python模块(本例中为Python CFFI)，如果存在，我们在进行版本确定:</p>
<ol>
<li><p>对于这个简单的例子，不需要语言支持:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">02</span> LANGUAGES NONE)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们要求Python解释器执行一个简短的代码片段，因此，需要使用<code>find_package</code>来查找解释器：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，调用<code>execute_process</code>来运行一个简短的Python代码段；下一节中，我们将更详细地讨论这个命令:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">this</span> <span class="keyword">is</span> <span class="keyword">set</span> <span class="keyword">as</span> variable to prepare</span><br><span class="line"># <span class="keyword">for</span> abstraction using loops or functions</span><br><span class="line"><span class="keyword">set</span>(_module_name <span class="string">"cffi"</span>)</span><br><span class="line"></span><br><span class="line">execute_process(</span><br><span class="line">  COMMAND</span><br><span class="line">  	$&#123;PYTHON_EXECUTABLE&#125; <span class="string">"-c"</span> <span class="string">"import <span class="subst">$&#123;_module_name&#125;</span>; print(<span class="subst">$&#123;_module_name&#125;</span>.__version__)"</span></span><br><span class="line">  OUTPUT_VARIABLE _stdout</span><br><span class="line">  ERROR_VARIABLE _stderr</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  ERROR_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，打印结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(_stderr MATCHES <span class="string">"ModuleNotFoundError"</span>)</span></span></span><br><span class="line">	message(STATUS <span class="string">"Module $&#123;_module_name&#125; not found"</span>)</span><br><span class="line"><span class="function"><span class="title">else</span><span class="params">()</span></span></span><br><span class="line">	message(STATUS <span class="string">"Found module $&#123;_module_name&#125; v$&#123;_stdout&#125;"</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面是一个配置示例(假设Python CFFI包安装在相应的Python环境中):</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line"></span><br><span class="line">-- Found <span class="symbol">PythonInterp:</span> /home/user/cmake-cookbook/chapter-<span class="number">05</span>/recipe-<span class="number">02</span>/example/venv/bin/python (found version <span class="string">"3.6.5"</span>)</span><br><span class="line">-- Found <span class="class"><span class="keyword">module</span> <span class="title">cffi</span> <span class="title">v1</span>.11.5</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>execute_process</code>命令将从当前正在执行的CMake进程中派生一个或多个子进程，从而提供了在配置项目时运行任意命令的方法。可以在一次调用<code>execute_process</code>时执行多个命令。但请注意，每个命令的输出将通过管道传输到下一个命令中。该命令接受多个参数:</p>
<ul>
<li>WORKING_DIRECTORY，指定应该在哪个目录中执行命令。</li>
<li>RESULT_VARIABLE将包含进程运行的结果。这要么是一个整数，表示执行成功，要么是一个带有错误条件的字符串。</li>
<li>OUTPUT_VARIABLE和ERROR_VARIABLE将包含执行命令的标准输出和标准错误。由于命令的输出是通过管道传输的，因此只有最后一个命令的标准输出才会保存到OUTPUT_VARIABLE中。</li>
<li>INPUT_FILE指定标准输入重定向的文件名</li>
<li>OUTPUT_FILE指定标准输出重定向的文件名</li>
<li>ERROR_FILE指定标准错误输出重定向的文件名</li>
<li>设置OUTPUT_QUIET和ERROR_QUIET后，CMake将静默地忽略标准输出和标准错误。</li>
<li>设置OUTPUT_STRIP_TRAILING_WHITESPACE，可以删除运行命令的标准输出中的任何尾随空格</li>
<li>设置ERROR_STRIP_TRAILING_WHITESPACE，可以删除运行命令的错误输出中的任何尾随空格。</li>
</ul>
<p>有了这些了解这些参数，回到我们的例子当中:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set(<span class="name">_module_name</span> <span class="string">"cffi"</span>)</span><br><span class="line"></span><br><span class="line">execute_process(</span><br><span class="line">  COMMAND</span><br><span class="line">  	$&#123;PYTHON_EXECUTABLE&#125; <span class="string">"-c"</span> <span class="string">"import $&#123;_module_name&#125;; print($&#123;_module_name&#125;.__version__)"</span></span><br><span class="line">  OUTPUT_VARIABLE _stdout</span><br><span class="line">  ERROR_VARIABLE _stderr</span><br><span class="line">  OUTPUT_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  ERROR_STRIP_TRAILING_WHITESPACE</span><br><span class="line">  )</span><br><span class="line">if(<span class="name">_stderr</span> MATCHES <span class="string">"ModuleNotFoundError"</span>)</span><br><span class="line">	message(<span class="name">STATUS</span> <span class="string">"Module $&#123;_module_name&#125; not found"</span>)</span><br><span class="line">else()</span><br><span class="line">  message(<span class="name">STATUS</span> <span class="string">"Found module $&#123;_module_name&#125; v$&#123;_stdout&#125;"</span>)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p>该命令检查<code>python -c &quot;import cffi; print(cffi.__version__)&quot;</code>的输出。如果没有找到模块，<code>_stderr</code>将包含<code>ModuleNotFoundError</code>，我们将在if语句中对其进行检查。本例中，我们将打印<code>Module cffi not found</code>。如果导入成功，Python代码将打印模块的版本，该模块通过管道输入<code>_stdout</code>，这样就可以打印如下内容:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">message</span><span class="params">(STATUS <span class="string">"Found module $&#123;_module_name&#125; v$&#123;_stdout&#125;"</span>)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="更多信息-1"><a href="#更多信息-1" class="headerlink" title="更多信息"></a>更多信息</h2><p>本例中，只打印了结果，但实际项目中，可以警告、中止配置，或者设置可以查询的变量，来切换某些配置选项。</p>
<p>代码示例会扩展到多个Python模块(如Cython)，以避免代码重复。一种选择是使用<code>foreach</code>循环模块名，另一种方法是将代码封装为函数或宏。我们将在第7章中讨论这些封装。</p>
<p>第9章中，我们将使用Python CFFI和Cython。现在的示例，可以作为有用的、可重用的代码片段，来检测这些包是否存在。</p>
<h1 id="5-3-构建时运行自定义命令-Ⅰ-使用add-custom-command"><a href="#5-3-构建时运行自定义命令-Ⅰ-使用add-custom-command" class="headerlink" title="5.3 构建时运行自定义命令:Ⅰ. 使用add_custom_command"></a>5.3 构建时运行自定义命令:Ⅰ. 使用add_custom_command</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-03" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-03</a> 中找到，其中包含一个C++例子。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>项目的构建目标取决于命令的结果，这些命令只能在构建系统生成完成后的构建执行。CMake提供了三个选项来在构建时执行自定义命令:</p>
<ol>
<li>使用<code>add_custom_command</code>编译目标，生成输出文件。</li>
<li><code>add_custom_target</code>的执行没有输出。</li>
<li>构建目标前后，<code>add_custom_command</code>的执行可以没有输出。</li>
</ol>
<p>这三个选项强制执行特定的语义，并且不可互换。接下来的三个示例将演示具体的用法。</p>
<h2 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将重用第3章第4节中的C++示例，以说明如何使用<code>add_custom_command</code>的第一个选项。代码示例中，我们了解了现有的BLAS和LAPACK库，并编译了一个很小的C++包装器库，以调用线性代数的Fortran实现。</p>
<p>我们将把代码分成两部分。<code>linear-algebra.cpp</code>的源文件与第3章、第4章没有区别，并且将包含线性代数包装器库的头文件和针对编译库的链接。源代码将打包到一个压缩的tar存档文件中，该存档文件随示例项目一起提供。存档文件将在构建时提取，并在可执行文件生成之前，编译线性代数的包装器库。</p>
<h2 id="具体实施-2"><a href="#具体实施-2" class="headerlink" title="具体实施"></a>具体实施</h2><p><code>CMakeLists.txt</code>必须包含一个自定义命令，来提取线性代数包装器库的源代码：</p>
<ol>
<li><p>从CMake最低版本、项目名称和支持语言的定义开始:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">03</span> LANGUAGES CXX Fortran)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>选择C++11标准:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，在系统上查找BLAS和LAPACK库:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(BLAS REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(LAPACK REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明一个变量<code>wrap_BLAS_LAPACK_sources</code>来保存<code>wrap_BLAS_LAPACK.tar.gz</code>压缩包文件的名称:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set(wrap_BLAS_LAPACK_sources</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><span class="regexp">/wrap_BLAS_LAPACK/</span>CxxBLAS.hpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><span class="regexp">/wrap_BLAS_LAPACK/</span>CxxBLAS.cpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><span class="regexp">/wrap_BLAS_LAPACK/</span>CxxLAPACK.hpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><span class="regexp">/wrap_BLAS_LAPACK/</span>CxxLAPACK.cpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明自定义命令来提取<code>wrap_BLAS_LAPACK.tar.gz</code>压缩包，并更新提取文件的时间戳。注意这个<code>wrap_BLAS_LAPACK_sources</code>变量的预期输出:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT</span><br><span class="line">  	<span class="variable">$&#123;wrap_BLAS_LAPACK_sources&#125;</span></span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E touch <span class="variable">$&#123;wrap_BLAS_LAPACK_sources&#125;</span></span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  DEPENDS</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  COMMENT</span><br><span class="line">  	<span class="string">"Unpacking C++ wrappers for BLAS/LAPACK"</span></span><br><span class="line">  VERBATIM</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，添加一个库目标，源文件是新解压出来的:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">add_library(math <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">target_sources(math</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.cpp</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.cpp</span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.hpp</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.hpp</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_include_directories(math</span><br><span class="line">  INTERFACE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_link_libraries(math</span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，添加<code>linear-algebra</code>可执行目标。可执行目标链接到库:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">linear-algebra</span> linear-algebra.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(<span class="name">linear-algebra</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	math</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们配置、构建和执行示例:</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line">$ ./linear-algebra 1000</span><br><span class="line"></span><br><span class="line">C_DSCAL done</span><br><span class="line">C_DGESV done</span><br><span class="line">info is 0</span><br><span class="line">check is 4.35597e-10</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h2><p>让我们来了解一下<code>add_custom_command</code>的使用:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT</span><br><span class="line">  	<span class="variable">$&#123;wrap_BLAS_LAPACK_sources&#125;</span></span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E touch <span class="variable">$&#123;wrap_BLAS_LAPACK_sources&#125;</span></span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  DEPENDS</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  COMMENT</span><br><span class="line">  	<span class="string">"Unpacking C++ wrappers for BLAS/LAPACK"</span></span><br><span class="line">  VERBATIM</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><code>add_custom_command</code>向目标添加规则，并通过执行命令生成输出。<code>add_custom_command</code>中声明的任何目标，即在相同的<code>CMakeLists.txt</code>中声明的任何目标，使用输出的任何文件作为源文件的目标，在构建时会有规则生成这些文件。因此，源文件生成在构建时，目标和自定义命令在构建系统生成时，将自动处理依赖关系。</p>
<p>我们的例子中，输出是压缩<code>tar</code>包，其中包含有源文件。要检测和使用这些文件，必须在构建时提取打包文件。通过使用带有<code>-E</code>标志的CMake命令，以实现平台独立性。下一个命令会更新提取文件的时间戳。这样做是为了确保没有处理陈旧文件。<code>WORKING_DIRECTORY</code>可以指定在何处执行命令。示例中，<code>CMAKE_CURRENT_BINARY_DIR</code>是当前正在处理的构建目录。<code>DEPENDS</code>参数列出了自定义命令的依赖项。例子中，压缩的<code>tar</code>是一个依赖项。CMake使用<code>COMMENT</code>字段在构建时打印状态消息。最后，<code>VERBATIM</code>告诉CMake为生成器和平台生成正确的命令，从而确保完全独立。</p>
<p>我们来仔细看看这用使用方式和打包库的创建：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">add_library(math <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">target_sources(math</span><br><span class="line">  PRIVATE</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.cpp</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.cpp</span><br><span class="line">  PUBLIC</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.hpp</span><br><span class="line">    <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.hpp</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_include_directories(math</span><br><span class="line">  INTERFACE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">target_link_libraries(math</span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>我们声明一个没有源的库目标，是因为后续使用<code>target_sources</code>填充目标的源。这里实现了一个非常重要的目标，即让依赖于此目标的目标，了解需要哪些目录和头文件，以便成功地使用库。C++源文件的目标是<code>PRIVATE</code>，因此只用于构建库。因为目标及其依赖项都需要使用它们来成功编译，所以头文件是<code>PUBLIC</code>。包含目录使用<code>target_include_categories</code>指定，其中<code>wrap_BLAS_LAPACK</code>声明为<code>INTERFACE</code>，因为只有依赖于<code>math</code>目标的目标需要它。</p>
<p><code>add_custom_command</code>有两个限制:</p>
<ul>
<li>只有在相同的<code>CMakeLists.txt</code>中，指定了所有依赖于其输出的目标时才有效。</li>
<li>对于不同的独立目标，使用<code>add_custom_command</code>的输出可以重新执行定制命令。这可能会导致冲突，应该避免这种情况的发生。</li>
</ul>
<p>第二个限制，可以使用<code>add_dependencies</code>来避免。不过，规避这两个限制的正确方法是使用<code>add_custom_target</code>命令，我们将在下一节的示例中详细介绍。</p>
<h1 id="5-4-构建时运行自定义命令-Ⅱ-使用add-custom-target"><a href="#5-4-构建时运行自定义命令-Ⅱ-使用add-custom-target" class="headerlink" title="5.4 构建时运行自定义命令:Ⅱ. 使用add_custom_target"></a>5.4 构建时运行自定义命令:Ⅱ. 使用add_custom_target</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-04" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-04</a> 中找到，其中包含一个C++例子。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>我们在前面的示例，讨论了<code>add_custom_command</code>有一些限制，可以通过<code>add_custom_target</code>绕过这些限制。这个CMake命令将引入新的目标，与<code>add_custom_command</code>相反，这些目标依次执行不返回输出。可以将<code>add_custom_target</code>和<code>add_custom_command</code>结合使用。使用这种方法，可以与其依赖项所在目录不同的目录指定自定义目标，CMake基础设施对项目设计模块化非常有用。</p>
<h2 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将重用前一节示例，对源码进行简单的修改。特别是，将把压缩后的<code>tar</code>打包文件放在名为<code>deps</code>的子目录中，而不是存储在主目录中。这个子目录包含它自己的<code>CMakeLists.txt</code>，将由主<code>CMakeLists.txt</code>调用。</p>
<h2 id="具体实施-3"><a href="#具体实施-3" class="headerlink" title="具体实施"></a>具体实施</h2><p>我们将从主<code>CMakeLists.txt</code>开始，然后讨论<code>deps/CMakeLists.txt</code>:</p>
<ol>
<li><p>声明启用C++11：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">04</span> LANGUAGES CXX Fortran)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，继续讨论<code>deps/CMakeLists.txt</code>。这通过<code>add_subdirectory</code>命令实现:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_subdirectory</span><span class="params">(deps)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>deps/CMakeLists.txt</code>中，我们首先定位必要的库(BLAS和LAPACK):</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(BLAS REQUIRED)</span></span></span><br><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(LAPACK REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，我们将<code>tar</code>包的内容汇集到一个变量<code>MATH_SRCS</code>中:</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set(MATH_SRCS</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><span class="regexp">/wrap_BLAS_LAPACK/</span>CxxBLAS.cpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><span class="regexp">/wrap_BLAS_LAPACK/</span>CxxLAPACK.cpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><span class="regexp">/wrap_BLAS_LAPACK/</span>CxxBLAS.hpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span><span class="regexp">/wrap_BLAS_LAPACK/</span>CxxLAPACK.hpp</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出要打包的源之后，定义一个目标和一个命令。这个组合用于提取<code>${CMAKE_CURRENT_BINARY_DIR}</code>中的包。但是，这里我们在一个不同的范围内，引用<code>deps/CMakeLists.txt</code>，因此<code>tar</code>包将存放在到主项目构建目录下的<code>deps</code>子目录中:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(BLAS_LAPACK_wrappers</span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  DEPENDS</span><br><span class="line">  	<span class="variable">$&#123;MATH_SRCS&#125;</span></span><br><span class="line">  COMMENT</span><br><span class="line">  	<span class="string">"Intermediate BLAS_LAPACK_wrappers target"</span></span><br><span class="line">  VERBATIM</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT</span><br><span class="line">  	<span class="variable">$&#123;MATH_SRCS&#125;</span></span><br><span class="line">  <span class="keyword">COMMAND</span></span><br><span class="line">  	<span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar xzf <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  WORKING_DIRECTORY</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  DEPENDS</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/wrap_BLAS_LAPACK.tar.gz</span><br><span class="line">  COMMENT</span><br><span class="line">  	<span class="string">"Unpacking C++ wrappers for BLAS/LAPACK"</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加数学库作为目标，并指定相应的源，包括目录和链接库:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add_library(math <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">target_sources(math</span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;MATH_SRCS&#125;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">target_include_directories(math</span><br><span class="line">  INTERFACE</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># BLAS_LIBRARIES are included in LAPACK_LIBRARIES</span></span><br><span class="line">target_link_libraries(math</span><br><span class="line">  PUBLIC</span><br><span class="line">  	<span class="variable">$&#123;LAPACK_LIBRARIES&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行完<code>deps/CMakeLists.txt</code>中的命令，返回到父范围，定义可执行目标，并将其链接到另一个目录的数学库:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="name">linear-algebra</span> linear-algebra.cpp)</span><br><span class="line"></span><br><span class="line">target_link_libraries(<span class="name">linear-algebra</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	math</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-3"><a href="#工作原理-3" class="headerlink" title="工作原理"></a>工作原理</h2><p>用户可以使用<code>add_custom_target</code>，在目标中执行定制命令。这与我们前面讨论的<code>add_custom_command</code>略有不同。<code>add_custom_target</code>添加的目标没有输出，因此总会执行。因此，可以在子目录中引入自定义目标，并且仍然能够在主<code>CMakeLists.txt</code>中引用它。</p>
<p>本例中，使用<code>add_custom_target</code>和<code>add_custom_command</code>提取了源文件的包。这些源文件稍后用于编译另一个库，我们设法在另一个(父)目录范围内链接这个库。构建<code>CMakeLists.txt</code>文件的过程中，<code>tar</code>包是在<code>deps</code>下，<code>deps</code>是项目构建目录下的一个子目录。这是因为在CMake中，构建树的结构与源树的层次结构相同。</p>
<p>这个示例中有一个值得注意的细节，就是我们把数学库的源标记为<code>PRIVATE</code>:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MATH_SRCS</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.cpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.cpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxBLAS.hpp</span><br><span class="line">  <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/wrap_BLAS_LAPACK/CxxLAPACK.hpp</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(<span class="keyword">math</span> <span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_sources</span>(<span class="keyword">math</span></span><br><span class="line">  PRIVATE</span><br><span class="line">  	<span class="variable">$&#123;MATH_SRCS&#125;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>虽然这些源代码是<code>PRIVATE</code>，但我们在父范围内编译了<code>linear-algebra.cpp</code>，并且这个源代码包括<code>CxxBLAS.hpp</code>和<code>CxxLAPACK.hpp</code>。为什么这里使用<code>PRIVATE</code>，以及如何编译<code>linear-algebra.cpp</code>，并构建可执行文件呢？如果将头文件标记为<code>PUBLIC</code>, CMake就会在创建时停止，并出现一个错误，“无法找到源文件”，因为要生成(提取)还不存在于文件树中的源文件。</p>
<p>这是一个已知的限制(参见<a href="https://gitlab.kitware.com/cmake/cmake/issues/1633" target="_blank" rel="noopener">https://gitlab.kitware.com/cmake/cmake/issues/1633</a> ，以及相关的博客文章:<a href="https://samthursfield.wordpress.com/2015/11/21/cmake-depende-ncies-targets-and-files-and-custom-commands" target="_blank" rel="noopener">https://samthursfield.wordpress.com/2015/11/21/cmake-depende-ncies-targets-and-files-and-custom-commands</a> )。我们通过声明源代码为<code>PRIVATE</code>来解决这个限制。这样CMake时，没有获得对不存在源文件的依赖。但是，CMake内置的C/C++文件依赖关系扫描器在构建时获取它们，并编译和链接源代码。</p>
<h1 id="5-5-构建时为特定目标运行自定义命令"><a href="#5-5-构建时为特定目标运行自定义命令" class="headerlink" title="5.5 构建时为特定目标运行自定义命令"></a>5.5 构建时为特定目标运行自定义命令</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-05" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-05</a> 中找到，其中包含一个Fortran例子。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>本节示例将展示，如何使用<code>add_custom_command</code>的第二个参数，来执行没有输出的自定义操作，这对于构建或链接特定目标之前或之后执行某些操作非常有用。由于自定义命令仅在必须构建目标本身时才执行，因此我们实现了对其执行的目标级控制。我们将通过一个示例来演示，在构建目标之前打印目标的链接，然后在编译后，立即测量编译后，可执行文件的静态分配大小。</p>
<h2 id="准备工作-3"><a href="#准备工作-3" class="headerlink" title="准备工作"></a>准备工作</h2><p>本示例中，我们将使用Fortran代码(<code>example.f90</code>):</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> example</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">real</span>(<span class="number">8</span>) :: array(<span class="number">20000000</span>)</span><br><span class="line">  <span class="keyword">real</span>(<span class="number">8</span>) :: r</span><br><span class="line">  <span class="keyword">integer</span> :: i</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">do</span> i = <span class="number">1</span>, <span class="built_in">size</span>(array)</span><br><span class="line">    <span class="keyword">call</span> <span class="built_in">random_number</span>(r)</span><br><span class="line">    array(i) = r</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span> *, <span class="built_in">sum</span>(array)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span></span><br></pre></td></tr></table></figure>
<p>虽然我们选择了Fortran，但Fortran代码的对于后面的讨论并不重要，因为有很多遗留的Fortran代码，存在静态分配大小的问题。</p>
<p>这段代码中，我们定义了一个包含20,000,000双精度浮点数的数组，这个数组占用160MB的内存。在这里，我们并不是推荐这样的编程实践。一般来说，这些内存的分配和代码中是否使用这段内存无关。一个更好的方法是只在需要时动态分配数组，随后立即释放。</p>
<p>示例代码用随机数填充数组，并计算它们的和——这样是为了确保数组确实被使用，并且编译器不会优化分配。我们将使用Python脚本(<code>static-size.py</code>)来统计二进制文件静态分配的大小，该脚本用size命令来封装:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># <span class="keyword">for</span> simplicity we <span class="keyword">do</span> not check <span class="keyword">number</span> of</span><br><span class="line"># arguments <span class="built_in">and</span> whether the <span class="keyword">file</span> really <span class="built_in">exists</span></span><br><span class="line">file_path = sys.<span class="built_in">argv</span>[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	output = subprocess.check_output([<span class="string">'size'</span>, file_path]).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">except FileNotFoundError:</span><br><span class="line">	<span class="keyword">print</span>(<span class="string">'command "size" is not available on this platform'</span>)</span><br><span class="line">	sys.<span class="keyword">exit</span>(<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">size = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">line</span> in output.<span class="keyword">split</span>(<span class="string">'\n'</span>):</span><br><span class="line">	<span class="keyword">if</span> file_path in <span class="built_in">line</span>:</span><br><span class="line">		# we are interested in the <span class="number">4</span><span class="keyword">th</span> <span class="keyword">number</span> <span class="keyword">on</span> this <span class="built_in">line</span></span><br><span class="line">		size = <span class="keyword">int</span>(<span class="built_in">line</span>.<span class="keyword">split</span>()[<span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line"><span class="keyword">print</span>(<span class="string">'&#123;0:.3f&#125; MB'</span>.format(size/<span class="number">1.0</span>e6))</span><br></pre></td></tr></table></figure>
<p>要打印链接行，我们将使用第二个Python helper脚本(<code>echo-file.py</code>)打印文件的内容:</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># <span class="keyword">for</span> simplicity we <span class="keyword">do</span> not verify the <span class="keyword">number</span> <span class="built_in">and</span></span><br><span class="line"># <span class="built_in">type</span> of arguments</span><br><span class="line">file_path = sys.<span class="built_in">argv</span>[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	with <span class="keyword">open</span>(file_path, <span class="string">'r'</span>) <span class="keyword">as</span> <span class="keyword">f</span>:</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">f</span>.<span class="keyword">read</span>())</span><br><span class="line">except FileNotFoundError:</span><br><span class="line">	<span class="keyword">print</span>(<span class="string">'ERROR: file &#123;0&#125; not found'</span>.format(file_path))</span><br></pre></td></tr></table></figure>
<h2 id="具体实施-4"><a href="#具体实施-4" class="headerlink" title="具体实施"></a>具体实施</h2><p>来看看<code>CMakeLists.txt</code>：</p>
<ol>
<li><p>首先声明一个Fortran项目:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">05</span> LANGUAGES Fortran)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>例子依赖于Python解释器，所以以一种可移植的方式执行helper脚本:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PythonInterp REQUIRED)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>本例中，默认为“Release”构建类型，以便CMake添加优化标志:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT CMAKE_BUILD_TYPE)</span></span></span><br><span class="line">	set(CMAKE_BUILD_TYPE Release CACHE STRING <span class="string">"Build type"</span> FORCE)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，定义可执行目标:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(example <span class="string">""</span>)</span></span></span><br><span class="line"></span><br><span class="line">target_sources(example</span><br><span class="line">  PRIVATE</span><br><span class="line">  	example.f90</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，定义一个自定义命令，在<code>example</code>目标在已链接之前，打印链接行:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  <span class="keyword">TARGET</span></span><br><span class="line">  	example</span><br><span class="line">  PRE_LINK</span><br><span class="line">  	<span class="keyword">COMMAND</span></span><br><span class="line">  		<span class="variable">$&#123;PYTHON_EXECUTABLE&#125;</span></span><br><span class="line">  		<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/echo-<span class="keyword">file</span>.py</span><br><span class="line">			<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/CMakeFiles/example.dir/link.txt</span><br><span class="line">  COMMENT</span><br><span class="line">  	<span class="string">"link line:"</span></span><br><span class="line">  VERBATIM</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试一下。观察打印的链接行和可执行文件的静态大小:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ cmake --build .</span><br><span class="line"></span><br><span class="line">Scanning <span class="built_in">dependencies</span> of target <span class="built_in">example</span></span><br><span class="line">[ <span class="number">50</span><span class="symbol">%</span>] Building Fortran object CMakeFiles/<span class="built_in">example</span>.dir/<span class="built_in">example</span>.<span class="built_in">f90</span>.o</span><br><span class="line">[<span class="number">100</span><span class="symbol">%</span>] Linking Fortran executable <span class="built_in">example</span></span><br><span class="line">link line:</span><br><span class="line">/usr/bin/f95 -O3 -DNDEBUG -O3 CMakeFiles/<span class="built_in">example</span>.dir/<span class="built_in">example</span>.<span class="built_in">f90</span>.o -o <span class="built_in">example</span></span><br><span class="line">static size of executable:</span><br><span class="line"><span class="number">160.003</span> MB</span><br><span class="line">[<span class="number">100</span><span class="symbol">%</span>] Built target <span class="built_in">example</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-4"><a href="#工作原理-4" class="headerlink" title="工作原理"></a>工作原理</h2><p>当声明了库或可执行目标，就可以使用<code>add_custom_command</code>将其他命令锁定到目标上。这些命令将在特定的时间执行，与它们所附加的目标的执行相关联。CMake通过以下选项，定制命令执行顺序:</p>
<ul>
<li><strong>PRE_BUILD</strong>：在执行与目标相关的任何其他规则之前执行的命令。</li>
<li><strong>PRE_LINK</strong>：使用此选项，命令在编译目标之后，调用链接器或归档器之前执行。Visual Studio 7或更高版本之外的生成器中使用<code>PRE_BUILD</code>将被解释为<code>PRE_LINK</code>。</li>
<li><strong>POST_BUILD</strong>：如前所述，这些命令将在执行给定目标的所有规则之后运行。</li>
</ul>
<p>本例中，将两个自定义命令绑定到可执行目标。<code>PRE_LINK</code>命令将<code>${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/example.dir/link.txt</code>的内容打印到屏幕上。在我们的例子中，链接行是这样的:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">link line:</span><br><span class="line">/usr/bin/f95 -O3 -DNDEBUG -O3 CMakeFiles/<span class="built_in">example</span>.dir/<span class="built_in">example</span>.<span class="built_in">f90</span>.o -o <span class="built_in">example</span></span><br></pre></td></tr></table></figure>
<p>使用Python包装器来实现这一点，它依赖于shell命令。</p>
<p>第二步中，<code>POST_BUILD</code>自定义命令调用Python helper脚本<code>static-size.py</code>，生成器表达式<code>$&lt;target_file:example&gt;</code>作为参数。CMake将在生成时(即生成生成系统时)将生成器表达式扩展到目标文件路径。然后，Python脚本<code>static-size.py</code>使用size命令获取可执行文件的静态分配大小，将其转换为MB，并打印结果。我们的例子中，获得了预期的160 MB:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">size</span> of executable:</span><br><span class="line"><span class="number">160.003</span> MB</span><br></pre></td></tr></table></figure>
<h1 id="5-6-探究编译和链接命令"><a href="#5-6-探究编译和链接命令" class="headerlink" title="5.6 探究编译和链接命令"></a>5.6 探究编译和链接命令</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-06" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-06</a> 中找到，其中包含一个C++例子。该示例在CMake 3.9版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。代码库还有一个与CMake 3.5兼容的示例。</em></p>
<p>生成构建系统期间最常见的操作，是试图评估在哪种系统上构建项目。这意味着要找出哪些功能工作，哪些不工作，并相应地调整项目的编译。使用的方法是查询依赖项是否被满足的信号，或者在代码库中是否启用工作区。接下来的几个示例，将展示如何使用CMake执行这些操作。我们将特别讨论以下事宜:</p>
<ol>
<li>如何确保代码能成功编译为可执行文件。</li>
<li>如何确保编译器理解相应的标志。</li>
<li>如何确保特定代码能成功编译为运行可执行程序。</li>
</ol>
<h2 id="准备工作-4"><a href="#准备工作-4" class="headerlink" title="准备工作"></a>准备工作</h2><p>示例将展示如何使用来自对应的<code>Check&lt;LANG&gt;SourceCompiles.cmake</code>标准模块的<code>check_&lt;lang&gt;_source_compiles</code>函数，以评估给定编译器是否可以将预定义的代码编译成可执行文件。该命令可帮助你确定:</p>
<ul>
<li>编译器支持所需的特性。</li>
<li>链接器工作正常，并理解特定的标志。</li>
<li>可以使用<code>find_package</code>找到的包含目录和库。</li>
</ul>
<p>本示例中，我们将展示如何检测OpenMP 4.5标准的循环特性，以便在C++可执行文件中使用。使用一个C++源文件，来探测编译器是否支持这样的特性。CMake提供了一个附加命令<code>try_compile</code>来探究编译。本示例将展示，如何使用这两种方法。</p>
<p><strong>TIPS</strong>:<em>可以使用CMake命令行界面来获取关于特定模块(<code>cmake --help-module &lt;module-name&gt;</code>)和命令(<code>cmake --help-command &lt;command-name&gt;</code>)的文档。示例中，<code>cmake --help-module CheckCXXSourceCompiles</code>将把<code>check_cxx_source_compiles</code>函数的文档输出到屏幕上，而<code>cmake --help-command try_compile</code>将对<code>try_compile</code>命令执行相同的操作。</em></p>
<h2 id="具体实施-5"><a href="#具体实施-5" class="headerlink" title="具体实施"></a>具体实施</h2><p>我们将同时使用<code>try_compile</code>和<code>check_cxx_source_compiles</code>，并比较这两个命令的工作方式:</p>
<ol>
<li><p>创建一个C++11工程：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.9</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">06</span> LANGUAGES CXX)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找编译器支持的OpenMP：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenMP)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(OpenMP_FOUND)</span><br><span class="line">	<span class="comment"># ... &lt;- the steps below will be placed here</span></span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">	<span class="keyword">message</span>(STATUS <span class="string">"OpenMP not found: no test for taskloop is run"</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果找到OpenMP，再检查所需的特性是否可用。为此，设置了一个临时目录，<code>try_compile</code>将在这个目录下来生成中间文件。我们把它放在前面步骤中引入的<code>if</code>语句中:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">set</span>(_scratch_dir <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/omp_try_compile)</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>try_compile</code>生成一个小项目，以尝试编译源文件<code>taskloop.cpp</code>。编译成功或失败的状态，将保存到<code>omp_taskloop_test_1</code>变量中。需要为这个示例编译设置适当的编译器标志、包括目录和链接库。因为使用导入的目标<code>OpenMP::OpenMP_CXX</code>，所以只需将<code>LINK_LIBRARIES</code>选项设置为<code>try_compile</code>即可。如果编译成功，则任务循环特性可用，我们为用户打印一条消息:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try_compile</span>(</span><br><span class="line">  omp_taskloop_test_1</span><br><span class="line">  	<span class="variable">$&#123;_scratch_dir&#125;</span></span><br><span class="line">  SOURCES</span><br><span class="line">  	<span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/taskloop.cpp</span><br><span class="line">  <span class="keyword">LINK_LIBRARIES</span></span><br><span class="line">  	OpenMP::OpenMP_CXX</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">"Result of try_compile: $&#123;omp_taskloop_test_1&#125;"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>要使用<code>check_cxx_source_compiles</code>函数，需要包含<code>CheckCXXSourceCompiles.cmake</code>模块文件。其他语言也有类似的模块文件，C(<code>CheckCSourceCompiles.cmake</code>)和Fortran(<code>CheckFortranSourceCompiles.cmake</code>):</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(CheckCXXSourceCompiles)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们复制源文件的内容，通过<code>file(READ ...)</code>命令读取内容到一个变量中，试图编译和连接这个变量:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">file</span>(<span class="keyword">READ</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/taskloop.cpp _snippet)</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们设置了<code>CMAKE_REQUIRED_LIBRARIES</code>。这对于下一步正确调用编译器是必需的。注意使用导入的<code>OpenMP::OpenMP_CXX</code>目标，它还将设置正确的编译器标志和包含目录:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set(<span class="name">CMAKE_REQUIRED_LIBRARIES</span> OpenMP:<span class="symbol">:OpenMP_CXX</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用代码片段作为参数，调用<code>check_cxx_source_compiles</code>函数。检查结果将保存到<code>omp_taskloop_test_2</code>变量中:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">check_cxx_source_compiles</span><span class="params">(<span class="string">"$&#123;_snippet&#125;"</span> omp_taskloop_test_2)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>check_cxx_source_compiles</code>并向用户打印消息之前，我们取消了变量的设置:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unset(<span class="name">CMAKE_REQUIRED_LIBRARIES</span>)</span><br><span class="line">message(<span class="name">STATUS</span> <span class="string">"Result of check_cxx_source_compiles: $&#123;omp_taskloop_test_2&#125;"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，进行测试：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line"></span><br><span class="line">-<span class="ruby">- ...</span></span><br><span class="line"><span class="ruby">-- Found <span class="symbol">OpenMP_CXX:</span> -fopenmp (found version <span class="string">"4.5"</span>)</span></span><br><span class="line"><span class="ruby">-- Found <span class="symbol">OpenMP:</span> TRUE (found version <span class="string">"4.5"</span>)</span></span><br><span class="line"><span class="ruby">-- Result of <span class="symbol">try_compile:</span> TRUE</span></span><br><span class="line"><span class="ruby">-- Performing Test omp_taskloop_test_2</span></span><br><span class="line"><span class="ruby">-- Performing Test omp_taskloop_test_2 - Success</span></span><br><span class="line"><span class="ruby">-- Result of <span class="symbol">check_cxx_source_compiles:</span> <span class="number">1</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-5"><a href="#工作原理-5" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>try_compile</code>和<code>check_cxx_source_compiles</code>都将编译源文件，并将其链接到可执行文件中。如果这些操作成功，那么输出变量<code>omp_task_loop_test_1</code>(前者)和<code>omp_task_loop_test_2</code>(后者)将被设置为<code>TRUE</code>。然而，这两个命令实现的方式略有不同。<code>check_&lt;lang&gt;_source_compiles</code>命令是<code>try_compile</code>命令的简化包装。因此，它提供了一个接口:</p>
<ol>
<li>要编译的代码片段必须作为CMake变量传入。大多数情况下，这意味着必须使用<code>file(READ ...)</code>来读取文件。然后，代码片段被保存到构建目录的<code>CMakeFiles/CMakeTmp</code>子目录中。</li>
<li>微调编译和链接，必须通过设置以下CMake变量进行:<ul>
<li>CMAKE_REQUIRED_FLAGS：设置编译器标志。</li>
<li>CMAKE_REQUIRED_DEFINITIONS：设置预编译宏。</li>
<li>CMAKE_REQUIRED_INCLUDES：设置包含目录列表。</li>
<li>CMAKE_REQUIRED_LIBRARIES：设置可执行目标能够连接的库列表。</li>
</ul>
</li>
<li>调用<code>check_&lt;lang&gt;_compiles_function</code>之后，必须手动取消对这些变量的设置，以确保后续使用中，不会保留当前内容。</li>
</ol>
<p><strong>NOTE</strong>:<em>使用CMake 3.9中可以对于OpenMP目标进行导入,但是目前的配置也可以使用CMake的早期版本，通过手动为<code>check_cxx_source_compiles</code>设置所需的标志和库:<code>set(CMAKE_REQUIRED_FLAGS ${OpenMP_CXX_FLAGS})</code>和<code>set(CMAKE_REQUIRED_LIBRARIES ${OpenMP_CXX_LIBRARIES})</code>。</em></p>
<p><strong>TIPS</strong>:<em>Fortran下，CMake代码的格式通常是固定的，但也有意外情况。为了处理这些意外，需要为<code>check_fortran_source_compiles</code>设置<code>-ffree-form</code>编译标志。可以通过<code>set(CMAKE_REQUIRED_FLAGS “-ffree-form&quot;)</code>实现。</em></p>
<p>这个接口反映了：测试编译是通过，在CMake调用中直接生成和执行构建和连接命令来执行的。</p>
<p>命令<code>try_compile</code>提供了更完整的接口和两种不同的操作模式:</p>
<ol>
<li>以一个完整的CMake项目作为输入，并基于它的<code>CMakeLists.txt</code>配置、构建和链接。这种操作模式提供了更好的灵活性，因为要编译项目的复杂度是可以选择的。</li>
<li>提供了源文件，和用于包含目录、链接库和编译器标志的配置选项。</li>
</ol>
<p>因此，<code>try_compile</code>基于在项目上调用CMake，其中<code>CMakeLists.txt</code>已经存在(在第一种操作模式中)，或者基于传递给<code>try_compile</code>的参数动态生成文件。</p>
<h2 id="更多信息-2"><a href="#更多信息-2" class="headerlink" title="更多信息"></a>更多信息</h2><p>本示例中概述的类型检查并不总是万无一失的，并且可能产生假阳性和假阴性。作为一个例子，可以尝试注释掉包含<code>CMAKE_REQUIRED_LIBRARIES</code>的行。运行这个例子仍然会报告“成功”，这是因为编译器将忽略OpenMP的<code>pragma</code>字段。</p>
<p>当返回了错误的结果时，应该怎么做？构建目录的<code>CMakeFiles</code>子目录中的<code>CMakeOutput.log</code>和<code>CMakeError.log</code>文件会提供一些线索。它们记录了CMake运行的操作的标准输出和标准错误。如果怀疑结果有误，应该通过搜索保存编译检查结果的变量集来检查前者。如果你怀疑有误报，你应该检查后者。</p>
<p>调试<code>try_compile</code>需要一些注意事项。即使检查不成功，CMake也会删除由该命令生成的所有文件。幸运的是，<code>debug-trycompile</code>将阻止CMake进行删除。如果你的代码中有多个<code>try_compile</code>调用，一次只能调试一个:</p>
<ol>
<li><p>运行CMake，不使用<code>--debug-trycompile</code>，将运行所有<code>try_compile</code>命令，并清理它们的执行目录和文件。</p>
</li>
<li><p>从CMake缓存中删除保存检查结果的变量。缓存保存到<code>CMakeCache.txt</code>文件中。要清除变量的内容，可以使用<code>-U</code>的CLI开关，后面跟着变量的名称，它将被解释为一个全局表达式，因此可以使用<code>*</code>和<code>?</code>：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> cmake -U &lt;<span class="keyword">variable</span>-name&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再次运行CMake，使用<code>--debug-trycompile</code>。只有清除缓存的检查才会重新运行。这次不会清理执行目录和文件。</p>
</li>
</ol>
<p><strong>TIPS</strong>:<em><code>try_compile</code>提供了灵活和干净的接口，特别是当编译的代码不是一个简短的代码时。我们建议在测试编译时，小代码片段时使用<code>check_&lt;lang&gt;_source_compile</code>。其他情况下，选择<code>try_compile</code>。</em></p>
<h1 id="5-7-探究编译器标志命令"><a href="#5-7-探究编译器标志命令" class="headerlink" title="5.7 探究编译器标志命令"></a>5.7 探究编译器标志命令</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-07" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-07</a> 中找到，其中包含一个C++例子。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>设置编译器标志，对是否能正确编译至关重要。不同的编译器供应商，为类似的特性实现有不同的标志。即使是来自同一供应商的不同编译器版本，在可用标志上也可能存在细微的差异。有时，会引入一些便于调试或优化目的的新标志。本示例中，我们将展示如何检查所选编译器是否可用某些标志。</p>
<h2 id="准备工作-5"><a href="#准备工作-5" class="headerlink" title="准备工作"></a>准备工作</h2><p>Sanitizers(请参考<a href="https://github.com/google/Sanitizers" target="_blank" rel="noopener">https://github.com/google/Sanitizers</a> )已经成为静态和动态代码分析的非常有用的工具。通过使用适当的标志重新编译代码并链接到必要的库，可以检查内存错误(地址清理器)、未初始化的读取(内存清理器)、线程安全(线程清理器)和未定义的行为(未定义的行为清理器)相关的问题。与同类型分析工具相比，Sanitizers带来的性能损失通常要小得多，而且往往提供关于检测到的问题的更详细的信息。缺点是，代码(可能还有工具链的一部分)需要使用附加的标志重新编译。</p>
<p>本示例中，我们将设置一个项目，使用不同的Sanitizers来编译代码，并展示如何检查，编译器标志是否正确使用。</p>
<h2 id="具体实施-6"><a href="#具体实施-6" class="headerlink" title="具体实施"></a>具体实施</h2><p>Clang编译器已经提供了Sanitizers，GCC也将其引入工具集中。它们是为C和C++程序而设计的。最新版本的Fortran也能使用这些编译标志，并生成正确的仪表化库和可执行程序。不过，本文将重点介绍C++示例。</p>
<ol>
<li><p>声明一个C++11项目：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.5</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">07</span> LANGUAGES CXX)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>声明列表<code>CXX_BASIC_FLAGS</code>，其中包含构建项目时始终使用的编译器标志<code>-g3</code>和<code>-O1</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">list</span><span class="params">(APPEND CXX_BASIC_FLAGS <span class="string">"-g3"</span> <span class="string">"-O1"</span>)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这里需要包括CMake模块<code>CheckCXXCompilerFlag.cmake</code>。C的模块为<code>CheckCCompilerFlag.cmake</code>，Fotran的模块为<code>CheckFortranCompilerFlag.cmake</code>(Fotran的模块是在CMake 3.3添加)：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(CheckCXXCompilerFlag)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们声明一个<code>ASAN_FLAGS</code>变量，它包含Sanitizer所需的标志，并设置<code>CMAKE_REQUIRED_FLAGS</code>变量，<code>check_cxx_compiler_flag</code>函数在内部使用该变量:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(ASAN_FLAGS <span class="string">"-fsanitize=address -fno-omit-frame-pointer"</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_REQUIRED_FLAGS $&#123;ASAN_FLAGS&#125;)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们调用<code>check_cxx_compiler_flag</code>来确保编译器理解<code>ASAN_FLAGS</code>变量中的标志。调用函数后，我们取消设置<code>CMAKE_REQUIRED_FLAGS</code>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">check_cxx_compiler_flag</span><span class="params">($&#123;ASAN_FLAGS&#125; asan_works)</span></span></span><br><span class="line"><span class="function"><span class="title">unset</span><span class="params">(CMAKE_REQUIRED_FLAGS)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果编译器理解这些选项，我们将变量转换为一个列表，用分号替换空格:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">asan_works</span>)</span><br><span class="line">	string(<span class="name">REPLACE</span> <span class="string">" "</span> <span class="string">";"</span> _asan_flags $&#123;ASAN_FLAGS&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们添加了一个可执行的目标，为代码定位Sanitizer:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">(asan-example asan-example.cpp)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们为可执行文件设置编译器标志，以包含基本的和Sanitizer标志:</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(asan-example</span><br><span class="line">  PUBLIC</span><br><span class="line">    <span class="variable">$&#123;CXX_BASIC_FLAGS&#125;</span></span><br><span class="line">    <span class="variable">$&#123;_asan_flags&#125;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，我们还将Sanitizer标志添加到链接器使用的标志集中。这将关闭<code>if(asan_works)</code>块:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">(asan-example PUBLIC $&#123;_asan_flags&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完整的示例源代码还展示了如何编译和链接线程、内存和未定义的行为清理器的示例可执行程序。这里不详细讨论这些，因为我们使用相同的模式来检查编译器标志。</p>
<p><strong>NOTE</strong>:<em>在GitHub上可以找到一个定制的CMake模块，用于在您的系统上寻找对Sanitizer的支持:<a href="https://github.com/arsenm/sanitizers-cmake" target="_blank" rel="noopener">https://github.com/arsenm/sanitizers-cmake</a></em></p>
<h2 id="工作原理-6"><a href="#工作原理-6" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>check_&lt;lang&gt;_compiler_flag</code>函数只是<code>check_&lt;lang&gt;_source_compiles</code>函数的包装器。这些包装器为特定代码提供了一种快捷方式。在用例中，检查特定代码片段是否编译并不重要，重要的是编译器是否理解一组标志。</p>
<p>Sanitizer的编译器标志也需要传递给链接器。可以使用<code>check_&lt;lang&gt;_compiler_flag</code>函数来实现，我们需要在调用之前设置<code>CMAKE_REQUIRED_FLAGS</code>变量。否则，作为第一个参数传递的标志将只对编译器使用。</p>
<p>当前配置中需要注意的是，使用字符串变量和列表来设置编译器标志。使用<code>target_compile_options</code>和<code>target_link_libraries</code>函数的字符串变量，将导致编译器和/或链接器报错。CMake将传递引用的这些选项，从而导致解析错误。这说明有必要用列表和随后的字符串操作来表示这些选项，并用分号替换字符串变量中的空格。实际上，CMake中的列表是分号分隔的字符串。</p>
<h2 id="更多信息-3"><a href="#更多信息-3" class="headerlink" title="更多信息"></a>更多信息</h2><p>我们将在第7章，编写一个函数来测试和设置编译器标志，到时候再来回顾，并概括测试和设置编译器标志的模式。</p>
<h1 id="5-8-探究可执行命令"><a href="#5-8-探究可执行命令" class="headerlink" title="5.8 探究可执行命令"></a>5.8 探究可执行命令</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-08" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-08</a> 中找到，其中包含一个C/C++例子。该示例在CMake 3.5版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>目前为止，我们已经展示了如何检查给定的源代码，是否可以由所选的编译器编译，以及如何确保所需的编译器和链接器标志可用。此示例中，将显示如何检查是否可以在当前系统上编译、链接和运行代码。</p>
<h2 id="准备工作-6"><a href="#准备工作-6" class="headerlink" title="准备工作"></a>准备工作</h2><p>本示例的代码示例是复用第3章第9节的配置，并进行微小的改动。之前，我们展示了如何在您的系统上找到ZeroMQ库并将其链接到一个C程序中。本示例中，在生成实际的C++程序之前，我们将检查一个使用GNU/Linux上的系统UUID库的小型C程序是否能够实际运行。</p>
<h2 id="具体实施-7"><a href="#具体实施-7" class="headerlink" title="具体实施"></a>具体实施</h2><p>开始构建C++项目之前，我们希望检查GNU/Linux上的UUID系统库是否可以被链接。这可以通过以下一系列步骤来实现:</p>
<ol>
<li><p>声明一个混合的C和C++11程序。这是必要的，因为我们要编译和运行的测试代码片段是使用C语言完成:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.6</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">08</span> LANGUAGES CXX C)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们需要在系统上找到UUID库。这通过使用<code>pkg-config</code>实现的。要求搜索返回一个CMake导入目标使用<code>IMPORTED_TARGET</code>参数:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">find_package</span><span class="params">(PkgConfig REQUIRED QUIET)</span></span></span><br><span class="line"><span class="function"><span class="title">pkg_search_module</span><span class="params">(UUID REQUIRED uuid IMPORTED_TARGET)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(TARGET PkgConfig::UUID)</span></span></span><br><span class="line">	message(STATUS <span class="string">"Found libuuid"</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来，需要使用<code>CheckCSourceRuns.cmake</code>模块。C++的是<code>CheckCXXSourceRuns.cmake</code>模块。但到CMake 3.11为止，Fortran语言还没有这样的模块:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">include</span><span class="params">(CheckCSourceRuns)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们声明一个<code>_test_uuid</code>变量，其中包含要编译和运行的C代码段:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(_test_uuid</span><br><span class="line">"</span><br><span class="line">#<span class="keyword">include</span> &lt;uuid/uuid.<span class="keyword">h</span>&gt;</span><br><span class="line">int main(int argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  uuid_t uuid;</span><br><span class="line">  uuid_generate(uuid);</span><br><span class="line">  <span class="keyword">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">")</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们声明<code>CMAKE_REQUIRED_LIBRARIES</code>变量后，对<code>check_c_source_runs</code>函数的调用。接下来，调用<code>check_c_source_runs</code>，其中测试代码作为第一个参数，<code>_runs</code>变量作为第二个参数，以保存执行的检查结果。之后，取消<code>CMAKE_REQUIRED_LIBRARIES</code>变量的设置:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_REQUIRED_LIBRARIES PkgConfig::UUID)</span></span></span><br><span class="line"><span class="function"><span class="title">check_c_source_runs</span><span class="params">(<span class="string">"$&#123;_test_uuid&#125;"</span> _runs)</span></span></span><br><span class="line"><span class="function"><span class="title">unset</span><span class="params">(CMAKE_REQUIRED_LIBRARIES)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果检查没有成功，要么是代码段没有编译，要么是没有运行，我们会用致命的错误停止配置:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(NOT _runs)</span></span></span><br><span class="line">	message(FATAL_ERROR <span class="string">"Cannot run a simple C executable using libuuid!"</span>)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>若成功，我们继续添加C++可执行文件作为目标，并链接到UUID:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add_executable(<span class="keyword">use</span>-<span class="keyword">uuid</span> <span class="keyword">use</span>-uuid.cpp)</span><br><span class="line">target_link_libraries(<span class="keyword">use</span>-<span class="keyword">uuid</span></span><br><span class="line">  <span class="keyword">PUBLIC</span></span><br><span class="line">  	PkgConfig::<span class="keyword">UUID</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-7"><a href="#工作原理-7" class="headerlink" title="工作原理"></a>工作原理</h2><p><code>check_&lt;lang&gt;_source_runs</code>用于C和C++的函数，与<code>check_&lt;lang&gt;_source_compile</code>相同，但在实际运行生成的可执行文件的地方需要添加一个步骤。对于<code>check_&lt;lang&gt;_source_compiles</code>, <code>check_&lt;lang&gt;_source_runs</code>的执行可以通过以下变量来进行:</p>
<ul>
<li>CMAKE_REQUIRED_FLAGS：设置编译器标志。</li>
<li>CMAKE_REQUIRED_DEFINITIONS：设置预编译宏。</li>
<li>CMAKE_REQUIRED_INCLUDES：设置包含目录列表。</li>
<li>CMAKE_REQUIRED_LIBRARIES：设置可执行目标需要连接的库列表。</li>
</ul>
<p>由于使用<code>pkg_search_module</code>生成的为导入目标，所以只需要将<code>CMAKE_REQUIRES_LIBRARIES</code>设置为<code>PkgConfig::UUID</code>，就可以正确设置包含目录。</p>
<p>正如<code>check_&lt;lang&gt;_source_compiles</code>是<code>try_compile</code>的包装器，<code>check_&lt;lang&gt;_source_runs</code>是CMake中另一个功能更强大的命令的包装器:<code>try_run</code>。因此，可以编写一个<code>CheckFortranSourceRuns.cmake</code>模块，通过适当包装<code>try_run</code>, 提供与C和C++模块相同的功能。</p>
<p><strong>NOTE</strong>:<em><code>pkg_search_module</code>只能定义导入目标(CMake 3.6),但目前的示例可以使工作，3.6之前版本的CMake可以通过手动设置所需的包括目录和库<code>check_c_source_runs</code>如下:<code>set(CMAKE_REQUIRED_INCLUDES $ {UUID_INCLUDE_DIRS})</code>和<code>set(CMAKE_REQUIRED_LIBRARIES $ {UUID_LIBRARIES})</code>。</em></p>
<h1 id="5-9-使用生成器表达式微调配置和编译"><a href="#5-9-使用生成器表达式微调配置和编译" class="headerlink" title="5.9 使用生成器表达式微调配置和编译"></a>5.9 使用生成器表达式微调配置和编译</h1><p><strong>NOTE</strong>:<em>此示例代码可以在 <a href="https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-09" target="_blank" rel="noopener">https://github.com/dev-cafe/cmake-cookbook/tree/v1.0/chapter-5/recipe-09</a> 中找到，其中包含一个C++例子。该示例在CMake 3.9版(或更高版本)中是有效的，并且已经在GNU/Linux、macOS和Windows上进行过测试。</em></p>
<p>CMake提供了一种特定于领域的语言，来描述如何配置和构建项目。自然会引入描述特定条件的变量，并在<code>CMakeLists.txt</code>中包含基于此的条件语句。</p>
<p>本示例中，我们将重新讨论生成器表达式。第4章中，以简洁地引用显式的测试可执行路径，使用了这些表达式。生成器表达式为逻辑和信息表达式，提供了一个强大而紧凑的模式，这些表达式在生成构建系统时进行评估，并生成特定于每个构建配置的信息。换句话说，生成器表达式用于引用仅在生成时已知，但在配置时未知或难于知晓的信息；对于文件名、文件位置和库文件后缀尤其如此。</p>
<p>本例中，我们将使用生成器表达式，有条件地设置预处理器定义，并有条件地链接到消息传递接口库(Message Passing Interface, MPI)，并允许我们串行或使用MPI构建相同的源代码。</p>
<p><strong>NOTE</strong>:<em>本例中，我们将使用一个导入的目标来链接到MPI，该目标仅从CMake 3.9开始可用。但是，生成器表达式可以移植到CMake 3.0或更高版本。</em></p>
<h2 id="准备工作-7"><a href="#准备工作-7" class="headerlink" title="准备工作"></a>准备工作</h2><p>我们将编译以下示例源代码(<code>example.cpp</code>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MPI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MPI</span></span><br><span class="line">  <span class="comment">// initialize MPI</span></span><br><span class="line">  MPI_Init(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// query and print the rank</span></span><br><span class="line">  <span class="keyword">int</span> rank;</span><br><span class="line">  MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello from rank "</span> &lt;&lt; rank &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize MPI</span></span><br><span class="line">  MPI_Finalize();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello from a sequential binary"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* HAVE_MPI */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码包含预处理语句(<code>#ifdef HAVE_MPI ... #else ... #endif</code>)，这样我们就可以用相同的源代码编译一个顺序的或并行的可执行文件了。</p>
<h2 id="具体实施-8"><a href="#具体实施-8" class="headerlink" title="具体实施"></a>具体实施</h2><p>编写<code>CMakeLists.txt</code>文件时，我们将重用第3章第6节的一些构建块:</p>
<ol>
<li><p>声明一个C++11项目：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.9</span> FATAL_ERROR)</span></span></span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(recipe-<span class="number">09</span> LANGUAGES CXX)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD <span class="number">11</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_EXTENSIONS OFF)</span></span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(CMAKE_CXX_STANDARD_REQUIRED ON)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后，我们引入一个选项<code>USE_MPI</code>来选择MPI并行化，并将其设置为默认值<code>ON</code>。如果为<code>ON</code>，我们使用<code>find_package</code>来定位MPI环境:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">option</span><span class="params">(USE_MPI <span class="string">"Use MPI parallelization"</span> ON)</span></span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(USE_MPI)</span></span></span><br><span class="line">	find_package(MPI REQUIRED)</span><br><span class="line"><span class="function"><span class="title">endif</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>然后定义可执行目标，并有条件地设置相应的库依赖项(<code>MPI::MPI_CXX</code>)和预处理器定义(<code>HAVE_MPI</code>)，稍后将对此进行解释:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add_executable(example example.cpp)</span><br><span class="line">target_link_libraries(example</span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;MPI_FOUND&#125;&gt;<span class="symbol">:MPI</span><span class="symbol">:</span><span class="symbol">:MPI_CXX&gt;</span></span><br><span class="line">  )</span><br><span class="line">target_compile_definitions(example</span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;MPI_FOUND&#125;&gt;<span class="symbol">:HAVE_MPI&gt;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果找到MPI，还将打印由<code>FindMPI.cmake</code>导出的<code>INTERFACE_LINK_LIBRARIES</code>，为了方便演示，使用了<code>cmake_print_properties()</code>函数:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">MPI_FOUND</span>)</span><br><span class="line">  include(<span class="name">CMakePrintHelpers</span>)</span><br><span class="line">  cmake_print_properties(</span><br><span class="line">    TARGETS MPI:<span class="symbol">:MPI_CXX</span></span><br><span class="line">    PROPERTIES INTERFACE_LINK_LIBRARIES</span><br><span class="line">    )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先使用默认MPI配置。观察<code>cmake_print_properties()</code>的输出:</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p build<span class="emphasis">_mpi</span></span><br><span class="line"><span class="emphasis">$ cd build_</span>mpi</span><br><span class="line">$ cmake ..</span><br><span class="line"></span><br><span class="line"><span class="bullet">-- </span>...</span><br><span class="line">--</span><br><span class="line">Properties for TARGET MPI::MPI<span class="emphasis">_CXX:</span></span><br><span class="line"><span class="emphasis">MPI::MPI_</span>CXX.INTERFACE<span class="emphasis">_LINK_</span>LIBRARIES = "-Wl,-rpath -Wl,/usr/lib/openmpi -Wl,--enable-new-dtags -pthread;/usr/lib/openmpi/libmpi<span class="emphasis">_cxx.so;/usr/lib/openmpi/libmpi.so"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译并运行并行例子:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cmake --build .</span><br><span class="line">$ mpirun -<span class="built_in">np</span> <span class="number">2</span> ./<span class="built_in">example</span></span><br><span class="line"></span><br><span class="line">hello from <span class="built_in">rank</span> <span class="number">0</span></span><br><span class="line">hello from <span class="built_in">rank</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>现在，创建一个新的构建目录，这次构建串行版本:</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> mkdir -p build_seq</span><br><span class="line"><span class="symbol">$</span> cd build_seq</span><br><span class="line"><span class="symbol">$</span> cmake -D USE_MPI=OFF ..</span><br><span class="line"><span class="symbol">$</span> cmake --build .</span><br><span class="line"><span class="symbol">$</span> ./example</span><br><span class="line"></span><br><span class="line">hello from a sequential <span class="keyword">binary</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="工作原理-8"><a href="#工作原理-8" class="headerlink" title="工作原理"></a>工作原理</h2><p>CMake分两个阶段生成项目的构建系统：配置阶段(解析<code>CMakeLists.txt</code>)和生成阶段(实际生成构建环境)。生成器表达式在第二阶段进行计算，可以使用仅在生成时才能知道的信息来调整构建系统。生成器表达式在交叉编译时特别有用，一些可用的信息只有解析<code>CMakeLists.txt</code>之后，或在多配置项目后获取，构建系统生成的所有项目可以有不同的配置，比如Debug和Release。</p>
<p>本例中，将使用生成器表达式有条件地设置链接依赖项并编译定义。为此，可以关注这两个表达式:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">target_link_libraries(example</span><br><span class="line">  PUBLIC</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;MPI_FOUND&#125;&gt;<span class="symbol">:MPI</span><span class="symbol">:</span><span class="symbol">:MPI_CXX&gt;</span></span><br><span class="line">  )</span><br><span class="line">target_compile_definitions(example</span><br><span class="line">  PRIVATE</span><br><span class="line">  	$&lt;$&lt;<span class="symbol">BOOL:</span>$&#123;MPI_FOUND&#125;&gt;<span class="symbol">:HAVE_MPI&gt;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>如果<code>MPI_FOUND</code>为真，那么<code>$&lt;BOOL:${MPI_FOUND}&gt;</code>的值将为1。本例中，<code>$&lt;$&lt;BOOL:${MPI_FOUND}&gt;:MPI::MPI_CXX&gt;</code>将计算<code>MPI::MPI_CXX</code>，第二个生成器表达式将计算结果存在<code>HAVE_MPI</code>。如果将<code>USE_MPI</code>设置为<code>OFF</code>，则<code>MPI_FOUND</code>为假，两个生成器表达式的值都为空字符串，因此不会引入链接依赖关系，也不会设置预处理定义。</p>
<p>我们可以通过<code>if</code>来达到同样的效果:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(<span class="name">MPI_FOUND</span>)</span><br><span class="line">  target_link_libraries(<span class="name">example</span></span><br><span class="line">    PUBLIC</span><br><span class="line">    	MPI:<span class="symbol">:MPI_CXX</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">  target_compile_definitions(<span class="name">example</span></span><br><span class="line">    PRIVATE</span><br><span class="line">    	HAVE_MPI</span><br><span class="line">    )</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure>
<p>这个解决方案不太优雅，但可读性更好。我们可以使用生成器表达式来重新表达<code>if</code>语句，而这个选择取决于个人喜好。但当我们需要访问或操作文件路径时，生成器表达式尤其出色，因为使用变量和<code>if</code>构造这些路径可能比较困难。本例中，我们更注重生成器表达式的可读性。第4章中，我们使用生成器表达式来解析特定目标的文件路径。第11章中，我们会再次来讨论生成器。</p>
<h2 id="更多信息-4"><a href="#更多信息-4" class="headerlink" title="更多信息"></a>更多信息</h2><p>CMake提供了三种类型的生成器表达式:</p>
<ul>
<li><strong>逻辑表达式</strong>，基本模式为<code>$&lt;condition:outcome&gt;</code>。基本条件为0表示false, 1表示true，但是只要使用了正确的关键字，任何布尔值都可以作为条件变量。</li>
<li><strong>信息表达式</strong>，基本模式为<code>$&lt;information&gt;</code>或<code>$&lt;information:input&gt;</code>。这些表达式对一些构建系统信息求值，例如：包含目录、目标属性等等。这些表达式的输入参数可能是目标的名称，比如表达式<code>$&lt;TARGET_PROPERTY:tgt,prop&gt;</code>，将获得的信息是tgt目标上的prop属性。</li>
<li><strong>输出表达式</strong>，基本模式为<code>$&lt;operation&gt;</code>或<code>$&lt;operation:input&gt;</code>。这些表达式可能基于一些输入参数，生成一个输出。它们的输出可以直接在CMake命令中使用，也可以与其他生成器表达式组合使用。例如, <code>- I$&lt;JOIN:$&lt;TARGET_PROPERTY:INCLUDE_DIRECTORIES&gt;, -I&gt;</code>将生成一个字符串，其中包含正在处理的目标的包含目录，每个目录的前缀由<code>-I</code>表示。</li>
</ul>
<p>有关生成器表达式的完整列表，请参考<a href="https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html</a></p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2021/03/100657.html" class="pre-post btn btn-default" title='CMake 完整使用教程 之七 生成源码'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之七 生成源码</span>
        </a>
    
    
        <a href="/archives/2021/03/100655.html" class="next-post btn btn-default" title='CMake 完整使用教程 之五 创建和运行测试'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">CMake 完整使用教程 之五 创建和运行测试</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#5-1-使用平台无关的文件操作"><span class="toc-text">5.1 使用平台无关的文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-2-配置时运行自定义命令"><span class="toc-text">5.2 配置时运行自定义命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-1"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-1"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-1"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-3-构建时运行自定义命令-Ⅰ-使用add-custom-command"><span class="toc-text">5.3 构建时运行自定义命令:Ⅰ. 使用add_custom_command</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-1"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-2"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-2"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-4-构建时运行自定义命令-Ⅱ-使用add-custom-target"><span class="toc-text">5.4 构建时运行自定义命令:Ⅱ. 使用add_custom_target</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-2"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-3"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-3"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-5-构建时为特定目标运行自定义命令"><span class="toc-text">5.5 构建时为特定目标运行自定义命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-3"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-4"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-4"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-6-探究编译和链接命令"><span class="toc-text">5.6 探究编译和链接命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-4"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-5"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-5"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-2"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-7-探究编译器标志命令"><span class="toc-text">5.7 探究编译器标志命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-5"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-6"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-6"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-3"><span class="toc-text">更多信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-8-探究可执行命令"><span class="toc-text">5.8 探究可执行命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-6"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-7"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-7"><span class="toc-text">工作原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-9-使用生成器表达式微调配置和编译"><span class="toc-text">5.9 使用生成器表达式微调配置和编译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#准备工作-7"><span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体实施-8"><span class="toc-text">具体实施</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#工作原理-8"><span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#更多信息-4"><span class="toc-text">更多信息</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2023&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>