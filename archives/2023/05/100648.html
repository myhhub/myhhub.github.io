<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="c++">


    <meta name="description" content="宏 替换 发生的时机   为了能够真正理解#define的作用，需要了解下C语言源程序的处理过程。当在一个集成的开发环境如Turbo C中将编写好的源程序进行编译时，实际经过了预处理、编译、汇编...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>C/C++宏 详解 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="C/C++宏 详解">
            
	            C/C++宏 详解
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/c/">c++</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2023/05/24</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>419</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="宏-替换-发生的时机"><a href="#宏-替换-发生的时机" class="headerlink" title="宏 替换 发生的时机"></a><strong>宏 替换 发生的时机</strong></h1><p>   为了能够真正理解#define的作用，需要了解下C语言源程序的处理过程。当在一个集成的开发环境如Turbo C中将编写好的源程序进行编译时，实际经过了<strong>预处理、编译、汇编</strong>和<strong>连接</strong>几个过程。其中预处理器产生编译器的输出，它实现以下的功能：</p>
<ol>
<li><strong>文件包含。</strong><br>可以把源程序中的#include 扩展为文件正文，即把包含的.h文件找到并展开到#include 所在处。</li>
<li><strong>条件编译。</strong><br>预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。</li>
<li><strong>宏展开。</strong><br>预处理器将源程序文件中出现的对宏的引用展开成相应的宏 定义，即本文所说的#define的功能，由预处理器来完成。经过预处理器处理的源程序与之前的源程序有所有不同，<strong>在这个阶段所进行的工作只是纯粹的替换与展开，没有任何计算功能，所以在学习#define命令时只要能真正理解这一点，这样才不会对此命令引起误解并误用。</strong></li>
</ol>
<h1 id="1-define的基本用法"><a href="#1-define的基本用法" class="headerlink" title="1. #define的基本用法"></a><strong>1. #define的基本用法</strong></h1><p>  #define 是 C语言中提供的宏定义命令，其主要目的是为程序员在编程时提供一定的方便，并能在一定程度上提高程序的运行效率，但学生在学习时往往不能 理解该命令的本质，总是在此处产生一些困惑，在编程时误用该命令，使得程序的运行与预期的目的不一致，或者在读别人写的程序时，把运行结果理解错误，这对 C语言的学习很不利。</p>
<h2 id="1-1-define命令剖析"><a href="#1-1-define命令剖析" class="headerlink" title="1.1 #define命令剖析"></a><strong>1.1 #define命令剖析</strong></h2><p>​     #define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。<strong>该命令有两种格式：**</strong>一种是简单的宏定义，另一种是带参数的宏定义**。</p>
<p>  一个标识符被宏定义后，该标识符便是一个宏名。这时，在程序中出现的是宏名，在该程序被编译前，先将宏名用被定义的字符串替换，这称为宏替换，替换后才进行编译，宏替换只是简单的替换，即 简单的纯文本替换，C预处理器不对宏体做任何语法检查，像缺个括号、少个分号什么的预处理器是不管的。</p>
<p> 宏体换行需要在行末加反斜杠 \</p>
<ul>
<li><p>宏名之后带括号的宏 被认为是 宏函数。用法和普通函数一样，只不过在预处理阶段，宏函数会被展开。优点是没有普通函数保存寄存器和参数传递的开销，展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。<br>#define min(X, Y) ((X) &lt; (Y) ? (X) : (Y))<br>y = min(1, 2);会被扩展成y = ((1) &lt; (2) ? (1) : (2));</p>
</li>
<li><p>分号吞噬 问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) \</span></span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">return</span> (x) &gt; (y) ? (x):(y); \</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">    MAX(<span class="number">20</span>, <span class="number">10</span>); <span class="comment">//这个分号导致这一部分代码块结束，致使else找不到对应的if分支而报错</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ;;</span><br><span class="line"> </span><br><span class="line">上面 宏 展开后 <span class="keyword">if</span> <span class="keyword">else</span> 代码如下</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">    &#123; <span class="keyword">return</span> (<span class="number">20</span>) &gt; (<span class="number">10</span>) ? (<span class="number">20</span>):(<span class="number">10</span>); &#125;;<span class="comment">//后面多了一个分号，导致 if 代码块结束，致使else找不到对应的if分支而报错</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>示例代码（test.c）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) \  </span></span><br><span class="line">&#123; \  </span><br><span class="line">    <span class="keyword">return</span> (x) &gt; (y) ? (x):(y); \  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)  </span><br><span class="line">        MAX(<span class="number">20</span>, <span class="number">10</span>); <span class="comment">//这个分号导致这一部分代码块结束，致使else找不到对应的if分支而报错  </span></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        ;;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>gcc -E test.c -o test.e 会生成 test.e 的预处理文件</p>
<p>gcc -E test.c 会直接把预处理后内容输出到屏幕上。</p>
<p>可以看到后面多了一个分号。现在执行编译</p>
<p>可以看到 else 分支缺少 对应的 if 。</p>
<p>预处理并不分析整个源代码文件, 它只是将源代码分割成一些标记(token), 识别语句中哪些是C语句, 哪些是预处理语句. 预处理器能够识别C标记, 文件名, 空白符, 文件结尾标志.</p>
<p>预处理语句格式:  <strong>#command name(…) token(s)</strong></p>
<p>1, command预处理命令的名称, 它之前以#开头, #之后紧随预处理命令, 标准C允许#两边可以有空白符, 但比较老的编译器可能不允许这样. 若某行中只包含#(以及空白符), 那么在标准C中该行被理解为空白. 整个预处理语句之后只能有空白符或者注释, 不能有其它内容.<br>2, name代表宏名称, 它可带参数. 参数可以是可变参数列表(C99).<br>3, 语句中可以利用”\”来换行.</p>
<p><strong>e.g.</strong><br># define ONE 1 /<em> ONE == 1 </em>/<br>等价于: #define ONE　１</p>
<p>#define err(flag, msg) if(flag) \<br>  printf(msg)<br>等价于: #define err(flag, msg) if(flag) printf(msg)</p>
<h3 id="简单的宏定义"><a href="#简单的宏定义" class="headerlink" title="简单的宏定义"></a><strong>简单的宏定义</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-string">&lt;宏名&gt; &lt;字符串&gt;</span></span></span><br><span class="line">例： <span class="meta">#<span class="meta-keyword">define</span> PI      3.1415926</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> FALSE   0</span></span><br></pre></td></tr></table></figure>
<h3 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a><strong>带参数的宏定义</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define &lt;宏名&gt;(&lt;形式参数表&gt;) &lt;宏体&gt;</span></span><br><span class="line">例： <span class="comment">#define A(x) x</span></span><br><span class="line">     <span class="comment">#define MAX(a,b) ( (a) &gt; (b) ) ? (a) : (b)</span></span><br></pre></td></tr></table></figure>
<h3 id="取消宏定义：-undef-宏名"><a href="#取消宏定义：-undef-宏名" class="headerlink" title="取消宏定义：#undef 宏名"></a><strong>取消宏定义：</strong>#undef 宏名</h3><h3 id="可变参数-的-宏"><a href="#可变参数-的-宏" class="headerlink" title="可变参数 的 宏"></a><strong>可变参数 的 宏</strong></h3><p>C/C++宏定义的可变参数详细解析_C 语言：<a href="https://yq.aliyun.com/ziliao/134584" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/134584</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG( format, ... ) printf( format, __VA_ARGS__ )</span></span><br><span class="line">LOG( <span class="string">"%s %d"</span>, str, count );</span><br></pre></td></tr></table></figure>
<p><strong>VA_ARGS</strong>是系统预定义宏，被自动替换为参数列表。</p>
<p>#define debug(format, args…) fprintf (stderr, format, args)<br>#define debug(format, …) fprintf (stderr, format, <strong>VA_ARGS</strong>)<br>或者</p>
<p>#define debug(format, …) fprintf (stderr, format, <strong>## <strong>VA_ARGS</strong></strong>)<br>前两者存在多余逗号问题，第三个宏使用##去掉可能多余的逗号。</p>
<p>即可变参数被忽略或为空，’##’操作将使预处理器(preprocessor)去除掉它前面的那个逗号</p>
<p> <strong>当一个宏自己调用自己时，会发生什么？</strong></p>
<p>例如：#define TEST( x ) ( x + TEST( x ) )<br>TEST( 1 ); 会发生什么？为了防止无限制递归展开，语法规定，当一个宏遇到自己时，就停止展开，也就是说，当对TEST( 1 )进行展开时，展开过程中又发现了一个TEST，那么就将这个TEST当作一般的符号。TEST(1) 最终被展开为：1 + TEST( 1) 。</p>
<h3 id="宏参数的prescan-预扫描"><a href="#宏参数的prescan-预扫描" class="headerlink" title="宏参数的prescan(预扫描)"></a><strong>宏参数的prescan(预扫描)</strong></h3><p>当一个宏参数被放进宏体时，这个宏参数会首先被全部展开(有例外，见下文)。当展开后的宏参数被放进宏体时，预处理器对新展开的宏体进行第二次扫描，并继续展开。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARAM( x ) x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDPARAM( x ) INT_##x</span></span><br><span class="line">PARAM( ADDPARAM( <span class="number">1</span> ) );</span><br></pre></td></tr></table></figure>
<p>因为ADDPARAM( 1 ) 是作为PARAM的宏参数，所以先将ADDPARAM( 1 )展开为INT_1，然后再将INT_1放进PARAM。<br>例外情况：如果PARAM宏里对宏参数使用了#或##，那么宏参数不会被展开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARAM( x ) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDPARAM( x ) INT_##x</span></span><br><span class="line">PARAM( ADDPARAM( <span class="number">1</span> ) );        <span class="comment">//将被展开为"ADDPARAM( 1 )"。</span></span><br></pre></td></tr></table></figure>
<p>使用这么一个规则，可以创建一个很有趣的技术：打印出一个宏被展开后的样子，这样可以方便你分析代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_STRING( x ) TO_STRING1( x )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_STRING1( x ) #x</span></span><br></pre></td></tr></table></figure>
<p>TO_STRING首先会将x全部展开(如果x也是一个宏的话)，然后再传给TO_STRING1转换为字符串。</p>
<p>现在你可以这样：</p>
<p>​    const char *str = TO_STRING( PARAM( ADDPARAM( 1 ) ) );</p>
<p>去一探PARAM展开后的样子。</p>
<h3 id="一个很重要的补充："><a href="#一个很重要的补充：" class="headerlink" title="一个很重要的补充："></a><strong>一个很重要的补充：</strong></h3><p>  如果一个像函数的宏在使用时没有出现括号，那么预处理器只是将这个宏作为一般的符号处理(即 就是不处理)。</p>
<p>  函数宏对参数类型是不敏感的, 你不必考虑将何种数据类型传递给宏. 那么, 如何构建对参数类型敏感的宏呢? 参考关于”##”的介绍.</p>
<h3 id="对象宏"><a href="#对象宏" class="headerlink" title="对象宏"></a><strong>对象宏</strong></h3><p>不带参数的宏被称为”对象宏(objectlike macro)”<br>#define 经常用来定义常量, 此时的宏名称一般为大写的字符串. 这样利于修改这些常量.<br><strong>e.g.</strong><br>#define MAX 100<br>int a[MAX];</p>
<p>#ifndef <strong>FILE_H</strong><br>#define <strong>FILE_H</strong><br>#include “file.h”<br>#endif<br>#define <strong>FILE_H</strong> 中的宏就不带任何参数, 也不扩展为任何标记. 这经常用于包含头文件.</p>
<p>要调用该宏, 只需在代码中指定宏名称, 该宏将被替代为它被定义的内容.</p>
<h3 id="函数宏"><a href="#函数宏" class="headerlink" title="函数宏"></a><strong>函数宏</strong></h3><p>带参数的宏也被称为”函数宏”. 利用宏可以提高代码的运行效率: 子程序的调用需要压栈出栈, 这一过程如果过于频繁会耗费掉大量的CPU运算资源. 所以一些代码量小但运行频繁的代码如果采用带参数宏来实现会提高代码的运行效率.</p>
<p>函数宏的参数是固定的情况</p>
<p>函数宏的定义采用这样的方式: #define name( args ) tokens<br>其中的args和tokens都是可选的. 它和对象宏定义上的区别在于宏名称之后不带括号.</p>
<p>注意, name之后的左括号(必须紧跟name, 之间不能有空格, 否则这就定义了一个对象宏, 它将被替换为 以(开始的字符串. 但在调用函数宏时, name与(之间可以有空格.</p>
<p><strong>e.g.</strong><br>#define mul(x,y) ((x)*(y))</p>
<p>注意, 函数宏之后的参数要用括号括起来, 看看这个例子:<br>e.g.<br>#define mul(x,y) x<em>y<br>“mul(1, 2+2);” 将被扩展为: 1</em>2 + 2<br>同样, 整个标记串也应该用括号引用起来:<br><strong>e.g.</strong><br>#define mul(x,y) (x)<em>(y)<br>sizeof mul(1,2.0) 将被扩展为 sizeof 1 </em> 2.0</p>
<p>调用函数宏时候, 传递给它的参数可以是函数的返回值, 也可以是任何有意义的语句:<br>e.g.<br>mul (f(a,b), g(c,d));</p>
<p>e.g.<br>#define insert(stmt) stmt<br>insert ( a=1; b=2;) 相当于在代码中加入 a=1; b=2 .<br>insert ( a=1, b=2;) 就有问题了: 预处理器会提示出错: 函数宏的参数个数不匹配. 预处理器把”,”视为参数间的分隔符.<br>insert ((a=1, b=2;)) 可解决上述问题.</p>
<p>在定义和调用函数宏时候, 要注意一些问题:<br>1, 我们经常用{}来引用函数宏被定义的内容, 这就要注意调用这个函数宏时的”;”问题.<br>example_3.7:<br>#define swap(x,y) { unsigned long _temp=x; x=y; y=_tmp}<br>如果这样调用它: “swap(1,2);” 将被扩展为: { unsigned long _temp=1; 1=2; 2=_tmp};<br>明显后面的;是多余的, 我们应该这样调用: swap(1,2)<br>虽然这样的调用是正确的, 但它和C语法相悖, 可采用下面的方法来处理被{}括起来的内容:</p>
<p>#define swap(x,y) \<br>  do { unsigned long _temp=x; x=y; y=_tmp} while (0)<br>swap(1,2); 将被替换为:<br>do { unsigned long _temp=1; 1=2; 2=_tmp} while (0);<br>在Linux内核源代码中对这种do-while(0)语句有这广泛的应用.</p>
<p>2, 有的函数宏是无法用do-while(0)来实现的, 所以在调用时不能带上”;”, 最好在调用后添加注释说明.<br>eg_3.8:<br>#define incr(v, low, high) \<br>  for ((v) = (low),; (v) &lt;= (high); (v)++)<br>只能以这样的形式被调用: incr(a, 1, 10) /<em> increase a form 1 to 10 </em>/</p>
<p>函数宏中的参数包括可变参数列表的情况<br>C99标准中新增了可变参数列表的内容. 不光是函数, 函数宏中也可以使用可变参数列表.</p>
<p><strong>#define name(args, …) tokens</strong><br><strong>#define name(…) tokens</strong><br>“…”代表可变参数列表, 如果它不是仅有的参数, 那么它只能出现在参数列表的最后. 调用这样的函数宏时, 传递给它的参数个数要不少于参数列表中参数的个数(多余的参数被丢弃).<br>通过<strong>VA_ARGS</strong>来替换函数宏中的可变参数列表. 注意<strong>VA_ARGS</strong>只能用于函数宏中参数中包含有”…”的情况.</p>
<p>e.g.<br>#ifdef DEBUG<br>#define my_printf(…) fprintf(stderr, <strong>VA_ARGS</strong>)<br>#else<br>#define my_printf(…) printf(<strong>VA_ARGS</strong>)<br>#endif</p>
<p>tokens中的<strong>VA_ARGS</strong>被替换为函数宏定义中的”…”可变参数列表. </p>
<p>注意在使用#define时候的一些常见错误:<br>#define MAX = 100<br>#define MAX 100;<br>=, ; 的使用要值得注意. 再就是调用函数宏是要注意, 不要多给出”;”.</p>
<h2 id="1-2-关于定义宏的另外一些问题"><a href="#1-2-关于定义宏的另外一些问题" class="headerlink" title="1.2 关于定义宏的另外一些问题"></a><strong>1.2 关于定义宏的另外一些问题</strong></h2><h3 id="1-宏可以被多次定义-前提是这些定义必须是相同的。"><a href="#1-宏可以被多次定义-前提是这些定义必须是相同的。" class="headerlink" title="(1)宏可以被多次定义, 前提是这些定义必须是相同的。"></a><strong>(1)</strong>宏可以被多次定义, 前提是这些定义必须是相同的。</h3><p>这里的”相同”要求先后定义中空白符出现的位置相同, 但具体的空白符类型或数量可不同, 比如原先的空格可替换为多个其他类型的空白符: 可为tab, 注释…<br><strong>e.g.</strong><br>#define NULL 0<br>#define NULL　/<em> null pointer </em>/   0<br>上面的重定义是相同的, 但下面的重定义不同:<br>#define fun(x) x+1<br>#define fun(x) x + 1 或: #define fun(y) y+1<br>如果多次定义时, 再次定义的宏内容是不同的, gcc会给出”NAME redefined”警告信息.</p>
<p>应该避免重新定义函数宏, 不管是在预处理命令中还是C语句中, 最好对某个对象只有单一的定义. 在gcc中, 若宏出现了重定义, gcc会给出警告.</p>
<h3 id="2-在gcc中-可在命令行中指定对象宏的定义"><a href="#2-在gcc中-可在命令行中指定对象宏的定义" class="headerlink" title="(2) 在gcc中, 可在命令行中指定对象宏的定义:"></a>(2) 在gcc中, 可在命令行中指定对象宏的定义:</h3><p><strong>e.g.</strong><br>$ gcc -Wall -DMAX=100 -o tmp tmp.c<br>相当于在tmp.c中添加” #define MAX 100”.</p>
<p>那么, 如果原先tmp.c中含有MAX宏的定义, 那么再在gcc调用命令中使用-DMAX, 会出现什么情况呢?<br>—若-DMAX=1, 则正确编译.<br>—若-DMAX的值被指定为不为1的值, 那么gcc会给出MAX宏被重定义的警告, MAX的值仍为1.</p>
<p>注意: 若在调用gcc的命令行中不显示地给出对象宏的值, 那么gcc赋予该宏默认值(1), 如: -DVAL == -DVAL=1</p>
<h3 id="3-define所定义的宏的作用域"><a href="#3-define所定义的宏的作用域" class="headerlink" title="(3) #define所定义的宏的作用域"></a>(3) #define所定义的宏的作用域</h3><p>宏在定义之后才生效, 若宏定义被#undef取消, 则#undef之后该宏无效. 并且字符串中的宏不会被识别<br><strong>e.g.</strong><br>#define ONE 1<br>sum = ONE + TWO  /<em> sum = 1 + TWO </em>/<br>#define TWO 2<br>sum = ONE + TWO  /<em> sum = 1 + 2  </em>/<br>#undef ONE<br>sum = ONE + TWO  /<em> sum = ONE + 2 </em>/<br>char c[] = “TWO”  /<em> c[] = “TWO”, NOT “2”! </em>/</p>
<h3 id="4-宏的替换可以是递归的-所以可以嵌套定义宏"><a href="#4-宏的替换可以是递归的-所以可以嵌套定义宏" class="headerlink" title="(4) 宏的替换可以是递归的, 所以可以嵌套定义宏."></a>(4) 宏的替换可以是递归的, 所以可以嵌套定义宏.</h3><p><strong>e.g.</strong><br># define ONE NUMBER_1<br># define NUMBER_1 1<br>int a = ONE /<em> a = 1 </em>/</p>
<h2 id="1-3-undef"><a href="#1-3-undef" class="headerlink" title="1.3 #undef"></a>1.3 #undef</h2><p>#undef用来取消宏定义, 它与#define对立:<br><strong>#undef name</strong><br>如够被取消的宏实际上没有被#define所定义, 针对它的#undef并不会产生错误.<br>当一个宏定义被取消后, 可以再度定义它. </p>
<h2 id="1-4-if-elif-else-endif"><a href="#1-4-if-elif-else-endif" class="headerlink" title="1.4 #if, #elif, #else, #endif"></a>1.4 #if, #elif, #else, #endif</h2><p>#if, #elif, #else, #endif用于条件编译:<br><strong>#if 常量表达式1</strong><br>  <strong>语句…</strong><br><strong>#elif 常量表达式2</strong><br>  <strong>语句…</strong><br><strong>#elif 常量表达式3</strong><br>  <strong>语句…</strong><br><strong>…</strong><br><strong>#else</strong><br>  <strong>语句…</strong><br><strong>#endif</strong></p>
<p>#if和#else分别相当于C语句中的if, else. 它们根据常量表达式的值来判别是否执行后面的语句. #elif相当于C中的else-if. 使用这些条件编译命令可以方便地实现对源代码内容的控制.<br>else之后不带常量表达式, 但若包含了常量表达式, gcc只是给出警告信息.</p>
<p>使用它们可以提升代码的可移植性—针对不同的平台使用执行不同的语句. 也经常用于大段代码注释.<br><strong>e.g.</strong><br>#if 0<br>{<br>  一大段代码;<br>}<br>#endif</p>
<p>常量表达式可以是包含宏, 算术运算, 逻辑运算等等的合法C常量表达式, 如果常量表达式为一个未定义的宏, 那么它的值被视为0.<br>#if MACRO_NON_DEFINED == #if 0<br>在判断某个宏是否被定义时, 应当避免使用#if, 因为该宏的值可能就是被定义为0. 而应当使用下面介绍的#ifdef或#ifndef.</p>
<p>注意: #if, #elif, #else之后的宏只能是对象宏. 如果name为名的宏未定义, 或者该宏是函数宏. 那么在gcc中使用”-Wundef”选项会显示宏未定义的警告信息.</p>
<h2 id="1-5-ifdef-ifndef-defined"><a href="#1-5-ifdef-ifndef-defined" class="headerlink" title="1.5 #ifdef, #ifndef, defined."></a>1.5 #ifdef, #ifndef, defined.</h2><p>#ifdef, #ifndef, defined用来测试某个宏是否被定义<br>#ifdef name 或 #ifndef name</p>
<p>它们经常用于避免头文件的重复引用:<br>#ifndef <strong>FILE_H</strong><br>#define <strong>FILE_H</strong><br>#include “file.h”<br>#endif</p>
<p>defined(name): 若宏被定义,则返回1, 否则返回0.<br>它与#if, #elif, #else结合使用来判断宏是否被定义, 乍一看好像它显得多余, 因为已经有了#ifdef和#ifndef. defined用于在一条判断语句中声明多个判别条件:</p>
<p>#if defined(VAX) &amp;&amp; defined(UNIX) &amp;&amp; !defined(DEBUG) </p>
<p>和#if, #elif, #else不同, #indef, #ifndef, defined测试的宏可以是对象宏, 也可以是函数宏. 在gcc中使用”-Wundef”选项不会显示宏未定义的警告信息.</p>
<h2 id="1-6-include-include-next"><a href="#1-6-include-include-next" class="headerlink" title="1.6 #include , #include_next"></a>1.6 #include , #include_next</h2><p>#include用于文件包含. 在#include 命令所在的行不能含有除注释和空白符之外的其他任何内容.<br><strong>#include “headfile”</strong><br><strong>#include <headfile></headfile></strong><br><strong>#include 预处理标记</strong><br>前面两种形式大家都很熟悉, “#include 预处理标记”中, 预处理标记会被预处理器进行替换, 替换的结果必须符合前两种形式中的某一种.</p>
<p>实际上, 真正被添加的头文件并不一定就是#include中所指定的文件. #include”headfile”包含的头文件当然是同一个文件, 但#include <headfile>包包含的”系统头文件”可能是另外的文件. 但这不值得被注意. 感兴趣的话可以查看宏扩展后到底引入了哪些系统头文件.</headfile></p>
<p>关于#include “headfile”和#include <headfile>的区别以及如何在gcc中包含头文件的详细信息, 参考本blog的GCC笔记.</headfile></p>
<p>相对于#include, 我们对#include_next不太熟悉. #include_next仅用于特殊的场合. 它被用于头文件中(#include既可用于头文件中, 又可用于.c文件中)来包含其他的头文件. 而且包含头文件的路径比较特殊: 从当前头文件所在目录之后的目录来搜索头文件.<br>比如: 头文件的搜索路径一次为A,B,C,D,E. #include_next所在的当前头文件位于B目录, 那么#include_next使得预处理器从C,D,E目录来搜索#include_next所指定的头文件.</p>
<p>可参考<a href="http://gcc.gnu.org/onlinedocs/" target="_blank" rel="noopener">cpp手册</a>进一步了解#include_next</p>
<h2 id="1-7-预定义-的-宏"><a href="#1-7-预定义-的-宏" class="headerlink" title="1.7 预定义 的 宏**"></a>1.7 预定义 的 宏**</h2><p>标准C中定义了一些对象宏, 这些宏的名称以”__”开头和结尾, 并且都是大写字符. 这些预定义宏可以被#undef, 也可以被重定义.</p>
<p>下面列出一些标准C中常见的预定义对象宏(其中也包含gcc自己定义的一些预定义宏:</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__LINE__           当前语句所在的行号, 以<span class="number">10</span>进制整数标注.</span><br><span class="line">__FILE__           当前源文件的文件名, 以字符串常量标注.</span><br><span class="line">__DATE__           程序被编译的日期, 以<span class="string">"Mmm dd yyyy"</span>格式的字符串标注.</span><br><span class="line">__TIME__           程序被编译的时间, 以<span class="string">"hh:mm:ss"</span>格式的字符串标注, 该时间由asctime返回.</span><br><span class="line"></span><br><span class="line">__STDC__           如果当前编译器符合ISO标准, 那么该宏的值为<span class="number">1</span></span><br><span class="line">__STDC_VERSION__   如果当前编译器符合C89, 那么它被定义为<span class="number">199409</span>L, 如果符合C99, 那么被定义为<span class="number">199901</span>L. </span><br><span class="line">                   我用gcc, 如果不指定-std=c99, 其他情况都给出__STDC_VERSION__未定义的错误信息, 咋回事呢?</span><br><span class="line">__STDC_HOSTED__    如果当前系统是<span class="string">"本地系统(hosted)"</span>, 那么它被定义为<span class="number">1</span>. 本地系统表示当前系统拥有完整的标准C库.</span><br></pre></td></tr></table></figure>
<p>ANSI标准说明了五个预定义的宏名。它们是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_LINE_             <span class="comment">/* (两个下划线)，对应%d*/</span></span><br><span class="line">_FILE_             <span class="comment">/* 对应%s */</span></span><br><span class="line">__FUNCTION__       <span class="comment">/* 对应%s */</span></span><br><span class="line">_DATE_             <span class="comment">/* 对应%s */</span></span><br><span class="line">_TIME_             <span class="comment">/* 对应%s */</span></span><br></pre></td></tr></table></figure>
<p>gcc定义的预定义宏:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__OPTMIZE__         如果编译过程中使用了优化, 那么该宏被定义为1.</span><br><span class="line">__OPTMIZE_SIZE__    同上, 但仅在优化是针对代码大小而非速度时才被定义为1.</span><br><span class="line">__VERSION__         显示所用gcc的版本号.</span><br></pre></td></tr></table></figure>
<p>可参考”GCC the complete reference”.<br>要想看到gcc所定义的所有预定义宏, 可以运行: $ cpp -dM /dev/null</p>
<h2 id="1-7-line"><a href="#1-7-line" class="headerlink" title="1.7 #line"></a>1.7 #line</h2><p>#line用来修改<strong>LINE</strong>和<strong>FILE</strong>.<br><strong>e.g.</strong><br>printf(“line: %d, file: %s\n”, <strong>LINE</strong>, <strong>FILE</strong>);<br>#line 100 “haha”<br>printf(“line: %d, file: %s\n”, <strong>LINE</strong>, <strong>FILE</strong>);<br>printf(“line: %d, file: %s\n”, <strong>LINE</strong>, <strong>FILE</strong>);</p>
<p>显示:<br>line: 34, file: 1.c<br>line: 100, file: haha<br>line: 101, file: haha </p>
<h2 id="1-8-pragma-和-Pragma"><a href="#1-8-pragma-和-Pragma" class="headerlink" title="1.8 #pragma 和 _Pragma"></a>1.8 #pragma 和 _Pragma</h2><p>#pragma用编译器用来添加新的预处理功能或者显示一些编译信息. #pragma的格式是各编译器特定的, gcc的如下:<br><strong>#pragma GCC name token(s)</strong></p>
<p>#pragma之后有两个部分: GCC和特定的pragma name. 下面分别介绍gcc中常用的.</p>
<p><strong>(1) #pragma GCC dependency</strong><br>dependency测试当前文件(既该语句所在的程序代码)与指定文件(既#pragma语句最后列出的文件)的时间戳. 如果指定文件比当前文件新, 则给出警告信息.<br><strong>e.g.</strong><br>在demo.c中给出这样一句:<br>#pragma GCC dependency “temp-file”<br>然后在demo.c所在的目录新建一个更新的文件: $ touch temp-file, 编译: $ gcc demo.c 会给出这样的警告信息: warning: current file is older than temp-file<br>如果当前文件比指定的文件新, 则不给出任何警告信息.</p>
<p>还可以在在#pragma中给添加自定义的警告信息.<br><strong>e.g.</strong><br>#pragma GCC dependency “temp-file” “demo.c needs to be updated!”<br>1.c:27:38: warning: extra tokens at end of #pragma directive<br>1.c:27:38: warning: current file is older than temp-file<br>注意: 后面新增的警告信息要用””引用起来, 否则gcc将给出警告信息.</p>
<p><strong>(2) #pragma GCC poison token(s)</strong><br>若源代码中出现了#pragma中给出的token(s), 则编译时显示警告信息. 它一般用于在调用你不想使用的函数时候给出<strong>出错信息</strong>.<br>e.g.<br>#pragma GCC poison scanf<br>scanf(“%d”, &amp;a);<br>warning: extra tokens at end of #pragma directive<br>error: attempt to use poisoned “scanf”<br>注意, 如果调用了poison中给出的标记, 那么编译器会给出的是出错信息. 关于第一条警告, 我还不知道怎么避免, 用””将token(s)引用起来也不行.</p>
<p><strong>(3) #pragma GCC system_header</strong><br>从#pragma GCC system_header直到文件结束之间的代码会被编译器视为系统头文件之中的代码. 系统头文件中的代码往往不能完全遵循C标准, 所以头文件之中的警告信息往往不显示. (除非用 #warning显式指明).<br>(这条#pragma语句还没发现用什么大的用处<img src="http://www.cublog.cn/images/face/033.gif" alt="img">)</p>
<p>由于#pragma不能用于宏扩展, 所以gcc还提供了<strong>_Pragma</strong>:<br>e.g.<br>#define PRAGMA_DEP #pragma GCC dependency “temp-file”<br>由于预处理之进行一次宏扩展, 采用上面的方法会在编译时引发错误, 要将#pragma语句定义成一个宏扩展, 应该使用下面的_Pragma语句:<br>#define PRAGMA_DEP _Pragma(“GCC dependency \”temp-file\””)<br>注意, ()中包含的””引用之前引该加上\转义字符. </p>
<h2 id="1-9-warning-error"><a href="#1-9-warning-error" class="headerlink" title="1.9 #warning, #error"></a>1.9 #warning, #error</h2><p>#warning, #error分别用于在编译时显示警告和错误信息, 格式如下:<br><strong>#warning tokens</strong><br><strong>#error tokens</strong><br><strong>e.g.</strong><br>#warning “some warning”<br>注意, #error 和 #warning 后的 token 要用””引用起来!<br>(在gcc中, 如果给出了warning, 编译继续进行, 但若给出了error, 则编译停止. 若在命令行中指定了 -Werror, 即使只有警告信息, 也不编译.</p>
<h2 id="1-10-常用的预处理命令"><a href="#1-10-常用的预处理命令" class="headerlink" title="1.10 常用的预处理命令"></a><strong>1.10 常用的预处理命令</strong></h2><p>预处理命令由#(hash字符)开头, 它独占一行, #之前只能是空白符. 以#开头的语句就是预处理命令，不以#开头的语句为C中的代码行。</p>
<p>常用的预处理命令如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>              定义一个预处理宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>               取消宏的定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>             包含文件命令</span></span><br><span class="line">#include_next        与<span class="meta">#<span class="meta-keyword">include</span>相似, 但它有着特殊的用途</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>                  编译预处理中的条件命令, 相当于C语法中的<span class="meta-keyword">if</span>语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>               判断某个宏是否被定义, 若已定义, 执行随后的语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>              与#<span class="meta-keyword">ifdef</span>相反, 判断某个宏是否未被定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span>                若#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>或前面的#<span class="meta-keyword">elif</span>条件不满足, 则执行#<span class="meta-keyword">elif</span>之后的语句, 相当于C语法中的<span class="meta-keyword">else</span>-<span class="meta-keyword">if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                与#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>对应, 若这些条件不满足, 则执行#<span class="meta-keyword">else</span>之后的语句, 相当于C语法中的<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>               #<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>这些条件命令的结束标志.</span></span><br><span class="line">defined              与<span class="meta">#<span class="meta-keyword">if</span>, #<span class="meta-keyword">elif</span>配合使用, 判断某个宏是否被定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span>                标志该语句所在的行号</span></span><br><span class="line">#                    将宏参数替代为以参数值为内容的字符窜常量</span><br><span class="line">##                   将两个相邻的标记(token)连接为一个单独的标记</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>              说明编译器信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span>             显示编译警告信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>               显示编译错误信息</span></span><br></pre></td></tr></table></figure>
<h1 id="2-define使用中的常见问题解析"><a href="#2-define使用中的常见问题解析" class="headerlink" title="2. #define使用中的常见问题解析"></a><strong>2. #define使用中的常见问题解析</strong></h1><h2 id="2-1-简单宏定义使用中出现的问题"><a href="#2-1-简单宏定义使用中出现的问题" class="headerlink" title="2.1 简单宏定义使用中出现的问题"></a>2.1 简单宏定义使用中出现的问题</h2><p> 在简单宏定义的使用中，当替换文本所表示的字符串为一个表达式时，容易引起误解和误用。如下例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2+2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=N*N;</span><br><span class="line">    <span class="built_in">printf</span>(“%d”,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>出现问题：</strong></p>
<p>  在此程序中存在着宏定义命令，宏N代表的字符串是2+2，在程序中有对宏N的使用，一般同学在读该程序时，容易产生的问题是先求解N为2＋2＝4，然后在程序中计算a时使用乘法，即N<em>N=4</em>4=16，<strong>其实该题的结果为8，为什么结果有这么大的偏差?</strong></p>
<p><strong>问题解析：</strong></p>
<p>宏展开是在预处理阶段完成的，这个阶段把替换文本只是看作一个字符串，并不会有任何的计算发生，在展开时是在宏N出现的地方 只是简单地使用串2＋2来代替N，并不会增添任何的符号，所以对该程序展开后的结果是a=2+2*2+2，计算后=8，这就是宏替换的实质，如何写程序才能完成结果为16的运算呢？</p>
<p><strong>解决办法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*将宏定义写成如下形式*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N (2+2)</span></span><br><span class="line"><span class="comment">/*这样就可替换成(2+2)*(2+2)=16*/</span></span><br></pre></td></tr></table></figure>
<p><strong>总结：把 宏体 和 所有的宏变量 都用 括号括起来</strong></p>
<h2 id="2-2-带参数的宏定义出现的问题"><a href="#2-2-带参数的宏定义出现的问题" class="headerlink" title="2.2 带参数的宏定义出现的问题"></a><strong>2.2 带参数的宏定义出现的问题</strong></h2><p>  在带参数的宏定义的使用中，极易引起误解。例如我们需要做个宏替换能求任何数的平方，这就需要使用参数，以便在程序中用实际参数来替换宏定义中的参数。一般容易写成如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> area(x) x*x</span></span><br><span class="line"><span class="comment">/*这在使用中是很容易出现问题的，看如下的程序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = area(<span class="number">2</span>+<span class="number">2</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(“%d”,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  按理说给的参数是2+2，所得的结果应该为4<em>4=16，但是错了，因为该程序的实际结果为8，仍然是没能遵循纯粹的简单替换的规则，又是先计算再替换 了，在这道程序里，2+2即为area宏中的参数，应该由它来替换宏定义中的x，即替换成2+2</em>2+2=8了。那如果遵循(1)中的解决办法，把2+2 括起来，即把宏体中的x括起来，是否可以呢？#define area(x) (x)<em>(x)，对于area(2+2)，替换为(2+2)</em>(2+2)=16，可以解决，但是对于area(2+2)/area(2+2)又会怎么样呢，有的学生一看到这道题马上给出结果，因为分子分母一样，又错了，还是忘了遵循先替换再计算的规则了，这道题替换后会变为 (2+2)<em>(2+2)/(2+2)</em>(2+2)即4<em>4/4</em>4按照乘除运算规则，结果为16/4<em>4=4</em>4=16，那应该怎么呢？解决方法是在整个宏体上再加一个括号，即#define  area(x) ((x)*(x))，不要觉得这没必要，没有它，是不行的。<br>  要想能够真正使用好宏定义，那么在读别人的程序时，一定要记住先将程序中对宏的使用全部替换成它所代表的字符串，不要自作主张地添加任何其他符号，完全展开后再进行相应的计算，就不会写错运行结果。</p>
<p>  如果是自己编程使用宏替换，则在使用简单宏定义时，当字符串中不只一个符号时，加上括号表现出优先级，如果是带参数的宏定义，则要给宏体中的每个参数加上括号，并在整个宏体上再加一个括号。看到这里，不禁要问，用宏定义这么麻烦，这么容易出错，可不可以摒弃它， 那让我们来看一下在C语言中用宏定义的好处吧。</p>
<p>如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> product(x)    x*x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> j,k;</span><br><span class="line">    j = product(i++);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"j="</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    k = product(++i);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"k="</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次输出结果：</p>
<p>j=9;i=5;k=49;i=7</p>
<h1 id="3-宏定义的优点"><a href="#3-宏定义的优点" class="headerlink" title="3. 宏定义的优点"></a><strong>3. 宏定义的优点</strong></h1><p><strong>(1)  方便程序的修改</strong></p>
<p>  使用简单宏定义可用宏代替一个在程序中经常使用的常量，这样在将该常量改变时，不用对整个程序进行修改，只修改宏定义的字符串即可，而且当常量比较长时， 我们可以用较短的有意义的标识符来写程序，这样更方便一些。我们所说的常量改变不是在程序运行期间改变，而是在编程期间的修改，举一个大家比较熟悉的例子，圆周率π是在数学上常用的一个值，有时我们会用3.14来表示，有时也会用3.1415926等，这要看计算所需要的精度，如果我们编制的一个程序中 要多次使用它，那么需要确定一个数值，在本次运行中不改变，但也许后来发现程序所表现的精度有变化，需要改变它的值， 这就需要修改程序中所有的相关数值，这会给我们带来一定的不便，但如果使用宏定义，使用一个标识符来代替，则在修改时只修改宏定义即可，还可以减少输入 3.1415926这样长的数值多次的情况，我们可以如此定义 #define  pi  3.1415926，既减少了输入又便于修改，何乐而不为呢？</p>
<p><strong>(2) 提高程序的运行效率</strong></p>
<p>  使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。正如C语言中所讲，函数的使用可以使程序更加模块化，便于组织，而且可重复利用，但在发生函数调用时，需要保留调用函数的现场，以便子 函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间，如果子函数执行的操作比较多，这种转换时间开销可以忽 略，但如果子函数完成的功能比较少，甚至于只完成一点操作，如一个乘法语句的操作，则这部分转换开销就相对较大了，但使用带参数的宏定义就不会出现这个问 题，因为它是在预处理阶段即进行了宏展开，在执行时不需要转换，即在当地执行。宏定义可完成简单的操作，但复杂的操作还是要由函数调用来完成，而且宏定义所占用的目标代码空间相对较大。所以在使用时要依据具体情况来决定是否使用宏定义。</p>
<h1 id="4-define中的三个特殊符号：-，-，-和-do-while"><a href="#4-define中的三个特殊符号：-，-，-和-do-while" class="headerlink" title="4. define中的三个特殊符号：#，##，#@ 和 do while"></a><strong>4. define中的三个特殊符号：#，##，#@ 和 do while</strong></h1><ol>
<li>#define Conn(x,y) x##y</li>
<li>#define ToChar(x) #@x</li>
<li>#define ToString(x) #x</li>
</ol>
<h2 id="1-x-y-表示什么？表示x连接y。"><a href="#1-x-y-表示什么？表示x连接y。" class="headerlink" title="(1) \x##y** 表示什么？表示x连接y。**"></a><strong>(1) \</strong>x##y** 表示什么？表示x连接y。**</h2><p>  <strong>##符号会连接两个符号，从而产生新的符号(词法层次)**</strong>，即 “##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。 例如：**<br>  #define SIGN( x ) INT_##x<br>  int SIGN( 1 ); 宏被展开后将成为：int INT_1;</p>
<p>  <strong>举例说：</strong></p>
<p>​    int n = Conn(123,456);        /<em> 结果就是n=123456;    </em>/<br>​    char<em> str = Conn(“asdf”, “adf”);  /</em> 结果就是 str = “asdfadf”; */<br>​    #define TYPE1(type,name) type name_##type##<em>type<br>​    #define TYPE2(type,name) type name##</em>##type##_type<br>​    TYPE1(int, c); 转换为：int 　name_int_type ; (因为##号将后面分为 name_ 、type 、 _type三组，替换后强制连接)<br>​    TYPE2(int, d);转换为： int 　d_int_type ; (因为##号将后面分为 name、_、type 、_type四组，替换后强制连接)</p>
<h2 id="（2）再来看-x-，其实就是给x加上单引号，结果返回是一个const-char。-举例说："><a href="#（2）再来看-x-，其实就是给x加上单引号，结果返回是一个const-char。-举例说：" class="headerlink" title="（2）再来看****#@x**，其实就是给x加上单引号，结果返回是一个const char。**举例说："></a><strong>（2）再来看***</strong>*#@x*<strong>*</strong>，其实就是给x加上单引号，结果返回是一个const char。<strong>**举例说：</strong></h2><p>​    char a = ToChar(1);结果就是a=’1’;<br>​    做个越界试验char a = ToChar(123);结果就错了;<br>​    但是如果你的参数超过四个字符，编译器就给给你报错了！</p>
<p>​    error C2015: too many characters in constant  ：P</p>
<h2 id="3）最后看看-x，估计你也明白了，他是给x加双引号。即-符号把一个符号直接转换为字符串。"><a href="#3）最后看看-x，估计你也明白了，他是给x加双引号。即-符号把一个符号直接转换为字符串。" class="headerlink" title="(3）最后看看#x，估计你也明白了，他是给x加双引号。即** **#符号把一个符号直接转换为字符串。"></a>(3）最后看看#x，估计你也明白了，他是给x加双引号。即** **#符号把一个符号直接转换为字符串。</h2><p>​    也就是** #是“字符串化”的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串**</p>
<p>​    char* str = ToString(123132);就成了str=”123132”;</p>
<p>​    #define ERROR_LOG(module) fprintf(stderr,”error: “#module”\n”)</p>
<p>​    ERROR_LOG(“add”); 转换为 fprintf(stderr,”error: “add”\n”);<br>​    ERROR_LOG(devied =0); 转换为 fprintf(stderr,”error: devied=0\n”);</p>
<h2 id="4-宏定义用-do-while-0"><a href="#4-宏定义用-do-while-0" class="headerlink" title="(4) 宏定义用 do{ }while(0)"></a><strong>(4) 宏定义用 do{ }while(0)</strong></h2><p>复杂宏定义及do{}while(0)的使用</p>
<p>#define foo() do{}while(0)</p>
<p>采用这种方式是为了防范在使用宏过程中出现错误，主要有如下几点：</p>
<p>　　（1）空的宏定义避免warning:<br>　　#define foo() do{}while(0)<br>　　（2）存在一个独立的block，可以用来进行变量定义，进行比较复杂的实现。<br>　　（3）如果出现在判断语句过后的宏，这样可以保证作为一个整体来是实现：<br>　　　　  #define foo(x) \<br>　　　　　　　 action1(); \<br>　　　　　　 action2();<br>　　　　在以下情况下：<br>　　　　if(NULL == pPointer)<br> 　　　　　  foo();<br>　　　　就会出现action1和action2不会同时被执行的情况，而这显然不是程序设计的目的。<br>　　（4）以上的第3种情况用单独的{}也可以实现，但是为什么一定要一个do{}while(0)呢，看以下代码：<br>　　　　　　#define switch(x,y) {int tmp; tmp=”x”;x=y;y=tmp;}<br>　　　　　　if(x&gt;y)<br>　　　　　　　　switch(x,y);<br>　　　　　　else    //error, parse error before else<br>　　　　　　otheraction();</p>
<p>在把宏引入代码中，会多出一个分号，从而会报错。使用do{….}while(0) 把它包裹起来，成为一个独立的语法单元，从而不会与上下文发生混淆。同时因为绝大多数的编译器都能够识别do{…}while(0)这种无用的循环并进行优化，所以使用这种方法也不会导致程序的性能降低。</p>
<p>为了看起来更清晰，这里用一个简单点的宏来演示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_DELETE(p) do&#123; delete p; p = NULL&#125; while(0)</span></span><br></pre></td></tr></table></figure>
<p>假设这里去掉do…while(0),</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_DELETE(p) delete p; p = NULL;</span></span><br></pre></td></tr></table></figure>
<p>那么以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != p) SAFE_DELETE(p)</span><br><span class="line"><span class="keyword">else</span> ...<span class="keyword">do</span> sth...</span><br></pre></td></tr></table></figure>
<p>就有两个问题：</p>
<ul>
<li>1) 因为if分支后有两个语句，else分支没有对应的if，编译失败</li>
<li>2) 假设没有else, SAFE_DELETE中的第二个语句无论if测试是否通过，会永远执行。</li>
</ul>
<p>你可能发现，为了避免这两个问题，我不一定要用这个令人费解的do…while, 我直接用{}括起来就可以了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_DELETE(p) &#123; delete p; p = NULL;&#125;</span></span><br></pre></td></tr></table></figure>
<p>的确，这样的话上面的问题是不存在了，但是我想对于C++程序员来讲，在每个语句后面加分号是一种约定俗成的习惯，这样的话，以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != p) SAFE_DELETE(p);</span><br><span class="line"><span class="keyword">else</span> ...<span class="keyword">do</span> sth...</span><br></pre></td></tr></table></figure>
<p>其else分支就无法通过编译了（原因同上），所以采用do…while(0)是做好的选择了。也许你会说，我们代码的习惯是在每个判断后面加上{}, 就不会有这种问题了，也就不需要do…while了，如：<br>if(…)<br>{<br>}<br>else<br>{<br>}</p>
<p>现有一个例子：#define PROJECT_LOG(level,arg) \ dosomething();\ if (level &lt;= PROJECT_LOG_get_level()) \ PROJECT_LOG_wrapper_##level(arg);</p>
<p>现在假设有以下应用，现有一个例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_LOG(level,arg) \</span></span><br><span class="line">    dosomething();\</span><br><span class="line">    <span class="keyword">if</span> (level &lt;= PROJECT_LOG_get_level()) \</span><br><span class="line">        PROJECT_LOG_wrapper_<span class="meta">##level(arg);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在假设有以下应用：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（L==<span class="number">1</span>）</span><br><span class="line">    PROJECT_LOG(L,<span class="string">"AAA"</span>);</span><br><span class="line"></span><br><span class="line">宏转开为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（L==<span class="number">1</span>）</span><br><span class="line">    dosomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt;= PROJECT_LOG_get_level())</span><br><span class="line">        PROJECT_LOG_wrapper_1(<span class="string">"AAA"</span>); ;</span><br><span class="line"></span><br><span class="line">显然<span class="keyword">if</span>（L==<span class="number">1</span>）只管到dosomething();而后面的</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt;= PROJECT_LOG_get_level())</span><br><span class="line">    PROJECT_LOG_wrapper_1(<span class="string">"AAA"</span>); ;</span><br><span class="line"></span><br><span class="line">则成了独立的语句。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假如使用<span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>（<span class="number">0</span>）语句块，进行宏定义：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_LOG(level,arg)do&#123; \</span></span><br><span class="line">    dosomething();\</span><br><span class="line">    <span class="keyword">if</span> (level &lt;= PROJECT_LOG_get_level()) \</span><br><span class="line">        PROJECT_LOG_wrapper_<span class="meta">##level(arg); \</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上述应用转开后为：</span><br><span class="line"><span class="keyword">if</span>（L==<span class="number">1</span>）</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    dosomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>&lt;= PROJECT_LOG_get_level())</span><br><span class="line">        PROJECT_LOG_wrapper_1(<span class="string">"AAA"</span>);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">这样避免了意外的麻烦。OK现在明白了很多C程序中奇怪的<span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>（<span class="number">0</span>）宏定义了吧</span><br></pre></td></tr></table></figure>
<p>使用示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT1(a,b)        \</span></span><br><span class="line">    &#123;                  \</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print a\n"</span>); \</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print b\n"</span>); \</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      PRINT2(a, b)      \</span></span><br><span class="line">  <span class="keyword">do</span>&#123;               \</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print a\n"</span>); \</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print b\n"</span>); \</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT(a) \</span></span><br><span class="line">    <span class="keyword">do</span>&#123;\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: %d\n"</span>,#a,a);\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>,a,a);\</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE1(type,name)   type name_##type##_type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE2(type,name)   type name##_##type##_type</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_LOG(module)   fprintf(stderr,<span class="meta-string">"error: "</span>#module<span class="meta-string">"\n"</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">19</span>;</span><br><span class="line">    TYPE1(<span class="keyword">int</span>, c);</span><br><span class="line">    ERROR_LOG(<span class="string">"add"</span>);</span><br><span class="line">    name_int_type = a;</span><br><span class="line">    TYPE2(<span class="keyword">int</span>, d);</span><br><span class="line">    d_int_type = a;</span><br><span class="line"> </span><br><span class="line">    PRINT(a);</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        PRINT1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PRINT2(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-常用的一些宏定义"><a href="#5-常用的一些宏定义" class="headerlink" title="5. 常用的一些宏定义"></a><strong>5. 常用的一些宏定义</strong></h1><h2 id="1-防止一个头文件被重复包含"><a href="#1-防止一个头文件被重复包含" class="headerlink" title="1. 防止一个头文件被重复包含"></a>1. 防止一个头文件被重复包含</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BODYDEF_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BODYDEF_H </span></span><br><span class="line"> <span class="comment">//头文件内容 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="2-得到指定地址上的一个字节或字"><a href="#2-得到指定地址上的一个字节或字" class="headerlink" title="2. 得到指定地址上的一个字节或字"></a>2. 得到指定地址上的一个字节或字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_B( x ) ( *( (byte *) (x) ) ) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_W( x ) ( *( (word *) (x) ) )</span></span><br></pre></td></tr></table></figure>
<p>用法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_B(x) (*((byte*)(x)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_W(x) (*((WORD*)(x)))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bTest = <span class="number">0x123456</span>;</span><br><span class="line">    byte m = MEM_B((&amp;bTest));<span class="comment">/*m=0x56*/</span></span><br><span class="line">    <span class="keyword">int</span> n = MEM_W((&amp;bTest));<span class="comment">/*n=0x3456*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-得到一个field在结构体-struct-中的偏移量"><a href="#3-得到一个field在结构体-struct-中的偏移量" class="headerlink" title="3. 得到一个field在结构体(struct)中的偏移量"></a>3. 得到一个field在结构体(struct)中的偏移量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSETOF( type, field ) ( (size_t) &amp;(( type *) 0)-&gt; field )</span></span><br></pre></td></tr></table></figure>
<p> <strong>请参考文章：详解**</strong>写宏定义：得到一个field在结构体（struct type）中的偏移量**。</p>
<h2 id="4-得到一个结构体中field所占用的字节数"><a href="#4-得到一个结构体中field所占用的字节数" class="headerlink" title="4. 得到一个结构体中field所占用的字节数"></a>4. 得到一个结构体中field所占用的字节数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )</span></span><br></pre></td></tr></table></figure>
<h2 id="5-得到一个变量的地址（word宽度）"><a href="#5-得到一个变量的地址（word宽度）" class="headerlink" title="5. 得到一个变量的地址（word宽度）"></a>5. 得到一个变量的地址（word宽度）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_PTR( var ) ( (byte *) (void *) &amp;(var) ) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_PTR( var ) ( (word *) (void *) &amp;(var) )</span></span><br></pre></td></tr></table></figure>
<h2 id="6-将一个字母转换为大写"><a href="#6-将一个字母转换为大写" class="headerlink" title="6. 将一个字母转换为大写"></a>6. 将一个字母转换为大写</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UPCASE( c ) ( ((c) &gt;= ''a'' &amp;&amp; (c) &lt;= ''z'') ? ((c) - 0x20) : (c) )</span><br></pre></td></tr></table></figure>
<h2 id="7-判断字符是不是10进值的数字"><a href="#7-判断字符是不是10进值的数字" class="headerlink" title="7. 判断字符是不是10进值的数字"></a>7. 判断字符是不是10进值的数字</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DECCHK( c ) ((c) &gt;= ''0'' &amp;&amp; (c) &lt;= ''9'')</span><br></pre></td></tr></table></figure>
<h2 id="8-判断字符是不是16进值的数字"><a href="#8-判断字符是不是16进值的数字" class="headerlink" title="8. 判断字符是不是16进值的数字"></a>8. 判断字符是不是16进值的数字</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define HEXCHK( c ) ( ((c) &gt;= ''0'' &amp;&amp; (c) &lt;= ''9'') ||((c) &gt;= ''A'' &amp;&amp; (c) &lt;= ''F'') ||((c) &gt;= ''a'' &amp;&amp; (c) &lt;= ''f'') )</span><br></pre></td></tr></table></figure>
<h2 id="9-防止溢出的一个方法"><a href="#9-防止溢出的一个方法" class="headerlink" title="9. 防止溢出的一个方法"></a>9. 防止溢出的一个方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_SAT( val ) (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))</span></span><br></pre></td></tr></table></figure>
<h2 id="10-返回数组元素的个数"><a href="#10-返回数组元素的个数" class="headerlink" title="10. 返回数组元素的个数"></a>10. 返回数组元素的个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )</span></span><br></pre></td></tr></table></figure>
<h1 id="6-宏的使用场景"><a href="#6-宏的使用场景" class="headerlink" title="6. 宏的使用场景"></a>6. 宏的使用场景</h1><h2 id="1-打印错误信息"><a href="#1-打印错误信息" class="headerlink" title="1. 打印错误信息"></a>1. 打印错误信息</h2><p>如果程序的执行必须要求某个宏被定义，在检查到宏没有被定义是可以使用#error，#warning打印错误（警告）信息，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __unix__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"This section will only work on UNIX systems"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>只有<strong>unix</strong>宏被定义，程序才能被正常编译。</p>
<h2 id="2-方便调试"><a href="#2-方便调试" class="headerlink" title="2. 方便调试"></a>2. 方便调试</h2><p><strong>FILE, </strong>LINE, __FUNCTION是由编译器预定义的宏，其分别代表当前代码所在的文件名，行号，以及函数名。可以在代码中加入如下语句来跟踪代码的执行情况：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(err) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"%s(%d)-%s\n"</span>,__FILE_<span class="number">_</span>,__LINE_<span class="number">_</span>,__FUNCTION_<span class="number">_</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-C-C-的混合编程"><a href="#3-C-C-的混合编程" class="headerlink" title="3. C/C++的混合编程"></a>3. C/C++的混合编程</h2><p>​    函数int foo(int a, int b);<br>​    在C语言的该函数在编译器编译后在库中的名字为_foo，而C++中该函数被编译后在库中的名字为_foo_int_int（为实现函数重载所做的改变）。如果C++中需要使用C编译后的库函数，则会提示找不到函数，因为符号名不匹配。C++中使用extern “C”解决该问题，说明要引用的函数是由C编译的，应该按照C的命名方式去查找符号。<br>​    如果foo是C编译的库，如果要在C++中使用foo，需要加如下声明，其中__cplusplus是c++编译器预定义的宏，说明该文件是被C++编译器编译，此时引用C的库函数，就需要加extern “C”。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> “C” &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="4-使用宏打印-Log-使用示例"><a href="#4-使用宏打印-Log-使用示例" class="headerlink" title="4. 使用宏打印 Log 使用示例"></a>4. 使用宏打印 Log 使用示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    ERROR_ONE,    <span class="comment">// 0</span></span><br><span class="line">    ERROR_TWO,</span><br><span class="line">    ERROR_THREE,</span><br><span class="line">    ERROR_END</span><br><span class="line">&#125;E_ERROR_CODE;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> g_error_statistics[ERROR_END] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* LOG 打印， # 直接常亮字符串替换 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PRINT(ERROR_CODE)                                             \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                                      \</span><br><span class="line">    g_error_statistics[ERROR_CODE]++;                                     \</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s : %d], error is %s\n"</span>, __FILE__, __LINE__, #ERROR_CODE);  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ERROR 公共前缀，传参时省略的写法, ## 直接展开拼接 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PRINT_2(CODE)                                                        \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                                             \</span><br><span class="line">    g_error_statistics[ERROR_ ## CODE]++;                                        \</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s : %d], error is %s\n"</span>, __FILE__, __LINE__, <span class="string">"ERROR_"</span> #CODE);      \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_PRINT(ERROR_TWO);</span><br><span class="line">    LOG_PRINT_2(ONE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ERROR_END; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error %u statistics is %lu \n"</span>, i, g_error_statistics[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写文件记录log</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_log</span> <span class="params">(FILE* pFile, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;  </span><br><span class="line">    va_list arg;  </span><br><span class="line">    <span class="keyword">int</span> done;  </span><br><span class="line">  </span><br><span class="line">    va_start (arg, format);  </span><br><span class="line">    <span class="comment">//done = vfprintf (stdout, format, arg);  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">time_t</span> time_log = time(<span class="literal">NULL</span>);  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">tm_log</span> = <span class="title">localtime</span>(&amp;<span class="title">time_log</span>);</span>  </span><br><span class="line">    <span class="built_in">fprintf</span>(pFile, <span class="string">"%04d-%02d-%02d %02d:%02d:%02d "</span>, tm_log-&gt;tm_year + <span class="number">1900</span>, tm_log-&gt;tm_mon + <span class="number">1</span>, tm_log-&gt;tm_mday, tm_log-&gt;tm_hour, tm_log-&gt;tm_min, tm_log-&gt;tm_sec);  </span><br><span class="line">  </span><br><span class="line">    done = <span class="built_in">vfprintf</span> (pFile, format, arg);  </span><br><span class="line">    va_end (arg);  </span><br><span class="line">  </span><br><span class="line">    fflush(pFile);  </span><br><span class="line">    <span class="keyword">return</span> done;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    FILE* pFile = fopen(<span class="string">"123.txt"</span>, <span class="string">"a"</span>);  </span><br><span class="line">    write_log(pFile, <span class="string">"%s %d %f\n"</span>, <span class="string">"is running"</span>, <span class="number">10</span>, <span class="number">55.55</span>);  </span><br><span class="line">    fclose(pFile);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译运行：</span></span><br><span class="line"><span class="comment">gcc log.c -o log</span></span><br><span class="line"><span class="comment">./log</span></span><br><span class="line"><span class="comment">返回结果：cat 123.txt</span></span><br><span class="line"><span class="comment">2016-12-13 13:10:02 is running 10 55.550000</span></span><br><span class="line"><span class="comment">2016-12-13 13:10:04 is running 10 55.550000</span></span><br><span class="line"><span class="comment">2016-12-13 13:10:04 is running 10 55.550000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG_WRITE(fmt,args)  DBG_Write_Log(strrchr(__FILE__, <span class="meta-string">'\\'</span>)+1, __LINE__, fmt,##args);</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBG_Write_Log</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">int</span> line, <span class="keyword">char</span>* fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    FILE* fp;</span><br><span class="line">    va_list argp;</span><br><span class="line">    <span class="keyword">char</span>* para;</span><br><span class="line">    <span class="keyword">char</span> logbuf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span> timeStr[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">time_t</span> tt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">local</span>;</span></span><br><span class="line">    tt = time(<span class="literal">NULL</span>);</span><br><span class="line">    local = localtime(&amp;tt);</span><br><span class="line">    strftime(timeStr, <span class="number">20</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>, local);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">sprintf</span>(logbuf, <span class="string">"[%s] %s[%d]"</span>, timeStr, filename, line);</span><br><span class="line"> </span><br><span class="line">    va_start(argp, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(logbuf+<span class="built_in">strlen</span>(logbuf), fmt, argp);</span><br><span class="line">    va_end(argp);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">fprintf</span>(fp, logbuf);</span><br><span class="line">    fclose(fp);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(logbuf);   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DBG_WRITE(<span class="string">"test log [%d]system[%s][%d]\n"</span>, <span class="number">1234</span>,<span class="string">"add by test"</span>, <span class="number">5</span>);</span><br><span class="line">    DBG_Write_Log(<span class="built_in">strrchr</span>(__FILE__,<span class="string">'\\'</span>)+<span class="number">1</span>,  __LINE__, <span class="string">"%s %d\n"</span>,  <span class="string">"add by test"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>几种 log 打印 printf 函数 的 宏定义 示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lU_DEBUG_PREFIX <span class="meta-string">"##########"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_DEBUG_CMD 0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_DEBUG_DATA 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_DEBUG_ERROR 0x04</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_PRINTF_cmd(msg...) do&#123;<span class="meta-keyword">if</span>(g_lu_debugs_level &amp; LU_DEBUG_CMD)printf(lU_DEBUG_PREFIX msg);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_PRINTF_data(msg...) do&#123;<span class="meta-keyword">if</span>(g_lu_debugs_level &amp; LU_DEBUG_DATA)printf(lU_DEBUG_PREFIX msg);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_PRINTF_error(msg...) do&#123;<span class="meta-keyword">if</span>(g_lu_debugs_level &amp; LU_DEBUG_ERROR)printf(lU_DEBUG_PREFIX msg);&#125;while(0)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lu_printf(level, msg...) LU_PRINTF_##level(msg)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lu_printf2(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lu_printf3(...) lu_printf(__VA_ARGS__)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lu_printf4_format</span><span class="params">(<span class="keyword">int</span> prio, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lu_printf4(prio, fmt...) lu_printf4_format(prio, fmt)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_lu_debugs_level; <span class="comment">//控制打印等级的全局开关</span></span><br><span class="line"><span class="comment">//lu_printf 类似内核的分等级打印宏，根据g_lu_debugs_level和输入的第一个标号名来决定该句打印是否输出。</span></span><br><span class="line"><span class="comment">//lu_printf3 等同于 lu_printf</span></span><br><span class="line"><span class="comment">//lu_printf2 等同于 printf</span></span><br><span class="line"><span class="comment">//lu_printf4 等同于 lu_printf4_format，作用是把输入的第一个整型参数用&lt;val&gt;的格式打印出来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_lu_debugs_level |= LU_DEBUG_CMD | LU_DEBUG_DATA | LU_DEBUG_ERROR;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_lu_debugs_level = %p\n"</span>, g_lu_debugs_level);</span><br><span class="line">    lu_printf(cmd,<span class="string">"this is cmd\n"</span>);</span><br><span class="line">    lu_printf(data,<span class="string">"this is data\n"</span>);</span><br><span class="line">    lu_printf(error,<span class="string">"this is error\n"</span>);</span><br><span class="line">    g_lu_debugs_level &amp;= ~(LU_DEBUG_CMD | LU_DEBUG_DATA);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_lu_debugs_level = %p\n"</span>, g_lu_debugs_level);</span><br><span class="line">    lu_printf(cmd,<span class="string">"this is cmd\n"</span>);</span><br><span class="line">    lu_printf(data,<span class="string">"this is data\n"</span>);</span><br><span class="line">    lu_printf(error,<span class="string">"this is error\n"</span>);</span><br><span class="line">    lu_printf2(<span class="string">"aa%d,%s,%dbbbbb\n"</span>, <span class="number">20</span>, <span class="string">"eeeeeee"</span>, <span class="number">100</span>);</span><br><span class="line">    g_lu_debugs_level |= LU_DEBUG_CMD | LU_DEBUG_DATA | LU_DEBUG_ERROR;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_lu_debugs_level = %p\n"</span>, g_lu_debugs_level);</span><br><span class="line">    lu_printf3(cmd,<span class="string">"this is cmd \n"</span>);</span><br><span class="line">    lu_printf3(data,<span class="string">"this is data\n"</span>);</span><br><span class="line">    lu_printf3(error,<span class="string">"this is error\n"</span>);</span><br><span class="line">    lu_printf4(<span class="number">0</span>,<span class="string">"luther %s ,%d ,%d\n"</span>, <span class="string">"gliethttp"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lu_printf4_format</span><span class="params">(<span class="keyword">int</span> prio, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE (4096)</span></span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> buf[LOG_BUF_SIZE];</span><br><span class="line"> </span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;%d&gt;: %s"</span>, prio, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENTER() LOGD(<span class="meta-string">"enter into %s"</span>, __FUNCTION__)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) ((void)LOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__))</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(priority, tag, ...) \</span></span><br><span class="line">    LOG_PRI(ANDROID_##priority, tag, __VA_ARGS__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PRI(priority, tag, ...) \</span></span><br><span class="line">    android_printLog(priority, tag, __VA_ARGS__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> android_printLog(prio, tag, fmt...) \</span></span><br><span class="line">    __android_log_print(prio, tag, fmt)</span><br></pre></td></tr></table></figure>
<p>使用示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Define Log print macro */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyLog(DebugLevel, format, ...)   \</span></span><br><span class="line">        <span class="keyword">do</span>&#123;  \</span><br><span class="line">            <span class="keyword">switch</span> (DebugLevel)  \</span><br><span class="line">            &#123;  \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  \</span><br><span class="line">                <span class="built_in">printf</span>(format, ##__VA_ARGS__);  \</span><br><span class="line">                <span class="keyword">break</span>;  \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: \</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Function: "</span>__FUNCTION__<span class="string">", Line: %d, ---&gt; "</span>format<span class="string">""</span>, __LINE__, ##__VA_ARGS__); \</span><br><span class="line">                <span class="keyword">break</span>;  \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:  \</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"File: "</span>__FILE__<span class="string">", Function: "</span>__FUNCTION__<span class="string">", Line: %d, ---&gt; "</span>format<span class="string">""</span>, __LINE__, ##__VA_ARGS__); \</span><br><span class="line">                <span class="keyword">break</span>; \</span><br><span class="line">            <span class="keyword">default</span>:   \</span><br><span class="line">                <span class="keyword">break</span>;  \</span><br><span class="line">            &#125;   \</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyLog(<span class="number">1</span>, <span class="string">"Simple Log print!\r\n"</span>);</span><br><span class="line">    MyLog(<span class="number">2</span>, <span class="string">"Satndard Log display!\r\n"</span>);</span><br><span class="line">    MyLog(<span class="number">3</span>, <span class="string">"Detail Log view!\r\n"</span>);</span><br><span class="line"> </span><br><span class="line">    MyLog(<span class="number">1</span>, <span class="string">"If debug level is not equal 1,2 or 3 that log is invisible, such as next line :\r\n"</span>);</span><br><span class="line">    MyLog(<span class="number">6</span>, <span class="string">"I am invisible log!\r\n"</span>);</span><br><span class="line">    MyLog(<span class="number">1</span>, <span class="string">"Now, I think you have understood how to use MyLog macro.\r\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG <span class="meta-string">"DEBUG"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TRACE <span class="meta-string">"TRACE"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR <span class="meta-string">"ERROR"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO  <span class="meta-string">"INFOR"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_CRIT  <span class="meta-string">"CRTCL"</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(level, format, ...) \  </span></span><br><span class="line">    <span class="keyword">do</span> &#123; \  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[%s|%s@%s,%d] "</span> format <span class="string">"\n"</span>, \  </span><br><span class="line">            level, __func__, __FILE__, __LINE__, ##__VA_ARGS__ ); \  </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    LOG(LOG_DEBUG, <span class="string">"a=%d"</span>, <span class="number">10</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define DBG(format, ...) fprintf(stderr, "[%s|%s@%s,%d] " format "\n", APP_NAME, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__ );  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(level, format, ...) \</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[%s|%s@%s,%d] "</span> format <span class="string">"/n"</span>, \</span><br><span class="line">        level, __func__, __FILE__, __LINE__, ##__VA_ARGS__ ); \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>使用示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(fmt, ...) do \</span></span><br><span class="line">&#123;                        \</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s][%s][%s:%d] %s:"</span>fmt<span class="string">"\n"</span>, __DATE__, __TIME__, __FILE__, __LINE__, __FUNCTION__, ##__VA_ARGS__); \</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">"this is test string"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    LOG(<span class="string">"test string : %s . test num: %d"</span>, str, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关宏定义的经验与技巧-简化代码-增强Log：<a href="http://blog.csdn.net/zh_2608/article/details/46646385" target="_blank" rel="noopener">http://blog.csdn.net/zh_2608/article/details/46646385</a></p>
<p>C语言日志处理：<a href="https://www.cnblogs.com/274914765qq/p/4589929.html" target="_blank" rel="noopener">https://www.cnblogs.com/274914765qq/p/4589929.html</a></p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2023/05/100671.html" class="pre-post btn btn-default" title='高效解析器 Lex&YACC(Flex&Bison) 使用教程'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">高效解析器 Lex&YACC(Flex&Bison) 使用教程</span>
        </a>
    
    
        <a href="/archives/2023/05/100647.html" class="next-post btn btn-default" title='QxOrm使用教程(ORM for C++ 对象关系映射)'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">QxOrm使用教程(ORM for C++ 对象关系映射)</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#宏-替换-发生的时机"><span class="toc-text">宏 替换 发生的时机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-define的基本用法"><span class="toc-text">1. #define的基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-define命令剖析"><span class="toc-text">1.1 #define命令剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简单的宏定义"><span class="toc-text">简单的宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带参数的宏定义"><span class="toc-text">带参数的宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#取消宏定义：-undef-宏名"><span class="toc-text">取消宏定义：#undef 宏名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可变参数-的-宏"><span class="toc-text">可变参数 的 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宏参数的prescan-预扫描"><span class="toc-text">宏参数的prescan(预扫描)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个很重要的补充："><span class="toc-text">一个很重要的补充：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象宏"><span class="toc-text">对象宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数宏"><span class="toc-text">函数宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-关于定义宏的另外一些问题"><span class="toc-text">1.2 关于定义宏的另外一些问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-宏可以被多次定义-前提是这些定义必须是相同的。"><span class="toc-text">(1)宏可以被多次定义, 前提是这些定义必须是相同的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-在gcc中-可在命令行中指定对象宏的定义"><span class="toc-text">(2) 在gcc中, 可在命令行中指定对象宏的定义:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-define所定义的宏的作用域"><span class="toc-text">(3) #define所定义的宏的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-宏的替换可以是递归的-所以可以嵌套定义宏"><span class="toc-text">(4) 宏的替换可以是递归的, 所以可以嵌套定义宏.</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-undef"><span class="toc-text">1.3 #undef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-if-elif-else-endif"><span class="toc-text">1.4 #if, #elif, #else, #endif</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-ifdef-ifndef-defined"><span class="toc-text">1.5 #ifdef, #ifndef, defined.</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-include-include-next"><span class="toc-text">1.6 #include , #include_next</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-预定义-的-宏"><span class="toc-text">1.7 预定义 的 宏**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-line"><span class="toc-text">1.7 #line</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-pragma-和-Pragma"><span class="toc-text">1.8 #pragma 和 _Pragma</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-warning-error"><span class="toc-text">1.9 #warning, #error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-常用的预处理命令"><span class="toc-text">1.10 常用的预处理命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-define使用中的常见问题解析"><span class="toc-text">2. #define使用中的常见问题解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-简单宏定义使用中出现的问题"><span class="toc-text">2.1 简单宏定义使用中出现的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-带参数的宏定义出现的问题"><span class="toc-text">2.2 带参数的宏定义出现的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-宏定义的优点"><span class="toc-text">3. 宏定义的优点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-define中的三个特殊符号：-，-，-和-do-while"><span class="toc-text">4. define中的三个特殊符号：#，##，#@ 和 do while</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-x-y-表示什么？表示x连接y。"><span class="toc-text">(1) \x##y** 表示什么？表示x连接y。**</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#（2）再来看-x-，其实就是给x加上单引号，结果返回是一个const-char。-举例说："><span class="toc-text">（2）再来看****#@x**，其实就是给x加上单引号，结果返回是一个const char。**举例说：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3）最后看看-x，估计你也明白了，他是给x加双引号。即-符号把一个符号直接转换为字符串。"><span class="toc-text">(3）最后看看#x，估计你也明白了，他是给x加双引号。即** **#符号把一个符号直接转换为字符串。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-宏定义用-do-while-0"><span class="toc-text">(4) 宏定义用 do{ }while(0)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-常用的一些宏定义"><span class="toc-text">5. 常用的一些宏定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-防止一个头文件被重复包含"><span class="toc-text">1. 防止一个头文件被重复包含</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-得到指定地址上的一个字节或字"><span class="toc-text">2. 得到指定地址上的一个字节或字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-得到一个field在结构体-struct-中的偏移量"><span class="toc-text">3. 得到一个field在结构体(struct)中的偏移量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-得到一个结构体中field所占用的字节数"><span class="toc-text">4. 得到一个结构体中field所占用的字节数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-得到一个变量的地址（word宽度）"><span class="toc-text">5. 得到一个变量的地址（word宽度）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-将一个字母转换为大写"><span class="toc-text">6. 将一个字母转换为大写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-判断字符是不是10进值的数字"><span class="toc-text">7. 判断字符是不是10进值的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-判断字符是不是16进值的数字"><span class="toc-text">8. 判断字符是不是16进值的数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-防止溢出的一个方法"><span class="toc-text">9. 防止溢出的一个方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-返回数组元素的个数"><span class="toc-text">10. 返回数组元素的个数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-宏的使用场景"><span class="toc-text">6. 宏的使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-打印错误信息"><span class="toc-text">1. 打印错误信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-方便调试"><span class="toc-text">2. 方便调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-C-C-的混合编程"><span class="toc-text">3. C/C++的混合编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-使用宏打印-Log-使用示例"><span class="toc-text">4. 使用宏打印 Log 使用示例</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2024&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>