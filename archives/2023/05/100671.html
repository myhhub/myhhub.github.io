<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="c++,c,lex,yacc" />


    <meta name="description" content="一、简介只要在Unix环境中写程序，必定会邂逅神秘的Lex&amp;YACC，就如GNU&#x2F;Linux用户所熟知的Flex&amp;Bison，这里的Flex就是由Vern Paxon实..." />



<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />

    <!--Title-->


<title>高效解析器 Lex&amp;YACC(Flex&amp;Bison) 使用教程 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    




<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0.css">
<link rel="stylesheet" href="/css/style.css?rev=@@hash.css">





    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx" />


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

<meta name="generator" content="Hexo 7.3.0"></head>


<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="高效解析器 Lex&amp;YACC(Flex&amp;Bison) 使用教程">
            
	            高效解析器 Lex&amp;YACC(Flex&amp;Bison) 使用教程
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-none-link" href="/tags/c/" rel="tag">c</a> <a class="tag-none-link" href="/tags/c/" rel="tag">c++</a> <a class="tag-none-link" href="/tags/lex/" rel="tag">lex</a> <a class="tag-none-link" href="/tags/yacc/" rel="tag">yacc</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2023/05/27</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>661</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>只要在Unix环境中写程序，必定会邂逅神秘的Lex&amp;YACC，就如GNU&#x2F;Linux用户所熟知的Flex&amp;Bison，这里的Flex就是由Vern Paxon实现的一个Lex，Bison则是GNU版本的YACC。在此我们将统一称呼这些程序为Lex和YACC。新版本的程序是向上兼容的(译注：即兼容老版本)，所以你可以用Flex和Bison来尝试下我们的实例。</p>
<p>这些程序实用性极广，但如同你的C编译器一样，在其主页上并没有描述它们，也没有关于怎样使用的信息。当和Lex结合使用时，YACC实在是棒极了，但是Bison的主页上并没有描述Bison如何跟Lex结合使用以生成代码的相应说明。</p>
<h1 id="二、Lex-YACC能为你做什么？"><a href="#二、Lex-YACC能为你做什么？" class="headerlink" title="二、Lex &amp; YACC能为你做什么？"></a>二、Lex &amp; YACC能为你做什么？</h1><p>如果使用得当，这些程序(指LEX&amp;YACC)可以让你轻易的解析复杂的语言，当你需要读取一个配置文件时，或者你需要编写一个你自己使用的语言的编译器时，这对于你来说是莫大的裨益。<br>本文档能提供给你一些帮助，你将发现你再也不用手工写解析器了，Lex &amp; YACC就是为你量身打造的利器。</p>
<p>先来看一个示例，简单计算器：</p>
<h2 id="2-1-简单计算器"><a href="#2-1-简单计算器" class="headerlink" title="2.1 简单计算器"></a>2.1 简单计算器</h2><p>计算器实现整数的 +、-、*、&#x2F;、% 五种简单运算。</p>
<h3 id="1-词法分析程序-cal-l"><a href="#1-词法分析程序-cal-l" class="headerlink" title="1. 词法分析程序 cal.l"></a>1. 词法分析程序 cal.l</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cal.tab.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> yylval;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+  &#123; yylval = <span class="built_in">atoi</span>(yytext); <span class="keyword">return</span> NUMBER; &#125;</span><br><span class="line">[ \t]   ;       <span class="comment">/* ignore white space */</span></span><br><span class="line">\n  <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* logical EOF */</span></span><br><span class="line">.   <span class="keyword">return</span> yytext[<span class="number">0</span>];</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>代码中定义了四条规则，前面的部分就是模式，处于一行的开始位置，后面部分是动作，也就是，输入中匹配到了这个模式的时候，对应进行什么动作（就像机器人接受到了什么样的指令，然后会执行相应的动作一样）</p>
<ul>
<li>第一个模式，匹配连续一个或者多个数字，匹配到之后就返回标签NUMBER。</li>
<li>第二个模式，匹配空格，没有任何操作，忽略所有空格。</li>
<li>第三个模式，匹配一个换行符，匹配到之后结束匹配。</li>
<li>第四个模式，匹配出了\n之外的字符，返回该字符。</li>
</ul>
<p>总体来说，匹配到连续数字，则返回NUMBER；忽略空格；换行结束；匹配到任何其他字符返回字符。</p>
<h3 id="2-语法分析程序-cal-y"><a href="#2-语法分析程序-cal-y" class="headerlink" title="2. 语法分析程序 cal.y"></a>2. 语法分析程序 cal.y</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> yylex(void);</span><br><span class="line">%&#125;</span><br><span class="line">%token NAME NUMBER</span><br><span class="line">%%</span><br><span class="line">statement:  NAME <span class="string">&#x27;=&#x27;</span> <span class="keyword">expression</span></span><br><span class="line">    |   <span class="keyword">expression</span>      &#123; printf(<span class="string">&quot;= %d\n&quot;</span>, $1); &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">expression</span>: <span class="keyword">expression</span> <span class="string">&#x27;+&#x27;</span> NUMBER   &#123; $$ = $1 + $3; &#125;</span><br><span class="line">    |   <span class="keyword">expression</span> <span class="string">&#x27;-&#x27;</span> NUMBER   &#123; $$ = $1 - $3; &#125;</span><br><span class="line">    |   <span class="keyword">expression</span> <span class="string">&#x27;*&#x27;</span> NUMBER   &#123; $$ = $1 * $3; &#125;</span><br><span class="line">    |   <span class="keyword">expression</span> <span class="string">&#x27;/&#x27;</span> NUMBER   &#123; $$ = $1 / $3; &#125;</span><br><span class="line">    |   <span class="keyword">expression</span> <span class="string">&#x27;%&#x27;</span> NUMBER   &#123; $$ = $1 % $3; &#125;</span><br><span class="line">    |   NUMBER          &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line">%%</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    yyparse();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> yyerror(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">&quot;%s/n&quot;</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> yywrap() </span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="3-编译运行过程"><a href="#3-编译运行过程" class="headerlink" title="3. 编译运行过程"></a>3. 编译运行过程</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="number">1</span>.  编译<span class="keyword">lex</span>文件，生成<span class="keyword">lex</span>.yy.<span class="keyword">c</span>文件 */</span><br><span class="line">C:\flex&gt;flex <span class="keyword">cal</span>.<span class="keyword">l</span></span><br><span class="line"></span><br><span class="line">/* <span class="number">2</span>. 编译yacc文件，生成<span class="keyword">cal</span>.<span class="keyword">tab</span>.h 与<span class="keyword">cal</span>.<span class="keyword">tab</span>.<span class="keyword">c</span>文件 */</span><br><span class="line">C:\flex&gt;bison -d <span class="keyword">cal</span>.<span class="keyword">y</span></span><br><span class="line"></span><br><span class="line">/* <span class="number">3</span>. 链接生成的.<span class="keyword">c</span> 文件，并生成相应的可执行文件 <span class="keyword">cal</span> */</span><br><span class="line">C:\flex&gt;gcc -<span class="keyword">o</span> <span class="keyword">cal</span> <span class="keyword">cal</span>.<span class="keyword">tab</span>.<span class="keyword">c</span> <span class="keyword">lex</span>.yy.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">/* <span class="number">4</span>. 运行可执行文件<span class="keyword">cal</span>，计算简单表达式  */</span><br><span class="line">C:\flex&gt;<span class="keyword">cal</span></span><br><span class="line"><span class="number">32</span>*<span class="number">10</span>-<span class="number">20</span>+<span class="number">150</span>/<span class="number">3</span></span><br><span class="line">= <span class="number">150</span></span><br></pre></td></tr></table></figure>

<h1 id="三、Lex"><a href="#三、Lex" class="headerlink" title="三、Lex"></a>三、Lex</h1><p>Lex会生成一个叫做『词法分析器』的程序。这是一个函数，它带有一个字符流传入参数，词法分析器函数看到一组字符就会去匹配一个关键字(key)，采取相应措施。</p>
<h2 id="3-1-Lex-的结构规范"><a href="#3-1-Lex-的结构规范" class="headerlink" title="3.1 Lex 的结构规范"></a>3.1 Lex 的结构规范</h2><p> lex源文件扩展名.l，分为三个段：定义段、规则段、用户子程序段</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义段 */</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">    <span class="comment">/* 规则段 */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">    <span class="comment">/* 用户子程序段 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>三个段用 <strong>%%</strong> 进行分隔。</p>
<h3 id="1-定义段"><a href="#1-定义段" class="headerlink" title="1. 定义段"></a>1. 定义段</h3><p>定义段包括文字块、定义、内部表声明、起始条件和转换。<br> C语言的注释、头文件包含等一般就放在<code>%&#123;</code>&nbsp;   <code>%&#125;</code>之间，这一部分的内容会被直接复制到输出文件的开头部分。<br> 例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cal.tab.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> yylval;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-规则段"><a href="#2-规则段" class="headerlink" title="2. 规则段"></a>2. 规则段</h3><p>规则段为一系列匹配模式和动作，模式一般使用正则表达式书写，动作部分为C代码：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">模式<span class="number">1</span> &#123;动作<span class="number">1</span> （C代码）&#125;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"><span class="string">[0-9]</span>+  &#123; yylval = atoi(yytext); <span class="keyword">return</span> NUMBER; &#125;</span><br></pre></td></tr></table></figure>

<p>在输入和模式1匹配的时候，执行动作部分的代码。<br>   <strong>C代码被逐字拷贝到生成的C文件中。</strong></p>
<p>当lex扫描程序运行时，它把输入与规则段的模式进行匹配。<br> ➢ 每次发现一个匹配（被匹配的输入称为标记（token））时就执行与那种模式相关的C代码。<br> ➢ 如果模式后面跟着 <strong>|</strong> 符号，则该模式将使用与文件中下一个模式相同的C代码。<br> ➢ 当输入字符不匹配模式时，词法分析程序的动作就好像它匹配上了代码ECHO的模式，ECHO将标记的拷贝写到输出。</p>
<h3 id="3-用户子程序段"><a href="#3-用户子程序段" class="headerlink" title="3. 用户子程序段"></a>3. 用户子程序段</h3><p>这里为C代码，会被原样复制到c文件中，一般这里定义一些辅助函数等，如动作代码中使用到的辅助函数。<br> 如果重新定义input()、unput()、output()、或者yywrap()，新的版本或者支持子程序，都可以放在这里。</p>
<p>词法分析器所做的，就是在输入中寻找字符的模式（pattern）。<br> 在词法分析器中，我们要给定我们需要识别的模式，因此需要使用一种方式来描述模式，这就是常用的正则表达式。</p>
<h2 id="3-2-Lex的常规表达式"><a href="#3-2-Lex的常规表达式" class="headerlink" title="3.2 Lex的常规表达式"></a>3.2 Lex的常规表达式</h2><p>lex模式是由编辑程序和实用程序使用的正则表达式的扩展版本。正则表达式由常规字符（代表它们本身）和元字符（在一种模式中具有特殊含义）组成。</p>
<h3 id="1-用-Lex-定义常规表达式"><a href="#1-用-Lex-定义常规表达式" class="headerlink" title="1. 用 Lex 定义常规表达式"></a>1. 用 Lex 定义常规表达式</h3><p>| 字符    | 含义                                                         |<br>| :———————| :——— —————————————– |<br>| A-Z, 0-9, a-z | 构成了部分模式的字符和数字。                                 |<br>| .             | 匹配任意字符，除了 \n。                                      |<br>| -             | 用来指定范围。例如：A-Z 指从 A 到 Z 之间的所有字符。         |<br>| [ ]           | 一个字符集合。匹配括号内的 任意 字符。如果第一个字符是 ^ 那么它表示否定模式。例如: [abC] 匹配 a, b, 和 C中的任何一个。 |<br>| *             | 匹配 0个或者多个上述的模式。                                 |<br>| +             | 匹配 1个或者多个上述模式。                                   |<br>| ?             | 匹配 0个或1个上述模式。                                      |<br>| $             | 作为模式的最后一个字符匹配一行的结尾。                       |<br>| { }           | 指出一个模式可能出现的次数。 例如: A{1,3} 表示 A 可能出现1次或3次。 |<br>| \             | 用来转义元字符。同样用来覆盖字符在此表中定义的特殊意义，只取字符的本意。 |<br>| ^             | 否定。                                                       |<br>|  &#124; | 表达式间的逻辑或。                                           |<br>| “&lt;一些符号&gt;”  | 字符的字面含义。元字符具有。                                 |<br>| &#x2F;             | 向前匹配。如果在匹配的模版中的“&#x2F;”后跟有后续表达式，只匹配模版中“&#x2F;”前 面的部分。如：如果输入 A01，那么在模版 A0&#x2F;1 中的 A0 是匹配的。 |<br>| ( )           | 将一系列常规表达式分组。                                     |</p>
<p>下面将逐一详细讲解;</p>
<h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>➢  <strong>.</strong><br> . 匹配除了换行符 <strong>\n</strong> 之外的任意单个字符<br> 例如</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.   <span class="keyword">return</span> yytext[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>➢  <strong>[]</strong><br> [] 匹配括号中字符的任意一个。<br> 用“-”（短划线）指示字符的范围，例如[0-9]指10个数字中的任意一个。<br> 如果开括号之后的第一个字符是短划线或者闭括号，那么它就不能被解释为元字符。<br> 如果第一个字符是抑扬字符“ ^ ”，那么它的含义就变为匹配括号内字符以外的任意字符。<br> *<strong>除了以“ \ ”开始的C转义序列被识别以外，其他的元字符在方括号中没有特殊含义。*</strong></p>
<p>例如</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>+  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 匹配大写字母，出现1次以上</span></span><br><span class="line"><span class="selector-attr">[^A-Z]</span>+  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 匹配除了大写字母外的其他字符，出现1次以上</span></span><br></pre></td></tr></table></figure>

<p>➢  *****<br> ***** 匹配前面正则表达式的零次或者多次出现。</p>
<p>例如</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>*  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 匹配大写字母，出现0次或者多次</span></span><br></pre></td></tr></table></figure>

<p>➢  <strong>+</strong><br> <strong>+</strong> 匹配前面正则表达式的一次或者多次出现。</p>
<p>例如</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>+  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125;<span class="comment">// 匹配大写字母，出现1次以上</span></span><br></pre></td></tr></table></figure>

<p>➢  <strong>?</strong><br> ? 匹配前面正则表达式的零次或者一次出现。例如： -?[0-9]+  指具有可选的前导或者一元减号的数字</p>
<p>例如</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>?  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 匹配大写字母，出现零次或者一次</span></span><br></pre></td></tr></table></figure>

<p>➢  <strong>{}</strong><br> {} 意味着根据括号内部的不同而不同。单个数字{n}意味着前面的模式重复n次。例如： [A-Z]{3} 表示任意3个大写字母。</p>
<p>如果大括号包含的由逗号分开的两个数字{n,m}，那么它们是前面模式重复的最小数和最大数。例如：A{1,3}表示字母A出现1次到3次。</p>
<p>如果第二个数字丢失就意味着无穷大，所以{1，}意味着 +    ；  {0，}意味着 *  。</p>
<p>如果大括号包含一个名字，它指示用那个名字来替换。</p>
<p>例如</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>&#123;<span class="number">3</span>&#125;  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 匹配大写字母，出现3次</span></span><br><span class="line"><span class="selector-attr">[A-Z]</span>&#123;<span class="number">3</span>,&#125;  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 匹配大写字母，出现3次以上</span></span><br><span class="line"><span class="selector-attr">[A-Z]</span>&#123;<span class="number">3</span>,<span class="number">6</span>&#125;  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 匹配大写字母，出现3~6次</span></span><br></pre></td></tr></table></figure>

<p>➢  ****<br> \ 转义符号，如果后面的字符是小写字母，那么它就是C转义序列。 例如制表位：\t</p>
<p>一些实现允许采用如“\123” 和 “\x3f” 这种形式的八进制和十六进制字符。</p>
<p>否则，“\” 引用后面的字符，所以 * 匹配一个 * 号。</p>
<p>*<strong>转义字符表*</strong></p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th align="center">ASCII码值（十进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td align="center">007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td align="center">008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td align="center">012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td align="center">010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td align="center">013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td align="center">009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td align="center">011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’&#39;</td>
<td align="center">092</td>
</tr>
<tr>
<td>&#39;</td>
<td>代表一个单引号（撇号）字符</td>
<td align="center">039</td>
</tr>
<tr>
<td>&quot;</td>
<td>代表一个双引号字符</td>
<td align="center">034</td>
</tr>
<tr>
<td>?</td>
<td>代表一个问号</td>
<td align="center">063</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td align="center">000</td>
</tr>
<tr>
<td>\ddd</td>
<td>1到3位八进制数所代表的任意字符</td>
<td align="center">三位八进制</td>
</tr>
<tr>
<td>\xhh</td>
<td>1到2位十六进制所代表的任意字符</td>
<td align="center">二位十六进制</td>
</tr>
</tbody></table>
<p>➢  <strong>()</strong><br> ()  将一系列正则表达式归组。 *   +   {}   中的每一个都直接作用于它左侧的表达式，而且 |  通常同时影响左侧和右侧的内容。圆括号可以改变这种情况，</p>
<p>例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(abc)<span class="string">&#123;3&#125;</span>  &#123;<span class="keyword">printf</span>(<span class="string">&quot;get word:<span class="variable">%s</span>\n&quot;</span>, yytext);&#125; // 连续出现<span class="number">3</span>次 abc</span><br><span class="line">(ab|cd)<span class="string">&#123;3&#125;</span>  &#123;<span class="keyword">printf</span>(<span class="string">&quot;get word:<span class="variable">%s</span>\n&quot;</span>, yytext);&#125; // 出现<span class="number">3</span>次：<span class="string">&quot;ab&quot;</span> 或 <span class="string">&quot;cd&quot;</span></span><br></pre></td></tr></table></figure>

<p>➢  <strong>|</strong><br> | 匹配前面的或者随后的表达式。<br> 例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ab|<span class="built_in">cd</span>)&#123;1&#125;  &#123;<span class="built_in">printf</span>(<span class="string">&quot;get word:%s\n&quot;</span>, yytext);&#125; // 出现1次：<span class="string">&quot;ab&quot;</span>或 <span class="string">&quot;cd&quot;</span></span><br></pre></td></tr></table></figure>

<p>➢  <strong>“…”</strong><br> “…”  逐字匹配引号内的每个字符。不同于“\”的元字符会失去它的含义。<br> 和 () 不同的是，引号内的都是普通字符，没有特殊含义。</p>
<p>例如：“&#x2F;<em>” 匹配两个字符 &#x2F;</em></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(\\)&#123;<span class="number">1</span>&#125;  &#123;printf(<span class="string">&quot;get word:%s<span class="subst">\n</span>&quot;</span>, yytext);&#125; <span class="comment">// 出现1次：&quot;\&quot;</span></span><br><span class="line"><span class="string">&quot;<span class="subst">\\</span>&quot;</span>&#123;<span class="number">1</span>&#125;  &#123;printf(<span class="string">&quot;get word:%s<span class="subst">\n</span>&quot;</span>, yytext);&#125; <span class="comment">// 出现1次：&quot;\\&quot;</span></span><br></pre></td></tr></table></figure>

<p>➢  <strong>&#x2F;</strong><br> &#x2F; 只有当有后面的表达式跟随时才匹配前面的表达式。</p>
<p>例如： 0&#x2F;1 匹配字符串01中的0 但是不匹配字符串0或者02中的任何字符。</p>
<p>每个模式只允许有一个&#x2F; ，并且模式不能同时包含 &#x2F; 和 $</p>
<p>➢  <strong>^</strong><br> ^作为正则表达式的第一个字符，它匹配行的开始；<br> ^在方括号[] 中用于否定。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^<span class="selector-attr">[A-Z]</span>* &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 行开始的所有大写字母串</span></span><br><span class="line"><span class="selector-attr">[^A-Z]</span>*  &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 匹配非大写字母的字符串</span></span><br></pre></td></tr></table></figure>

<p>➢  <strong>$</strong><br> $作为正则表达式的最后一个字符，它匹配行的结束</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>*$ &#123;<span class="built_in">printf</span>(&quot;get word:%s\n&quot;, yytext);&#125; <span class="comment">// 行末尾的大写字母串</span></span><br></pre></td></tr></table></figure>

<p>➢  <strong>&lt;&gt;</strong><br> &lt;&gt; 位于模式开头的尖括号内的一个或者一列名字，使那个模式只应用于指定的起始状态。<br> 匹配词（word）的开始（&lt;）和结束（&gt;）。例如正则表达式<code>&lt;the&gt;</code>能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。</p>
<p>➢  <strong><code>&lt;&lt;EOF&gt;&gt;</code></strong><br> <code>&lt;&lt;EOF&gt;&gt;</code> 只用于flex中，这个特殊模式匹配文件的结尾。</p>
<h3 id="2-常规表达式举例"><a href="#2-常规表达式举例" class="headerlink" title="2. 常规表达式举例"></a>2. 常规表达式举例</h3><table>
<thead>
<tr>
<th align="left">常规表达式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">joke[rs]</td>
<td align="left">匹配 jokes 或 joker。</td>
</tr>
<tr>
<td align="left">A{1,2}shis+</td>
<td align="left">匹配 AAshis, Ashis, AAshi, Ashi。</td>
</tr>
<tr>
<td align="left">(A[b-e])+</td>
<td align="left">匹配在 A 出现位置后跟随的从 b 到 e 的所有字符中的 0 个或 1个。</td>
</tr>
</tbody></table>
<h3 id="3-标记声明举例"><a href="#3-标记声明举例" class="headerlink" title="3. 标记声明举例"></a>3. 标记声明举例</h3><table>
<thead>
<tr>
<th>标记</th>
<th>相关表达式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>数字(number)</td>
<td>([0-9])+</td>
<td>1个或多个数字</td>
</tr>
<tr>
<td>字符(chars)</td>
<td>[A-Za-z]</td>
<td>任意字符</td>
</tr>
<tr>
<td>空格(blank)</td>
<td>“ “</td>
<td>一个空格</td>
</tr>
<tr>
<td>字(word)</td>
<td>(chars)+</td>
<td>1个或多个 <em>chars</em></td>
</tr>
<tr>
<td>变量(variable)</td>
<td>(字符)+(数字)<em>(字符)</em>(数字)*</td>
<td>&nbsp;</td>
</tr>
</tbody></table>
<h2 id="3-3-简单示例"><a href="#3-3-简单示例" class="headerlink" title="3.3 简单示例"></a>3.3 简单示例</h2><p>一个非常简单的例子(example1)如下:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line"><span class="function">stop <span class="title">printf</span><span class="params">(<span class="string">&quot;Stop command received\n&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">start <span class="title">printf</span><span class="params">(<span class="string">&quot;Start command received\n&quot;</span>)</span></span>;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>


<p>第一部分，位于%{和%}对之间直接包含了输出程序(stdio.h)。我们需要这个程序，因为使用了printf函数，它在stdio.h中定义。</p>
<p>第二部分用’%%’分割开来，所以第二行起始于’stop’，一旦在输入参数中遇到了’stop’，接下来的那一行(printf()调用)将被执行。</p>
<p>除此之外，还有’start’，其跟stop的行为差不多。</p>
<p>我们再次用’%%’结束代码段。</p>
<p>为了编译上面的例子，只需要执行以下命令：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lex</span> example1.<span class="keyword">l</span></span><br><span class="line"><span class="keyword">cc</span> <span class="keyword">lex</span>.yy.<span class="keyword">c</span> -<span class="keyword">o</span> example -<span class="keyword">ll</span></span><br></pre></td></tr></table></figure>

<p>flex，执行以下命令：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">C:</span>\flex&gt;flex example1.l</span><br><span class="line"></span><br><span class="line"><span class="symbol">C:</span>\flex&gt;gcc lex.yy.c -o example -L C:\Qt\GnuWin32\<span class="keyword">lib</span> -lfl</span><br><span class="line"></span><br><span class="line"><span class="symbol">C:</span>\flex&gt;example</span><br><span class="line">aa</span><br><span class="line">aa</span><br><span class="line"><span class="keyword">stop</span></span><br><span class="line"><span class="keyword">Stop</span> command received</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">Start command received</span><br><span class="line"></span><br><span class="line">^Z</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果你用flex，则就将lex命令用flex代替，还需要将’-ll’选项改成’-lfl’。在RedHat 6.x以及SuSe中需要这样做。</p>
<p>这样，Lex将生成’example1’这个文件。运行该文件，它将等待你输入一些数据。每次你输入一些不匹配的命令(非’stop’和’start’)，它会将你输入的字符再次输出。你若输入’stop’，它将输出’Stop command received’。</p>
<p>用一个EOF(^D)来结束程序。</p>
<p>也许你想知道，它是怎么运行的，因为我们并没有定义main()函数。这个函数(指main())已经在lib1(liblex)中定义好了，在此我们选用了编译选项’-ll’</p>
<h2 id="3-4-匹配中的正则表达式示例"><a href="#3-4-匹配中的正则表达式示例" class="headerlink" title="3.4 匹配中的正则表达式示例"></a>3.4 匹配中的正则表达式示例</h2><p>这个实例(example2)本身并没什么用处，下一个实例也不会提及正则表达式。但这里它展示了如何在Lex中使用正则表达式，这在后面将非常有用。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%&#123;</span></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">[<span class="number">0123456789</span>]+ printf(<span class="string">&quot;NUMBER\n&quot;</span>);</span><br><span class="line">[a-zA-<span class="symbol">Z</span>][a-zA-<span class="symbol">Z0</span><span class="number">-9</span>]* printf(<span class="string">&quot;WORD\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>该Lex文件描述了两种token匹配：WORDs和NUMBERs。正则表达式非常恐怖，但是只需要稍花力气便可以加以理解。</p>
<p>其中NUMBER匹配“[0123456789]+”可以写成“[0-9]+”。</p>
<p>WORD匹配就有点复杂：[a-zA-Z][a-zA-Z0-9]*</p>
<p>第一部分仅仅匹配一个’a’到’z’或’A’到’Z’之间的字符，也即一个字母。接着该字母后面需要连上0个或多个字符，这些字符可以是字母，也可以是数字。这里为何用’<em>’? ’+’表示至少1次的匹配。一个WORD只有一个字符也可以很好的匹配，在第一部分我们已经匹配到了一个字符，所以第二部分可以是0个匹配，所以用’</em>’。</p>
<p>用这种方式，我们就模仿了很多编程语言中对于一个变量名的要求，即要求变量名『必须』以字母开头，但是可以在后续字符中用数字。也就是说’temperature1’是一个正确的命名，但是’1temperature’就不是。</p>
<p>像example1一样编译example2，并输入一些文本，如下：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ./example2</span><br><span class="line">foo</span><br><span class="line"><span class="built_in">WORD</span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"><span class="built_in">WORD</span></span><br><span class="line"></span><br><span class="line"><span class="number">123</span></span><br><span class="line">NUMBER</span><br><span class="line"></span><br><span class="line">bar123</span><br><span class="line"><span class="built_in">WORD</span></span><br><span class="line"></span><br><span class="line">123bar</span><br><span class="line">NUMBER</span><br><span class="line"><span class="built_in">WORD</span></span><br></pre></td></tr></table></figure>


<p>你也许会疑惑，所有的输出中的空格是从哪来的？理由很简单：从输入而来，我们不在空格上匹配任何内容，所以它们又输出来了。</p>
<p>Flex主页上有正则表达式的详细文档。很多人觉得perl正则表达式主页的说明非常有用，但是Flex并不实现perl所实现的所有东西。</p>
<p>你只需要确保不写一些形如’[0-9]*’的空匹配即可，你的词法分析器(由Flex生成)将不明就里的开始不断的匹配空字符。</p>
<h2 id="3-5-复杂一点的类C语法示例"><a href="#3-5-复杂一点的类C语法示例" class="headerlink" title="3.5 复杂一点的类C语法示例"></a>3.5 复杂一点的类C语法示例</h2><p>假定我们需要解析一个形如下面的文件：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logging</span>&#123;</span><br><span class="line">category lame<span class="operator">-</span><span class="keyword">servers</span> &#123; <span class="literal">null</span>; &#125;;</span><br><span class="line">category <span class="keyword">cname</span> &#123; <span class="literal">null</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">&quot;.&quot;</span> &#123;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">hint</span>;</span><br><span class="line">file <span class="string">&quot;/etc/bind/db.root&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在此见到了很多token：</p>
<ul>
<li>WORD: 如’zone’和’type’</li>
<li>FILENAME：如“&#x2F;etc&#x2F;bind&#x2F;db.root”</li>
<li>QUOTE: 如包含文件名的引号</li>
<li>OBRACE：{</li>
<li>EBRACE: }</li>
<li>SEMICOLON: ;</li>
</ul>
<p>example3相应的Lex文件如下：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="selector-id">#include</span> &lt;stdio<span class="selector-class">.h</span>&gt;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"><span class="selector-attr">[a-zA-Z]</span><span class="selector-attr">[a-zA-Z0-9]</span>* <span class="built_in">printf</span>(&quot;WORD &quot;);</span><br><span class="line"><span class="selector-attr">[a-zA-Z0-9\/.-]</span>+ <span class="built_in">printf</span>(&quot;FILENAME &quot;);</span><br><span class="line">\&quot; <span class="built_in">printf</span>(&quot;QUOTE &quot;);</span><br><span class="line">\&#123; <span class="built_in">printf</span>(&quot;OBRACE &quot;);</span><br><span class="line">\&#125; <span class="built_in">printf</span>(&quot;EBRACE &quot;);</span><br><span class="line">; <span class="built_in">printf</span>(&quot;SEMICOLON &quot;);</span><br><span class="line">\n <span class="built_in">printf</span>(&quot;\n&quot;);</span><br><span class="line"><span class="selector-attr">[ \t]</span>+ <span class="comment">/* ignore whitespace */</span>;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>


<p>当输入我们的文件到Lex生成的example3中，我们得到：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WORD</span> OBRACE</span><br><span class="line"><span class="built_in">WORD</span> FILENAME OBRACE <span class="built_in">WORD</span> SEMICOLON EBRACE SEMICOLON</span><br><span class="line"><span class="built_in">WORD</span> <span class="built_in">WORD</span> OBRACE <span class="built_in">WORD</span> SEMICOLON EBRACE SEMICOLON</span><br><span class="line">EBRACE SEMICOLON</span><br><span class="line"><span class="built_in">WORD</span> QUOTE FILENAME QUOTE OBRACE</span><br><span class="line"><span class="built_in">WORD</span> <span class="built_in">WORD</span> SEMICOLON</span><br><span class="line"><span class="built_in">WORD</span> QUOTE FILENAME QUOTE SEMICOLON</span><br><span class="line">EBRACE SEMICOLON</span><br></pre></td></tr></table></figure>

<h2 id="3-6-Lex深入学习"><a href="#3-6-Lex深入学习" class="headerlink" title="3. 6 Lex深入学习"></a>3. 6 Lex深入学习</h2><p>.l文件 的结构</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="selector-tag">section</span>(定义段)</span><br><span class="line">%%</span><br><span class="line">Rules <span class="selector-tag">section</span>（规则段）</span><br><span class="line">%%</span><br><span class="line">C <span class="selector-tag">code</span> <span class="selector-tag">section</span> （用户子程序段）</span><br></pre></td></tr></table></figure>

<p>下面以一个单词统计程序详细说明。</p>
<h3 id="1-Definition-Section-定义段"><a href="#1-Definition-Section-定义段" class="headerlink" title="1. Definition Section(定义段)"></a>1. Definition Section(定义段)</h3><p>这块可以放C语言的各种各种include，define等声明语句，但是要用%{ %}括起来。<br> 可以放预定义的正则表达式：minus “-” 还要放token的定义，方法是：代号 正则表达式。然后到了<strong>规则段</strong>就可以通过{代号} 来引用正则表达式</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#include &lt;<span class="string">stdio.h</span>&gt; <span class="comment">// include</span></span></span><br><span class="line"><span class="type">int</span> wordCount = <span class="number">0</span>;  <span class="comment">// 定义全局变量 单词计数器</span></span><br><span class="line">%&#125;</span><br><span class="line"><span class="comment">// 预定义代号表</span></span><br><span class="line">chars [A-za-z\_\&#x27;\.\<span class="string">&quot;]</span></span><br><span class="line"><span class="string">numbers ([0-9])+</span></span><br><span class="line"><span class="string">delim [&quot;</span> <span class="string">&quot;\n\t]</span></span><br><span class="line"><span class="string">whitespace &#123;delim&#125;+  // 使用前面的代号 来 定义代号</span></span><br><span class="line"><span class="string">words &#123;chars&#125;+  // 使用前面的代号 来 定义代号</span></span><br><span class="line"><span class="string">%%</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Rules-section（规则段）"><a href="#2-Rules-section（规则段）" class="headerlink" title="2. Rules section（规则段）"></a>2. Rules section（规则段）</h3><p>在这里放置的rules就是每个正则表达式要对应的动作，一般是返回一个token<br> 这里的动作都是用{}扩起来的，用C语言来描述，这些代码可以做你任何想要做的事情</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;words&#125; &#123; wordCount++; <span class="comment">/* wordCount 加1 */</span> &#125;</span><br><span class="line">&#123;whitespace&#125; &#123; <span class="comment">/* 空白，什么也不做*/</span> &#125;</span><br><span class="line">&#123;numbers&#125; &#123; <span class="comment">/* 这里可以加入如果遇到数字的处理逻辑*/</span> &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<h3 id="3-C-code-section-（用户子程序段）"><a href="#3-C-code-section-（用户子程序段）" class="headerlink" title="3. C code section （用户子程序段）"></a>3. C code section （用户子程序段）</h3><p>Lex 编程的第三段，也就是最后一段覆盖了 C 的函数声明（有时是主函数）。注意这一段必须包括 yywrap() 函数。 Lex 有一套可供使用的函数和变量。 其中之一就是 yywrap。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    yylex(); <span class="comment">//这一函数开始分析。 它由 Lex 自动生成。</span></span><br><span class="line">    printf(<span class="string">&quot; No of words: %d\n&quot;</span>, wordCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这一函数在文件（或输入）的末尾调用。 如果函数的返回值是1，就停止解析。</span></span><br><span class="line"><span class="comment"> 因此它可以用来解析多个文件。 代码可以写在第三段，这就能够解析多个文件。</span></span><br><span class="line"><span class="comment"> 方法是使用 yyin 文件指针指向不同的文件，直到所有的文件都被解析。 </span></span><br><span class="line"><span class="comment"> 最后，yywrap() 可以返回 1 来表示解析的结束。*/</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">yywrap</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-编译运行"><a href="#4-编译运行" class="headerlink" title="4.编译运行"></a>4.编译运行</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">c:\&gt;flex</span> <span class="string">wordcount.l</span> </span><br><span class="line"></span><br><span class="line"><span class="string">c:\&gt;gcc</span> <span class="string">-o</span> <span class="string">wordcount</span> <span class="string">lex.yy.c</span></span><br><span class="line"></span><br><span class="line"><span class="string">c:\&gt;wordcount</span></span><br><span class="line"><span class="literal">yes</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="string">but</span></span><br><span class="line"><span class="string">---99</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">^Z</span></span><br><span class="line"> <span class="attr">No of words:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="string">c:\&gt;wordcount</span> <span class="string">&lt;</span> <span class="string">text.txt</span>  <span class="comment">#运行程序，将输入流重定向为要分析的文件</span></span><br><span class="line"><span class="string">------</span> <span class="attr">No of words:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="5-常用的全局变量和宏"><a href="#5-常用的全局变量和宏" class="headerlink" title="5. 常用的全局变量和宏"></a>5. 常用的全局变量和宏</h3><p>lex.yy.c中，有很多全局变量、函数、宏。这里之处部分最常用的</p>
<blockquote>
<blockquote>
<p><strong>FILE *yyin:</strong><br> <strong>FILE *yyout：</strong> 这是Lex中本身已定义的输入和输出文件指针。这两个变量指明了lex生成的词法分析器从哪里获得输入和输出到哪里。默认：键盘输入，屏幕输出。</p>
</blockquote>
<blockquote>
<p>**char *yytext：**指向当前识别的词法单元（词文）的指针</p>
</blockquote>
<blockquote>
<p>**int yyleng：**当前词法单元的长度。</p>
</blockquote>
<blockquote>
<p><strong>yylineno</strong> 提供当前的行数信息。（lexer不一定支持。）</p>
</blockquote>
<blockquote>
<p>**ECHO：**Lex中预定义的宏，可以出现在动作中，相当于fprintf(yyout, “%s”,yytext)，即输出当前匹配的词法单元。</p>
</blockquote>
<blockquote>
<p><strong>REJECT：</strong> 指示简析器对当前规则不做处理，而是采用第二匹配规则。<br> 因为解析器在通常情况下，每个被匹配的对象只会对一个动作生效。REJECT指示解析器，会寻找下一个最配的规则来做处理。下面的规则会把输入的”abcd”处理后输出”abcd|abc|ab|a|abcd”。</p>
</blockquote>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a <span class="string">|</span></span><br><span class="line">ab <span class="string">|</span></span><br><span class="line">abc <span class="string">|</span></span><br><span class="line">abcd &#123;ECHO<span class="punctuation">;</span>printf<span class="punctuation">(</span><span class="string">&quot;|&quot;</span><span class="punctuation">)</span><span class="punctuation">;</span>REJECT<span class="punctuation">;</span>&#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>BEGIN</strong> 开始一个条件处理块</p>
</blockquote>
<blockquote>
<p>**int yylex()：**词法分析器驱动程序，用Lex翻译器生成的lex.yy.c内必然含有这个函数。它自动移动文件指针<br> yyin 和 yyout 。<br> <strong>在定义模式动作时，可以用 return 语句来结束 yylex分析函数。return 需要返回一个整数。</strong><br> 由于 yylex() 函数的运行环境都是以全局变量的方式来保存，因此在下一次调用 yylex() 时，yylex()可以从上次扫描的断点处继续扫描。若用户未定义相应的return语句，则yylex()继续分析被扫描的文件，直到碰到文件结束标识符EOF。<br> 在读取到EOF时，yylex() 函数调用 int yywrap() 函数，若yywrap()返回非0值，则yylex() 函数结束返回0；否则，yylex()继续对yyin指向的文件扫描。</p>
</blockquote>
<blockquote>
<p>**int yywrap()：**词法分析器遇到文件结尾时会调用yywrap()来决定下一步怎么做：<br> 若yywrap()返回0，则继续扫描<br> 若返回1，则返回报告文件结尾的0标记。<br> 由于词法分析器总会调用yywrap，因此辅助函数中最好提供yywrap，如果不提供，则在用C编译器编译lex.yy.c时，需要链接相应的库，库中会给出标准的yywrap函数（标准函数返回1）。</p>
</blockquote>
<blockquote>
<p>**yymore()**这一函数告诉 Lexer 将下一个标记附加到当前标记后。<br> &#96;yymore()’ 告诉解析器下一次匹配的规则，满足的部分将会添加到当前yytext值得后面而不是替换它。 例如，指定的输入”mega-kludge”经过下面的程序处理后将会输出”mega-mega-kludge”。</p>
</blockquote>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;%%</span><br><span class="line">mega- ECHO; <span class="built_in">yymore</span>();</span><br><span class="line">kludge ECHO;<span class="comment">/* 这时，yytext的值为mega-kludge */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>yyless(int n)</strong> 返回当前匹配项除了开始的n个字符内的所有的内容到输入缓存区，解析器处理下一个匹配时，它们将会被重新解析。yyless将会导致yytext与yyleng的调整。（yyleng将会等于&#x3D;n） 如输入”createtable”被下面的程序处理后，将会输出”createtableatetable”. 因为前n&#x3D;3个字符foo外的字符atetable被重新返回到输入缓存区，再次解析。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">createtable ECHO; yyless(3);</span></span><br><span class="line">[a-zA-Z]+ ECHO;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">\n <span class="built_in">return</span> 0;</span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">%</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>unput(c)</strong> 将字符c放回到输入流中，该字符可以重新被解析。下面的动作将当前的匹配值附上括号后重新进行匹配。</p>
</blockquote>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&#123;</span><br><span class="line">int i;</span><br><span class="line">&gt;<span class="comment">/* Copy yytext because unput() trashes yytext */</span></span><br><span class="line">char <span class="comment">*yycopy = strdup( yytext );</span></span><br><span class="line">&gt;un<span class="meta">put</span>( <span class="string">&#x27;)&#x27;</span> );</span><br><span class="line">for ( i = yyleng - 1; i &gt;= 0; --i )</span><br><span class="line">un<span class="meta">put</span>( yycopy[i] );</span><br><span class="line">un<span class="meta">put</span>( <span class="string">&#x27;(&#x27;</span> );</span><br><span class="line">free( yycopy );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 由于每次unput()将指定的字符添加到输入源的开头，所以将字符串添加到输入源开头必须从后道前处理。一个比较重要的潜在问题是使用unput()的时候，如果采用了%pointer指针模式保存yytext,unput会破坏yytext的内容，从最右边的字符开始将会破坏左边的一个字符。如果在unput()后要用到yytext,你首先必须复制一份yytext,或者用%array模式来保存yytext. 最后不能尝试放一个EOF标志输入流的结束。</p>
</blockquote>
<blockquote>
<p><strong>input()</strong> 从输入源中读取下一个字符。<br> 下面例子将会吃掉C语言注释</p>
</blockquote>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%%</span><br><span class="line">&gt;<span class="string">&quot;/*&quot;</span> &#123;</span><br><span class="line"> register <span class="keyword">int</span> c;</span><br><span class="line"> <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">  <span class="keyword">while</span> ( (c = input()) != <span class="string">&#x27;*&#x27;</span> &amp;&amp;&gt;c != EOF ); <span class="comment">/* eat up text of comment */</span></span><br><span class="line">   <span class="keyword">if</span> ( c == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( (c = input()) == <span class="string">&#x27;*&#x27;</span> );</span><br><span class="line">     <span class="keyword">if</span> ( c == <span class="string">&#x27;/&#x27;</span> ) <span class="keyword">break</span>; <span class="comment">/* found the end */</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> ( c == EOF ) &#123;</span><br><span class="line">     <span class="keyword">error</span>( <span class="string">&quot;EOF in comment&quot;</span> );</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>yyterminate()</strong> 可以在动作内部返回描述区域中使用，它将终止解析器并返回0给解析器调用者，表示操作完成。缺省情况下，到达文件结束位置也会被调用，它是一个宏，并且可能重定义。</p>
</blockquote>
</blockquote>
<h3 id="6-条件模式"><a href="#6-条件模式" class="headerlink" title="6. 条件模式"></a>6. 条件模式</h3><p>LEX提供控制模式在一定状态下使用的功能，称为条件模式。LEX首先在定义部份通过 “%start&#x2F;x&#x2F;s 条件名” 来定义条件句。在规则部份可通过宏 “BEGIN(条件名)” 来激活条件。”BEGIN(INITIAL)” 或 “BEGIN(0)” 将休眠所有的条件模式，使分析器回到开始状态。</p>
<p>下面是postgresql里面的一段LEX代码，解析SQL里面的comments</p>
<figure class="highlight mercury"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">op_chars        [\~\!\@\#\^\&amp;\|\`\?\+\-\*<span class="built_in">\/</span>\<span class="comment">%\&lt;\&gt;\=]</span></span><br><span class="line">... ...</span><br><span class="line"><span class="comment">/* C-style comments</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The &quot;extended comment&quot; syntax closely resembles allowable operator syntax.</span></span><br><span class="line"><span class="comment"> * The tricky part here is to get lex to recognize a string starting with</span></span><br><span class="line"><span class="comment"> * slash-star as a comment, when interpreting it as an operator would produce</span></span><br><span class="line"><span class="comment"> * a longer match --- remember lex will prefer a longer match!  Also, if we</span></span><br><span class="line"><span class="comment"> * have something like plus-slash-star, lex will think this is a 3-character</span></span><br><span class="line"><span class="comment"> * operator whereas we want to see it as a + operator and a comment start.</span></span><br><span class="line"><span class="comment"> * The solution is two-fold:</span></span><br><span class="line"><span class="comment"> * 1. append &#123;op_chars&#125;* to xcstart so that it matches as much text as</span></span><br><span class="line"><span class="comment"> *    &#123;operator&#125; would. Then the tie-breaker (first matching rule of same</span></span><br><span class="line"><span class="comment"> *    length) ensures xcstart wins.  We put back the extra stuff with yyless()</span></span><br><span class="line"><span class="comment"> *    in case it contains a star-slash that should terminate the comment.</span></span><br><span class="line"><span class="comment"> * 2. In the operator rule, check for slash-star within the operator, and</span></span><br><span class="line"><span class="comment"> *    if found throw it back with yyless().  This handles the plus-slash-star</span></span><br><span class="line"><span class="comment"> *    problem.</span></span><br><span class="line"><span class="comment"> * Dash-dash comments have similar interactions with the operator rule.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">xcstart         <span class="built_in">\/</span>\*&#123;op_chars&#125;*</span><br><span class="line">xcstop          \*+<span class="built_in">\/</span></span><br><span class="line">xcinside        [^*/]+</span><br><span class="line">... ...</span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">... ...</span><br><span class="line">&#123;xcstart&#125;       &#123;</span><br><span class="line">                    <span class="comment">/* Set location in case of syntax error in comment */</span></span><br><span class="line">                    SET_YYLLOC();</span><br><span class="line">                    yyextra-&gt;xcdepth <span class="built_in">=</span> <span class="number">0</span>;</span><br><span class="line">                    BEGIN(xc);</span><br><span class="line">                    <span class="comment">/* Put back any characters past slash-star; see above */</span></span><br><span class="line">                    yyless(<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&#123;xcstart&#125;   &#123;</span><br><span class="line">                    (yyextra-&gt;xcdepth)++;</span><br><span class="line">                    <span class="comment">/* Put back any characters past slash-star; see above */</span></span><br><span class="line">                    yyless(<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&#123;xcstop&#125;    &#123;</span><br><span class="line">                    <span class="built_in">if</span> (yyextra-&gt;xcdepth <span class="built_in">&lt;=</span> <span class="number">0</span>)</span><br><span class="line">                        BEGIN(INITIAL);</span><br><span class="line">                    <span class="built_in">else</span></span><br><span class="line">                        (yyextra-&gt;xcdepth)--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&#123;xcinside&#125;  &#123;</span><br><span class="line">                    <span class="comment">/* ignore */</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&#123;op_chars&#125;  &#123;</span><br><span class="line">                    <span class="comment">/* ignore */</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;\*+         &#123;</span><br><span class="line">                    <span class="comment">/* ignore */</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&lt;&lt;EOF&gt;&gt;     &#123; yyerror(<span class="string">&quot;unterminated /* comment&quot;</span>); &#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>

<p><strong>&lt;INITIAL,STRING,QUOTE&gt;</strong> 将会在 “INITIAL”, “STRING”, “QUOTE”三者之一的条件下被激活。</p>
<p>开始条件在定义段被申明，在’%s’ 或 ‘%x’后跟随着名字列表。 %s申明了包含的开始条件，%x申明了排他的开始条件。开始条件被BEGIN动作激活。直到下一个BEGIN动作，满足开始条件名称的规则将会被规则，不满足启动条件的规则将不会被执行。<br> <strong>如果是包含条件，没有开始条件的规则也会被激活执行，如果时排他条件，只有满足开始条件的规则才会被执行。</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%s example</span><br><span class="line">%%</span><br><span class="line">&lt;example&gt;<span class="function">foo   <span class="title">do_something</span>()</span>;</span><br><span class="line"><span class="function">bar            <span class="title">something_else</span>()</span>;</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%<span class="attribute">x</span> example</span><br><span class="line">%%</span><br><span class="line">&lt;example&gt;foo   <span class="built_in">do_something</span>();</span><br><span class="line">&lt;INITIAL,example&gt;bar    <span class="built_in">something_else</span>();</span><br></pre></td></tr></table></figure>

<p>上面的程序中如果没有&lt;INITIAL,example&gt;，在example条件下bar规则将永远不会被激活。如果使用<example>，将会导致只能在exmaple开始条件下激活，而INITIAL条件下不会被激活。而第一个程序中在任何条件下bar都被会激活。因为第一个程序用example时%s，时包含条件。*<strong>也可以通过特殊开始条件&lt;*&gt;来配置任何开始条件，上面的程序还可以写为：*</strong></p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%<span class="attribute">x</span> example</span><br><span class="line">%%</span><br><span class="line">&lt;example&gt;foo   <span class="built_in">do_something</span>();</span><br><span class="line">&lt;*&gt;bar    <span class="built_in">something_else</span>();</span><br></pre></td></tr></table></figure>

<p><strong>YY_START</strong> 开始条件的名字实际上时一个整形值并且能够被保存，可以使用 <strong>YY_START</strong> 宏来访问当前的开始条件。<strong>YYSTATE</strong> 是 YY_START 的别名（AT&amp;T lex使用了YYSTATE）。</p>
<p>下面的代码能够是被C语言注释并且统计行数。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%x <span class="built_in">comment</span> foo</span><br><span class="line">%%</span><br><span class="line">        int line_num = <span class="number">1</span>;</span><br><span class="line">        int comment_caller;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;/*&quot;</span>         &#123;</span><br><span class="line">             comment_caller = INITIAL;</span><br><span class="line">             BEGIN(<span class="built_in">comment</span>);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;foo&gt;<span class="string">&quot;/*&quot;</span>    &#123;</span><br><span class="line">             comment_caller = foo; <span class="comment">/* comment_caller = foo ==》comment_caller = YY_START */</span></span><br><span class="line">             BEGIN(<span class="built_in">comment</span>);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="built_in">comment</span>&gt;[^*\n]*        <span class="comment">/* eat anything that&#x27;s not a &#x27;*&#x27; */</span></span><br><span class="line">&lt;<span class="built_in">comment</span>&gt;<span class="string">&quot;*&quot;</span>+[^*/]*   <span class="comment">/* eat up &#x27;*&#x27;s not followed by &#x27;/&#x27;s */</span></span><br><span class="line">&lt;<span class="built_in">comment</span>&gt;\n             ++line_num;</span><br><span class="line">&lt;<span class="built_in">comment</span>&gt;<span class="string">&quot;*&quot;</span>+<span class="string">&quot;/&quot;</span>        BEGIN(comment_caller);</span><br></pre></td></tr></table></figure>

<h4 id="开始条件范围"><a href="#开始条件范围" class="headerlink" title="开始条件范围"></a>开始条件范围</h4><p>前面条件模式的代码中，会有许多相同开始条件的处理。使用开始条件范围可以简化重复操作。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">SCs</span>&gt;</span></span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure>

<p>SCs 是一个或开始条件的列表。在这个开始条件范围内，每个规则将会自动具有前缀 ‘<SCs>‘ 直到 ‘}’ 与开始的 ‘{‘ 匹配. 例如</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;comment&gt;  &#123;</span><br><span class="line">  [^*]*        <span class="comment">/* eat anything that&#x27;s not a &#x27;*&#x27; */</span></span><br><span class="line">  <span class="string">&quot;*&quot;</span>+[^*<span class="regexp">/]*   /</span>* eat up <span class="string">&#x27;*&#x27;</span>s <span class="keyword">not</span> followed <span class="keyword">by</span> <span class="string">&#x27;/&#x27;</span>s */</span><br><span class="line">  <span class="string">\n</span>             ++line_num;</span><br><span class="line">  <span class="string">&quot;*&quot;</span>+<span class="string">&quot;/&quot;</span>        BEGIN(comment_caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">comment</span>&gt;[^*]*        <span class="comment">/* eat anything that&#x27;s not a &#x27;*&#x27; */</span></span><br><span class="line">&lt;<span class="keyword">comment</span>&gt;&quot;*&quot;+[^*/]*   <span class="comment">/* eat up &#x27;*&#x27;s not followed by &#x27;/&#x27;s */</span></span><br><span class="line">&lt;<span class="keyword">comment</span>&gt;\n             ++line_num;</span><br><span class="line">&lt;<span class="keyword">comment</span>&gt;&quot;*&quot;+&quot;/&quot;        <span class="keyword">BEGIN</span>(comment_caller);</span><br></pre></td></tr></table></figure>

<h4 id="条件嵌套"><a href="#条件嵌套" class="headerlink" title="条件嵌套"></a>条件嵌套</h4><p>开始条件也可以嵌套，下面时三个管理开始条件堆栈的参数。</p>
<blockquote>
<p><strong>void yy_push_state(int new_state)</strong> 将当前的开始条件压栈，切换到 new_state 与使用 ‘BEGIN new_state’类似。<br> <strong>void yy_pop_state()</strong> 从栈顶弹出，类似于 BEGIN.<br> <strong>int yy_top_state()</strong> 返回栈顶值，不改变栈内容。</p>
</blockquote>
<p>开始条件栈动态增长，没有固定限制，如果内存用尽，程序自会终止。</p>
<h3 id="7-多输入缓存区"><a href="#7-多输入缓存区" class="headerlink" title="7. 多输入缓存区"></a>7. 多输入缓存区</h3><p>YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )<br> void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )<br> void yy_delete_buffer( YY_BUFFER_STATE buffer )<br> void yy_flush_buffer( YY_BUFFER_STATE buffer )</p>
<h1 id="四、YACC"><a href="#四、YACC" class="headerlink" title="四、YACC"></a>四、YACC</h1><p>yacc是开发编译器的一个有用的工具,采用LR（1）（实际上是LALR(1)）语法分析方法。<br> LR(k)分析方法，括号中的k（k &gt;&#x3D;0）表示向右查看输入串符号的个数。LR分析法正视给出一种能根据当前分析栈中的符号串和向右顺序查看输入串的k个符号就可唯一确定分析器的动作是移进还是规约和用哪个产生式规约。<br> 这种方法具有分析速度快，能准确，即使地指出出错的位置，它的主要缺点是对于一个使用语言文法的分析器的构造工作量相当大，k愈大构造愈复杂，实现比较困难。</p>
<p>一个LR分析器有3个部分组成：</p>
<ul>
<li><strong>总控程序，也可以称为驱动程序。</strong><br> 对所有的LR分析器总控程序都是相同的。</li>
<li><strong>分析表或分析函数。</strong><br> 不同的文法分析表将不同，同一个文法采用的LR分析器不同时，分析表也不同，分析表又可分为动作(ACTION)表和状态转换(GOTO)表两个部分，它们都可用二维数组表示。</li>
<li><strong>分析栈，包括文法符号栈和相应的状态栈。</strong><br> 它们均是先进后出栈。 分析器的动作由栈顶状态和当前输入符号所决定(LR(0)分析器不需要向前查看输入符号)。<br> LR分析器工作过程如下 :<br> 其中SP为栈指针，S[i]为状态栈，X[i]为文法符号栈。状态转换表内容按关系GOTO[Si，X] &#x3D; Sj确定，该关系式是指当栈顶状态为Si遇到当前文法符号为X时应转向状态Sj。X为终结符或非终结符。 ACTION[Si，a]规定了栈顶状态为Si是遇到输入符号a应执行的动作。</li>
</ul>
<p>YACC可以解析输入流中的标识符(token)，这就清楚的描述了YACC和LEX的关系，YACC并不知道『输入流』为何物，它需要事先就将输入流预加工成标识符，虽然你可以自己手工写一个Tokenizer，但我们将这些工作留给LEX来做。</p>
<p>YACC用来为编译器解析输入数据，即程序代码。这些用编程语言写成的程序代码一点也不模棱两可——它们只有一个意思。正因为如此，YACC才不会去对付那些有歧义的语法，并且会抱怨shift&#x2F;reduce或者reduce&#x2F;reduce冲突。更多的关于模糊性和YACC『问题』可以在『冲突』一章中找到。</p>
<h2 id="4-1-yacc语法结构"><a href="#4-1-yacc语法结构" class="headerlink" title="4.1 yacc语法结构"></a>4.1 yacc语法结构</h2><p>yacc语法包括三部分：定义段、规则段和用户子例程段</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span>定义段<span class="string">...</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">...</span>规则段<span class="string">...</span></span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="string">...</span>用户子例程段<span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>各部分由以两个百分号开头的行分开，尽管某一个部分可以为空，但是前两部分是必须的，第三部分和前面的百分号可以省略。</p>
<h3 id="1-符号"><a href="#1-符号" class="headerlink" title="1. 符号"></a>1. 符号</h3><p>yacc 语法由符号组成，即语法的“词”。符号是一串不以数字开头的字母、数字、句点和下划线。符号error专用于错误恢复，另外，yacc对任何符号都不会附加“先验”的意义。</p>
<p>由词法分析程序产生的符号叫做终结符号或者标记。定义在规则左侧的叫做非终结符号或者非终结。标记也可能是字面上引用的字符，<strong>通常遵循约定：标记大写，非终结符号小写</strong>。</p>
<h3 id="2-定义段"><a href="#2-定义段" class="headerlink" title="2. 定义段"></a>2. 定义段</h3><p>定义段包括文字块，逐字拷贝到生成的C文件开头部分的C代码，通常包括声明和#include行。可能有%union  %start   %token   %type   %left  %right  和 %nonassoc声明。</p>
<p>也可以包含普通的C语言风格的注释，所有这些都是可选的，在简单的语法分析程序中，定义段可能完全是空的。</p>
<p>如在定义部分定义标志：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">token</span></span> INTEGER</span><br></pre></td></tr></table></figure>

<p>当运行yacc后，会产生头文件，里面包含该标志的预定义，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YYSTYPE </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YYSTYPE int </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTEGER 258 </span></span><br><span class="line"><span class="keyword">extern</span> YYSTYPE yylval;</span><br></pre></td></tr></table></figure>

<p>lex使用该头文件中的标志定义。Yacc调用lex的yylex()来获得标志（token），与标志对应的值由lex放在变量yylval中。yylval的类型由YYSTYPE决定，YYSTYPE缺省类型是int。如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0-9]</span>+ &#123; </span><br><span class="line">yylval = atoi(yytext); </span><br><span class="line"><span class="keyword">return</span> INTEGER; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标志0-255被保留作为字符值，一般产生的token标志从258开始。如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[-+]</span> <span class="keyword">return</span> *yytext; <span class="comment">/* return operator */</span></span><br></pre></td></tr></table></figure>

<p>返回加号或减号。注意要把减号放在前面，避免被认作是范围符号。<br> 对于操作符，可以定义%left和%right：%left表示左相关（left-associative），%right表示右相关（right-associative）。<strong>可以定义多组%left或%right，在后面定义的组有更高的优先级</strong>。如：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">left</span></span> ‘+’ ‘-‘</span><br><span class="line"><span class="tag">%<span class="selector-tag">left</span></span> ‘*’ ‘/’</span><br></pre></td></tr></table></figure>

<p>上面定义的乘法和除法比加法和减法有更高的优先级。<br> 改变YYSTYPE的类型。如这样定义TTSTYPE：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%<span class="keyword">union</span></span><br><span class="line">&#123; </span><br><span class="line">     <span class="type">int</span> iValue; <span class="comment">/* integer value */</span> </span><br><span class="line">     <span class="type">char</span> sIndex; <span class="comment">/* symbol table index */</span> </span><br><span class="line">     nodeType *nPtr; <span class="comment">/* node pointer */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>则生成的头文件中的内容是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span></span><br><span class="line">&#123; </span><br><span class="line">     <span class="type">int</span> iValue;      <span class="comment">/* integer value */</span> </span><br><span class="line">     <span class="type">char</span> sIndex;    <span class="comment">/* symbol table index */</span> </span><br><span class="line">     nodeType *nPtr; <span class="comment">/* node pointer */</span> </span><br><span class="line">&#125; YYSTYPE; </span><br><span class="line"><span class="keyword">extern</span> YYSTYPE yylval;</span><br></pre></td></tr></table></figure>

<p>可以把标志（token）绑定到YYSTYPE的某个域。如：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%token &lt;iValue&gt; <span class="type">INTEGER</span> </span><br><span class="line"><span class="meta">%type</span> &lt;nPtr&gt; expr</span><br></pre></td></tr></table></figure>

<p>把expr绑定到nPtr，把INTEGER绑定到iValue。yacc处理时会做转换。如：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr: <span class="keyword">INTEGER</span> &#123; <span class="symbol">$</span><span class="symbol">$</span> = con(<span class="symbol">$</span><span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>转换结果为：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yylval.nPtr</span> = con(yyvsp[<span class="number">0</span>].iValue)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>其中yyvsp[0]是值栈（value stack）当前的头部。</p>
<p>定义一元减号符有更高的优先级的方法：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%left <span class="keyword">GE</span> <span class="keyword">LE</span> <span class="keyword">EQ</span> <span class="keyword">NE</span> <span class="string">&#x27;&gt;&#x27;</span> <span class="string">&#x27;&lt;&#x27;</span> </span><br><span class="line">%left <span class="string">&#x27;+&#x27;</span> <span class="string">&#x27;-&#x27;</span> </span><br><span class="line">%left <span class="string">&#x27;*&#x27;</span> </span><br><span class="line">%nonassoc UMINUS</span><br></pre></td></tr></table></figure>

<p>%nonassoc的含义是没有结合性。它一般与%prec结合使用表示该操作有同样的优先级。如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">expr</span>: <span class="string">&#x27;-&#x27;</span> <span class="built_in">expr</span> %prec UMINUS &#123; $$ = node(UMINUS, 1, <span class="variable">$2</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>表示该操作的优先级与UMINUS相同，在上面的定义中，UMINUS的优先级高于其他操作符，所以该操作的优先级也高于其他操作符计算。</p>
<h3 id="3-规则段"><a href="#3-规则段" class="headerlink" title="3. 规则段"></a>3. 规则段</h3><p>规则段由语法规则和包括C代码的动作组成。</p>
<p>规则中目标或非终端符放在左边，后跟一个冒号（：），然后是产生式的右边，之后是对应的动作（用{}包含）。如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%token INTEGER</span><br><span class="line">%%</span><br><span class="line">program: program <span class="built_in">expr</span> <span class="string">&#x27;\n&#x27;</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="variable">$2</span>); &#125; </span><br><span class="line">              ;</span><br><span class="line"><span class="built_in">expr</span>: INTEGER &#123; $$ = <span class="variable">$1</span>; &#125;  </span><br><span class="line">         | <span class="built_in">expr</span> <span class="string">&#x27;+&#x27;</span> <span class="built_in">expr</span> &#123; $$ = <span class="variable">$1</span> + <span class="variable">$3</span>; &#125; </span><br><span class="line">         | <span class="built_in">expr</span> <span class="string">&#x27;-&#x27;</span> <span class="built_in">expr</span> &#123; $$ = <span class="variable">$1</span> - <span class="variable">$3</span>; &#125; </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">int yyerror(char *s) </span><br><span class="line">&#123; </span><br><span class="line">     fprintf(stderr, <span class="string">&quot;%s\n&quot;</span>, s); </span><br><span class="line">     <span class="built_in">return</span> 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，1表示右边的第一个标记的值，2表示右边的第二个标记的值，依次类推。$$表示归约后的值。</p>
<h3 id="4-用户子例程段"><a href="#4-用户子例程段" class="headerlink" title="4. 用户子例程段"></a>4. 用户子例程段</h3><p>yacc 将用户子例程段的内容完全拷贝到C文件中，通常这部分包括从动作调用的例程。<br> 该部分是函数部分。当yacc解析出错时，会调用函数yyerror()，用户可自定义函数的实现。<br> main函数是调用yacc解析入口函数yyparse()。如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     <span class="built_in">yyparse</span>(); </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-动作"><a href="#5-动作" class="headerlink" title="5. 动作"></a>5. 动作</h3><p>动作 是yacc与在语法中规则相符时执行的C代码，动作一定是C复合语句。</p>
<p>动作有4种可能：</p>
<ul>
<li>移进：<br> 当Sj &#x3D; GOTO[Si，a]成立，则把Sj移入到状态栈，把a移入到文法符号栈。其中i，j表示状态号。</li>
<li>规约：<br> 当在栈顶形成句柄为β时，则用β归约为相应的非终结符A，即当文法中有 A–&gt;β的产生式，而β的长度为r（即|β| &#x3D; r）,则从状态栈和文法符号栈中自栈顶向下去掉r个符号，即栈指针SP减去r。并把A移入文法符号栈内，再把满足Sj &#x3D; GOTO[Si，A]的状态移进状态栈，其中Si为修改指针后的栈顶状态。</li>
<li>接受acc:<br> 当规约到文法符号栈只剩文法的开始符号S时，并且输入符号串已结束即当前输入符是‘#’，则为分析成功。</li>
<li>报错：<br> 当遇到状态栈顶为某一状态下出现不该遇到的文法符号时，则报错，说明输入串不是该文法能接受的句子。</li>
</ul>
<p>通过使用后面跟有数字的美元符号，动作可以查阅在规则中与符号有关的值,冒号后面跟的第一个符号是数字1，例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date：month  <span class="string">&#x27;/&#x27;</span>  day   <span class="string">&#x27;/&#x27;</span>  year  </span><br><span class="line">           &#123; <span class="keyword">printf</span> (<span class="string">&quot;date <span class="variable">%d</span>-<span class="variable">%d</span>-<span class="variable">%d</span>  found&quot;</span>,<span class="variable">$1</span>,<span class="variable">$3</span>,<span class="variable">$5</span>);&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>而名字，$$是指冒号左边符号的值，符号值可以有不同的C类型。</strong></p>
<h2 id="4-2-递归处理"><a href="#4-2-递归处理" class="headerlink" title="4.2 递归处理"></a>4.2 递归处理</h2><p>递归处理有左递归和右递归。<br> 左递归形式：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list: <span class="type">item</span> </span><br><span class="line">    | list <span class="string">&#x27;,&#x27;</span> <span class="type">item</span>;</span><br></pre></td></tr></table></figure>

<p>右递归形式：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list: <span class="keyword">item</span> </span><br><span class="line">     | <span class="keyword">item</span> <span class="string">&#x27;,&#x27;</span> list</span><br></pre></td></tr></table></figure>

<p>使用右递归时，所有的项都压入堆栈里，才开始规约；而使用左递归的话，同一时刻不会有超过三个项在堆栈里。</p>
<h3 id="1-歧义和冲突"><a href="#1-歧义和冲突" class="headerlink" title="1. 歧义和冲突"></a>1. 歧义和冲突</h3><p>由于语法有歧义或者包含冲突，yacc对于语法规范的翻译可能会失败。一些情况下，语法确实有歧义，也就是说对于一个单独的输入字符串有两种可能的分析而且yacc处理不了。</p>
<p>另外一些情况，语法并无歧义，但yacc使用的语法分析技术不足以分析这个语法。</p>
<ul>
<li><strong>移进&#x2F;归约冲突</strong><br> 当一个输入字符串有两种可能的分析时，而且其中一个分析完成一个规则（归约选项），而另一个却没有（移进选项）时，移进&#x2F;归约冲突便发生了。<br> 例如：</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%  </span><br><span class="line"><span class="symbol">e:</span> ‘<span class="built_in">X</span>’  </span><br><span class="line">     |e  <span class="string">&#x27;+&#x27;</span>   e  </span><br><span class="line">         <span class="comment">;  </span></span><br></pre></td></tr></table></figure>

<p>对于输入字符串“X+X+X” ，有两种可能的分析： “（X+X）+X”或者“X+(X+X)”，采用归约选项使得语法分析程序使用第一个分析，而采用移进选项则使用另一个。</p>
<ul>
<li><strong>归约&#x2F;归约冲突</strong><br> 当同样的标记可以完成两个不同的规则时，就会发生归约&#x2F;归约冲突。<br> 例如：</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%  </span><br><span class="line"><span class="symbol">prog:</span>    proga | progb  </span><br><span class="line"><span class="symbol">proga:</span>       <span class="string">&#x27;X&#x27;</span> <span class="comment">;  </span></span><br><span class="line"><span class="symbol">progb:</span>       <span class="string">&#x27;Y&#x27;</span> <span class="comment">;  </span></span><br></pre></td></tr></table></figure>

<p>一个“X”可能是proga，也可能是progb。</p>
<p>大多数归约&#x2F;归约冲突没这么明显，但是几乎在任何情况下它们在语法中都表现为错误。</p>
<ul>
<li><strong>If-Else 的冲突</strong><br> 当有两个IF一个ELSE时，该ELSE和哪个IF匹配是一个问题。有两种匹配方法：与第一个匹配和与第二匹配。<strong>现代程序语言都让ELSE与最近的IF匹配，这也是yacc的缺省行为。</strong><br> 虽然yacc行为正确，但为避免警告，可以给IF-ELSE语句比IF语句更高的优先级：</li>
</ul>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%nonassoc <span class="type">IFX</span> </span><br><span class="line">%nonassoc <span class="type">ELSE</span></span><br><span class="line"><span class="type">stmt</span>: <span class="type">IF</span> <span class="type">expr</span> <span class="type">stmt</span> %prec <span class="type">IFX</span> </span><br><span class="line">       | <span class="type">IF</span> <span class="type">expr</span> <span class="type">stmt</span> <span class="type">ELSE</span> <span class="type">stmt</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-特殊字符"><a href="#4-3-特殊字符" class="headerlink" title="4.3 特殊字符"></a>4.3 特殊字符</h2><p>由于yacc处理符号标记而不是文本，它的输入字符集比起lex来说就简单的多，下面列出了yacc所使用的特殊符号的列表：</p>
<blockquote>
<p><strong>%</strong><br> 具有两个%标记的行将yacc语法分成了几部分；<br> 定义段的所有声明都是以%开始，包括%{ %}    %union  %start   %token   %type   %left  %right  和 %nonassoc声明。</p>
<p>****<br> 反斜线符号是废弃的百分号同义词，在动作中，C语言字符串中有其通常作用。</p>
<p><strong>$</strong><br> 在动作中，美元符号引入一个值引用，举例来说，$3表示规则右端第3个符号的值。</p>
<p><strong>‘</strong><br> 文字标记由一个单引号结束，例如 ‘z’ 。</p>
<p><strong>&lt;&gt;</strong><br> 在一个动作的值引用中，可以不考虑尖括号包围起来的默认类型。</p>
<p><strong>“</strong><br> 有些yacc版本在文字标记中将单引号和双引号同等对待，这样使用根本不方便。</p>
<p><strong>{}</strong><br> 动作中C代码在大括号中。</p>
<p><strong>;</strong><br> 除了后面紧接着是以竖线开头的规则外，规则部分每个都是以分号结束。</p>
<p><strong>|</strong><br> 当连续两个规则具有相同的左端，第二个规则可用一个 | 代替符号和冒号。</p>
<p><strong>:</strong><br> 在每一条规则里，左端的每个符号后面都跟着一个冒号。</p>
<p><strong>_</strong><br> 符号可以包括和字母、数字以及句点在一起的下划线。</p>
<p><strong>.</strong><br> 符号可以包括与字母、数字、下划线一起的句点。</p>
<p><strong>&#x3D;</strong><br> 早期版本使用，现已不推荐。</p>
</blockquote>
<h2 id="4-3-Yacc-源程序的风格"><a href="#4-3-Yacc-源程序的风格" class="headerlink" title="4.3 Yacc 源程序的风格"></a>4.3 Yacc 源程序的风格</h2><p>建议按照如下风格来写：</p>
<ol>
<li>终端符名全部用大写字母，非终端符全部用小写字母；</li>
<li>把语法规则和语义动作放在不同的行；</li>
<li>把左部相同的规则写在一起，左部只写一次，而后面所有规则都写在竖线“|”之后；</li>
<li>把分号“；”放在规则最后，独占一行；</li>
<li>用制表符来对齐规则和动作。</li>
</ol>
<h2 id="4-4-一个简单的温度控制器"><a href="#4-4-一个简单的温度控制器" class="headerlink" title="4.4 一个简单的温度控制器"></a>4.4 一个简单的温度控制器</h2><p>假定我们有一个温度计，我们要用一种简单的语言来控制它。关于此的一个会话、如下：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">heat <span class="keyword">on</span></span><br><span class="line">Heater <span class="keyword">on</span>!</span><br><span class="line">heat <span class="keyword">off</span></span><br><span class="line">Header <span class="keyword">off</span>!</span><br><span class="line"><span class="keyword">target</span> temperature <span class="keyword">set</span>!</span><br></pre></td></tr></table></figure>

<p>我们需要识别的标识符为heat, on&#x2F;off(STATE), target, temperature, NUMBER。</p>
<p>LEX的tokenizer(example4)为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;y.tab.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+ <span class="keyword">return</span> NUMBER;</span><br><span class="line">heat <span class="keyword">return</span> TOKHEAT;</span><br><span class="line">on|off <span class="keyword">return</span> STATE;</span><br><span class="line">target <span class="keyword">return</span> TOKTARGET;</span><br><span class="line">temperature <span class="keyword">return</span> TOKTEMPERATURE;</span><br><span class="line">\n <span class="comment">/* ignore end of line */</span>;</span><br><span class="line">[ \t]+ <span class="comment">/* ignore whitespace */</span></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>


<p>有两个重点需要注意：<br>第一，我们包含了『y.tab.h』；<br>第二，我们不再打印输出了，我们返回标识符的名字。之所这样做是因为我们将这些返回传送给了YACC，而它对于我们屏幕上的输出并不感冒。 『y.tab.h』中定义了这些标识符。</p>
<p>但是y.tab.h从哪里来？它由YACC从我们编写的语法文件中生成，语法文件非常简单，如下：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">commands:</span> <span class="comment">/* empty */</span></span><br><span class="line">| commands command</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="params">command:</span> heat_switch | target_set ;</span><br><span class="line"></span><br><span class="line"><span class="params">heat_switch:</span></span><br><span class="line">TOKHEAT STATE</span><br><span class="line">&#123;</span><br><span class="line">	printf(<span class="string">&quot;<span class="char escape_">\t</span>Heat turned on or off<span class="char escape_">\n</span>&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="params">target_set:</span></span><br><span class="line">TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">&#123;</span><br><span class="line">	printf(<span class="string">&quot;<span class="char escape_">\t</span>Temperature set<span class="char escape_">\n</span>&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>第一部分，我们称之为根(root)。它告诉我们有一个『commands』，并且这些『commands』由单个的『command』组成。正如你所见到的那样，这是一个标准的递归结构，因为它又再次包含了『commands』。这意味着该程序可以一个个的递减一系列的命令。参见『LEX和YACC内部工作原理』一章，阅读更多的递归细节。</p>
<p>第二个规则定义了『command』的内容。我们只假定两种命令。</p>
<p>一个heat_switch由HEAT标识符组成，它后面跟着一个状态，该状态在LEX中定义，为『on』或『off』。</p>
<p>target_set稍微有点复杂，它由TARGET标识符、TEMPERATURE以及一个数字组成。</p>
<p>前面的那个例子只有YACC文件的语法部分，起始在YACC文件中还有其它内容，完整的YACC文件如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在lex.yy.c里定义，会被yyparse()调用。在此声明消除编译和链接错误。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">yylex</span><span class="params">(<span class="type">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此声明，消除yacc生成代码时的告警</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">yyparse</span><span class="params">(<span class="type">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yywrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数在y.tab.c里会被调用，需要在此定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[error] %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">yyparse</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER TOKHEAT STATE TOKTARGET TOKTEMPERATURE</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">commands: <span class="comment">/* empty */</span></span><br><span class="line">| commands command</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">command: heat_switch | target_set ;</span><br><span class="line"></span><br><span class="line">heat_switch:</span><br><span class="line">TOKHEAT STATE</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\tHeat turned on or off\n&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target_set:</span><br><span class="line">TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\tTemperature set\n&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>


<p>函数yyerror()在YACC发现一个错误的时候被调用，我们只是简单的输出错误信息，但其实还可以做一些更漂亮的事情，参见文档尾的『进阶阅读』部分。</p>
<p>yywrap()函数用于不断的从一个文件中读取数据，当遇到EOF时，你可以再输入一个文件，然后返回0，你也可以使得其返回1，暗示着输入结束。更多细节，参见『YACC和LEX内部如何工作的？』一章。</p>
<p>接着，这里有一个main()函数，它基本什么也不做，只是调用一些函数。</p>
<p>最后一行简单的定义了我将使用的标识符，如果调用YACC时，使用『-d』选项，那么它们会输出到y.tab.h中。</p>
<p>编译并运行恒温控制器：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lex</span> example4.<span class="keyword">l</span></span><br><span class="line">yacc –d example4.<span class="keyword">y</span></span><br><span class="line"><span class="keyword">cc</span> <span class="keyword">lex</span>.yy.<span class="keyword">c</span> <span class="keyword">y</span>.<span class="keyword">tab</span>.<span class="keyword">c</span> –<span class="keyword">o</span> example4</span><br></pre></td></tr></table></figure>

<p>在此，情况有所改变，我们现在调用YACC来编译我们的程序，它创建了y.tab.c和y.tab.h. 我接着再调用LEX。 编译时，我们去除了『-ll』编译选项，因为此时我们有了自己的main()函数，并不需要libl来提供。</p>
<p>注意：如果在编译过程中报错说找不到『yylval』，那么在example4.l的#include &lt;y.tab.h&gt;下面加上：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> YYSTYPE yylval；</span><br></pre></td></tr></table></figure>

<p>具体细节在『LEX和YACC内部工作原理』中解说。</p>
<p>一个简单的会话：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./example4</span><br><span class="line">heat on</span><br><span class="line">Heat turned on or off</span><br><span class="line">heat off</span><br><span class="line">Heat turned on or off</span><br><span class="line">target temperature 10</span><br><span class="line">Temperature set</span><br><span class="line">target humidity 20</span><br><span class="line"><span class="keyword">error: </span>parse error</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="4-5-扩展恒温器，使得其可以接受参数"><a href="#4-5-扩展恒温器，使得其可以接受参数" class="headerlink" title="4.5 扩展恒温器，使得其可以接受参数"></a>4.5 扩展恒温器，使得其可以接受参数</h2><p>我们已经可以正确的解析温度计命令了，并且能对一些错误做标记。但也许一些狡猾的人会猜疑说，该解析器并不知道你应该做什么，也没有处理一些你输入的数值。</p>
<p>让我们来添加能读取新的温度参数的功能。为达到此目的，我们得知道LEX中的NUMBER匹配要转化成一个数值，然后才能为YACC所接收.</p>
<p>每当LEX匹配到了一个目标字串，它就将该匹配文本赋值给『yytext』，YACC则依次在『yylval』中来查找一个值，在example5中，我们可以得到一个明晰的方案：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;y.tab.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+ yylval = <span class="built_in">atoi</span>(yytext); <span class="keyword">return</span> NUMBER;</span><br><span class="line">heat <span class="keyword">return</span> TOKHEAT;</span><br><span class="line">on|off yylval = !<span class="built_in">strcmp</span>(yytext, <span class="string">&quot;on&quot;</span>); <span class="keyword">return</span> STATE;</span><br><span class="line">target <span class="keyword">return</span> TOKTARGET;</span><br><span class="line">temperature <span class="keyword">return</span> TOKTEMPERATURE;</span><br><span class="line">\n <span class="comment">/* ignore end of line */</span></span><br><span class="line">[ \t]+ <span class="comment">/* ignore whitespace */</span></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>


<p>如你所见，我们在yytext中用了atoi()，并将结果存储在yylval中，使得YACC可以『看见』它。 同理，我们再处理STATE匹配，将其与『on』比较，若想等，则将yylval设置为1。</p>
<p>接下来，我们就得考察YACC如何来应对。我们来看看新的temperature target规则设置：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_set:</span><br><span class="line">TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;\tTemperature set to <span class="variable">%d</span>\n&quot;</span>, <span class="variable">$3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为得到规则中第三部分的值(NUMBER)，我们用『$3』来表示，每次yylex()返回时，yylval的值便依附到了终结符上，其值可以通过『$-常数』来获取。</p>
<p>为更进一步加深理解，我们来看『heat_switch』规则：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">heat_switch:</span></span><br><span class="line">TOKHEAT STATE</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ($<span class="number">2</span>)</span><br><span class="line">        printf(<span class="string">&quot;<span class="char escape_">\t</span>Heat turned on<span class="char escape_">\n</span>&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        printf(<span class="string">&quot;<span class="char escape_">\t</span>Heat turned off<span class="char escape_">\n</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果现在运行example5，它将输出你所输入的数据。</p>
<h2 id="4-6-解析一个配置文件"><a href="#4-6-解析一个配置文件" class="headerlink" title="4.6 解析一个配置文件"></a>4.6 解析一个配置文件</h2><p>让我们再次回顾先前提到的那个配置文件：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">&quot;./www&quot;</span> &#123;</span><br><span class="line">	type hint<span class="comment">;</span></span><br><span class="line">	name foo<span class="comment">;</span></span><br><span class="line">	hello <span class="string">&quot;/hello/world&quot;</span><span class="comment">;</span></span><br><span class="line">	file <span class="string">&quot;/etc/bind/db.root&quot;</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>之前我们已经将LEX文件写好了，接下来只需要编写YACC语法文件，并且对词法分析器做一些修改，使得其可以返回一些值给YACC。<br>example6中的词法分析器如下：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#<span class="keyword">include</span> &lt;stdio.<span class="keyword">h</span>&gt;</span><br><span class="line">#define YYSTYPE <span class="keyword">char</span> *</span><br><span class="line">extern YYSTYPE yylval; <span class="comment">// 必须放在#include &quot;y.tab.h&quot;前面</span></span><br><span class="line">#<span class="keyword">include</span> <span class="string">&quot;y.tab.h&quot;</span></span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line">zone <span class="keyword">return</span> ZONETOK;</span><br><span class="line"><span class="keyword">file</span> <span class="keyword">return</span> FILETOK;</span><br><span class="line">[a-zA-Z][a-zA-Z0-9]* yylval = strdup(yytext); <span class="keyword">return</span> WORD;</span><br><span class="line">[a-zA-Z0-9\/.-]+ yylval = strdup(yytext); <span class="keyword">return</span> FILENAME;</span><br><span class="line">\&quot; <span class="keyword">return</span> QUOTE;</span><br><span class="line">\&#123; <span class="keyword">return</span> OBRACE;</span><br><span class="line">\&#125; <span class="keyword">return</span> EBRACE;</span><br><span class="line">; <span class="keyword">return</span> SEMICOLON;</span><br><span class="line">[ \t]+ <span class="comment">/* ignore whitespace */</span>;</span><br><span class="line">\<span class="keyword">n</span> <span class="comment">/* ignore EOL */</span>;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure>


<p>细心的话，你会发现yylval已经改变了！我们不再认为它是一个整数，而是假定为一个char*类型数据。为保持简单性，我们调用strdup并因此耗费了很多内存。但这并不影响你解析这个文件。</p>
<p>我们需要保存字符串的值，在此我们处理的都是一些命名，文件名以及区域命。在下一章，我们将解说如何对付一些复杂类型的数据。</p>
<p>为通知YACC关于yylval的新类型，我们在YACC的语法文件中添加一行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> YYSTYPE char *</span></span><br></pre></td></tr></table></figure>

<p>下面是完整的YACC文件，语法比较复杂，建议结合代码画AST树来帮助理解（原文这里的代码有不少问题，下面是修正后的代码，对语法也简化了一点点）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YYSTYPE char *</span></span><br><span class="line"><span class="keyword">extern</span> YYSTYPE yylval;</span><br><span class="line"><span class="comment">//int yydebug = 1; // debug</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">yylex</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">yyparse</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">yywrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">yyerror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[error] %s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">yyparse</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token SEMICOLON ZONETOK OBRACE EBRACE QUOTE FILENAME WORD FILETOK</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">commands:</span><br><span class="line">| commands command SEMICOLON</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">command:</span><br><span class="line">zone_set</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">zone_set:</span><br><span class="line">ZONETOK quotedname zonecontent</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Complete zone for &#x27;%s&#x27; found\n&quot;</span>, $<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zonecontent:</span><br><span class="line">OBRACE zonestatements EBRACE</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">quotedname:</span><br><span class="line">QUOTE FILENAME QUOTE</span><br><span class="line">&#123;</span><br><span class="line">	$$ = $<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zonestatements:</span><br><span class="line">| zonestatements zonestatement SEMICOLON</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">zonestatement:</span><br><span class="line">statements | FILETOK quotedname</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;A zonefile name &#x27;%s&#x27; was encountered\n&quot;</span>, $<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">statements:</span><br><span class="line">| WORD statement</span><br><span class="line">&#123;</span><br><span class="line">	$$ = $<span class="number">2</span>; <span class="comment">// seems unnecessary</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;statements, key: %s, value: %s\n&quot;</span>, $<span class="number">1</span>, $<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">statement:</span><br><span class="line">WORD | quotedname</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>


<p>我们执行example6的输出文件：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将配置文件的内容保存到<span class="keyword">sample</span>.<span class="keyword">conf</span>文件中，方便测试</span><br><span class="line">$ <span class="keyword">cat</span> <span class="keyword">sample</span>.<span class="keyword">conf</span> | ./example6</span><br></pre></td></tr></table></figure>


<p>输出为：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">statements</span>, <span class="built_in">key</span>: <span class="built_in">type</span>, value: hint</span><br><span class="line"><span class="built_in">statements</span>, <span class="built_in">key</span>: name, value: foo</span><br><span class="line"><span class="built_in">statements</span>, <span class="built_in">key</span>: hello, value: /hello/world</span><br><span class="line"> A zonefile name &#x27;/etc/bind/db.root&#x27; was encountered</span><br><span class="line">Complete zone <span class="keyword">for</span> &#x27;./www&#x27; found</span><br></pre></td></tr></table></figure>

<h1 id="五、生成C-代码的解析器"><a href="#五、生成C-代码的解析器" class="headerlink" title="五、生成C++代码的解析器"></a>五、生成C++代码的解析器</h1><p>虽然LEX和YACC的历史要早于C++，但是还是可以用它们来生成一个C++解析器。但我们用LEX来生成C++的词法分析器，YACC并不知道如何直接来处理这些，所以我们不打算这么做。</p>
<p>我认为比较好的做法是，要做一个C++解析器，就需要LEX生成一个C文件，并且让YACC来生成C++代码。但当你这么做的时候，在这个过程中你将会遇到问题，因为C++代码默认情况下并不能找到C的函数，除非你将那些函数定义为extern “C”。</p>
<p>为达此目的，我们在YACC代码中编写一个C开头：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C”</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">yyparse</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">yylex</span>(<span class="params"><span class="keyword">void</span></span>)</span>;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">yywrap</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想声明并改变yydebug函数，你得这样做：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">int</span> yydebug;</span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    yydebug = <span class="number">1</span>;</span><br><span class="line">    yyparse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为C++中的一个关于定义的规则，即不允许yydebug的多处定义。</p>
<p>你还可能发现，你需要在你的LEX文件中重复#define YYSTYPE，这是由于C++中严格的类型检查(机制)造成的。</p>
<p>按照如下方式来编译：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Makefile</span></span><br><span class="line"><span class="symbol">example_cpp:</span></span><br><span class="line">	lex -o <span class="variable">$@</span>.yy.c <span class="variable">$@</span>.lex</span><br><span class="line">	cc -c <span class="variable">$@</span>.yy.c -o <span class="variable">$@</span>.yy.o</span><br><span class="line">	yacc -dtv <span class="variable">$@</span>.yy -o <span class="variable">$@</span>.cpp</span><br><span class="line">	g++ <span class="variable">$@</span>.yy.o <span class="variable">$@</span>.cpp -o <span class="variable">$@</span>.<span class="keyword">out</span></span><br></pre></td></tr></table></figure>

<p>由于-o选项的存在，y.tab.h现在变成example_cpp.hpp，记住这点。</p>
<p>总结： 不要自寻烦恼的在C++中编译你的词法分析器，让它呆在C的领地里。在C++中编写解析器时，(也得)确保向编译器解释清楚，即你的C函数都有一个extern “C”声明。</p>
<h1 id="六、Lex和YACC内部工作原理"><a href="#六、Lex和YACC内部工作原理" class="headerlink" title="六、Lex和YACC内部工作原理"></a>六、Lex和YACC内部工作原理</h1><p>在YACC文件中，你定义了你自己的main()函数，它在某个点上调用了yyparse()。YACC会创建你的yyparse()函数，并在y.tab.c中结束该函数。</p>
<p>yyparse()函数读取一个『标识符&#x2F;值对』(token&#x2F;value pairs)流，这些流需要事先就提供，这些流可以是你自己手写的代码提供的，也可以是LEX生成的。在我们的示例中，我们把这个工作丢给了LEX。</p>
<p>LEX生成的yylex()函数从文件参数FILE *file中读取字符(文件名为yyin)。如果不设置成yyin，则默认为标准输入，它会输出到yyout中，如果不加设置，就是stdout。你可以在yywrap()函数中修改位于文件尾的yyin.yywrap()函数。这些修改使得你可以打开另一些文件，并继续解析。</p>
<p>如果是这种情况，那么就让yywrap()返回0，如果你想在该文件上结束解析，就让它返回1。</p>
<p>每次yylex()调用都会返回一个整数值，该值代表了一个标识符类型(token type)。它告诉YACC，已经读取了这种标识符。该标识符可以有一个值，它应该存放在yylval变量中。</p>
<p>yylval的默认类型为int，但是你可以修改其类型，通过在YACC文件中#define YYSTYPE。</p>
<p>词法分析器需要能够访问yylval，为达到此效果，(yylval)必须在词法分析器(lexer)中被声明为一个外部变量(extern variable)。原来的YACC忽略了这点，并没有为你干这项工作，所以，你必须添加以下代码到你的词法分析器中，就在#include &lt;y.tab.h&gt;下面：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern YYSTYPE yylval<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>当今多数人使用的Bison已经为你把这事自动做好了。</p>
<h2 id="6-1-标识符的值-token-values"><a href="#6-1-标识符的值-token-values" class="headerlink" title="6.1 标识符的值(token values)"></a>6.1 标识符的值(token values)</h2><p>在前面我已经说过，yylex()需要返回它遇到了一个什么标识符类型，并将其值存储在yylval中。当这些标识符在%token命令中定义时，它们就被赋予了一些数字ID，从256开始。</p>
<p>由于这个事实，(我们)可以将所有的ascii字符当作标识符。假定你要写一个计算器，到现在为止，我们可能已经这样写了其词法分析器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>-<span class="number">9</span>]+ yylval = atoi(yytext); <span class="keyword">return</span> NUMBER;</span><br><span class="line">[ \n]+ <span class="comment">/* eat whitespace */</span></span><br><span class="line">- <span class="keyword">return</span> MINUS;</span><br><span class="line">\* <span class="keyword">return</span> MULT;</span><br><span class="line">\+ <span class="keyword">return</span> PLUS;</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>YACC文件可能是这样：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span> : <span class="built_in">NUMBER</span></span><br><span class="line">| <span class="built_in">exp</span> PLUS <span class="built_in">exp</span></span><br><span class="line">| <span class="built_in">exp</span> MINUS <span class="built_in">exp</span></span><br><span class="line">| <span class="built_in">exp</span> MULT <span class="built_in">exp</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>没有必要弄这么复杂。用字符作为速记法来作为标识符的数字ID，我们可以这样来重写我们的词法分析器：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[0-9]</span>+ yylval = atoi(yytext); <span class="keyword">return</span> NUMBER;</span><br><span class="line"><span class="string">[ \n]</span>+ <span class="comment">/* eat whitespace */</span></span><br><span class="line">. <span class="keyword">return</span> (<span class="built_in">int</span>) yytext[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>最后一行匹配任何的单个字符，否则就是不匹配字符。</p>
<p>而YACC的语法文件则是这样:</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span> : <span class="built_in">NUMBER</span></span><br><span class="line">| <span class="built_in">exp</span> <span class="string">&#x27;+&#x27;</span> <span class="built_in">exp</span></span><br><span class="line">| <span class="built_in">exp</span> <span class="string">&#x27;-&#x27;</span> <span class="built_in">exp</span></span><br><span class="line">| <span class="built_in">exp</span> <span class="string">&#x27;*&#x27;</span> <span class="built_in">exp</span></span><br></pre></td></tr></table></figure>

<p>这样更加简短而直观，你就不必在文件头用%token来定义那些ascii字符了。<br>另一方面，这样构造还有一些好处，它可以匹配所有丢给它的东西，而避免了将那些不匹配的输入输出到标准输出的默认行为。如果用户在当前计算器上输入一个’^’字符，将会导致一个解析错误，而不是将其输出到标准输出中。</p>
<h2 id="6-2-递归：’right-is-wrong’"><a href="#6-2-递归：’right-is-wrong’" class="headerlink" title="6.2 递归：’right is wrong’"></a>6.2 递归：’right is wrong’</h2><p>递归是YACC一个极其重要的特性。没有递归的话，你就确定一个文件是由一系列独立的命令组成还是由语句组成。由于YACC自身的特性，它只对第一个规则或那个你将其设计为『起始规则』的规则感兴趣。起始规则用’%start’符号标记。</p>
<p>YACC中的递归以两种形式出现，左递归和右递归。左递归是你应该经常使用的，它们看起来如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands ： <span class="comment">/* empty */</span></span><br><span class="line">| commands <span class="keyword">command</span></span><br></pre></td></tr></table></figure>


<p>这是在说，一个command要么为空，要么它包含了更多的commands，后面再跟一个command。YACC的这种工作方式意味着它现在可以轻易的剔除单个的command群并一步步简化(处理)。<br>拿上面的例子和下面的右递归做比较：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands : <span class="comment">/* empty */</span></span><br><span class="line">| <span class="keyword">command</span> <span class="title">commands</span></span><br></pre></td></tr></table></figure>

<p>但是这样做开销有点大，如果(commands)是%start规则(即起始规则)，那么YACC会将所有的commands保存在你的栈数据中(file on the stack)，这将耗费大量内存。所以，在解析长的语句时，务必使用左递归，例如整个文件。但有时难以避免右递归，不过，如果你的语句并不太长，你就没有必要越轨使用左递归。</p>
<p>如果你有一些东西来终结(因此而分割)你的commands，右递归就非常适合了，但开销还是有点大:</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands : <span class="comment">/* empty */</span></span><br><span class="line">| <span class="keyword">command</span> <span class="title">SEMICOLON</span> <span class="title">commands</span></span><br></pre></td></tr></table></figure>

<p>正确的做法是使用左递归(这也不是我发明的)：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands : <span class="comment">/* empty */</span></span><br><span class="line">| commands <span class="keyword">command</span> <span class="title">SEMICOLON</span></span><br></pre></td></tr></table></figure>

<p>本文档的早期版本错误的使用了右递归。Markus Triska友好的提示我们这点(错误)。</p>
<h2 id="6-3-高级yylval-union"><a href="#6-3-高级yylval-union" class="headerlink" title="6.3 高级yylval: %union"></a>6.3 高级yylval: %union</h2><p>现在，我们需要定义yylval的类型。但是这并不一直恰如其当。我们可能会多次这样做，因为需要处理多种数据类型。回到我们假定的那个恒温器，可能你想选择控制一个加热器，例如：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heater mainbuilding</span><br><span class="line">Selected ‘mainbuilding’ heater</span><br><span class="line"><span class="keyword">Target</span> temperature <span class="number">23</span></span><br><span class="line">‘mainbuilding’ heater <span class="keyword">target</span> temperature now <span class="number">23</span></span><br></pre></td></tr></table></figure>

<p>这样的话，就要求yylval是一个union，它可以存储字符串，也可以存储整数，但并不是同时存储。<br>回忆之前我们讲过，我们提前通知YACC哪种yylval类型会要处理是通过定义YYSTYPE来实现。同样，我们可以定义YYSTYPE为一个union，YACC中有一种简便的方法来实现，即%union语句。</p>
<p>在example4基础上，我编写example7的YACC语法：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">token</span></span> TOKHEATER TOKHEAT TOKTARGET TOKTEMERATURE</span><br><span class="line"><span class="tag">%<span class="selector-tag">union</span></span></span><br><span class="line">&#123;</span><br><span class="line">int number;</span><br><span class="line">char *string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">%<span class="selector-tag">token</span></span> &lt;number&gt; STATE</span><br><span class="line"><span class="tag">%<span class="selector-tag">token</span></span> &lt;number&gt; NUMBER</span><br><span class="line"><span class="tag">%<span class="selector-tag">token</span></span> &lt;string&gt; WORD</span><br></pre></td></tr></table></figure>

<p>我们定义了union，它只包含一个整数和一个字符串。接着使用了一个扩展的%token语法，我们向YACC解释了应该获取union哪个部分的标识符。<br>在本例中，我们让STATE标识符用一个整数(来表示)，这跟之前一样。NUMBER同理，我们之前用来读取温度。<br>但是WORD有所改变，它声明为需要一个字符串。<br>词法解析器文件有所改变：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;y.tab.h&quot;</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+ yylval.number=<span class="built_in">atoi</span>(yytext); <span class="keyword">return</span> NUMBER;</span><br><span class="line">heater <span class="keyword">return</span> TOKHEATER;</span><br><span class="line">heat <span class="keyword">return</span> TOKHEAT;</span><br><span class="line">on|off yylval.number =! <span class="built_in">strcmp</span>(yytext,<span class="string">&quot;on&quot;</span>); returnSTATE;</span><br><span class="line">target <span class="keyword">return</span> TOKTARGET;</span><br><span class="line">temperature <span class="keyword">return</span> TOKTEMPERATURE;</span><br><span class="line">[a-z0<span class="number">-9</span>]+ yylval.string = <span class="built_in">strdup</span>(yytext); <span class="keyword">return</span> WORD;</span><br><span class="line">\n <span class="comment">/* ignore end of line */</span></span><br><span class="line">[ \t]+ <span class="comment">/* ignore whitespace */</span></span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure>

<p>正如你所见，我们不再直接访问yylval，我们添加了一个后缀来说明我们要访问那个部分。我们不再需要在YACC语法文件中来干这个工作，YACC在这里耍了下魔法：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heater_select:</span><br><span class="line">TOKHEATER WORD</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">&quot;\tSelected heater &#x27;<span class="variable">%s</span>&#x27;\n&quot;</span>, <span class="variable">$2</span>);</span><br><span class="line">    heater = <span class="variable">$2</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于上面的%token声明，YACC自动选择了union中的’string’成员。注意这里$2中存储的一份拷贝，在后面它会告诉用户发送命令到哪个heater（需要在C文件头定义char *heater）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target_set:</span><br><span class="line">TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\tHeater &#x27;%s&#x27; temperature set to %d\n&quot;</span>, </span><br><span class="line">            heater, $<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="6-4-自定义YY-INPUT指向字符串而非标准输入"><a href="#6-4-自定义YY-INPUT指向字符串而非标准输入" class="headerlink" title="6.4 自定义YY_INPUT指向字符串而非标准输入"></a>6.4 自定义YY_INPUT指向字符串而非标准输入</h2><p>很多情况下，我们不希望从标准输入解析，而希望解析给定的字符串。实现方法是自定义实现YY_INPUT，具体做法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LEX 文件 */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">lex_custom_input</span><span class="params">(<span class="type">char</span>* buf, <span class="type">unsigned</span> <span class="type">long</span> *num_read,<span class="type">int</span> max_read)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YY_INPUT(b,r,s) lex_custom_input(b,&amp;r,s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* C 文件 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_read_offset;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_TEXT_LEN 1024</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> s_text_buf[MAX_TEXT_LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lex_custom_input</span><span class="params">(<span class="type">char</span>* buf, <span class="type">unsigned</span> <span class="type">long</span> *num_read,<span class="type">int</span> max_read)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num_to_read = max_read;</span><br><span class="line">    <span class="type">int</span> remain = <span class="built_in">strlen</span>(s_text_buf) - g_read_offset;</span><br><span class="line"></span><br><span class="line">    num_to_read = num_to_read&gt;remain ? reamin:num_to_read;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, s_text_buf + g_read_offset, num_to_read);</span><br><span class="line"></span><br><span class="line">    *num_read = num_to_read;</span><br><span class="line">    g_read_offset += num_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、调试"><a href="#七、调试" class="headerlink" title="七、调试"></a>七、调试</h1><p>YACC中有许多调试反馈信息。这些调试信息的代价有点高，所以你需要提供一些开关来打开它。</p>
<p>当调试你的语法时，在YACC命令行中添加—debug和—verbose选项，在你的C文件头中添加以下语句：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int yydebug <span class="operator">=</span> <span class="number">1</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>


<p>这将生成一个y.output文件，其中说明了所创建的那个状态机。<br>当你运行那个生成的二进制文件，它将输出很多运行时信息。里面包含当前所运行的状态机以及读取到的一些标识符。</p>
<p>Peter Jinks写了一篇关于调试的文章，他在其中讲述了一些常见得错误以及如何修正这些错误。</p>
<h2 id="7-1-状态机"><a href="#7-1-状态机" class="headerlink" title="7.1 状态机"></a>7.1 状态机</h2><p>YACC解析器在内部运行的是一个『状态机』，该状态机可以有多种转台。接着有多个规则来管制状态间的相互转化。任何内容都是从『root』规则开始。</p>
<p>在example7的y.output文件中：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">state</span> <span class="number">0</span></span><br><span class="line">ZPONETOK , and go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">1</span></span><br><span class="line"><span class="variable">$default</span> reduce using <span class="keyword">rule</span> <span class="number">1</span> (commands)</span><br><span class="line">commands go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">29</span></span><br><span class="line">command go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">2</span></span><br><span class="line">zone_set go <span class="keyword">to</span> satte <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>默认情形下，这个状态机从『commands』规则开始递减演化，这也是我们之前的那个递归规则，它定义了『commands』并从单个的『command』进行构造，后面跟着一个分号，然后可能再跟着更多的『commands』。</p>
<p>这个状态机不断递减演化，直到它遇到某些它能理解的东西，在本例中，为一个ZONETOK，也即单词『zone』。然后转化到状态1，在此，进一步处理一个zone command:</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">state</span> <span class="number">1</span></span><br><span class="line">zone_set -&gt; ZONETOK .quotedname zonecontent (<span class="keyword">rule</span> <span class="number">4</span>)</span><br><span class="line">QUOTE , and go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">4</span></span><br><span class="line">Quotedname go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>第一行中有一个『.』，它用来说明我们所处的位置：即刚刚识别到了一个ZONETOK，目前正在寻找一个『quotedname』。显然，一个『quotedname』会以QUOTE开始，它将我们转化到状态4。<br>为进一步跟踪，用在『调试』章节中提到的标志来编译example7。</p>
<h2 id="7-2-冲突：『shift-reduce』以及『reduce-reduce』"><a href="#7-2-冲突：『shift-reduce』以及『reduce-reduce』" class="headerlink" title="7.2 冲突：『shift&#x2F;reduce』以及『reduce&#x2F;reduce』"></a>7.2 冲突：『shift&#x2F;reduce』以及『reduce&#x2F;reduce』</h2><p>一旦YACC警告你出现了冲突，那么你的麻烦来了。要解决这些问题显得是一种技巧形式，它会教会很多关于你的语言的东西。比你想知道的要多的多的内容。</p>
<p>问题萦绕于如何来翻译一系列标识符。假定我们定义了一种语言，它需要接受一下两种命令：</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> heater <span class="symbol">all</span></span><br><span class="line"><span class="keyword">delete</span> heater number1</span><br></pre></td></tr></table></figure>

<p>为达到此目的，我们的语法为：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">delete_heaters :</span><br><span class="line">TOKDELETE TOKHEATER mode</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Deleteheaters</span>($<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">mode : WORD</span><br><span class="line">delete_a_heater:</span><br><span class="line">TOKDELETE TOKHEATER WORD</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">delete</span>($<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>也许你已经嗅到了麻烦的味道。状态机从读取单词『word』开始，接着它根据下一个标识符觉得转换到何种状态。接下来的标识符可以是『mode』，它指定了如何来删除heater，或者是将要删除的heater。<br>然而这里的麻烦是，对于这两个命令，下一个标识符都将是一个WORD。YACC因此也无法决定下一步该干嘛。这回导致一个『reduce&#x2F;reduce』警告，而下一个警告就是『delete_a_heater』节点在状态转化图中永远也不能达到。<br>这种情况的冲突容易解决(例如，重命名第一个命令为『delete all heater』，或者将『all』作为一个分开的标识符)，但有时，(要解决冲突)却非常困难。 通过『–verbose』参数生成的y.output文件可以提供给你极大的帮助。</p>
<h1 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h1><p>GNU YACC(Bison)有一个非常棒的.info文件，在其中很好的记录了YACC的语法。其中只提到了一次LEX，然而它还是很棒的。你可以用Emacs中那个非常好的『pinfo』工具阅读.info文件。同时，在Bison的主页上可以获得它：<a href="http://www.gnu.org/software/bison/manual/bison.html">Bison手册</a>。<br>FLEX有一个不错的主页。如果你粗略了解了FLEX所作所为，那将是非常有益的。<a href="http://www.gnu.org/manual/flex/">FLEX的手册</a>也可以联机获取。<br>在这些关于YACC和LEX的介绍之后，你可能觉得你想需要更多的信息。下面的书籍也相当不错：</p>
<ul>
<li>《Bison—The Yacc-Compitible Parser Generator》——Charles Donnelly &amp;&amp; Richard Stallman.</li>
<li>《Lex &amp; Yacc》——John R. Levine, Tony Mason ,Doug Brown.</li>
<li>《Compilers: Principles, Techniques, and Tools》——By Alfred V.Aho,Ravi</li>
</ul>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2023/06/100639.html" class="pre-post btn btn-default" title='Wine完全使用指南'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Wine完全使用指南</span>
        </a>
    
    
        <a href="/archives/2023/05/100648.html" class="next-post btn btn-default" title='C/C++宏 详解'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">C/C++宏 详解</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>


    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E4%BB%8B"><span class="toc-text">一、简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Lex-YACC%E8%83%BD%E4%B8%BA%E4%BD%A0%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">二、Lex &amp; YACC能为你做什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AE%80%E5%8D%95%E8%AE%A1%E7%AE%97%E5%99%A8"><span class="toc-text">2.1 简单计算器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F-cal-l"><span class="toc-text">1. 词法分析程序 cal.l</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F-cal-y"><span class="toc-text">2. 语法分析程序 cal.y</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">3. 编译运行过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Lex"><span class="toc-text">三、Lex</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Lex-%E7%9A%84%E7%BB%93%E6%9E%84%E8%A7%84%E8%8C%83"><span class="toc-text">3.1 Lex 的结构规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E6%AE%B5"><span class="toc-text">1. 定义段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A7%84%E5%88%99%E6%AE%B5"><span class="toc-text">2. 规则段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%94%A8%E6%88%B7%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%AE%B5"><span class="toc-text">3. 用户子程序段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Lex%E7%9A%84%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">3.2 Lex的常规表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8-Lex-%E5%AE%9A%E4%B9%89%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">1. 用 Lex 定义常规表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-text">元字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%BE%E4%BE%8B"><span class="toc-text">2. 常规表达式举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%87%E8%AE%B0%E5%A3%B0%E6%98%8E%E4%B8%BE%E4%BE%8B"><span class="toc-text">3. 标记声明举例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.3 简单示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.4 匹配中的正则表达式示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E5%A4%8D%E6%9D%82%E4%B8%80%E7%82%B9%E7%9A%84%E7%B1%BBC%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.5 复杂一点的类C语法示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Lex%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0"><span class="toc-text">3. 6 Lex深入学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Definition-Section-%E5%AE%9A%E4%B9%89%E6%AE%B5"><span class="toc-text">1. Definition Section(定义段)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Rules-section%EF%BC%88%E8%A7%84%E5%88%99%E6%AE%B5%EF%BC%89"><span class="toc-text">2. Rules section（规则段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-C-code-section-%EF%BC%88%E7%94%A8%E6%88%B7%E5%AD%90%E7%A8%8B%E5%BA%8F%E6%AE%B5%EF%BC%89"><span class="toc-text">3. C code section （用户子程序段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C"><span class="toc-text">4.编译运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%AE%8F"><span class="toc-text">5. 常用的全局变量和宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9D%A1%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">6. 条件模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%9D%A1%E4%BB%B6%E8%8C%83%E5%9B%B4"><span class="toc-text">开始条件范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%B5%8C%E5%A5%97"><span class="toc-text">条件嵌套</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A4%9A%E8%BE%93%E5%85%A5%E7%BC%93%E5%AD%98%E5%8C%BA"><span class="toc-text">7. 多输入缓存区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81YACC"><span class="toc-text">四、YACC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-yacc%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">4.1 yacc语法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AC%A6%E5%8F%B7"><span class="toc-text">1. 符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89%E6%AE%B5"><span class="toc-text">2. 定义段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%A7%84%E5%88%99%E6%AE%B5"><span class="toc-text">3. 规则段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%A8%E6%88%B7%E5%AD%90%E4%BE%8B%E7%A8%8B%E6%AE%B5"><span class="toc-text">4. 用户子例程段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8A%A8%E4%BD%9C"><span class="toc-text">5. 动作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E9%80%92%E5%BD%92%E5%A4%84%E7%90%86"><span class="toc-text">4.2 递归处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%AD%A7%E4%B9%89%E5%92%8C%E5%86%B2%E7%AA%81"><span class="toc-text">1. 歧义和冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-text">4.3 特殊字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Yacc-%E6%BA%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A3%8E%E6%A0%BC"><span class="toc-text">4.3 Yacc 源程序的风格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B8%A9%E5%BA%A6%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-text">4.4 一个简单的温度控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%89%A9%E5%B1%95%E6%81%92%E6%B8%A9%E5%99%A8%EF%BC%8C%E4%BD%BF%E5%BE%97%E5%85%B6%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E5%8F%82%E6%95%B0"><span class="toc-text">4.5 扩展恒温器，使得其可以接受参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E8%A7%A3%E6%9E%90%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">4.6 解析一个配置文件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E7%94%9F%E6%88%90C-%E4%BB%A3%E7%A0%81%E7%9A%84%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">五、生成C++代码的解析器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Lex%E5%92%8CYACC%E5%86%85%E9%83%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">六、Lex和YACC内部工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%80%BC-token-values"><span class="toc-text">6.1 标识符的值(token values)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E9%80%92%E5%BD%92%EF%BC%9A%E2%80%99right-is-wrong%E2%80%99"><span class="toc-text">6.2 递归：’right is wrong’</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E9%AB%98%E7%BA%A7yylval-union"><span class="toc-text">6.3 高级yylval: %union</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E8%87%AA%E5%AE%9A%E4%B9%89YY-INPUT%E6%8C%87%E5%90%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%80%8C%E9%9D%9E%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5"><span class="toc-text">6.4 自定义YY_INPUT指向字符串而非标准输入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%B0%83%E8%AF%95"><span class="toc-text">七、调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">7.1 状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%86%B2%E7%AA%81%EF%BC%9A%E3%80%8Eshift-reduce%E3%80%8F%E4%BB%A5%E5%8F%8A%E3%80%8Ereduce-reduce%E3%80%8F"><span class="toc-text">7.2 冲突：『shift&#x2F;reduce』以及『reduce&#x2F;reduce』</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">八、参考资料</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2025&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>








<script src="/js/app.js?rev=@@hash.js"></script>


</body>
</html>