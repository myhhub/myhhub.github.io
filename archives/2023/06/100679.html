<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="c++,qt">


    <meta name="description" content="一、前言Qt 6.2 也是 Qt 6 的第一个版本，Qt 公司将为 Qt 商业客户提供长期支持。
在 Qt 6.2 中，包含了 Qt 5.15 中的所有常用功能以及为 Qt 6 添加的新功能。随...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>Qt项目升级到Qt6移植总结 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Qt项目升级到Qt6移植总结">
            
	            Qt项目升级到Qt6移植总结
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/c/">c++</a> <a class="tag-link" href="/tags/qt/">qt</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2023/06/11</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Qt 6.2 也是 Qt 6 的第一个版本，Qt 公司将为 Qt 商业客户提供长期支持。</p>
<p>在 Qt 6.2 中，包含了 Qt 5.15 中的所有常用功能以及为 Qt 6 添加的新功能。随着 Qt 6.2 的发布，几乎所有的用户都应该能够将他们的代码从 Qt 5 迁移到 Qt 6。</p>
<p>目前Qt的支持路线为：Qt5.15.2编译的程序支持WIN7及以上的系统，Qt5.6.3编译的程序支持XP系统。</p>
<h1 id="二、Qt-6-的架构变化"><a href="#二、Qt-6-的架构变化" class="headerlink" title="二、Qt 6 的架构变化"></a>二、Qt 6 的架构变化</h1><p>我们在 Qt 6 中进行了一些更广泛的架构更改，我们现在正在构建 Qt 6.2 和任何未来版本。</p>
<ul>
<li>利用 C++17 在处理 Qt 6 时，我们希望建立在现代 C++ 标准之上。C++17 是最新发布的版本，而 Qt 6 现在依赖于 C++17 兼容编译器。这使得我们可以清理和改进我们的代码库，并为我们的用户提供更现代的 API。</li>
<li>在处理大型数据集和性能方面改进了我们的低级容器类。</li>
<li>下一代 QML 我们已经开始更加努力地更新 QML 语言，使其在未来更安全、更易于使用。Qt 6.0 – 6.2 在这里奠定了基础，但这种持续的努力将在整个 Qt 6 系列中继续进行。</li>
<li>将属性绑定引入 C++ 属性绑定是使 QML 如此成功的概念之一。在 Qt 6 中，我们一直在 C++ 中提供该概念 。</li>
<li>新的图形架构 Qt 6 在如何处理与底层操作系统 API 的集成方面采用了 全新的架构。得益于新的渲染硬件接口 (RHI)，Qt 6 现在默认使用每个系统上可用的最佳图形 API，显着提高了兼容性——尤其是在桌面和移动操作系统（如 Windows 和 macOS 以及 iOS）上。</li>
<li>Qt Quick 的统一 2D 和 3D Qt Quick 一直是构建动画和流畅的 2D 用户界面的框架。使用 Qt 6，我们也简化了将 3D 内容集成到基于 QML 的应用程序的过程。深度集成使得在任何级别混合 2D 和 3D 内容变得微不足道，同时从系统中获得最大性能。</li>
<li>CMake 构建系统 在 Qt 6 中，我们将构建系统从 qmake切换到 cmake，这是当今基于 C++ 的应用程序的标准构建系统。虽然在 Qt 6 的整个生命周期内仍支持 qmake，但初步用户报告表明切换到 cmake 后有显着改进。</li>
</ul>
<h1 id="三、添加模块"><a href="#三、添加模块" class="headerlink" title="三、添加模块"></a>三、添加模块</h1><p>开发 Qt 6.2 的主要工作之一是重新添加我们在 Qt 6.0 中遗漏的所有模块和功能。除了极少数例外，Qt 5.15 支持的所有模块现在也支持 Qt 6.2。</p>
<p>在 Qt 6.2 中，我们添加了对以下附加模块的支持（在 Qt 6.1 中已有的模块之上）：</p>
<ul>
<li>Qt Bluetooth</li>
<li>Qt Multimedia</li>
<li>Qt NFC</li>
<li>Qt Positioning</li>
<li>Qt Quick Dialogs</li>
<li>Qt RemoteObjects</li>
<li>Qt Sensors</li>
<li>Qt SerialBus</li>
<li>Qt SerialPort</li>
<li>Qt WebChannel</li>
<li>Qt WebEngine</li>
<li>Qt WebSockets</li>
<li>Qt WebView</li>
</ul>
<p>这些模块的 API 主要向后兼容 Qt 5，并且在移植到 Qt 6 时只需要对用户代码进行少量调整。</p>
<p>Qt 6.2 支持的 <a href="https://doc.qt.io/qt-6/qtmodules.html" target="_blank" rel="noopener">完整模块列表</a> 可以在我们的文档中找到 。</p>
<h1 id="四、Qt-6-2-中的新功能"><a href="#四、Qt-6-2-中的新功能" class="headerlink" title="四、Qt 6.2 中的新功能"></a>四、Qt 6.2 中的新功能</h1><p>除了我们从 Qt 5 带来的许多模块之外，我们 在 6.2 中还有大量的 <a href="https://wiki.qt.io/New_Features_in_Qt_6.2" target="_blank" rel="noopener">新特性</a>和功能。我们来看一下。</p>
<h2 id="1、Qt-快速-3D"><a href="#1、Qt-快速-3D" class="headerlink" title="1、Qt 快速 3D"></a>1、Qt 快速 3D</h2><p>Qt Quick 3D 获得了一些很酷的新功能，现在支持 实例化渲染，允许您使用不同的变换渲染大量相同的对象。我们还添加了一个新的 API，用于向 场景添加 3D 粒子效果。</p>
<p>输入处理已得到改进，我们现在可以为嵌入在 3D 场景中的 2D 项目正确创建 Qt Quick 输入事件。我们还添加了一个新的 API，用于从场景中的任意点进行基于光线的拾取。</p>
<h2 id="2、QML工具"><a href="#2、QML工具" class="headerlink" title="2、QML工具"></a>2、QML工具</h2><p>Qt 6.2 对 QML 工具进行了较大改进。我们现在有一个公共的 CMake API ，它极大地简化了创建您自己的 QML 模块的过程。</p>
<p>QML linter (qmlint) 是一种工具，用于检查 QML 源代码的最佳实践、潜在的编码和性能问题，并帮助编写更易于维护的 QML。该工具经历了很大的变化，现在可以完全配置，无论是在命令行级别，还是通过配置文件，甚至是 QML 文件本身中的各个块。此外，它现在可以生成 JSON 输出以简化与其他工具或自动化系统的集成。</p>
<p>QML 格式化程序 (qmlformat) 现在使用 QML dom 库，大大改进了生成的输出。</p>
<h2 id="3、Qt多媒体"><a href="#3、Qt多媒体" class="headerlink" title="3、Qt多媒体"></a>3、Qt多媒体</h2><p>Qt 多媒体在 Qt 6 中发生了一些相当大的变化。它是我们在 Qt 5 的生命周期中不满意的 API 之一。因此，我们退后一步，对 Qt 6 进行了一些更广泛的 API 和架构更改。没有过多考虑向后兼容性的模块。</p>
<p>尽管如此，从 Qt 5 中的 Qt 多媒体移植到 Qt 6 应该相对简单。</p>
<p>Qt 6 中的 Qt 多媒体确实支持一些我们在 Qt 5 中从未设法正确支持的高度要求的功能。示例包括播放的字幕和语言选择支持以及媒体捕获的可配置设置。</p>
<p>内部架构已经过清理，不再像 Qt 5 那样通过公共 API 公开。这将使我们能够更快地修复错误，并使将来添加新功能变得更加容易。您可以在有关 Qt 6 中的 Qt 多媒体的单独博客文章中找到更多详细信息。</p>
<p>然而，由于这些巨大的变化，该模块仍然存在粗糙的边缘，并且可能在实现中存在相当多的错误。但是，我们相信多媒体是一项必不可少的功能，我们将在 Qt 6.2 中完全支持该模块。</p>
<p>因此，我们将在补丁级别版本的常规提交策略上有所偏离，如果需要修复较大的问题，可能会添加一些较小的 API。</p>
<p>此外，我们将努力在即将发布的补丁级别版本中尽快修复任何报告的错误。</p>
<h2 id="4、整个过程中的小改进"><a href="#4、整个过程中的小改进" class="headerlink" title="4、整个过程中的小改进"></a>4、整个过程中的小改进</h2><p>几乎所有其他模块都看到了许多较小的 API 添加和改进。</p>
<p>我们已经移植了许多 API 以利用新的属性系统，以便您可以使用 C++ 中的属性绑定。这项工作尚未完成，我们将在未来的版本中继续。</p>
<p>我们还在各个地方修复了许多 API 缺点和缺失的功能。仅举几个例子：</p>
<ul>
<li>Qt Charts 获得了一些新的 API，以提高便利性并使事情更加可定制。</li>
<li>我们为 QImage 添加了浮点图像格式。</li>
<li>QByteArray::number() 现在可以正确处理 10 以外的基数的负值。</li>
<li>QLockFile 现在具有采用 std::chrono 的重载</li>
<li>Qt Network 支持多个可以在运行时共存的 SSL 后端。</li>
</ul>
<h2 id="5、Qt-Creator-和-Qt-Design-Studio"><a href="#5、Qt-Creator-和-Qt-Design-Studio" class="headerlink" title="5、Qt Creator 和 Qt Design Studio"></a>5、Qt Creator 和 Qt Design Studio</h2><p>Qt Creator 和 Qt Design Studio 也做了大量工作，以确保它们为 Qt 6.2 提供一流的支持。Qt Creator 5 包含您为 Qt 6.2 开发所需的一切。</p>
<p>我们今天还发布了全新版本的 Qt Design Studio。Qt Design Studio 2.2 基于 Qt 6.2，极大地支持在一个图形工具中创建基于 Qt Quick 和 Qt Quick 的 3D 用户界面。您可以轻松地在目标硬件上测试这些，无论是台式机、移动设备还是嵌入式设备。有关 更多详细信息，请查看有关Qt Design Studio 2.2的单独博客文章。</p>
<h1 id="五、新平台"><a href="#五、新平台" class="headerlink" title="五、新平台"></a>五、新平台</h1><p>对于 Qt 6.2，我们做了很多工作来改进我们对当前支持平台的支持，包括桌面和移动端，例如，通过改进我们对 HighDPI 渲染的支持和在 iOS 上添加 NFC 后端。</p>
<p>最重要的是，Qt 6.2 大大扩展了支持平台的范围：</p>
<p>Qt 6.2 完全支持 Apple Silicon 上的 macOS。Qt 现在可以轻松创建通用二进制文件并在 Intel 和 Apple Silicon 上为 macOS 进行开发。当然，该版本也在我们的 CI 系统中进行了全面测试。一直可以通过 Rosetta 层在 Apple 芯片上运行 Qt 应用程序，但 Qt 6.2 现在提供了在 Apple 芯片上本地运行的完整支持。</p>
<p>Qt 6.2 还恢复了对 INTEGRITY 和 QNX 实时操作系统的支持。支持需要 C++17 工具链和最新版本的操作系统。QNX 的最低要求是 7.1 版，在 INTEGRITY 上，我们支持 19.0.13 版。</p>
<p>针对 Qt 6.2 的 webOS 验证也已完成，以进一步加强 Qt 对 webOS 的承诺。</p>
<p>有很多工作正在进行以支持 Windows 11，我们希望能够在 6.2 补丁级别版本中为其提供全面支持。Windows on ARM HW 也可作为 Qt 6.2 的技术预览版提供。</p>
<p>最后，我们做了进一步的工作来改进我们对 WebAssembly 的支持，它在 Qt 6.2 中作为技术预览提供支持。</p>
<p>Qt for Python 今天也发布了，大家可以试一试。未来几天将发布一篇单独的博客文章，重点介绍最新 Qt 6.2 更改中采用的所有功能。敬请关注！</p>
<h1 id="六、Qt6-核心的变化"><a href="#六、Qt6-核心的变化" class="headerlink" title="六、Qt6 核心的变化"></a>六、Qt6 核心的变化</h1><p>Qt 6 是有意识地努力使框架更加高效和易于使用的结果。</p>
<p>我们尝试维护每个版本中所有公共 API 的二进制和源代码兼容性。但是为了使 Qt 成为更好的框架，一些变化是不可避免的。</p>
<p>在本主题中，我们总结了 Qt Core 中的这些变化，并提供了处理它们的指导。</p>
<h2 id="1、容器类"><a href="#1、容器类" class="headerlink" title="1、容器类"></a>1、容器类</h2><h3 id="QHash、QMultiHash、QSet"><a href="#QHash、QMultiHash、QSet" class="headerlink" title="QHash、QMultiHash、QSet"></a>QHash、QMultiHash、QSet</h3><h4 id="qHash-签名"><a href="#qHash-签名" class="headerlink" title="qHash() 签名"></a>qHash() 签名</h4><p>对于自定义类型，<a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">QHash</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qmultihash.html" target="_blank" rel="noopener">QMultiHash</a>依赖于您在同一命名空间中提供<a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">自定义 qHash() 函数。</a>在 Qt 4 和 Qt 5 中，函数的返回值和可选的第二个参数的<code>qHash</code>类型是<code>uint</code>. 在 Qt 6 中，它是<code>size_t</code>.</p>
<p>也就是说，你需要改变</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint</span> <span class="title">qHash</span>(<span class="params">MyType x, <span class="keyword">uint</span> seed</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> qHash(MyType x, <span class="keyword">size_t</span> seed);</span><br></pre></td></tr></table></figure>
<p>这允许<a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">QHash</a>、<a href="https://doc-snapshots.qt.io/qt6-dev/qmultihash.html" target="_blank" rel="noopener">QMultiHash</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qset.html" target="_blank" rel="noopener">QSet</a>在 64 位平台上保存超过 2^32 个项目。</p>
<h4 id="参考文献的稳定性"><a href="#参考文献的稳定性" class="headerlink" title="参考文献的稳定性"></a>参考文献的稳定性</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">Qt 6 中QHash</a>、<a href="https://doc-snapshots.qt.io/qt6-dev/qmultihash.html" target="_blank" rel="noopener">QMultiHash</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qset.html" target="_blank" rel="noopener">QSet</a>的实现从基于节点的方法更改为两阶段查找表。这种设计允许保持哈希实例的内存开销非常小，同时提供良好的性能。</p>
<p>需要注意的一个行为变化是，当表需要增长或删除条目时，新实现将不会提供对散列中元素的稳定引用。依赖这种稳定性的应用程序现在可能会遇到未定义的行为。</p>
<h4 id="移除-QHash-insertMulti"><a href="#移除-QHash-insertMulti" class="headerlink" title="移除 QHash::insertMulti"></a>移除 QHash::insertMulti</h4><p>在 Qt 5 中，<a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">QHash</a>可以通过使用 QHash::insertMulti 来创建多值散列，而<a href="https://doc-snapshots.qt.io/qt6-dev/qmultihash.html" target="_blank" rel="noopener">QMultiHash</a>是派生 vom <a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">QHash 的</a>。</p>
<p>在 Qt 6 中，类型和用例都是不同的，并且 QHash::insertMulti 被删除了。</p>
<h3 id="QVector，QList"><a href="#QVector，QList" class="headerlink" title="QVector，QList"></a>QVector，QList</h3><p>在 Qt 6 之前，<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>是独立的类。在 Qt 6 中，它们是统一的：Qt 5 <a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>实现消失了，两个类都使用更新<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">的 QVector</a>实现。<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>是具有实际实现的类，<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>是<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>的别名（typedef） 。</p>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>的 fromVector() 和 toVector() 以及<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>的 fromList() 和 toList() 在 Qt 6 中不再涉及数据复制。它们现在返回调用它们的对象。</p>
<h4 id="API-更改"><a href="#API-更改" class="headerlink" title="API 更改"></a>API 更改</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>的（以及<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>的）大小类型从 更改<code>int</code>为<code>qsizetype</code>。连同大小类型，所有相关方法的签名都更新为使用<code>qsizetype</code>. 这允许<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>在 64 位平台上保存超过 2^31 个项目。</p>
<p>在将代码库升级到 Qt 6 时，此 API 更改很可能会导致编译器警告关于缩小类型转换。具有以下示例代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myFunction(QList&lt;MyType&gt; &amp;data) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pos = getInsertPosition(<span class="built_in">size</span>);</span><br><span class="line">    data.insert(pos, MyType());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您需要更新它以使用其中一个<code>qsizetype</code>或一个 auto 关键字：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myFunction(QList&lt;MyType&gt; &amp;data) &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">size</span> = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pos = getInsertPosition(<span class="built_in">size</span>);</span><br><span class="line">    data.insert(pos, MyType());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，您可以使用类型转换并将所有内容转换为<code>int</code>或<code>qsizetype</code>。</p>
<p><strong>注意：</strong>如果您想同时针对 Qt 5 和 Qt 6 进行构建，auto 关键字是一个很好的解决方案，可以覆盖版本之间的签名差异。</p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>收到了与 Qt 6 中的内存布局相关的多项更改。</p>
<p>在 Qt 5 中，<code>sizeof(QList&lt;T&gt;)</code>等于指针的大小。现在，额外的指针间接被删除，<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>数据成员直接存储在对象中。默认情况下，期望<code>sizeof(QList&lt;T&gt;)</code>等于 3 个指针的大小。</p>
<p>同时，元素的内存布局也更新了。<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>现在总是将其元素直接存储在分配的内存区域中，而不是 Qt 5，在 Qt 5 中，某些对象被单独分配在堆上，而指向对象的指针被放置到<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>中。</p>
<p>请注意，后者尤其会影响大型对象。要具有 Qt 5 行为，您可以将对象包装成智能指针并将这些智能指针直接存储在<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList中。</a>在这种情况下，您的<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>的类型将与 Qt 5 中的类型<code>QList&lt;MySmartPointer&lt;MyLargeObject&gt;&gt;</code>相反。<code>QList&lt;MyLargeObject&gt;</code></p>
<h4 id="参考文献的稳定性-1"><a href="#参考文献的稳定性-1" class="headerlink" title="参考文献的稳定性"></a>参考文献的稳定性</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">对QVector</a> / <a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>实现进行了一些更改。QVector相关的一个是：<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">优化</a>了开头的插入（类似于Qt 5中的<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>）。<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>相关的一个是：元素的内存布局被简化。</p>
<p><strong>重要提示：</strong>这些更改会影响参考的稳定性。在 Qt 6 中，您应该考虑使用任何大小或容量修改方法来使所有引用无效，即使<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>不是<a href="https://doc-snapshots.qt.io/qt6-dev/implicit-sharing.html" target="_blank" rel="noopener">隐式共享</a>的。此规则的例外情况已明确记录。</p>
<p>依赖某些参考稳定性的应用程序在升级到使用 Qt 6 时可能会遇到未定义的行为。您应该特别注意最初使用具有非 C 兼容数组布局的<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>或<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList的情况。</a></p>
<h2 id="2、在-Qt6-中查看类"><a href="#2、在-Qt6-中查看类" class="headerlink" title="2、在 Qt6 中查看类"></a>2、在 Qt6 中查看类</h2><h3 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h3><p><code>View</code>Qt6有几个新的类。已经存在<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>，现在伴随着<a href="https://doc-snapshots.qt.io/qt6-dev/qbytearrayview.html" target="_blank" rel="noopener">QByteArrayView</a>，然后是专门的<a href="https://doc-snapshots.qt.io/qt6-dev/qutf8stringview.html" target="_blank" rel="noopener">QUtf8StringView</a>和更通用的<a href="https://doc-snapshots.qt.io/qt6-dev/qanystringview.html" target="_blank" rel="noopener">QAnyStringView</a>。</p>
<h3 id="QStringView示例上的视图类介绍"><a href="#QStringView示例上的视图类介绍" class="headerlink" title="QStringView示例上的视图类介绍"></a>QStringView示例上的视图类介绍</h3><p>QStringView类通过<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a> API的只读子集提供统一的 UTF-16 字符串视图<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">。</a>与保留自己的字符串副本（可能是引用计数）的<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString不同， </a><a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>提供了存储在其他地方的字符串的视图。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char hello[]&#123; <span class="string">"Hello."</span> &#125;;   <span class="regexp">//</span> <span class="regexp">//</span> 窄多字节字符串字面量</span><br><span class="line">QString str&#123;hello&#125;;         <span class="regexp">//</span> 需要复制字符串文字</span><br><span class="line">QString strToStr(str);      <span class="regexp">//</span> 原子增量涉及不再创建 hello 的副本</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 上面的代码可以重写以避免复制和原子增量.</span><br><span class="line"></span><br><span class="line">QStringView view&#123; <span class="string">u"Hello."</span> &#125;;  <span class="regexp">//</span> 查看到 UTF-<span class="number">16</span> 编码的字符串字面量</span><br><span class="line">QStringView viewToView&#123; view &#125;; <span class="regexp">//</span> 查看相同的 UTF-<span class="number">16</span> 编码字符串文字</span><br></pre></td></tr></table></figure>
<p>字符串<code>&quot;Hello.&quot;</code>存储在二进制文件中，在运行时不分配。<code>view</code>只是对 string 的一个视图<code>&quot;Hello.&quot;</code>，因此不必创建副本。当我们复制<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>时，<code>viewToView</code>观察到的字符串与复制源观察到的字符串相同<code>view</code>。这意味着<code>viewToView</code>不需要创建副本或原子增量。它们是现有字符串的视图<code>&quot;Hello.&quot;</code>。</p>
<h3 id="作为函数参数的视图"><a href="#作为函数参数的视图" class="headerlink" title="作为函数参数的视图"></a>作为函数参数的视图</h3><p>视图应该按值传递，而不是通过对 const 的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun1</span><span class="params">(QStringView sv)</span></span>;        <span class="comment">// 首选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun2</span><span class="params">(<span class="keyword">const</span> QStringView &amp;sv)</span></span>; <span class="comment">// 编译和工作，但速度较慢</span></span><br></pre></td></tr></table></figure>
<h3 id="视图操作函数"><a href="#视图操作函数" class="headerlink" title="视图操作函数"></a>视图操作函数</h3><p><a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>支持让我们操作字符串视图的函数。这允许我们在不创建已查看字符串的部分副本的情况下更改视图。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QString pineapple = <span class="string">"Pineapple"</span><span class="comment">;</span></span><br><span class="line">QString pine = pineapple.left(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 可以重写上面的代码以避免创建部分副本.</span><br><span class="line"></span><br><span class="line">QStringView pineappleView&#123; pineapple &#125;<span class="comment">;</span></span><br><span class="line">QStringView pineView = pineappleView.left(<span class="number">4</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h3 id="非空终止的字符串和包含的字符串-39-0-39"><a href="#非空终止的字符串和包含的字符串-39-0-39" class="headerlink" title="非空终止的字符串和包含的字符串 &#39;\0&#39;"></a>非空终止的字符串和包含的字符串 <code>&#39;\0&#39;</code></h3><p><a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>支持空终止和非空终止字符串。不同之处在于您初始化<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>的方式：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QChar aToE[]&#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> &#125;;</span><br><span class="line"></span><br><span class="line">QStringView nonNull&#123; aToE, std::size(aToE) &#125;; <span class="regexp">//</span> 给定长度QStringView nonNull&#123;aToE&#125;; </span><br><span class="line"><span class="regexp">//</span>  自动确定长度</span><br><span class="line"></span><br><span class="line">QChar fToJ[]&#123; <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'\0'</span>, <span class="string">'j'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 使用给定长度，不搜索 <span class="string">'\0'</span>，所以位置 <span class="number">3</span> 的 <span class="string">'\0'</span></span><br><span class="line"><span class="regexp">//</span> 被认为是字符串的一部分，类似于 <span class="string">'h'</span> 和 <span class="string">'j'</span></span><br><span class="line">QStringView nonNull&#123; fToJ, std::size(fToJ) &#125;;</span><br><span class="line">QStringView part&#123; fToJ &#125;; <span class="regexp">//</span>在第一次遇到<span class="string">'\0'</span>时停止</span><br></pre></td></tr></table></figure>
<h3 id="视图的所有权模型"><a href="#视图的所有权模型" class="headerlink" title="视图的所有权模型"></a>视图的所有权模型</h3><p>由于<code>views</code>不拥有它们引用的内存，因此必须注意确保引用的数据（例如，由<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>拥有）<code>view</code>在所有代码路径上的寿命都更长。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QStringView <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QString <span class="title">hello</span><span class="params">(<span class="string">"Hello."</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> QStringView&#123; hello &#125;; <span class="comment">// hello 超出范围并被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringView hello&#123; sayHello() &#125;;</span><br><span class="line">    qDebug() &lt;&lt; hello; <span class="comment">// 未定义的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将-QStringView-转换为-QString"><a href="#将-QStringView-转换为-QString" class="headerlink" title="将 QStringView 转换为 QString"></a>将 QStringView 转换为 QString</h3><p><a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>不会隐式或显式转换为<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>，但可以创建其数据的深层副本：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void print(const QString &amp;s) &#123; qDebug() &lt;&lt; s; &#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    QStringView string&#123; <span class="string">u"string"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> print(string); <span class="regexp">//</span> 无效，没有隐式转换</span><br><span class="line">    <span class="regexp">//</span> QString str&#123; string &#125;; <span class="regexp">//</span> 无效，没有显式转换</span><br><span class="line"></span><br><span class="line">    print(string.toString());</span><br><span class="line">    QString str = string.toString(); <span class="regexp">//</span> 从view创建QString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重要笔记"><a href="#重要笔记" class="headerlink" title="重要笔记"></a>重要笔记</h3><p>通过利用新的视图类，可以在许多用例中实现大量性能提升。但是，重要的是要知道可能有一些警告。因此，重要的是要记住：</p>
<ul>
<li>视图应该按值传递，而不是通过对 const 的引用。</li>
<li>构造具有负长度的视图是未定义的行为。</li>
<li>必须注意确保引用的数据（例如，由<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>拥有）比所有代码路径上的视图都长。</li>
</ul>
<h2 id="3、字符串相关类"><a href="#3、字符串相关类" class="headerlink" title="3、字符串相关类"></a>3、字符串相关类</h2><h3 id="QStringView-类"><a href="#QStringView-类" class="headerlink" title="QStringView 类"></a>QStringView 类</h3><p>从 Qt6 开始，通常建议使用<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a> over <code>QStringRef</code>。<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>引用它不拥有的 UTF-16 字符串的连续部分。它充当各种 UTF-16 字符串的接口类型，无需先构造<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>。QStringView类公开了几乎所有<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QString</a>的只读方法<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">和</a>以前存在的<code>QStringRef</code>类。</p>
<p><strong>注意：</strong>必须注意确保引用的字符串数据（例如，由<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>拥有）在所有代码路径上都超过<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView 。</a></p>
<p><strong>注意：</strong>如果<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>包装了<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>，则需要小心，因为与<code>QStringRef</code> <a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView不同，一旦</a><a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>数据重定位，将不会更新内部数据指针。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="built_in">string</span> = <span class="params">...</span>;</span><br><span class="line">QStringView view&#123;<span class="built_in">string</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加很长的内容可能会导致重定位，并且</span></span><br><span class="line"><span class="comment">// 最终会导致 QStringView 出现乱码.</span></span><br><span class="line"><span class="built_in">string</span> += <span class="params">...</span>;</span><br></pre></td></tr></table></figure>
<h3 id="QStringRef-类"><a href="#QStringRef-类" class="headerlink" title="QStringRef 类"></a>QStringRef 类</h3><p>在 Qt6中， <a href="https://doc-snapshots.qt.io/qt6-dev/qstringref.html" target="_blank" rel="noopener">QStringRef</a>已从 Qt Core 中删除。为了在不涉及整个代码库的情况下简化现有应用程序的移植，<code>QStringRef</code>该类并没有完全消失，而是被移到了 Qt5Compat 模块中。如果您想<code>QStringRef</code>进一步使用，请参阅<a href="https://doc-snapshots.qt.io/qt6-dev/qtcore-changes-qt6.html#using-the-qt5compat-module" target="_blank" rel="noopener">使用 Qt5Compat 模块</a>。</p>
<p>不幸的是，<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>公开的一些方法返回 a <code>QStringRef</code>，无法移动到 Qt5Compat。因此，可能需要一些手动移植。如果您的代码使用以下一个或多个函数，您需要将它们移植到使用<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>或<a href="https://doc-snapshots.qt.io/qt6-dev/qstringtokenizer.html" target="_blank" rel="noopener">QStringTokenizer</a>。对于性能关键代码，还建议使用<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html#tokenize" target="_blank" rel="noopener">QStringView::tokenize</a>而不是<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html#split" target="_blank" rel="noopener">QStringView::split 。</a></p>
<p>使用以下代码更改代码<code>QStringRef</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="keyword">string</span> = ...;</span><br><span class="line">QStringRef left = <span class="keyword">string</span>.leftRef(n);</span><br><span class="line">QStringRef mid = <span class="keyword">string</span>.midRef(n);</span><br><span class="line">QStringRef right = <span class="keyword">string</span>.rightRef(n);</span><br><span class="line"></span><br><span class="line">QString <span class="keyword">value</span> = ...;</span><br><span class="line"><span class="keyword">const</span> QVector&lt;QStringRef&gt; refs = <span class="keyword">string</span>.splitRef(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">if</span> (refs.contains(<span class="keyword">value</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>到：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QString string = ...;</span><br><span class="line">QStringView left = QStringView&#123;string&#125;.left(n);</span><br><span class="line">QStringView mid = QStringView&#123;string&#125;.mid(n);</span><br><span class="line">QStringView right = QStringView&#123;string&#125;.right(n);</span><br><span class="line"></span><br><span class="line">QString value = ...;</span><br><span class="line">const QList&lt;QStringView&gt; refs = QStringView&#123;string&#125;.split(<span class="string">u' '</span>);</span><br><span class="line"><span class="keyword">if</span> (refs.contains(QStringView&#123;value&#125;))</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">// 或</span><br><span class="line">const auto refs = QStringView&#123;string&#125;.tokenize(<span class="string">u' '</span>);</span><br><span class="line"><span class="keyword">for</span> (auto ref : refs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref == value)</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4、QMutex-和相关类"><a href="#4、QMutex-和相关类" class="headerlink" title="4、QMutex 和相关类"></a>4、QMutex 和相关类</h2><p>在 Qt 6 中，<a href="https://doc-snapshots.qt.io/qt6-dev/qrecursivemutex.html" target="_blank" rel="noopener">QRecursiveMutex</a>不再继承自<a href="https://doc-snapshots.qt.io/qt6-dev/qmutex.html" target="_blank" rel="noopener">QMutex</a>。进行此更改是为了提高<a href="https://doc-snapshots.qt.io/qt6-dev/qmutex.html" target="_blank" rel="noopener">QMutex</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qrecursivemutex.html" target="_blank" rel="noopener">QRecursiveMutex</a>的性能。</p>
<p>由于这些更改， QMutex::RecursionMode 枚举已被删除，并且<a href="https://doc-snapshots.qt.io/qt6-dev/qmutexlocker.html" target="_blank" rel="noopener">QMutexLocker</a>现在是一个模板类，可以在<a href="https://doc-snapshots.qt.io/qt6-dev/qmutex.html" target="_blank" rel="noopener">QMutex</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qrecursivemutex.html" target="_blank" rel="noopener">QRecursiveMutex</a>上运行。</p>
<h2 id="5、QFuture-及相关类"><a href="#5、QFuture-及相关类" class="headerlink" title="5、QFuture 及相关类"></a>5、QFuture 及相关类</h2><h3 id="QFuture-类"><a href="#QFuture-类" class="headerlink" title="QFuture 类"></a>QFuture 类</h3><p>为避免意外使用<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture ，Qt 6 中对</a><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a> API进行了一些更改，这可能会导致源代码兼容性中断。</p>
<h4 id="QFuture-和其他类型之间的隐式转换"><a href="#QFuture-和其他类型之间的隐式转换" class="headerlink" title="QFuture 和其他类型之间的隐式转换"></a>QFuture 和其他类型之间的隐式转换</h4><p><code>QFuture&lt;T&gt;</code>到的转换<code>T</code>已被禁用。转换操作符调用<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html#result" target="_blank" rel="noopener">QFuture::result</a> ()，如果用户在尝试进行转换之前通过<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html#takeResult" target="_blank" rel="noopener">QFuture::takeResult () 从</a><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>移动了结果，这可能会导致未定义的行为。在需要转换<code>QFuture&lt;T&gt;</code>到<code>T</code>。</p>
<p><code>QFuture&lt;T&gt;</code>从to的隐式转换<code>QFuture&lt;void&gt;</code>也被禁用。如果您真的打算进行转换，请使用显式<code>QFuture&lt;void&gt;(const QFuture&lt;T&gt; &amp;)</code>构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QFuture&lt;<span class="keyword">int</span>&gt; future = ...</span><br><span class="line">QFuture&lt;<span class="keyword">void</span>&gt; voidFuture = QFuture&lt;<span class="keyword">void</span>&gt;(future);</span><br></pre></td></tr></table></figure>
<h4 id="等式运算符"><a href="#等式运算符" class="headerlink" title="等式运算符"></a>等式运算符</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>的相等运算符已被删除。他们正在比较底层的 d 指针，而不是比较结果，这可能不是用户所期望的。如果需要比较<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>对象，使用<code>QFuture::result()</code>or<code>QFuture::takeResult()</code>方法。例如：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QFuture&lt;int&gt; future1 = <span class="string">...</span>;</span><br><span class="line">QFuture&lt;int&gt; future2 = <span class="string">...</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(future1.result()</span> == future2.result<span class="params">()</span>)</span><br><span class="line">    <span class="string">//</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>
<h3 id="QFuture-和-QFutureWatcher-的行为变化"><a href="#QFuture-和-QFutureWatcher-的行为变化" class="headerlink" title="QFuture 和 QFutureWatcher 的行为变化"></a>QFuture 和 QFutureWatcher 的行为变化</h3><p><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">在 Qt 6 中，对QFuture</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a>进行了一些改进，导致以下行为变化：</p>
<ul>
<li>在暂停<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>或<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a>（通过调用<code>pause()</code>or <code>setPaused(true)</code>）后，<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a>不会立即停止传递进度和结果就绪信号。在暂停的那一刻，可能仍有计算正在进行且无法停止。此类计算的信号可能在暂停后仍被传递，而不是被推迟并仅在下一次恢复后才报告。要在暂停实际生效时得到通知，可以使用<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html#suspended" target="_blank" rel="noopener">QFutureWatcher::suspended () 信号。</a>此外，还有新的<code>isSuspending()</code>和<code>isSuspended()</code>方法，用于检查<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>是处于挂起过程中还是已经处于挂起状态。请注意，出于一致性原因，对于两者<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a>与暂停相关的 API 已被弃用，取而代之的是名称中带有“suspend”的类似方法。</li>
<li><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html#waitForFinished" target="_blank" rel="noopener">QFuture::waitForFinished</a> () 现在会等到<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>实际上处于完成状态，而不是在它不处于运行状态时立即退出。如果在调用它的那一刻未来还没有开始，这可以防止<code>waitForFinished()</code>立即退出。这同样适用于<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html#waitForFinished" target="_blank" rel="noopener">QFutureWatcher::waitForFinished</a> ()。此更改不会影响将<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>与<a href="https://doc-snapshots.qt.io/qt6-dev/qtconcurrent-module.html" target="_blank" rel="noopener">QtConcurrent</a>一起使用的代码的行为。只有在未记录的情况下使用它的代码<code>QFutureInterface</code>可能会受到影响。</li>
<li><a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html#isFinished" target="_blank" rel="noopener">QFutureWatcher::isFinished</a> () 现在反映 QFuture 的完成状态，<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">而不是在</a><a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html#finished" target="_blank" rel="noopener">QFutureWatcher::finished</a> () 发出之前返回 false 。</li>
</ul>
<h3 id="QPromise-类"><a href="#QPromise-类" class="headerlink" title="QPromise 类"></a>QPromise 类</h3><p>在 Qt 6 中，应该使用新的<a href="https://doc-snapshots.qt.io/qt6-dev/qpromise.html" target="_blank" rel="noopener">QPromise类而不是非官方的 QFutureInterface 作为</a><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>的“setter”对应物。</p>
<h2 id="6、IO-类"><a href="#6、IO-类" class="headerlink" title="6、IO 类"></a>6、IO 类</h2><h3 id="QProcess-类"><a href="#QProcess-类" class="headerlink" title="QProcess 类"></a>QProcess 类</h3><p>在 Qt 6 中，通过将单个命令字符串拆分为程序名称和参数来解释单个命令字符串的<a href="https://doc-snapshots.qt.io/qt6-dev/qprocess.html#start" target="_blank" rel="noopener">QProcess::start () 重载重命名为</a><a href="https://doc-snapshots.qt.io/qt6-dev/qprocess.html#startCommand" target="_blank" rel="noopener">QProcess::startCommand</a> ()。但是，存在采用单个字符串的<a href="https://doc-snapshots.qt.io/qt6-dev/qprocess.html#start" target="_blank" rel="noopener">QProcess::start</a> () 重载以及用于参数的<a href="https://doc-snapshots.qt.io/qt6-dev/qstringlist.html" target="_blank" rel="noopener">QStringList 。</a>由于<a href="https://doc-snapshots.qt.io/qt6-dev/qstringlist.html" target="_blank" rel="noopener">QStringList</a>参数默认为空列表，因此仅传递字符串的现有代码仍然可以编译，但如果它是包含参数的完整命令字符串，则将无法执行该过程。</p>
<p>Qt 5.15 为相应的重载引入了弃用警告，以便于发现和更新现有代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QProcess <span class="built_in">process</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 5.15 中编译时出现警告，在 Qt 6</span></span><br><span class="line"><span class="built_in">process</span>.start(<span class="string">"dir \"My Documents\""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于 Qt 5 和 Qt 6; 另请参阅QProcess::splitCommand()</span></span><br><span class="line"><span class="built_in">process</span>.start(<span class="string">"dir"</span>, QStringList(&#123;<span class="string">"My Documents"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于 Qt 6</span></span><br><span class="line"><span class="built_in">process</span>.startCommand(<span class="string">"dir \"My Documents\""</span>);</span><br></pre></td></tr></table></figure>
<p>QProcess::pid() 和 Q_PID 类型已被移除；使用<a href="https://doc-snapshots.qt.io/qt6-dev/qprocess.html#processId" target="_blank" rel="noopener">QProcess::processId</a> () 来获取本机进程标识符。<code>PROCESS_INFORMATION</code>不再支持使用本机 Win32 API 以 Win32 结构访问 Q_PID 中的数据的代码。</p>
<h2 id="7、元类型系统"><a href="#7、元类型系统" class="headerlink" title="7、元类型系统"></a>7、元类型系统</h2><h3 id="QVariant-类"><a href="#QVariant-类" class="headerlink" title="QVariant 类"></a>QVariant 类</h3><p><code>QVariant</code>已被重写以<code>QMetaType</code>用于其所有操作。这意味着一些方法的行为改变：</p>
<ul>
<li><code>QVariant::isNull()</code>现在仅<code>true</code>在 the<code>QVariant</code>为空或包含 a时返回<code>nullptr</code>。在 Qt 5 中，如果 qtbase 中的类<code>isNull</code>本身有一个方法返回 true，它也会返回 true。依赖于旧行为的代码需要检查包含的值是否返回 isNull ——然而这种代码在实践中不太可能出现，因为<code>isNull()</code>很少有人感兴趣的属性（比较<code>QString::isEmpty()</code>/<code>isNull()</code>和<code>QTime::isValid</code>/ <code>isNull</code>）。</li>
<li><code>QVariant::operator==</code>在 Qt 6 中使用<code>QMetaType::equals</code>。因此，某些图形类型，如<code>QPixmap</code>,<code>QImage</code>并且<code>QIcon</code>永远不会比较相等。此外，存储在中的浮点数<code>QVariant</code>不再与 进行比较<code>qFuzzyCompare</code>，而是使用精确比较。</li>
</ul>
<p>此外，QVariant::operator&lt;、QVariant::operator&lt;=、QVariant::operator&gt; 和 QVariant::operator&gt;= 被删除，因为不同的变体并不总是可订购的。这也意味着<a href="https://doc-snapshots.qt.io/qt6-dev/qvariant.html" target="_blank" rel="noopener">QVariant</a>不能再用作<a href="https://doc-snapshots.qt.io/qt6-dev/qmap.html" target="_blank" rel="noopener">QMap</a>中的键。</p>
<h3 id="QMetaType-类"><a href="#QMetaType-类" class="headerlink" title="QMetaType 类"></a>QMetaType 类</h3><p>在 Qt 6 中，比较器以及<a href="https://doc-snapshots.qt.io/qt6-dev/qdebug.html" target="_blank" rel="noopener">QDebug</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qdatastream.html" target="_blank" rel="noopener">QDataStream</a>流操作符的注册是自动完成的。因此，、<code>QMetaType::registerEqualsComparator()</code>和不再存在。移植到 Qt 6 时，必须删除对这些方法的调用。<code>QMetaType::registerComparators()`</code>qRegisterMetaTypeStreamOperators()<code></code>QMetaType::registerDebugStreamOperator()`</p>
<h3 id="类型注册"><a href="#类型注册" class="headerlink" title="类型注册"></a>类型注册</h3><p>中使用的类型<code>Q_PROPERTY</code>将其元类型存储在类’<code>QMetaObject</code>中。这要求当 moc 看到它们时类型是完整的，这可能导致在 Qt 5 中工作的代码中出现编译错误。有三种方法可以解决此问题：</p>
<ul>
<li>包括定义类型的标题。</li>
<li>不要使用包含，而是使用<code>Q_MOC_INCLUDE</code>宏。如果包含标头会导致循环依赖，或者会减慢编译速度，这将很有帮助。</li>
<li>如果头文件存在于实现类的 cpp 文件中，也可以在其中包含 moc 生成的文件。</li>
</ul>
<h2 id="8、正则表达式类"><a href="#8、正则表达式类" class="headerlink" title="8、正则表达式类"></a>8、正则表达式类</h2><h3 id="QRegularExpression-类"><a href="#QRegularExpression-类" class="headerlink" title="QRegularExpression 类"></a>QRegularExpression 类</h3><p>在 Qt6 中，所有采用 的方法都已<code>QRegExp</code>从我们的代码库中删除。因此，您很可能必须将您的应用程序或库移植到<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>。</p>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>实现了与 Perl 兼容的正则表达式。它完全支持Unicode。<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">有关QRegularExpression</a>支持的正则表达式语法的概述，请参阅前面提到的 pcrepattern(3) 手册页。一个正则表达式由两部分组成：一个模式字符串和一组改变模式字符串含义的模式选项。</p>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>之间存在一些细微的差异<code>QRegExp</code>，本文档将对此进行解释以简化移植工作。</p>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>在正则表达式的语法方面更加严格。因此检查表达式的<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#isValid" target="_blank" rel="noopener">有效性</a>总是好的。</p>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>几乎总是可以声明为 const （模式改变时除外），而<code>QRegExp</code>几乎不可能。</p>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/qregexp.html#CaretMode-enum" target="_blank" rel="noopener">CaretMode</a>枚举没有替代品。QRegularExpression <a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#MatchOption-enum" target="_blank" rel="noopener">::AnchoredMatchOption</a>匹配选项可用于模拟<a href="https://doc-snapshots.qt.io/qt6-dev/qregexp.html#CaretMode-enum" target="_blank" rel="noopener">QRegExp::CaretAtOffset</a>行为。<a href="https://doc-snapshots.qt.io/qt6-dev/qregexp.html#CaretMode-enum" target="_blank" rel="noopener">其他QRegExp::CaretMode</a>模式没有等价物。</p>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>仅支持与 Perl 兼容的正则表达式。尽管如此，它仍然不支持 Perl 兼容的正则表达式中可用的所有功能。最值得注意的是不支持捕获组的重复名称，使用它们可能会导致未定义的行为。这可能会在未来的 Qt 版本中改变。</p>
<h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h4><p>在<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>中没有直接的方法来进行通配符匹配。但是，提供了<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#wildcardToRegularExpression" target="_blank" rel="noopener">QRegularExpression::wildcardToRegularExpression</a>方法来将 glob 模式转换为可用于该目的的 Perl 兼容的正则表达式。</p>
<p>例如，如果您有类似的代码</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QRegExp</span> <span class="selector-tag">wildcard</span>(<span class="string">"*.txt"</span>);</span><br><span class="line"><span class="selector-tag">wildcard</span><span class="selector-class">.setPatternSyntax</span>(<span class="attribute">QRegExp</span>::Wildcard);</span><br></pre></td></tr></table></figure>
<p>您可以将其重写为</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wildcard = QRegularExpression(<span class="name">QRegularExpression</span>:<span class="symbol">:wildcardToRegularExpression</span>(<span class="string">"*.txt"</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>请注意，并非所有类似于通配符模式的 shell 都可能以您期望的方式进行翻译。如果简单地使用上述函数进行转换，以下示例代码将静默中断：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const QString fp1(<span class="string">"C:/Users/dummy/files/content.txt"</span>);</span><br><span class="line">const QString fp2(<span class="string">"/home/dummy/files/content.txt"</span>);</span><br><span class="line"></span><br><span class="line">QRegExp re1(<span class="string">"*/files/*"</span>);</span><br><span class="line">re1.setPatternSyntax(QRegExp<span class="type">::Wildcard</span>);</span><br><span class="line"><span class="params">...</span> = re1.exactMatch(fp1);  <span class="comment">// 返回true</span></span><br><span class="line"><span class="params">...</span> = re1.exactMatch(fp2);  <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是使用 QRegularExpression::wildcardToRegularExpression()</span></span><br><span class="line"></span><br><span class="line">QRegularExpression re2(QRegularExpression<span class="type">::wildcardToRegularExpression</span>(<span class="string">"*/files/*"</span>));</span><br><span class="line"><span class="params">...</span> = re2.<span class="keyword">match</span>(fp1).hasMatch();    <span class="comment">// returns false</span></span><br><span class="line"><span class="params">...</span> = re2.<span class="keyword">match</span>(fp2).hasMatch();    <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure>
<h4 id="向前搜索"><a href="#向前搜索" class="headerlink" title="向前搜索"></a>向前搜索</h4><p>字符串内的前向搜索通常通过循环使用<code>QRegExp::indexIn</code>和不断增长的偏移量来实现，但现在可以使用<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpressionmatchiterator.html" target="_blank" rel="noopener">QRegularExpressionMatchIterator</a>或<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html#indexOf" target="_blank" rel="noopener">QString::indexOf</a>轻松实现。</p>
<p>例如，如果您有类似的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">subject</span><span class="params">(<span class="string">"the quick fox"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="function">QRegExp <span class="title">re</span><span class="params">(<span class="string">"(\\w+)"</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> ((offset = re.indexIn(subject, offset)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    offset += re.matchedLength();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以将其重写为</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRegularExpression <span class="title">re</span>(<span class="params"><span class="string">"(\\w+)"</span></span>)</span>;</span><br><span class="line"><span class="function">QString <span class="title">subject</span>(<span class="params"><span class="string">"the quick fox"</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">QRegularExpressionMatchIterator i = re.globalMatch(subject);</span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">    QRegularExpressionMatch match = i.next();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 或者使用 QString::indexOf</span></span><br><span class="line"></span><br><span class="line">qsizetype <span class="keyword">from</span> = <span class="number">0</span>;</span><br><span class="line">QRegularExpressionMatch match;</span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">from</span> = subject.indexOf(re, <span class="keyword">from</span>, &amp;match)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">from</span> += match.capturedLength();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="向后搜索"><a href="#向后搜索" class="headerlink" title="向后搜索"></a>向后搜索</h4><p>在字符串中向后搜索通常是作为循环实现的<code>QRegExp::lastIndexIn</code>，但现在可以使用<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html#lastIndexOf" target="_blank" rel="noopener">QString::lastIndexOf</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpressionmatch.html" target="_blank" rel="noopener">QRegularExpressionMatch</a>轻松实现。</p>
<p><strong>注意：</strong><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpressionmatchiterator.html" target="_blank" rel="noopener">QRegularExpressionMatchIterator</a>不能执行向后搜索。</p>
<p>例如，如果您有类似的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = <span class="number">-1</span>;</span><br><span class="line"><span class="function">QString <span class="title">subject</span><span class="params">(<span class="string">"Lorem ipsum dolor sit amet, consetetur sadipscing."</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QRegExp <span class="title">re</span><span class="params">(<span class="string">"\\s+([ids]\\w+)"</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> ((offset = re.lastIndexIn(subject, offset)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    --offset;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以将其重写为</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qsizetype <span class="keyword">from</span> = <span class="number">-1</span>;</span><br><span class="line"><span class="function">QString <span class="title">subject</span>(<span class="params"><span class="string">"Lorem ipsum dolor sit amet, consetetur sadipscing."</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">QRegularExpressionMatch match;</span><br><span class="line"><span class="function">QRegularExpression <span class="title">re</span>(<span class="params"><span class="string">"\\s+([ids]\\w+)"</span></span>)</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">from</span> = subject.lastIndexOf(re, <span class="keyword">from</span>, &amp;match)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    --<span class="keyword">from</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exactMatch-与-match-hasMatch"><a href="#exactMatch-与-match-hasMatch" class="headerlink" title="exactMatch 与 match.hasMatch"></a>exactMatch 与 match.hasMatch</h4><p><code>QRegExp::exactMatch</code>有两个目的：将正则表达式与主题字符串完全匹配，并实现部分匹配。精确匹配表示正则表达式是否匹配整个主题字符串。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QString</span> <span class="selector-tag">source</span>(<span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QRegExp</span>(<span class="string">"\\d+"</span>)<span class="selector-class">.exactMatch</span>(source);         <span class="comment">// 返回false</span></span><br><span class="line"><span class="selector-tag">QRegExp</span>(<span class="string">"[a-z]+\\d+"</span>)<span class="selector-class">.exactMatch</span>(source);   <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QRegularExpression</span>(<span class="string">"\\d+"</span>)<span class="selector-class">.match</span>(source)<span class="selector-class">.hasMatch</span>();        <span class="comment">// 返回true</span></span><br><span class="line"><span class="selector-tag">QRegularExpression</span>(<span class="string">"[a-z]+\\d+"</span>)<span class="selector-class">.match</span>(source)<span class="selector-class">.hasMatch</span>();  <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure>
<p>精确匹配未反映在<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>中。如果要确保主题字符串与正则表达式完全匹配，可以使用<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#anchoredPattern" target="_blank" rel="noopener">QRegularExpression::anchoredPattern</a>函数包装模式：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QString source(<span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line">QString <span class="built_in">pattern</span>(<span class="string">"\\d+"</span>);</span><br><span class="line">QRegularExpression(<span class="built_in">pattern</span>).<span class="keyword">match</span>(source).hasMatch();  // 返回true</span><br><span class="line"></span><br><span class="line"><span class="built_in">pattern</span> = QRegularExpression::anchoredPattern(<span class="built_in">pattern</span>);</span><br><span class="line">QRegularExpression(<span class="built_in">pattern</span>).<span class="keyword">match</span>(source).hasMatch();  // 返回false</span><br></pre></td></tr></table></figure>
<h4 id="最小匹配"><a href="#最小匹配" class="headerlink" title="最小匹配"></a>最小匹配</h4><p><code>QRegExp::setMinimal()</code>通过简单地反转量词的贪婪来实现最小匹配（<code>QRegExp</code>不支持惰性量词，如*？、+？等）。<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">相反， QRegularExpression</a>确实支持贪婪、懒惰和所有格量词。QRegularExpression <a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#PatternOption-enum" target="_blank" rel="noopener">::InvertedGreedinessOption</a>模式选项可用于模拟<code>QRegExp::setMinimal()</code>: 如果启用，它会反转量词的贪婪（贪婪的变得懒惰，反之亦然）。</p>
<h4 id="不同的模式语法"><a href="#不同的模式语法" class="headerlink" title="不同的模式语法"></a>不同的模式语法</h4><p>将正则表达式从 QRegularExpression 移植<code>QRegExp</code>可能<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">需要</a>更改模式本身。因此建议检查与<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#isValid" target="_blank" rel="noopener">QRegularExpression::isValid</a>方法一起使用的模式。这对于用户提供的模式或不受开发人员控制的模式尤其重要。</p>
<p>在其他情况下，从<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a><code>QRegExp</code>移植的模式可能会默默地改变语义。因此，有必要审查所使用的模式。最值得注意的无声不兼容案例是：</p>
<ul>
<li><code>\xHHHH</code>为了使用超过 2 位的十六进制转义，需要大括号。<code>\x2022</code>需要将类似的模式移植到<code>\x{2022}</code>，否则它将匹配<code>(0x20)</code>字符串后面的空格<code>&quot;22&quot;</code>。<code>\x</code>通常，无论指定多少位数，强烈建议始终使用带有转义的花括号。</li>
<li>需要移植类似的<code>0-to-n</code>量化以保留语义。否则，诸如这样的模式实际上会匹配一个数字后跟确切的字符串。<code>{,n}</code> <code>{0,n}</code> <code>\d{,3}</code> <code>&quot;{,3}&quot;</code></li>
</ul>
<h4 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h4><p>使用 时<code>QRegExp::exactMatch()</code>，如果没有找到精确匹配，仍然可以通过调用<code>QRegExp::matchedLength()</code>. 如果返回的长度等于主题字符串的长度，则可以断定找到了部分匹配。<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>通过适当的<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#MatchType-enum" target="_blank" rel="noopener">QRegularExpression::MatchType</a>显式支持部分匹配。</p>
<h4 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h4><p>由于<code>QRegExp</code>API 的限制，不可能正确地实现全局匹配（也就是说，就像 Perl 一样）。特别是，可以匹配零个字符的模式（如“a*”）是有问题的。<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#wildcardToRegularExpression" target="_blank" rel="noopener">QRegularExpression::wildcardToRegularExpression</a>正确实现 Perl 全局匹配，返回的迭代器可用于检查每个结果。</p>
<h4 id="Unicode-属性支持"><a href="#Unicode-属性支持" class="headerlink" title="Unicode 属性支持"></a>Unicode 属性支持</h4><p>使用 时<code>QRegExp</code>，诸如 、 等字符类<code>\w</code>匹配<code>\d</code>具有相应 Unicode 属性的字符：例如，<code>\d</code>匹配具有 Unicode Nd（十进制数字）属性的任何字符。默认情况下，这些字符类仅匹配 ASCII 字符。使用<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>时：例如，<code>\d</code>精确匹配 0-9 ASCII 范围内的字符。可以通过使用<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#PatternOption-enum" target="_blank" rel="noopener">QRegularExpression::UseUnicodePropertiesOption</a>模式选项来更改此行为。</p>
<h3 id="QRegExp-类"><a href="#QRegExp-类" class="headerlink" title="QRegExp 类"></a>QRegExp 类</h3><p>在 Qt6<a href="https://doc-snapshots.qt.io/qt6-dev/qregexp.html" target="_blank" rel="noopener">中</a>，QRegExp从 Qt Core 中移除。如果您的应用程序现在无法移植<code>QRegExp</code>，Qt5Compat 中仍然存在以保持这些代码库正常工作。如果您想<code>QRegExp</code>进一步使用，请参阅<a href="https://doc-snapshots.qt.io/qt6-dev/qtcore-changes-qt6.html#using-the-qt5compat-module" target="_blank" rel="noopener">使用 Qt5Compat 模块</a>。</p>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html" target="_blank" rel="noopener">QEvent</a>类定义了一个复制构造函数和一个赋值运算符，尽管它是一个多态类。在将不同类中的对象相互分配时，使用虚拟方法复制类可能会导致切片。由于复制和分配经常隐含地发生，这可能会导致难以调试的问题。</p>
<p>在 Qt 6 中，<a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html" target="_blank" rel="noopener">QEvent</a>子类的复制构造函数和赋值运算符已被保护以防止隐式复制。如果您需要复制事件，请使用<a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html#clone" target="_blank" rel="noopener">clone</a>方法，该方法将返回<a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html" target="_blank" rel="noopener">QEvent</a>对象的堆分配副本。确保删除克隆，可能使用 std::unique_ptr，除非您发布它（在这种情况下，Qt 将在交付后删除它）。</p>
<p>在您的<a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html" target="_blank" rel="noopener">QEvent</a>子类中，覆盖 clone()，并声明受保护和默认实现的复制构造函数和赋值运算符，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> :</span> <span class="keyword">public</span> QEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MyEvent *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> MyEvent(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    MyEvent(<span class="keyword">const</span> MyEvent &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    MyEvent &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyEvent &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    MyEvent(MyEvent &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MyEvent &amp;<span class="keyword">operator</span>=(MyEvent &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 成员数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>请注意，如果您的 MyEvent 类分配内存（例如，通过指向实现模式的指针），那么您将必须实现自定义复制语义。</p>
<h2 id="9、序列化类"><a href="#9、序列化类" class="headerlink" title="9、序列化类"></a>9、序列化类</h2><p>在 Qt 6 中，用于将其转换为/从 Qt 的遗留 JSON 二进制格式转换的<a href="https://doc-snapshots.qt.io/qt6-dev/qjsondocument.html" target="_blank" rel="noopener">QJsonDocument</a>方法被删除，以支持标准化的 CBOR 格式。Qt JSON 类型可以转换为 Qt CBOR 类型，后者又可以序列化为 CBOR 二进制格式，反之亦然。例如，参见<a href="https://doc-snapshots.qt.io/qt6-dev/qcborvalue.html#fromJsonValue" target="_blank" rel="noopener">QCborValue::fromJsonValue</a> () 和<a href="https://doc-snapshots.qt.io/qt6-dev/qcborvalue.html#toJsonValue" target="_blank" rel="noopener">QCborValue::toJsonValue</a> ()。</p>
<p>如果仍然需要使用二进制 JSON 格式，可以使用 Qt5Compat 模块中提供的替换。它们可以在<a href="https://doc-snapshots.qt.io/qt6-dev/qbinaryjson.html" target="_blank" rel="noopener">QBinaryJson</a>命名空间中找到。请参阅<a href="https://doc-snapshots.qt.io/qt6-dev/qtcore-changes-qt6.html#using-the-qt5compat-module" target="_blank" rel="noopener">使用 Qt5Compat 模块</a>以了解如何在您的应用程序中使用该模块。</p>
<h2 id="10、其他类"><a href="#10、其他类" class="headerlink" title="10、其他类"></a>10、其他类</h2><p>在 Qt 5 中，<a href="https://doc-snapshots.qt.io/qt6-dev/qcoreapplication.html#quit" target="_blank" rel="noopener">QCoreApplication::quit</a> () 等价于调用<a href="https://doc-snapshots.qt.io/qt6-dev/qcoreapplication.html#exit" target="_blank" rel="noopener">QCoreApplication::exit</a> ()。这刚刚退出了主事件循环。</p>
<p>在 Qt 6 中，该方法将尝试通过发布关闭事件来关闭所有顶级窗口。窗口可以通过忽略该事件来自由取消关闭过程。</p>
<p>调用<a href="https://doc-snapshots.qt.io/qt6-dev/qcoreapplication.html#exit" target="_blank" rel="noopener">QCoreApplication::exit</a> () 来保持非条件行为。</p>
<p>由于命名不一致，不推荐使用 QLibraryInfo::location() 和 QLibraryInfo::Location。请改用新的 API <a href="https://doc-snapshots.qt.io/qt6-dev/qlibraryinfo.html#path" target="_blank" rel="noopener">QLibraryInfo::path</a> () 和<a href="https://doc-snapshots.qt.io/qt6-dev/qlibraryinfo.html#LibraryPath-enum" target="_blank" rel="noopener">QLibraryInfo::LibraryPath</a>。</p>
<h2 id="11、Qt-状态机框架"><a href="#11、Qt-状态机框架" class="headerlink" title="11、Qt 状态机框架"></a>11、Qt 状态机框架</h2><p><a href="https://doc-snapshots.qt.io/qt6-dev/qtstatemachine-index.html" target="_blank" rel="noopener">Qt 状态机</a>被移入 Qt SCXML 模块（即将重命名为 Qt 状态机），因此它不再是 Qt 核心的一部分。Qt Core 内部很少有交叉依赖项，最终导致了这个决定。</p>
<h2 id="12、使用-Qt5Compat-模块"><a href="#12、使用-Qt5Compat-模块" class="headerlink" title="12、使用 Qt5Compat 模块"></a>12、使用 Qt5Compat 模块</h2><p>要使用<a href="https://doc-snapshots.qt.io/qt6-dev/qtcore5-index.html" target="_blank" rel="noopener">Qt5Compat</a>模块，您需要在包含路径中使用它的头文件进行构建，并链接到它的库。如果您使用的是<a href="https://doc-snapshots.qt.io/qt6-dev/resources.html#qmake" target="_blank" rel="noopener">qmake</a>，请将以下内容添加到您的<code>.pro</code>文件中：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += core5compat</span><br></pre></td></tr></table></figure>
<p><a href="https://doc-snapshots.qt.io/qt6-dev/cmake-manual.html" target="_blank" rel="noopener">如果您使用cmake</a>构建应用程序或库，请将以下内容添加到您的<code>CMakeList.txt</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC_LIBRARIES</span><br><span class="line">    Qt::Core5Compat</span><br></pre></td></tr></table></figure>
<h1 id="七、从-Qt-5-移植"><a href="#七、从-Qt-5-移植" class="headerlink" title="七、从 Qt 5 移植"></a>七、从 Qt 5 移植</h1><p>在开发 Qt 6 时，与 Qt 5 的源代码兼容性一直是我们工作的关键部分。有一些地方我们不得不在某种程度上打破这种兼容性，以进行一些必需的架构更改或为我们带来一些巨大的性能优势。</p>
<p>在大多数情况下，从 Qt 5 移植到 Qt 6 应该很简单。在Qt的6移植指南 列出了所需要的步骤，并具有更多的信息。您还可以从我们的合作伙伴之一或我们的顾问那里获得移植帮助。</p>
<p>移植到 Qt 6 的典型步骤是：</p>
<ul>
<li>检查您是否使用了受支持的编译器和平台版本</li>
<li>首先在 Qt 6 模式下使用 Qt 5.15 编译（使用 QT_DISABLE_DEPRECATED_BEFORE 宏）</li>
<li>然后用 Qt 6.x 编译 - 如果需要，在移植阶段利用兼容性模块</li>
</ul>
<p>有了这些，您就可以在 Qt 6 上运行应用程序，并可以开始使用它提供的所有新特性和功能。例如，如果您的应用程序使用 QML，请运行 qmlint 工具并修复它给出的警告。</p>
<h2 id="1、变化总括"><a href="#1、变化总括" class="headerlink" title="1、变化总括"></a>1、变化总括</h2><p>1）. 增加了很多轮子，同时原有模块拆分的也更细致，估计为了方便拓展个管理。</p>
<p>2）. 把一些过度封装的东西移除了（比如同样的功能有多个函数），保证了只有一个函数执行该功能。<br>3）. 把一些Qt5中兼容Qt4的方法废弃了，必须用Qt5中对应的新的函数。<br>4）. 跟随时代脚步，增加了不少新特性以满足日益增长的客户需求。<br>5）. 对某些模块和类型及处理进行了革命性的重写，运行效率提高不少。<br>6）. 有参数类型的变化，比如 long <em> 到 qintptr </em> 等，更加适应后续的拓展以及同时对32 64位不同系统的兼容。<br>7）. 源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。<br>8）. 我测试的都是QWidget部分，quick部分没有测试，估计quick部分更新可能会更多。<br>9）. 强烈建议暂时不要用Qt6.0到Qt6.2之间的版本，一些模块还缺失，相对来说BUG也比较多，推荐6.2版本开始正式迁移。</p>
<h2 id="2、移植案例"><a href="#2、移植案例" class="headerlink" title="2、移植案例"></a>2、移植案例</h2><h3 id="新的-Qt-模块状态机"><a href="#新的-Qt-模块状态机" class="headerlink" title="新的 Qt 模块状态机"></a>新的 Qt 模块状态机</h3><p>具有 QStateMachine、QState 和 QFinalState 等类的状态机框架已从模块 Core 移至新模块 StateMachine。我们<code>StateMachine</code>在<em>CMakeLists.txt</em>文件中添加<code>find_package</code>调用和调用。<code>Qt6::StateMachine`</code>target_link_libraries`</p>
<h3 id="Error-no-match-for-‘operator-lt-’-operand-types-are-‘const-QVariant’-and-‘const-QVariant’"><a href="#Error-no-match-for-‘operator-lt-’-operand-types-are-‘const-QVariant’-and-‘const-QVariant’" class="headerlink" title="Error: no match for ‘operator&lt;’ (operand types are ‘const QVariant’ and ‘const QVariant’)"></a>Error: no match for ‘operator&lt;’ (operand types are ‘const QVariant’ and ‘const QVariant’)</h3><p><em>问题</em>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QMap</span>&lt;<span class="selector-tag">std</span><span class="selector-pseudo">::pair</span>&lt;<span class="selector-tag">QString</span>, <span class="selector-tag">QVariant</span>&gt;, <span class="selector-tag">QObject</span> *&gt; <span class="selector-tag">m_entities</span>;</span><br><span class="line"><span class="selector-tag">m_impl-</span>&gt;<span class="selector-tag">m_entities</span><span class="selector-class">.insert</span>(<span class="selector-tag">it</span><span class="selector-class">.key</span>(), <span class="selector-tag">it</span><span class="selector-class">.value</span>());</span><br></pre></td></tr></table></figure>
<p>该函数返回一个&gt; 类型的对象，它与 . 的键类型相同。QMap 需要在键类型上定义才能知道在哪里插入新值。<code>it.key()`</code>std::pair&lt;QString, QVariant<code>QMap</code>operator&lt;`</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap<span class="string">`比较该对`</span>p1<span class="string">`是否小于`</span>p2<span class="string">`，两者都`</span>p1<span class="string">`具有`</span>p2<span class="string">`类型。如果等于，则比较必须计算。G++-9 正确地抱怨没有为s 定义。G++-7 忽略了 s的缺失。`</span>std::pair&lt;QString, QVariant&gt;<span class="string">``</span>p1.first<span class="string">``</span>p2.first<span class="string">``</span>p1.second &lt; p2.second<span class="string">``</span>operator&lt;<span class="string">``</span>QVariant<span class="string">``</span>operator&lt;<span class="string">``</span>QVariant</span><br></pre></td></tr></table></figure>
<p><em>修复</em>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QMap</span>&lt;<span class="selector-tag">std</span><span class="selector-pseudo">::pair</span>&lt;<span class="selector-tag">QString</span>, <span class="selector-tag">QString</span>&gt;, <span class="selector-tag">QObject</span> *&gt; <span class="selector-tag">m_entities</span>;</span><br><span class="line"><span class="selector-tag">m_impl-</span>&gt;<span class="selector-tag">m_entities</span><span class="selector-class">.insert</span>(<span class="selector-tag">it</span><span class="selector-class">.key</span>(), <span class="selector-tag">it</span><span class="selector-class">.value</span>());</span><br></pre></td></tr></table></figure>
<p>将 a<code>QVariant</code>转换为<code>QString</code>with适用于. 由于仅对其键的第二个元素使用支持的类型，我们可以安全地替换键类型中的by 。<code>QVariant::toString()`</code>QVariant<code>m_entities</code>QVariant<code></code>QString`</p>
<h3 id="Error-QTextCodec-No-such-file-or-directory"><a href="#Error-QTextCodec-No-such-file-or-directory" class="headerlink" title="Error: QTextCodec: No such file or directory"></a>Error: QTextCodec: No such file or directory</h3><p><em>问题</em>：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line">...</span><br><span class="line">QTextStream is&#123;&amp;csvFile&#125;;</span><br><span class="line">is.setCodec(<span class="symbol">QTextCodec::</span>codecForName(<span class="string">"ISO-8859-1"</span>));</span><br></pre></td></tr></table></figure>
<p>该类<code>QTextCodec</code>已从 Qt 6 中删除，并被新的类所取代<code>QStringConverter</code>。同样，类<code>QTextEncoder</code>and<code>QTextDecoder</code>被 and 取代<code>QStringEncoder</code>（<code>QStringDecoder</code>参见这篇<a href="https://www.qt.io/blog/porting-from-qt-5-to-qt-6-using-qt5compat-library" target="_blank" rel="noopener">文章</a>）。使用任何旧类的代码都无法编译。</p>
<p><em>修复</em>：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringConverter&gt;</span></span></span><br><span class="line">...</span><br><span class="line">QTextStream is&#123;&amp;csvFile&#125;;</span><br><span class="line">is.setEncoding(<span class="symbol">QStringConverter::</span>Latin1);</span><br></pre></td></tr></table></figure>
<p>我们包括替换类的标题<code>QStringConverter</code>。搜索 的功能最<code>QStringConverter</code>有<code>setEncoding</code>可能替代<code>setCodec</code>. 了解 ISO-8859-1 是 Latin1 的正式名称有助于我们<code>setEncoding</code>使用正确的常量调用。<code>QStringConverter::Latin1</code></p>
<h3 id="Error-QRegExp-No-such-file-or-directory"><a href="#Error-QRegExp-No-such-file-or-directory" class="headerlink" title="Error: QRegExp: No such file or directory"></a>Error: QRegExp: No such file or directory</h3><p>问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QRegExp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In anonymous namespace</span></span><br><span class="line"><span class="function">QRegExp &amp;<span class="title">rxHexFilename</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> QRegExp <span class="title">rx</span><span class="params">(<span class="string">"_(A\\d\\d)_V_(\\d\\d)_(\\d\\d)\\.hex$"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In constructor</span></span><br><span class="line"><span class="keyword">auto</span> pos = rxHexFilename().indexIn(fileName);</span><br><span class="line"><span class="keyword">auto</span> ecuName = rxHexFilename().cap(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span> || ...) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_version = QString(<span class="string">"v%1.%2"</span>)</span><br><span class="line">    .arg(rxHexFilename().cap(<span class="number">2</span>).toUInt())</span><br><span class="line">    .arg(rxHexFilename().cap(<span class="number">3</span>).toUInt());</span><br><span class="line">m_ecuType = fileName.left(fileName.size() - </span><br><span class="line">    rxHexFilename().matchedLength());</span><br></pre></td></tr></table></figure>
<p>替换<code>QRegExp</code>——Qt 4 的遗物——<code>QRegularExpression</code>自 Qt 5.0 以来一直在酝酿之中。<code>QRegularExpression</code>是在 Qt 6 中使用正则表达式的唯一方法。界面发生了很大变化。</p>
<p>修复：</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QRegularExpression&gt;</span><br><span class="line"></span><br><span class="line">// In anonymous namespace</span><br><span class="line">const QRegularExpression rxHexFilename(<span class="string">"_(A\\d\\d)_V_(\\d\\d)_(\\d\\d)\\.hex$"</span>);</span><br><span class="line"></span><br><span class="line">// In <span class="built_in">constructor</span></span><br><span class="line"><span class="built_in">auto</span> <span class="keyword">match</span> = rxHexFilename.<span class="keyword">match</span>(fileName);</span><br><span class="line"><span class="built_in">auto</span> ecuName = <span class="keyword">match</span>.captured(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">match</span>.hasMatch() |<span class="type">| ...) &#123;</span></span><br><span class="line"><span class="type">    return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_version = QString(<span class="string">"v%1.%2"</span>)</span><br><span class="line">    .arg(<span class="keyword">match</span>.captured(<span class="number">2</span>).toUInt())</span><br><span class="line">    .arg(<span class="keyword">match</span>.captured(<span class="number">3</span>).toUInt());</span><br><span class="line">m_ecuType = fileName.<span class="built_in">left</span>(fileName.size() - </span><br><span class="line">    <span class="keyword">match</span>.capturedLength(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>将字符串与正则表达式匹配的函数有它的自然名称：（<code>match</code>而不是<code>indexIn</code>）。它返回一个<code>QRegularExpressionMatch</code>对象<code>match</code>而不是索引。我们通过调用来检索<code>nth</code>捕获的子字符串。match.hasMatch() 告诉我们字符串是否匹配正则表达式。<code>match.captured(nth)</code></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QRegExp<span class="type">::matchedLength</span><span class="string">`返回匹配完整正则表达式的子字符串的长度。此子字符串与第 0 个捕获的子字符串相同，其长度为。`</span><span class="keyword">match</span>.captured(<span class="number">0</span>)<span class="string">``</span><span class="keyword">match</span>.capturedLength(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Error-‘class-QString’-has-no-member-named-‘midRef"><a href="#Error-‘class-QString’-has-no-member-named-‘midRef" class="headerlink" title="Error: ‘class QString’ has no member named ‘midRef"></a>Error: ‘class QString’ has no member named ‘midRef</h3><p><em>问题</em>：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">subDev</span> = m_deviceName.midRef(splitPos + 1).toLatin1();</span><br></pre></td></tr></table></figure>
<p>该函数在 Qt 6 中已过时。该函数也是如此。<code>QString::midRef`</code>QString::leftRef`</p>
<p><em>修复</em>：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">subDev</span> = m_deviceName.mid(splitPos + 1).toLatin1();</span><br></pre></td></tr></table></figure>
<p>我们将和分别替换为和。<code>QString::midRef`</code>QString::leftRef<code>QString::mid</code>QString::left`</p>
<h3 id="Error-cannot-convert-‘QString’-to-‘const-QFileInfo-amp-’"><a href="#Error-cannot-convert-‘QString’-to-‘const-QFileInfo-amp-’" class="headerlink" title="Error: cannot convert ‘QString’ to ‘const QFileInfo&amp;’"></a>Error: cannot convert ‘QString’ to ‘const QFileInfo&amp;’</h3><p><em>问题</em>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString extractVersion(<span class="name">const</span> QFileInfo <span class="symbol">&amp;info</span>) const<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">QString fileName(...)<span class="comment">;</span></span><br><span class="line">auto version = extractVersion(<span class="name">fileName</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在 Qt 5 中，该函数使用构造函数<code>extractVersion</code>将 隐式转换<code>QString</code> <code>filename</code>为<code>QFileInfo</code>对象。在 Qt 6 中，这个构造函数被标记为，它阻止了隐式转换。<code>QFileInfo(const QString &amp;)`</code>explicit`</p>
<p><em>修复</em>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString extractVersion(<span class="name">const</span> QFileInfo <span class="symbol">&amp;info</span>) const<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">QString fileName(...)<span class="comment">;</span></span><br><span class="line">auto version = extractVersion(<span class="name">QFileInfo</span>(<span class="name">fileName</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>我们通过显式调用构造函数来消除错误。<code>QFileInfo(const QString &amp;)</code></p>
<h3 id="Error-invalid-application-of-‘sizeof’-to-incomplete-type-‘IntegerRangeModel’"><a href="#Error-invalid-application-of-‘sizeof’-to-incomplete-type-‘IntegerRangeModel’" class="headerlink" title="Error: invalid application of ‘sizeof’ to incomplete type ‘IntegerRangeModel’"></a>Error: invalid application of ‘sizeof’ to incomplete type ‘IntegerRangeModel’</h3><p><em>问题</em>：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">IntegerRangeModel</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DateTimeModel</span> : public <span class="type">QObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    <span class="type">Q_OBJECT</span></span></span><br><span class="line"><span class="class">    <span class="type">Q_PROPERTY</span>(<span class="type">IntegerRangeModel</span>* <span class="title">days</span> <span class="type">READ</span> <span class="title">days</span> <span class="type">CONSTANT</span>)</span></span><br></pre></td></tr></table></figure>
<p>的前向声明对于Qt 5<code>IntegerRangeModel</code>中的定义来说已经足够好了，因为它被声明为一个指针。Qt 6 添加了一个静态断言。另一条错误消息记录了对静态断言的违反：<code>Q_PROPERTY`</code>days`</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static_assert(<span class="name">sizeof</span>(<span class="name">T</span>), <span class="string">"Type argument of Q_PROPERTY or Q_DECLARE_METATYPE(T*) must be fully defined"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><em>修复</em>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IntegerRangeModel.h"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateTimeModel</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PROPERTY(IntegerRangeModel* days READ days CONSTANT)</span><br></pre></td></tr></table></figure>
<p>我们通过包含头文件<code>IntegerRangeModel</code>而不是前向声明来消除错误消息<code>IntegerRangeModel</code>。</p>
<h3 id="Warning-‘Type’-is-deprecated-Use-QMetaType-Type-instead-Wdeprecated-declarations"><a href="#Warning-‘Type’-is-deprecated-Use-QMetaType-Type-instead-Wdeprecated-declarations" class="headerlink" title="Warning: ‘Type’ is deprecated: Use QMetaType::Type instead. [-Wdeprecated-declarations]"></a>Warning: ‘Type’ is deprecated: Use QMetaType::Type instead. [-Wdeprecated-declarations]</h3><p><em>问题</em>：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityColumn(<span class="keyword">const</span> QString &amp;<span class="keyword">name</span>, QVariant::<span class="keyword">Type</span> <span class="keyword">type</span>, ...)</span><br></pre></td></tr></table></figure>
<p>枚举列出了可以存储在. 它大致是 enumeration 的一个子集，它列出了 Qt 元对象系统已知的类型。建议自己替换。不再包含在 Qt 6 中。<code>QVariant::Type`</code>QVariant<code>QMetaType::Type</code>QVariant::Type<code>QMetaType::Type</code>QVariant::Type`</p>
<p><em>修复</em>：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityColumn(<span class="keyword">const</span> QString &amp;<span class="keyword">name</span>, QMetaType::<span class="keyword">Type</span> <span class="keyword">type</span>, ...)</span><br></pre></td></tr></table></figure>
<p>在 Qt 6 中，我们使用而不是. 我们还必须分别替换过时的枚举常量，例如,和,和。<code>QMetaType::Type`</code>QVariant::Type<code>QVariant::Invalid</code>QVariant::UInt<code>QVariant::Bool</code>QMetaType::UnknownType<code>QMetaType::UInt</code>QMetaType::Bool`</p>
<h3 id="Error-cannot-convert-‘QVariant-Type’-to-‘QMetaType-Type’"><a href="#Error-cannot-convert-‘QVariant-Type’-to-‘QMetaType-Type’" class="headerlink" title="Error: cannot convert ‘QVariant::Type’ to ‘QMetaType::Type’"></a>Error: cannot convert ‘QVariant::Type’ to ‘QMetaType::Type’</h3><p><em>问题</em>：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool typesAreAffine(QMetaType<span class="type">::Type</span> sqlType, <span class="params">...</span>) const;</span><br><span class="line"></span><br><span class="line">QSqlField tableColumn = <span class="params">...</span>;</span><br><span class="line"><span class="keyword">if</span> (!typesAreAffine(tableColumn.<span class="keyword">type</span>(), <span class="params">...</span>)) <span class="params">...</span></span><br></pre></td></tr></table></figure>
<p>最初， 的第一个参数<code>typesAreAffine</code>具有 type ，它被前面的迁移步骤替换。具有返回类型的函数在 Qt 6 中不存在。<code>QVariant::Type`</code>QMetaType::Type<code>QSqlField::type</code>QVariant::Type`</p>
<p><em>修复</em>：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool typesAreAffine(QMetaType<span class="type">::Type</span> sqlType, <span class="params">...</span>) const;</span><br><span class="line"></span><br><span class="line">QSqlField tableColumn = <span class="params">...</span>;</span><br><span class="line"><span class="keyword">if</span> (!typesAreAffine(QMetaType<span class="type">::Type</span>(tableColumn.metaType().id()), <span class="params">...</span>)) <span class="params">...</span></span><br></pre></td></tr></table></figure>
<p>我们用 Qt 6 函数替换现在已过时的 Qt 5 函数。返回一个对象。我们使用 检索对象的类型 ID ，它返回一个而不是 a来为自定义元类型打开。从整数创建一个枚举常量。<code>QSqlField::metaType()`</code>QSqlField::type()<code>QSqlField::metaType()</code>QMetaType<code>QMetaType</code>id()<code>int</code>QMetaType::Type<code>QMetaType::Type(typeID)</code>typeID`</p>
<h3 id="Error-warning-conversion-from-‘qsizetype’-aka-‘long-long-int’-to-‘int’-may-change-value-Wconversion"><a href="#Error-warning-conversion-from-‘qsizetype’-aka-‘long-long-int’-to-‘int’-may-change-value-Wconversion" class="headerlink" title="Error: warning: conversion from ‘qsizetype’ {aka ‘long long int’} to ‘int’ may change value [-Wconversion]"></a>Error: warning: conversion from ‘qsizetype’ {aka ‘long long int’} to ‘int’ may change value [-Wconversion]</h3><p><em>问题</em>：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QFileInfo&gt; m_dirEntries.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DirectoryModel::rowCount(<span class="keyword">const</span> QModelIndex &amp;<span class="keyword">parent</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(<span class="keyword">parent</span>)</span><br><span class="line">    <span class="keyword">return</span> m_impl-&gt;m_dirEntries.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 Qt 6.0 开始，具有返回类型，相当于. DirectoryModel 类间接派生自，它像这样声明纯虚函数：<code>QList&lt;T&gt;::size()`</code>qsizetype<code>long long int</code>QAbstractItemModel<code></code>rowCount`</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">rowCount</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="keyword">const</span> </span>= <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>该<code>return</code>语句可以将一个值缩小为一个值，这可能会改变该值。似乎 Qt 开发人员忘记了将from的返回类型更改为.<code>long long int`</code>int<code>rowCount</code>int<code></code>qsizetype`</p>
<p>类似<code>beginInsertRows</code>,<code>beginRemoveRows</code>和<code>beginMoveRows</code>的函数<code>beginInsertColumns</code>也接受<code>int</code>-type 参数。我们可能还需要注意缩小转化率。</p>
<p><em>修复</em>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QFileInfo&gt; m_dirEntries.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DirectoryModel::rowCount(<span class="keyword">const</span> QModelIndex &amp;parent) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(parent)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_impl-&gt;m_dirEntries.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有时没有办法绕过静态演员表。这是其中之一。我们将值强制<code>qsizetype</code>转换为 int<code>value</code>并消除错误。</p>
<h3 id="Warning-conversion-from-‘size-t’-aka-‘long-unsigned-int’-to-‘uint’-aka-‘unsigned-int’-may-change-value-Wconversion"><a href="#Warning-conversion-from-‘size-t’-aka-‘long-unsigned-int’-to-‘uint’-aka-‘unsigned-int’-may-change-value-Wconversion" class="headerlink" title="Warning: conversion from ‘size_t’ {aka ‘long unsigned int’} to ‘uint’ {aka ‘unsigned int’} may change value [-Wconversion]"></a>Warning: conversion from ‘size_t’ {aka ‘long unsigned int’} to ‘uint’ {aka ‘unsigned int’} may change value [-Wconversion]</h3><p>问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitId</span> :</span> quint16 &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> uint <span class="title">qHash</span><span class="params">(UnitId unit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qHash(<span class="keyword">static_cast</span>&lt;quint16&gt;(unit));</span><br><span class="line">&#125;</span><br><span class="line">qHash``uint`函数在 Qt <span class="number">5</span> 中返回值`uint`，其中. 在 Qt <span class="number">6</span> 中，它们返回值，其中是. 语句中的函数是一个内置的散列函数。它返回一个值，该值可以通过自定义散列函数缩小为一个值。由于这可能会更改值，因此编译器会发出警告。`<span class="keyword">unsigned</span> <span class="keyword">int</span>``<span class="keyword">size_t</span>``<span class="keyword">size_t</span>``<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>``qHash``<span class="keyword">return</span>``<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>``<span class="keyword">unsigned</span> <span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>修复：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitId</span> :</span> quint16 &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> size_t <span class="title">qHash</span><span class="params">(UnitId unit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qHash(<span class="keyword">static_cast</span>&lt;quint16&gt;(unit));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将自定义散列函数的返回类型从<code>uint</code>更改为<code>size_t</code>。</p>
<h3 id="Warning-‘static-QQmlFileSelector-QQmlFileSelector-get-QQmlEngine-’-is-deprecated-Wdeprecated-declarations"><a href="#Warning-‘static-QQmlFileSelector-QQmlFileSelector-get-QQmlEngine-’-is-deprecated-Wdeprecated-declarations" class="headerlink" title="Warning: ‘static QQmlFileSelector QQmlFileSelector::get(QQmlEngine)’ is deprecated [-Wdeprecated-declarations]"></a>Warning: ‘static QQmlFileSelector<em> QQmlFileSelector::get(QQmlEngine</em>)’ is deprecated [-Wdeprecated-declarations]</h3><p><em>问题</em>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fs = QQmlFileSelector::<span class="built_in">get</span>(engine);</span><br><span class="line">fs-&gt;setExtraSelectors(&#123;<span class="string">"left"</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>静态函数返回 QML 上当前活动的文件选择器。它在 Qt 6 中已过时，因为它复制了构造函数提供的功能。<code>QQmlFileSelector::get`</code>engine<code></code>QQmlFileSelector`</p>
<p><em>修复</em>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto fs = new QQmlFileSelector(<span class="name">engine</span>)<span class="comment">;</span></span><br><span class="line">fs-&gt;setExtraSelectors(&#123;<span class="string">"left"</span>&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在堆上创建<code>QQmlFileSelector</code>对象与调用. 我们必须在堆上创建对象，因为构造函数参数拥有文件选择器的所有权。<code>QQmlFileSelector::get`</code>engine`</p>
<h3 id="Error-using-typedef-name-‘using-QStringList-class-QList’-after-‘class"><a href="#Error-using-typedef-name-‘using-QStringList-class-QList’-after-‘class" class="headerlink" title="Error: using typedef-name ‘using QStringList = class QList’ after ‘class"></a>Error: using typedef-name ‘using QStringList = class QList<qstring>’ after ‘class</qstring></h3><p><em>问题</em>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QStringList</span>;</span></span><br></pre></td></tr></table></figure>
<p>包含的 Qt 头文件介绍了类型定义。有问题的行向前声明了编译器不喜欢的这种类型定义。<code>using QStringList = class QList&lt;QString&gt;</code></p>
<p><em>修复</em>：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringList&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>我们通过包含头文件来替换前向声明。</p>
<h3 id="Error-‘QLatin1Literal’-was-not-declared-in-this-scope-did-you-mean-‘QStringLiteral’"><a href="#Error-‘QLatin1Literal’-was-not-declared-in-this-scope-did-you-mean-‘QStringLiteral’" class="headerlink" title="Error: ‘QLatin1Literal’ was not declared in this scope; did you mean ‘QStringLiteral’?"></a>Error: ‘QLatin1Literal’ was not declared in this scope; did you mean ‘QStringLiteral’?</h3><p><em>问题</em>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList errors<span class="comment">;</span></span><br><span class="line">Q_ASSERT_X(<span class="name">false</span>, __PRETTY_FUNCTION__, </span><br><span class="line">    errors.join(<span class="name">QLatin1Literal</span>(<span class="string">"; "</span>)).toUtf8())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p><code>QLatin1Literal</code> Qt 6 中不再存在。</p>
<p><em>修复</em>：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList errors<span class="comment">;</span></span><br><span class="line">Q_ASSERT_X(<span class="name">false</span>, __PRETTY_FUNCTION__, </span><br><span class="line">    errors.join(<span class="name">QLatin1String</span>(<span class="string">"; "</span>)).toUtf8())<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>我们替换<code>QLatin1Literal</code>为<code>QLatin1String</code>。</p>
<h3 id="Error-No-type-name-‘State’-in-QMediaPlayer"><a href="#Error-No-type-name-‘State’-in-QMediaPlayer" class="headerlink" title="Error: No type name ‘State’ in QMediaPlayer"></a>Error: No type name ‘State’ in QMediaPlayer</h3><p><em>问题：</em></p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">on</span>StateChanged(QMediaPlayer::State <span class="keyword">state</span>);</span><br><span class="line"></span><br><span class="line">connect(&amp;m_impl-&gt;m_player, &amp;QMediaPlayer::<span class="keyword">state</span>Changed,</span><br><span class="line">        m_impl, &amp;Impl::<span class="keyword">on</span>StateChanged);</span><br><span class="line"></span><br><span class="line">if (m_player.<span class="keyword">state</span>() != QMediaPlayer::PlayingState) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>我们用信号替换并连接插槽。我们还需要替换对by 的调用。<code>QMediaPlayer::State`</code>QMediaPlayer::PlaybackState<code>onStateChanged</code>QMediaPlayer::playbackStateChanged<code>QMediaPlayer::state()</code>QMediaPlayer::playbackState()`</p>
<p><em>修复：</em></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> onStateChanged(QMediaPlayer<span class="type">::PlaybackState</span> state);</span><br><span class="line"></span><br><span class="line">connect(&amp;m_impl-&gt;m_player, &amp;QMediaPlayer<span class="type">::playbackStateChanged</span>,</span><br><span class="line">        m_impl, &amp;Impl<span class="type">::onStateChanged</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_player.playbackState() != QMediaPlayer<span class="type">::PlayingState</span>) &#123; <span class="params">...</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Error-‘QMediaPlaylist’-No-such-file-or-directory"><a href="#Error-‘QMediaPlaylist’-No-such-file-or-directory" class="headerlink" title="Error: ‘QMediaPlaylist’: No such file or directory"></a>Error: ‘QMediaPlaylist’: No such file or directory</h3><p><em>问题：</em></p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMediaPlaylist&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><a href="https://doc.qt.io/qt-6/qtmultimedia-changes-qt6.html" target="_blank" rel="noopener">Changes to Qt Multimedia</a>页面通知我们该类<code>QMediaPlaylist</code>已从 Qt 6 中删除。当显示信息、警告或错误对话框时，应用程序会播放不同的 MP3 文件。它将<code>QMediaPlaylist</code>带有正确 MP3 文件的 a 传递给<code>QMediaPlayer</code>. 用户还可以更改播放音量。</p>
<p><em>修复：</em></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMediaPlaylist<span class="string">`替换为。音量不能直接用 改变，但可以用 间接改变。以下有关 QMediaPlayer 和 QMediaPlaylist 的错误消息告诉我们要修复什么。`</span>QMediaPlayer::setSource<span class="string">``</span>QMediaPlayer::setVolume<span class="string">``</span>QAudioOutput::setVolume</span><br></pre></td></tr></table></figure>
<h3 id="Error-No-member-named-‘setVolume’-in-‘QMediaPlayer’"><a href="#Error-No-member-named-‘setVolume’-in-‘QMediaPlayer’" class="headerlink" title="Error: No member named ‘setVolume’ in ‘QMediaPlayer’"></a>Error: No member named ‘setVolume’ in ‘QMediaPlayer’</h3><p><em>问题：</em></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_player.setVolume(<span class="number">80</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>Qt 6 将函数<code>setVolume</code>和<code>volume</code>从<code>QMediaPlayer</code>移至<code>QAudioOutput</code>.</p>
<p><em>修复：</em></p>
<p>使用的客户端类必须在其构造函数中向该对象<code>QMediaPlayer</code>注册一个<code>QAudioOutput</code>对象。我们必须告诉对象它应该在哪个扬声器上播放 MP3 文件。我们可以使用 访问默认扬声器。这对于只有一个扬声器的终端硬件来说已经足够了。<code>QMediaPlayer`</code>m_player<code>QAudioOutput</code>QMediaDevices::defaultAudioOutput`</p>
<p>客户端类将音量设置为默认值（例如，0.8）。请注意，新的采用 0.0 到 1.0 之间的浮点值作为参数，而旧的采用 0 到 100 之间的整数。<code>QAudioOutput::setVolume`</code>QMediaPlayer::setVolume`</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto audioOut = new QAudioOutput&#123;&#125;<span class="comment">;</span></span><br><span class="line">audioOut-&gt;setDevice(QMediaDevices::defaultAudioOutput())<span class="comment">;</span></span><br><span class="line">audioOut-&gt;setVolume(<span class="number">0</span>.<span class="number">8</span>f)<span class="comment">;</span></span><br><span class="line">m_player.setAudioOutput(audioOut)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>客户端类的函数改变音量如下：<code>setVolume(int vol)</code></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_player.audioOutput<span class="function"><span class="params">()</span>-&gt;</span>setVolume(<span class="number">0.8f</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Error-QMediaPlayer-cannot-play-back-a-QMediaPlaylist-any-more"><a href="#Error-QMediaPlayer-cannot-play-back-a-QMediaPlaylist-any-more" class="headerlink" title="Error: QMediaPlayer cannot play back a QMediaPlaylist any more"></a>Error: QMediaPlayer cannot play back a QMediaPlaylist any more</h3><p><em>问题：</em></p>
<p>当然，标题错误信息并不是真正的编译器错误。由于 QMediaPlaylist 从 Qt 6 中删除，以下错误类别的播放功能不再编译。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">AudioService</span><span class="selector-pseudo">::Impl</span><span class="selector-pseudo">::playFeedback(int</span> <span class="selector-tag">category</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">m_playlist</span><span class="selector-class">.addMedia</span>(m_audioFiles[category]);</span><br><span class="line">    <span class="selector-tag">m_player</span><span class="selector-class">.play</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">m_audioFiles</span><span class="selector-attr">[category]</span>`返回给定错误的 <span class="selector-tag">MP3</span> 文件的 <span class="selector-tag">QRC</span> <span class="selector-tag">URL</span> `<span class="selector-tag">category</span>`。例如，它返回类别 <span class="selector-tag">2</span>。`<span class="selector-tag">QUrl</span>(<span class="string">"qrc:/Can/Audio/ding.mp3"</span>)</span><br></pre></td></tr></table></figure>
<p><em>修复：</em></p>
<p>为给定播放 MP3 文件的修改函数<code>category</code>如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AudioService::Impl::playFeedback(<span class="keyword">int</span> category)</span><br><span class="line">&#123;</span><br><span class="line">    m_player.setSource(m_audioFiles[category]);</span><br><span class="line">    m_player.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="QML-警告、错误和改进"><a href="#QML-警告、错误和改进" class="headerlink" title="QML 警告、错误和改进"></a>QML 警告、错误和改进</h3><h4 id="Remove-versions-from-import-statements"><a href="#Remove-versions-from-import-statements" class="headerlink" title="Remove versions from import statements"></a>Remove versions from import statements</h4><p><em>问题：</em></p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick 2.15</span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls 2.15</span><br><span class="line"><span class="keyword">import</span> Ag.Models 1.0</span><br></pre></td></tr></table></figure>
<p>Qt 5 需要导入模块的版本。Qt 6 不会抱怨这些版本，但它不再需要它们。</p>
<p><em>使固定：</em></p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick</span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls</span><br><span class="line"><span class="keyword">import</span> Ag.Models</span><br></pre></td></tr></table></figure>
<p>在 Qt 6 中只导入一个没有版本的模块就足够了。我们从所有导入语句中删除了版本。</p>
<h4 id="警告：未声明参数“page”。不推荐将参数注入信号处理程序。"><a href="#警告：未声明参数“page”。不推荐将参数注入信号处理程序。" class="headerlink" title="警告：未声明参数“page”。不推荐将参数注入信号处理程序。"></a>警告：未声明参数“page”。不推荐将参数注入信号处理程序。</h4><p><em>问题：</em></p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: RDirectBar.qml</span></span><br><span class="line">Pane </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">signal</span><span class="string"> selectedPage</span>(<span class="built_in">url</span> page, <span class="built_in">bool</span> fullscreen)</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: main.qml</span></span><br><span class="line">RDirectBar</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">onSelectedPage</span>: &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>信号在 的实例化中<code>selectedPage</code>连接到信号处理程序。Qt 6 接受带有警告的旧式信号处理程序。<code>onSelectedPage`</code>RDirectBar`</p>
<p><em>使固定：</em></p>
<p>新方法是使用箭头函数或匿名函数（参见Qt 6.2 文档中的<a href="https://doc.qt.io/qt-6/qtqml-syntax-signals.html#signal-parameters" target="_blank" rel="noopener">信号参数</a>）。我们在 C++ 中称它们为 lambda 函数。</p>
<h2 id="3、移植总结"><a href="#3、移植总结" class="headerlink" title="3、移植总结"></a>3、移植总结</h2><p>1）. 万能方法：安装5.15版本，定位到报错的函数，切换到源码头文件，可以看到对应提示字样 QT_DEPRECATED_X(“Use sizeInBytes”) 和新函数。按照这个提示类修改就没错，一些函数是从Qt5.7 5.9 5.10等版本新增加的，可能你的项目还用的Qt4的方法，但是Qt6以前都兼容这些旧方法，到了Qt6就彻底需要用新方法了。<br>2）. Qt6对core这个核心类进行了拆分，多出来core5compat，因此你需要在pro增加对应的模块已经代码中引入对应的头文件。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pro文件引入模块</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, <span class="number">5</span>): QT += core5compat</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore5Compat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>（1）. 默认Qt6开启了高分屏支持，界面会变得很大，甚至字体发虚，很多人会不习惯，因为这种模式如果程序很多坐标计算没有采用devicePixelRatio进行运算的话，100%会出现奇奇怪怪的问题，因为坐标不准确了。要取消这种效果可以设置高分屏缩放因子。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="symbol">    QGuiApplication:</span>:setHighDpiScaleFactorRoundingPolicy(<span class="symbol">Qt::</span><span class="symbol">HighDpiScaleFactorRoundingPolicy::</span>Floor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>（1）. 原有的随机数函数提示用QRandomGenerator替代，为了兼容所有qt版本，改动最小的办法是直接用c++中的随机数，比如qsrand函数换成srand，qrand函数换成rand，查看过源代码，其实封装的就是c++中的随机数，很多类似的封装比如qSin封装的sin。<br>（2）. QColor的 light 改成 lighter ，dark 改成 darker，其实 lighter、darker 这两个方法以前一直有。<br>（3）. QFontMetricsF 中的 fm.width 换成 fm.horizontalAdvance ，从5.11开始用新函数。<br>（4）. QPalette调色板枚举值，Foreground = WindowText, Background = Window，其中 Foreground 和 Background 没有了，要用 WindowText 和 Window 替代，以前就有。类似的还有 setTextColor 改成了 setForeground 。<br>（5）. QWheelEvent的 delta() 改成 angleDelta().y()，pos() 改成 position() 。<br>（6）. svg模块拆分出来了svgwidgets，如果用到了该模块则需要在pro增加 QT += svgwidgets 。<br>（7）. qlayout中的 margin() 函数换成 contentsMargins().left()，查看源码得知以前的 margin() 返回的就是 contentsMargins().left()，在四个数值一样的时候，默认四个数值就是一样。类似的还有setMargin移除了，统统用setContentsMargins。<br>（8）. 之前 QChar c = 0xf105 全部要改成强制转换 QChar c = (QChar)0xf105，不再有隐式转换，不然编译报错提示error: conversion from ‘int’ to ‘QChar’ is ambiguous 。<br>（9）. qSort等一些函数用回c++的 std::sort 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="built_in">std</span>::sort(ipv4s.begin(), ipv4s.end());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    qSort(ipv4s);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>（1）. Qt::WA_NoBackground 改成 Qt::WA_OpaquePaintEvent 。<br>（2）. QMatrix 类废弃了没有了，换成 QTransform ，函数功能基本一致，QTransform 类在Qt4就一直有。<br>（3）. QTime 计时去掉了，需要改成 QElapsedTimer ，QElapsedTimer 类在Qt4就一直有。<br>（4）. QApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"qscreen.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> deskGeometry qApp-&gt;primaryScreen()-&gt;geometry()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> deskGeometry2 qApp-&gt;primaryScreen()-&gt;availableGeometry()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"qdesktopwidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> deskGeometry qApp-&gt;desktop()-&gt;geometry()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> deskGeometry2 qApp-&gt;desktop()-&gt;availableGeometry()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>（1）. 获取当前屏幕索引以及尺寸需要分别处理。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前屏幕索引</span></span><br><span class="line"><span class="keyword">int</span> QUIHelper::getScreenIndex()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要对多个屏幕进行处理</span></span><br><span class="line">    <span class="keyword">int</span> screenIndex = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    <span class="keyword">int</span> screenCount = qApp-&gt;screens().count();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> screenCount = qApp-&gt;desktop()-&gt;screenCount();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">if</span> (screenCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//找到当前鼠标所在屏幕</span></span><br><span class="line">        QPoint pos = QCursor::pos();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; screenCount; ++i) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">            <span class="built_in">if</span> (qApp-&gt;screens().at(i)-&gt;geometry().contains(pos)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="built_in">if</span> (qApp-&gt;desktop()-&gt;screenGeometry(i).contains(pos)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                screenIndex = i;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> screenIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前屏幕尺寸区域</span></span><br><span class="line">QRect QUIHelper::getScreenRect(<span class="keyword">bool</span> <span class="built_in">available</span>)</span><br><span class="line">&#123;</span><br><span class="line">    QRect <span class="built_in">rect</span>;</span><br><span class="line">    <span class="keyword">int</span> screenIndex = QUIHelper::getScreenIndex();</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">available</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">        <span class="built_in">rect</span> = qApp-&gt;screens().at(screenIndex)-&gt;availableGeometry();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">rect</span> = qApp-&gt;desktop()-&gt;availableGeometry(screenIndex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="built_in">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">        <span class="built_in">rect</span> = qApp-&gt;screens().at(screenIndex)-&gt;geometry();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">rect</span> = qApp-&gt;desktop()-&gt;screenGeometry(screenIndex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">rect</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）. QRegExp类移到了core5compat模块，需要主动引入头文件 #include 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//设置限制只能输入数字+小数位</span></span><br><span class="line">    QString pattern = <span class="string">"^-?[0-9]+([.]&#123;1&#125;[0-9]+)&#123;0,1&#125;$"</span>;</span><br><span class="line">    <span class="comment">//设置IP地址校验过滤</span></span><br><span class="line">    QString pattern = <span class="string">"(2[0-5]&#123;2&#125;|2[0-4][0-9]|1?[0-9]&#123;1,2&#125;)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确切的说 QRegularExpression QRegularExpressionValidator 从5.0 5.1开始就有</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regExp</span><span class="params">(pattern)</span></span>;</span><br><span class="line">    QRegularExpressionValidator *validator = <span class="keyword">new</span> QRegularExpressionValidator(regExp, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function">QRegExp <span class="title">regExp</span><span class="params">(pattern)</span></span>;</span><br><span class="line">    QRegExpValidator *validator = <span class="keyword">new</span> QRegExpValidator(regExp, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    lineEdit-&gt;setValidator(validator);</span><br></pre></td></tr></table></figure>
<p>（1）. QWheelEvent构造参数和对应的计算方位函数变了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟鼠标滚轮</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="function">QWheelEvent <span class="title">wheelEvent</span><span class="params">(QPoint(<span class="number">0</span>, <span class="number">0</span>), -scal, Qt::LeftButton, Qt::NoModifier)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">QWheelEvent <span class="title">wheelEvent</span><span class="params">(QPointF(<span class="number">0</span>, <span class="number">0</span>), QPointF(<span class="number">0</span>, <span class="number">0</span>), QPoint(<span class="number">0</span>, <span class="number">0</span>), QPoint(<span class="number">0</span>, -scal), Qt::LeftButton, Qt::NoModifier, Qt::ScrollBegin, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">QApplication::sendEvent(widget, &amp;wheelEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标滚轮直接修改值</span></span><br><span class="line">QWheelEvent *whellEvent = (QWheelEvent *)event;</span><br><span class="line"><span class="comment">//滚动的角度,*8就是鼠标滚动的距离</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="keyword">int</span> degrees = whellEvent-&gt;delta() / <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">int</span> degrees = whellEvent-&gt;angleDelta().x() / <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//滚动的步数,*15就是鼠标滚动的角度</span></span><br><span class="line"><span class="keyword">int</span> steps = degrees / <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p>（1）. qVariantValue 改成 qvariant_cast ，qVariantSetValue(v, value) 改成了 v.setValue(val)。相当于退回到最原始的方法，查看qVariantValue源码封装的就是qvariant_cast。<br>（2）. QStyleOption的init改成了initFrom。<br>（3）. QVariant::Type 换成了 QMetaType::Type ，本身以前的 QVariant::Type 封装的就是 QMetaType::Type 。<br>（4）. QStyleOptionViewItemV2 V3 V4 之类的全部没有了，暂时可以用 QStyleOptionViewItem 替代。<br>（5）. QFont的 resolve 的一个重载函数换成了 resolveMask。<br>（6）. QSettings的 setIniCodec 方法移除了，默认就是utf8，不需要设置。<br>（7）. qcombobox 的 activated(QString) 和 currentIndexChanged(QString) 信号删除了，用int索引参数的那个，然后自己通过索引获取值。个人觉得这个没必要删除。<br>（8）. qtscript模块彻底没有了，尽管从Qt5时代的后期版本就提示为废弃模块，一致坚持到Qt6才正式废弃，各种json数据解析全部换成qjson类解析。<br>（9）. QByteArray 的 append indexOf lastIndexOf 等众多方法的QString参数重载函数废弃了，要直接传 QByteArray，就在原来参数基础上加上 .toUtf8() 。查看源码也看得到以前的QString参数也是转成.toUtf8()再去比较。<br>（10）. QDateTime的时间转换函数 toTime_t + setTime_t 名字改了，对应改成了 toSecsSinceEpoch + setSecsSinceEpoch ，这两个方法在Qt5.8时候新增加的。<br>（11）. QLabel的 pixmap 函数之前是指针 *pixmap() 现在换成了引用 pixmap()。<br>（12）. QTableWidget的 sortByColumn 方法移除了默认升序的方法，必须要填入第二个参数表示升序还是降序。<br>（13）. qtnetwork中的错误信号error换成了errorOccurred。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if (<span class="name">QT_VERSION</span> &gt;= QT_VERSION_CHECK(<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    connect(<span class="name">tcpSocket</span>, SIGNAL(<span class="name">errorOccurred</span>(<span class="name">QAbstractSocket</span>:<span class="symbol">:SocketError</span>)), this, SLOT(<span class="name">error</span>()))<span class="comment">;</span></span><br><span class="line">#else</span><br><span class="line">    connect(<span class="name">tcpSocket</span>, SIGNAL(<span class="name">error</span>(<span class="name">QAbstractSocket</span>:<span class="symbol">:SocketError</span>)), this, SLOT(<span class="name">error</span>()))<span class="comment">;</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>（1）. XmlPatterns模块木有了，全部用xml模块重新解析。<br>（2）. nativeEvent的参数类型变了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nativeEvent</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;eventType, <span class="keyword">void</span> *message, qintptr *result)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nativeEvent</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;eventType, <span class="keyword">void</span> *message, <span class="keyword">long</span> *result)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>（1）. QButtonGroup的buttonClicked信号中int参数的函数全部改名字叫idClicked。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    QButtonGroup *btnGroup = new QButtonGroup(<span class="name">this</span>)<span class="comment">;</span></span><br><span class="line">#if (<span class="name">QT_VERSION</span> &gt;= QT_VERSION_CHECK(<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    connect(<span class="name">btnGroup</span>, SIGNAL(<span class="name">idClicked</span>(<span class="name">int</span>)), ui-&gt;xstackWidget, SLOT(<span class="name">setCurrentIndex</span>(<span class="name">int</span>)))<span class="comment">;</span></span><br><span class="line">#else</span><br><span class="line">    connect(<span class="name">btnGroup</span>, SIGNAL(<span class="name">buttonClicked</span>(<span class="name">int</span>)), ui-&gt;xstackWidget, SLOT(<span class="name">setCurrentIndex</span>(<span class="name">int</span>)))<span class="comment">;</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>（1）. QWebEngineSettings之前是QWebEngineSettings::defaultSettings();现在改成了QWebEngineProfile::defaultProfile()-&gt;settings();通过查看之前的源码得知QWebEngineSettings::defaultSettings();封装的就是QWebEngineProfile::defaultProfile()-&gt;settings();因为Qt6去除了N多过度封装的函数。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    QWebEngineSettings *webSetting = <span class="symbol">QWebEngineProfile::</span>defaultProfile()-&gt;settings();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    QWebEngineSettings *webSetting = <span class="symbol">QWebEngineSettings::</span>defaultSettings();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2023/06/100670.html" class="pre-post btn btn-default" title='C/C++ 开源算法库'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">C/C++ 开源算法库</span>
        </a>
    
    
        <a href="/archives/2023/06/100683.html" class="next-post btn btn-default" title='什么情况下需要对数据库进行分库分表分区'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">什么情况下需要对数据库进行分库分表分区</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、前言"><span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Qt-6-的架构变化"><span class="toc-text">二、Qt 6 的架构变化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、添加模块"><span class="toc-text">三、添加模块</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、Qt-6-2-中的新功能"><span class="toc-text">四、Qt 6.2 中的新功能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、Qt-快速-3D"><span class="toc-text">1、Qt 快速 3D</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、QML工具"><span class="toc-text">2、QML工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、Qt多媒体"><span class="toc-text">3、Qt多媒体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、整个过程中的小改进"><span class="toc-text">4、整个过程中的小改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、Qt-Creator-和-Qt-Design-Studio"><span class="toc-text">5、Qt Creator 和 Qt Design Studio</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、新平台"><span class="toc-text">五、新平台</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六、Qt6-核心的变化"><span class="toc-text">六、Qt6 核心的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、容器类"><span class="toc-text">1、容器类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QHash、QMultiHash、QSet"><span class="toc-text">QHash、QMultiHash、QSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#qHash-签名"><span class="toc-text">qHash() 签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考文献的稳定性"><span class="toc-text">参考文献的稳定性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#移除-QHash-insertMulti"><span class="toc-text">移除 QHash::insertMulti</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QVector，QList"><span class="toc-text">QVector，QList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#API-更改"><span class="toc-text">API 更改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存布局"><span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参考文献的稳定性-1"><span class="toc-text">参考文献的稳定性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、在-Qt6-中查看类"><span class="toc-text">2、在 Qt6 中查看类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#总体概述"><span class="toc-text">总体概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QStringView示例上的视图类介绍"><span class="toc-text">QStringView示例上的视图类介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作为函数参数的视图"><span class="toc-text">作为函数参数的视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图操作函数"><span class="toc-text">视图操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非空终止的字符串和包含的字符串-39-0-39"><span class="toc-text">非空终止的字符串和包含的字符串 &#39;\0&#39;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#视图的所有权模型"><span class="toc-text">视图的所有权模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将-QStringView-转换为-QString"><span class="toc-text">将 QStringView 转换为 QString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重要笔记"><span class="toc-text">重要笔记</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、字符串相关类"><span class="toc-text">3、字符串相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QStringView-类"><span class="toc-text">QStringView 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QStringRef-类"><span class="toc-text">QStringRef 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、QMutex-和相关类"><span class="toc-text">4、QMutex 和相关类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、QFuture-及相关类"><span class="toc-text">5、QFuture 及相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QFuture-类"><span class="toc-text">QFuture 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QFuture-和其他类型之间的隐式转换"><span class="toc-text">QFuture 和其他类型之间的隐式转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#等式运算符"><span class="toc-text">等式运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QFuture-和-QFutureWatcher-的行为变化"><span class="toc-text">QFuture 和 QFutureWatcher 的行为变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QPromise-类"><span class="toc-text">QPromise 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、IO-类"><span class="toc-text">6、IO 类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QProcess-类"><span class="toc-text">QProcess 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、元类型系统"><span class="toc-text">7、元类型系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QVariant-类"><span class="toc-text">QVariant 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QMetaType-类"><span class="toc-text">QMetaType 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型注册"><span class="toc-text">类型注册</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8、正则表达式类"><span class="toc-text">8、正则表达式类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#QRegularExpression-类"><span class="toc-text">QRegularExpression 类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#通配符匹配"><span class="toc-text">通配符匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向前搜索"><span class="toc-text">向前搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向后搜索"><span class="toc-text">向后搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exactMatch-与-match-hasMatch"><span class="toc-text">exactMatch 与 match.hasMatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最小匹配"><span class="toc-text">最小匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不同的模式语法"><span class="toc-text">不同的模式语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#部分匹配"><span class="toc-text">部分匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局匹配"><span class="toc-text">全局匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unicode-属性支持"><span class="toc-text">Unicode 属性支持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QRegExp-类"><span class="toc-text">QRegExp 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9、序列化类"><span class="toc-text">9、序列化类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10、其他类"><span class="toc-text">10、其他类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11、Qt-状态机框架"><span class="toc-text">11、Qt 状态机框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12、使用-Qt5Compat-模块"><span class="toc-text">12、使用 Qt5Compat 模块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、从-Qt-5-移植"><span class="toc-text">七、从 Qt 5 移植</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、变化总括"><span class="toc-text">1、变化总括</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、移植案例"><span class="toc-text">2、移植案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#新的-Qt-模块状态机"><span class="toc-text">新的 Qt 模块状态机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-no-match-for-‘operator-lt-’-operand-types-are-‘const-QVariant’-and-‘const-QVariant’"><span class="toc-text">Error: no match for ‘operator&lt;’ (operand types are ‘const QVariant’ and ‘const QVariant’)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-QTextCodec-No-such-file-or-directory"><span class="toc-text">Error: QTextCodec: No such file or directory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-QRegExp-No-such-file-or-directory"><span class="toc-text">Error: QRegExp: No such file or directory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-‘class-QString’-has-no-member-named-‘midRef"><span class="toc-text">Error: ‘class QString’ has no member named ‘midRef</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-cannot-convert-‘QString’-to-‘const-QFileInfo-amp-’"><span class="toc-text">Error: cannot convert ‘QString’ to ‘const QFileInfo&amp;’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-invalid-application-of-‘sizeof’-to-incomplete-type-‘IntegerRangeModel’"><span class="toc-text">Error: invalid application of ‘sizeof’ to incomplete type ‘IntegerRangeModel’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Warning-‘Type’-is-deprecated-Use-QMetaType-Type-instead-Wdeprecated-declarations"><span class="toc-text">Warning: ‘Type’ is deprecated: Use QMetaType::Type instead. [-Wdeprecated-declarations]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-cannot-convert-‘QVariant-Type’-to-‘QMetaType-Type’"><span class="toc-text">Error: cannot convert ‘QVariant::Type’ to ‘QMetaType::Type’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-warning-conversion-from-‘qsizetype’-aka-‘long-long-int’-to-‘int’-may-change-value-Wconversion"><span class="toc-text">Error: warning: conversion from ‘qsizetype’ {aka ‘long long int’} to ‘int’ may change value [-Wconversion]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Warning-conversion-from-‘size-t’-aka-‘long-unsigned-int’-to-‘uint’-aka-‘unsigned-int’-may-change-value-Wconversion"><span class="toc-text">Warning: conversion from ‘size_t’ {aka ‘long unsigned int’} to ‘uint’ {aka ‘unsigned int’} may change value [-Wconversion]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Warning-‘static-QQmlFileSelector-QQmlFileSelector-get-QQmlEngine-’-is-deprecated-Wdeprecated-declarations"><span class="toc-text">Warning: ‘static QQmlFileSelector QQmlFileSelector::get(QQmlEngine)’ is deprecated [-Wdeprecated-declarations]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-using-typedef-name-‘using-QStringList-class-QList’-after-‘class"><span class="toc-text">Error: using typedef-name ‘using QStringList = class QList’ after ‘class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-‘QLatin1Literal’-was-not-declared-in-this-scope-did-you-mean-‘QStringLiteral’"><span class="toc-text">Error: ‘QLatin1Literal’ was not declared in this scope; did you mean ‘QStringLiteral’?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-No-type-name-‘State’-in-QMediaPlayer"><span class="toc-text">Error: No type name ‘State’ in QMediaPlayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-‘QMediaPlaylist’-No-such-file-or-directory"><span class="toc-text">Error: ‘QMediaPlaylist’: No such file or directory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-No-member-named-‘setVolume’-in-‘QMediaPlayer’"><span class="toc-text">Error: No member named ‘setVolume’ in ‘QMediaPlayer’</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error-QMediaPlayer-cannot-play-back-a-QMediaPlaylist-any-more"><span class="toc-text">Error: QMediaPlayer cannot play back a QMediaPlaylist any more</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QML-警告、错误和改进"><span class="toc-text">QML 警告、错误和改进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Remove-versions-from-import-statements"><span class="toc-text">Remove versions from import statements</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#警告：未声明参数“page”。不推荐将参数注入信号处理程序。"><span class="toc-text">警告：未声明参数“page”。不推荐将参数注入信号处理程序。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、移植总结"><span class="toc-text">3、移植总结</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2024&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>