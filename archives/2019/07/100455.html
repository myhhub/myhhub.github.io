<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="hadoop,scala">


    <meta name="description" content="一、泛型Scala支持类型参数化，使得我们能够编写泛型程序。
1.1 泛型类Java中使用&lt;&gt;符号来包含定义的类型参数，Scala则使用[]。
123class Pair[T, S]...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>Scala类型参数 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Scala类型参数">
            
	            Scala类型参数
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/hadoop/">hadoop</a> <a class="tag-link" href="/tags/scala/">scala</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/07/18</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1370</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h2 id="一、泛型"><a href="#一、泛型" class="headerlink" title="一、泛型"></a>一、泛型</h2><p>Scala支持类型参数化，使得我们能够编写泛型程序。</p>
<h3 id="1-1-泛型类"><a href="#1-1-泛型类" class="headerlink" title="1.1 泛型类"></a>1.1 泛型类</h3><p>Java中使用<code>&lt;&gt;</code>符号来包含定义的类型参数，Scala则使用<code>[]</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>, <span class="type">S</span>](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">S</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = first + <span class="string">":"</span> + second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用时候你直接指定参数类型，也可以不指定，由程序自动推断</span></span><br><span class="line">  <span class="keyword">val</span> pair01 = <span class="keyword">new</span> <span class="type">Pair</span>(<span class="string">"heibai01"</span>, <span class="number">22</span>)</span><br><span class="line">  <span class="keyword">val</span> pair02 = <span class="keyword">new</span> <span class="type">Pair</span>[<span class="type">String</span>,<span class="type">Int</span>](<span class="string">"heibai02"</span>, <span class="number">33</span>)</span><br><span class="line"></span><br><span class="line">  println(pair01)</span><br><span class="line">  println(pair02)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-泛型方法"><a href="#1-2-泛型方法" class="headerlink" title="1.2 泛型方法"></a>1.2 泛型方法</h3><p>函数和方法也支持类型参数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getHalf</span></span>[<span class="type">T</span>](a: <span class="type">Array</span>[<span class="type">T</span>]): <span class="type">Int</span> = a.length / <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二、类型限定"><a href="#二、类型限定" class="headerlink" title="二、类型限定"></a>二、类型限定</h2><h3 id="2-1-类型上界限定"><a href="#2-1-类型上界限定" class="headerlink" title="2.1 类型上界限定"></a>2.1 类型上界限定</h3><p>Scala和Java一样，对于对象之间进行大小比较，要求被比较的对象实现<code>java.lang.Comparable</code>接口。所以如果想对泛型进行比较，需要限定类型上界为<code>java.lang.Comparable</code>，语法为<code>S &lt;: T</code>，代表类型S是类型T的子类或其本身。示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 &lt;: 符号，限定T必须是Comparable[T]的子类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span> &lt;: <span class="type">Comparable</span>[<span class="type">T</span>]](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回较小的值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">smaller</span></span>: <span class="type">T</span> = <span class="keyword">if</span> (first.compareTo(second) &lt; <span class="number">0</span>) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">val</span> pair = <span class="keyword">new</span> <span class="type">Pair</span>(<span class="string">"abc"</span>, <span class="string">"abcd"</span>)</span><br><span class="line">println(pair.smaller) <span class="comment">// 输出 abc</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展：如果你想要在Java中实现类型变量限定，需要使用关键字extends来实现，等价的Java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">&gt;    <span class="keyword">private</span> T first;</span><br><span class="line">&gt;    <span class="keyword">private</span> T second;</span><br><span class="line">&gt;    Pair(T first, T second) &#123;</span><br><span class="line">&gt;        <span class="keyword">this</span>.first = first;</span><br><span class="line">&gt;        <span class="keyword">this</span>.second = second;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;    <span class="function"><span class="keyword">public</span> T <span class="title">smaller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt;        <span class="keyword">return</span> first.compareTo(second) &lt; <span class="number">0</span> ? first : second;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-2-视图界定"><a href="#2-2-视图界定" class="headerlink" title="2.2 视图界定"></a>2.2 视图界定</h3><p>在上面的例子中，如果你使用Int类型或者Double等类型进行测试，点击运行后，你会发现程序根本无法通过编译：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pair1 = <span class="keyword">new</span> <span class="type">Pair</span>(<span class="number">10</span>, <span class="number">12</span>)</span><br><span class="line"><span class="keyword">val</span> pair2 = <span class="keyword">new</span> <span class="type">Pair</span>(<span class="number">10.0</span>, <span class="number">12.0</span>)</span><br></pre></td></tr></table></figure>
<p>之所以出现这样的问题，是因为Scala中的Int类并没有实现Comparable接口。在Scala中直接继承Comparable接口的是特质Ordered，它在继承compareTo方法的基础上，额外定义了关系符方法，源码如下:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 除了compareTo方法外，还提供了额外的关系符方法</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ordered</span>[<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">Any</span> <span class="keyword">with</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Comparable</span>[<span class="type">A</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">A</span>): <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&lt;</span>  </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &lt;  <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&gt;</span>  </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &gt;  <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span> </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &lt;= <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span> </span>(that: <span class="type">A</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> compare that) &gt;= <span class="number">0</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">compareTo</span></span>(that: <span class="type">A</span>): <span class="type">Int</span> = compare(that)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之所以在日常的编程中之所以你能够执行<code>3&gt;2</code>这样的判断操作，是因为程序执行了定义在<code>Predef</code>中的隐式转换方法<code>intWrapper(x: Int)</code>，将Int类型转换为RichInt类型，而RichInt间接混入了Ordered特质，所以能够进行比较。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Predef.scala</span></span><br><span class="line"><span class="meta">@inline</span> <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intWrapper</span></span>(x: <span class="type">Int</span>)   = <span class="keyword">new</span> runtime.<span class="type">RichInt</span>(x)</span><br></pre></td></tr></table></figure>
<div align="center"> <img src="/img/bigdata/scala-richInt.png"> </div>

<p>要想解决传入数值无法进行比较的问题，可以使用视图界定。语法为<code>T &lt;% U</code>，代表T能够通过隐式转换转为U，即允许Int型参数在无法进行比较的时候转换为RichInt类型。示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视图界定符号 &lt;%</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span> &lt;% <span class="type">Comparable</span>[<span class="type">T</span>]](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回较小的值</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">smaller</span></span>: <span class="type">T</span> = <span class="keyword">if</span> (first.compareTo(second) &lt; <span class="number">0</span>) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：由于直接继承Java中Comparable接口的是特质Ordered，所以如下的视图界定和上面是等效的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">// 隐式转换为Ordered[T]</span></span><br><span class="line">&gt;    <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span> &lt;% <span class="type">Ordered</span>[<span class="type">T</span>]](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">&gt; <span class="function"><span class="keyword">def</span> <span class="title">smaller</span></span>: <span class="type">T</span> = <span class="keyword">if</span> (first.compareTo(second) &lt; <span class="number">0</span>) first <span class="keyword">else</span> second</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-3-类型约束"><a href="#2-3-类型约束" class="headerlink" title="2.3 类型约束"></a>2.3 类型约束</h3><p>如果你用的Scala是2.11+，会发现视图界定已被标识为废弃。官方推荐使用类型约束(type constraint)来实现同样的功能，其本质是使用隐式参数进行隐式转换，示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1.使用隐式参数隐式转换为Comparable[T]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>)(<span class="params">implicit ev: <span class="type">T</span> =&gt; <span class="type">Comparable</span>[<span class="type">T</span>]</span>) </span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">smaller</span></span>: <span class="type">T</span> = <span class="keyword">if</span> (first.compareTo(second) &lt; <span class="number">0</span>) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.由于直接继承Java中Comparable接口的是特质Ordered，所以也可以隐式转换为Ordered[T]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>)(<span class="params">implicit ev: <span class="type">T</span> =&gt; <span class="type">Ordered</span>[<span class="type">T</span>]</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">smaller</span></span>: <span class="type">T</span> = <span class="keyword">if</span> (first.compareTo(second) &lt; <span class="number">0</span>) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，隐式参数转换也可以运用在具体的方法上：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PairUtils</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">smaller</span></span>[<span class="type">T</span>](a: <span class="type">T</span>, b: <span class="type">T</span>)(<span class="keyword">implicit</span> order: <span class="type">T</span> =&gt; <span class="type">Ordered</span>[<span class="type">T</span>]) = <span class="keyword">if</span> (a &lt; b) a <span class="keyword">else</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-上下文界定"><a href="#2-4-上下文界定" class="headerlink" title="2.4 上下文界定"></a>2.4 上下文界定</h3><p>上下文界定的形式为<code>T:M</code>，其中M是一个泛型，它要求必须存在一个类型为M[T]的隐式值，当你声明一个带隐式参数的方法时，需要定义一个隐式默认值。所以上面的程序也可以使用上下文界定进行改写：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 请注意 这个地方用的是Ordering[T]，而上面视图界定和类型约束，用的是Ordered[T]，两者的区别会在后文给出解释</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">smaller</span></span>(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">T</span> = <span class="keyword">if</span> (ord.compare(first, second) &lt; <span class="number">0</span>) first <span class="keyword">else</span> second </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">val</span> pair= <span class="keyword">new</span> <span class="type">Pair</span>(<span class="number">88</span>, <span class="number">66</span>)</span><br><span class="line">println(pair.smaller)  <span class="comment">//输出：66</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们无需手动添加隐式默认值就可以完成转换，这是因为Scala自动引入了Ordering[Int]这个隐式值。为了更好的说明上下文界定，下面给出一个自定义类型的比较示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个人员类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = name + <span class="string">":"</span> + age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.继承Ordering[T],实现自定义比较器,按照自己的规则重写比较方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonOrdering</span> <span class="keyword">extends</span> <span class="title">Ordering</span>[<span class="type">Person</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">Person</span>, y: <span class="type">Person</span>): <span class="type">Int</span> = <span class="keyword">if</span> (x.age &gt; y.age) <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">smaller</span></span>(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">T</span> = <span class="keyword">if</span> (ord.compare(first, second) &lt; <span class="number">0</span>) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> pair = <span class="keyword">new</span> <span class="type">Pair</span>(<span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"hei"</span>, <span class="number">88</span>), <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"bai"</span>, <span class="number">66</span>))</span><br><span class="line">  <span class="comment">// 3.定义隐式默认值,如果不定义,则下一行代码无法通过编译</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> <span class="type">ImpPersonOrdering</span> = <span class="keyword">new</span> <span class="type">PersonOrdering</span></span><br><span class="line">  println(pair.smaller) <span class="comment">//输出： bai:66</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-ClassTag上下文界定"><a href="#2-5-ClassTag上下文界定" class="headerlink" title="2.5 ClassTag上下文界定"></a>2.5 ClassTag上下文界定</h3><p>这里先看一个例子：下面这段代码，没有任何语法错误，但是在运行时会抛出异常：<code>Error: cannot find class tag for element type T</code>, 这是由于Scala和Java一样，都存在类型擦除，即<strong>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉</strong>。对于下面的代码，在运行阶段创建Array时，你必须明确指明其类型，但是此时泛型信息已经被擦除，导致出现找不到类型的异常。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makePair</span></span>[<span class="type">T</span>](first: <span class="type">T</span>, second: <span class="type">T</span>) = &#123;</span><br><span class="line">    <span class="comment">// 创建以一个数组 并赋值</span></span><br><span class="line">    <span class="keyword">val</span> r = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](<span class="number">2</span>); r(<span class="number">0</span>) = first; r(<span class="number">1</span>) = second; r</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scala针对这个问题，提供了ClassTag上下文界定，即把泛型的信息存储在ClassTag中，这样在运行阶段需要时，只需要从ClassTag中进行获取即可。其语法为<code>T : ClassTag</code>，示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.reflect._</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makePair</span></span>[<span class="type">T</span> : <span class="type">ClassTag</span>](first: <span class="type">T</span>, second: <span class="type">T</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> r = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">T</span>](<span class="number">2</span>); r(<span class="number">0</span>) = first; r(<span class="number">1</span>) = second; r</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-类型下界限定"><a href="#2-6-类型下界限定" class="headerlink" title="2.6 类型下界限定"></a>2.6 类型下界限定</h3><p>2.1小节介绍了类型上界的限定，Scala同时也支持下界的限定，语法为：<code>U &gt;: T</code>，即U必须是类型T的超类或本身。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首席执行官</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CEO</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">部门经理</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Manager</span> <span class="keyword">extends</span> <span class="title">CEO</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">本公司普通员工</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Manager</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">//</span> <span class="title">其他公司人员</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">OtherCompany</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 限定：只有本公司部门经理以上人员才能获取权限</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Check</span></span>[<span class="type">T</span> &gt;: <span class="type">Manager</span>](t: <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    println(<span class="string">"获得审核权限"</span>)</span><br><span class="line">    t</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 错误写法: 省略泛型参数后,以下所有人都能获得权限,显然这是不正确的</span></span><br><span class="line">  <span class="type">Check</span>(<span class="keyword">new</span> <span class="type">CEO</span>)</span><br><span class="line">  <span class="type">Check</span>(<span class="keyword">new</span> <span class="type">Manager</span>)</span><br><span class="line">  <span class="type">Check</span>(<span class="keyword">new</span> <span class="type">Employee</span>)</span><br><span class="line">  <span class="type">Check</span>(<span class="keyword">new</span> <span class="type">OtherCompany</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正确写法,传入泛型参数</span></span><br><span class="line">  <span class="type">Check</span>[<span class="type">CEO</span>](<span class="keyword">new</span> <span class="type">CEO</span>)</span><br><span class="line">  <span class="type">Check</span>[<span class="type">Manager</span>](<span class="keyword">new</span> <span class="type">Manager</span>)</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 以下两条语句无法通过编译,异常信息为: </span></span><br><span class="line"><span class="comment">   * do not conform to method Check's type parameter bounds(不符合方法Check的类型参数边界)</span></span><br><span class="line"><span class="comment">   * 这种情况就完成了下界限制，即只有本公司经理及以上的人员才能获得审核权限</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">Check</span>[<span class="type">Employee</span>](<span class="keyword">new</span> <span class="type">Employee</span>)</span><br><span class="line">  <span class="type">Check</span>[<span class="type">OtherCompany</span>](<span class="keyword">new</span> <span class="type">OtherCompany</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-多重界定"><a href="#2-7-多重界定" class="headerlink" title="2.7 多重界定"></a>2.7 多重界定</h3><ul>
<li><p>类型变量可以同时有上界和下界。 写法为 ：<code>T &gt; : Lower &lt;: Upper</code>；</p>
</li>
<li><p>不能同时有多个上界或多个下界 。但可以要求一个类型实现多个特质，写法为 :</p>
<p><code>T &lt; : Comparable[T] with Serializable with Cloneable</code>；</p>
</li>
<li><p>你可以有多个上下文界定，写法为<code>T : Ordering : ClassTag</code> 。</p>
</li>
</ul>
<h2 id="三、Ordering-amp-Ordered"><a href="#三、Ordering-amp-Ordered" class="headerlink" title="三、Ordering &amp; Ordered"></a>三、Ordering &amp; Ordered</h2><p>上文中使用到Ordering和Ordered特质，它们最主要的区别在于分别继承自不同的Java接口：Comparable和Comparator：</p>
<ul>
<li><strong>Comparable</strong>：可以理解为内置的比较器，实现此接口的对象可以与自身进行比较；</li>
<li><strong>Comparator</strong>：可以理解为外置的比较器；当对象自身并没有定义比较规则的时候，可以传入外部比较器进行比较。</li>
</ul>
<p>为什么Java中要同时给出这两个比较接口，这是因为你要比较的对象不一定实现了Comparable接口，而你又想对其进行比较，这时候当然你可以修改代码实现Comparable，但是如果这个类你无法修改(如源码中的类)，这时候就可以使用外置的比较器。同样的问题在Scala中当然也会出现，所以Scala分别使用了Ordering和Ordered来继承它们。</p>
<div align="center"> <img src="/img/bigdata/scala-ordered-ordering.png"> </div>



<p>下面分别给出Java中Comparable和Comparator接口的使用示例：</p>
<h3 id="3-1-Comparable"><a href="#3-1-Comparable" class="headerlink" title="3.1 Comparable"></a>3.1 Comparable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">// 实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name,<span class="keyword">int</span> age) &#123;<span class="keyword">this</span>.name=name;<span class="keyword">this</span>.age=age;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name+<span class="string">":"</span>+age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心的方法是重写比较规则，按照年龄进行排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - person.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] peoples= &#123;<span class="keyword">new</span> Person(<span class="string">"hei"</span>, <span class="number">66</span>), <span class="keyword">new</span> Person(<span class="string">"bai"</span>, <span class="number">55</span>), <span class="keyword">new</span> Person(<span class="string">"ying"</span>, <span class="number">77</span>)&#125;;</span><br><span class="line">        Arrays.sort(peoples);</span><br><span class="line">        Arrays.stream(peoples).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">bai:<span class="number">55</span></span><br><span class="line">hei:<span class="number">66</span></span><br><span class="line">ying:<span class="number">77</span></span><br></pre></td></tr></table></figure>
<h3 id="3-2-Comparator"><a href="#3-2-Comparator" class="headerlink" title="3.2 Comparator"></a>3.2 Comparator</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    Person(String name,<span class="keyword">int</span> age) &#123;<span class="keyword">this</span>.name=name;<span class="keyword">this</span>.age=age;&#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name+<span class="string">":"</span>+age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person[] peoples= &#123;<span class="keyword">new</span> Person(<span class="string">"hei"</span>, <span class="number">66</span>), <span class="keyword">new</span> Person(<span class="string">"bai"</span>, <span class="number">55</span>), <span class="keyword">new</span> Person(<span class="string">"ying"</span>, <span class="number">77</span>)&#125;;</span><br><span class="line">        <span class="comment">// 这里为了直观直接使用匿名内部类,实现Comparator接口</span></span><br><span class="line">        <span class="comment">//如果是Java8你也可以写成Arrays.sort(peoples, Comparator.comparingInt(o -&gt; o.age));</span></span><br><span class="line">        Arrays.sort(peoples, <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age-o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Arrays.stream(peoples).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用外置比较器还有一个好处，就是你可以随时定义其排序规则：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照年龄大小排序</span></span><br><span class="line"><span class="type">Arrays</span>.sort(peoples, <span class="type">Comparator</span>.comparingInt(o -&gt; o.age));</span><br><span class="line"><span class="type">Arrays</span>.stream(peoples).forEach(<span class="type">System</span>.out::println);</span><br><span class="line"><span class="comment">// 按照名字长度倒序排列</span></span><br><span class="line"><span class="type">Arrays</span>.sort(peoples, <span class="type">Comparator</span>.comparingInt(o -&gt; -o.name.length()));</span><br><span class="line"><span class="type">Arrays</span>.stream(peoples).forEach(<span class="type">System</span>.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="3-3-上下文界定的优点"><a href="#3-3-上下文界定的优点" class="headerlink" title="3.3 上下文界定的优点"></a>3.3 上下文界定的优点</h3><p>这里再次给出上下文界定中的示例代码作为回顾：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.定义一个人员类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name: <span class="type">String</span>, val age: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = name + <span class="string">":"</span> + age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.继承Ordering[T],实现自定义比较器,这个比较器就是一个外置比较器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonOrdering</span> <span class="keyword">extends</span> <span class="title">Ordering</span>[<span class="type">Person</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">Person</span>, y: <span class="type">Person</span>): <span class="type">Int</span> = <span class="keyword">if</span> (x.age &gt; y.age) <span class="number">1</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>[<span class="type">T</span>](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">smaller</span></span>(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">T</span> = <span class="keyword">if</span> (ord.compare(first, second) &lt; <span class="number">0</span>) first <span class="keyword">else</span> second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> pair = <span class="keyword">new</span> <span class="type">Pair</span>(<span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"hei"</span>, <span class="number">88</span>), <span class="keyword">new</span> <span class="type">Person</span>(<span class="string">"bai"</span>, <span class="number">66</span>))</span><br><span class="line">  <span class="comment">// 3.在当前上下文定义隐式默认值,这就相当于传入了外置比较器</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> <span class="type">ImpPersonOrdering</span> = <span class="keyword">new</span> <span class="type">PersonOrdering</span></span><br><span class="line">  println(pair.smaller) <span class="comment">//输出： bai:66</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用上下文界定和Ordering带来的好处是：传入<code>Pair</code>中的参数不一定需要可比较，只要在比较时传入外置比较器即可。</p>
<p>需要注意的是由于隐式默认值二义性的限制，你不能像上面Java代码一样，在同一个上下文作用域中传入两个外置比较器，即下面的代码是无法通过编译的。但是你可以在不同的上下文作用域中引入不同的隐式默认值，即使用不同的外置比较器。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> <span class="type">ImpPersonOrdering</span> = <span class="keyword">new</span> <span class="type">PersonOrdering</span></span><br><span class="line">println(pair.smaller) </span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> <span class="type">ImpPersonOrdering2</span> = <span class="keyword">new</span> <span class="type">PersonOrdering</span></span><br><span class="line">println(pair.smaller)</span><br></pre></td></tr></table></figure>
<h2 id="四、通配符"><a href="#四、通配符" class="headerlink" title="四、通配符"></a>四、通配符</h2><p>在实际编码中，通常需要把泛型限定在某个范围内，比如限定为某个类及其子类。因此Scala和Java一样引入了通配符这个概念，用于限定泛型的范围。不同的是Java使用<code>?</code>表示通配符，Scala使用<code>_</code>表示通配符。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ceo</span>(<span class="params">val name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span>(<span class="params">name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Ceo</span>(<span class="params">name</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Employee</span>(<span class="params">name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Manager</span>(<span class="params">name</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Pair</span>[<span class="type">T</span>](<span class="params">val first: <span class="type">T</span>, val second: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">"first:"</span> + first + <span class="string">", second: "</span> + second</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 限定部门经理及以下的人才可以组队</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makePair</span></span>(p: <span class="type">Pair</span>[_ &lt;: <span class="type">Manager</span>]): <span class="type">Unit</span> = &#123;println(p)&#125;</span><br><span class="line">  makePair(<span class="keyword">new</span> <span class="type">Pair</span>(<span class="keyword">new</span> <span class="type">Employee</span>(<span class="string">"heibai"</span>), <span class="keyword">new</span> <span class="type">Manager</span>(<span class="string">"ying"</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前Scala中的通配符在某些复杂情况下还不完善，如下面的语句在Scala 2.12 中并不能通过编译：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span></span>[<span class="type">T</span> &lt;: <span class="type">Comparable</span>[_ &gt;: <span class="type">T</span>]](p: <span class="type">Pair</span>[<span class="type">T</span>]) =&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用以下语法代替：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">SuperComparable</span>[<span class="type">T</span>] </span>= <span class="type">Comparable</span>[_ &gt;: <span class="type">T</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span></span>[<span class="type">T</span> &lt;: <span class="type">SuperComparable</span>[<span class="type">T</span>]](p: <span class="type">Pair</span>[<span class="type">T</span>]) = &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>Martin Odersky . Scala编程(第3版)[M] . 电子工业出版社 . 2018-1-1  </li>
<li>凯.S.霍斯特曼  . 快学Scala(第2版)[M] . 电子工业出版社 . 2017-7</li>
</ol>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2019/07/100456.html" class="pre-post btn btn-default" title='Scala隐式转换和隐式参数'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Scala隐式转换和隐式参数</span>
        </a>
    
    
        <a href="/archives/2019/07/100454.html" class="next-post btn btn-default" title='Scala模式匹配'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Scala模式匹配</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、泛型"><span class="toc-text">一、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-泛型类"><span class="toc-text">1.1 泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-泛型方法"><span class="toc-text">1.2 泛型方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、类型限定"><span class="toc-text">二、类型限定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-类型上界限定"><span class="toc-text">2.1 类型上界限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-视图界定"><span class="toc-text">2.2 视图界定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-类型约束"><span class="toc-text">2.3 类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-上下文界定"><span class="toc-text">2.4 上下文界定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-ClassTag上下文界定"><span class="toc-text">2.5 ClassTag上下文界定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-类型下界限定"><span class="toc-text">2.6 类型下界限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-多重界定"><span class="toc-text">2.7 多重界定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、Ordering-amp-Ordered"><span class="toc-text">三、Ordering &amp; Ordered</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-Comparable"><span class="toc-text">3.1 Comparable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Comparator"><span class="toc-text">3.2 Comparator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-上下文界定的优点"><span class="toc-text">3.3 上下文界定的优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、通配符"><span class="toc-text">四、通配符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2023&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>