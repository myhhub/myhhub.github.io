<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="hadoop,scala">


    <meta name="description" content="一、继承1.1 Scala中的继承结构Scala中继承关系如下图：

Any是整个继承关系的根节点；
AnyRef包含Scala Classes和Java Classes，等价于Java中的ja...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>Scala继承和特质 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Scala继承和特质">
            
	            Scala继承和特质
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/back/">后端</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/hadoop/">hadoop</a> <a class="tag-link" href="/tags/scala/">scala</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/07/18</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1372</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h2 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h2><h3 id="1-1-Scala中的继承结构"><a href="#1-1-Scala中的继承结构" class="headerlink" title="1.1 Scala中的继承结构"></a>1.1 Scala中的继承结构</h3><p>Scala中继承关系如下图：</p>
<ul>
<li>Any是整个继承关系的根节点；</li>
<li>AnyRef包含Scala Classes和Java Classes，等价于Java中的java.lang.Object；</li>
<li>AnyVal是所有值类型的一个标记；</li>
<li>Null是所有引用类型的子类型，唯一实例是null，可以将null赋值给除了值类型外的所有类型的变量;</li>
<li>Nothing是所有类型的子类型。</li>
</ul>
<div align="center"> <img src="/img/bigdata/scalajccc.png"> </div>

<h3 id="1-2-extends-amp-override"><a href="#1-2-extends-amp-override" class="headerlink" title="1.2 extends &amp; override"></a>1.2 extends &amp; override</h3><p>Scala的集成机制和Java有很多相似之处，比如都使用<code>extends</code>关键字表示继承，都使用<code>override</code>关键字表示重写父类的方法或成员变量。示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">  <span class="comment">// 1.不加任何修饰词,默认为public,能被子类和外部访问</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 2.使用protected修饰的变量能子类访问，但是不能被外部访问</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">var</span> birthday = <span class="string">""</span></span><br><span class="line">  <span class="comment">// 3.使用private修饰的变量不能被子类和外部访问</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sex = <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setSex</span></span>(sex: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 4.重写父类的方法建议使用override关键字修饰</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = name + <span class="string">":"</span> + age + <span class="string">":"</span> + birthday + <span class="string">":"</span> + sex</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>extends</code>关键字实现继承：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用extends关键字实现继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">"Employee~"</span> + <span class="keyword">super</span>.toString</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.使用public或protected关键字修饰的变量能被子类访问</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">setBirthday</span></span>(date: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    birthday = date</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试继承：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> employee = <span class="keyword">new</span> <span class="type">Employee</span></span><br><span class="line"></span><br><span class="line">  employee.name = <span class="string">"myhhub"</span></span><br><span class="line">  employee.age = <span class="number">20</span></span><br><span class="line">  employee.setBirthday(<span class="string">"2019-03-05"</span>)</span><br><span class="line">  employee.setSex(<span class="string">"男"</span>)</span><br><span class="line"></span><br><span class="line">  println(employee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： Employee~myhhub:20:2019-03-05:男</span></span><br></pre></td></tr></table></figure>
<h3 id="1-3-调用超类构造器"><a href="#1-3-调用超类构造器" class="headerlink" title="1.3 调用超类构造器"></a>1.3 调用超类构造器</h3><p>在Scala的类中，每个辅助构造器都必须首先调用其他构造器或主构造器，这样就导致了子类的辅助构造器永远无法直接调用超类的构造器，只有主构造器才能调用超类的构造器。所以想要调用超类的构造器，代码示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>(<span class="params">name:<span class="type">String</span>,age:<span class="type">Int</span>,salary:<span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>,age:<span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-类型检查和转换"><a href="#1-4-类型检查和转换" class="headerlink" title="1.4 类型检查和转换"></a>1.4 类型检查和转换</h3><p>想要实现类检查可以使用<code>isInstanceOf</code>，判断一个实例是否来源于某个类或者其子类，如果是，则可以使用<code>asInstanceOf</code>进行强制类型转换。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> employee = <span class="keyword">new</span> <span class="type">Employee</span></span><br><span class="line">  <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 判断一个实例是否来源于某个类或者其子类 输出 true </span></span><br><span class="line">  println(employee.isInstanceOf[<span class="type">Person</span>])</span><br><span class="line">  println(person.isInstanceOf[<span class="type">Person</span>])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 强制类型转换</span></span><br><span class="line">  <span class="keyword">var</span> p: <span class="type">Person</span> = employee.asInstanceOf[<span class="type">Person</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 判断一个实例是否来源于某个类(而不是其子类)</span></span><br><span class="line">  println(employee.getClass == classOf[<span class="type">Employee</span>])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-构造顺序和提前定义"><a href="#1-5-构造顺序和提前定义" class="headerlink" title="1.5 构造顺序和提前定义"></a>1.5 构造顺序和提前定义</h3><h4 id="1-构造顺序"><a href="#1-构造顺序" class="headerlink" title="1. 构造顺序"></a><strong>1. 构造顺序</strong></h4><p>在Scala中还有一个需要注意的问题，如果你在子类中重写父类的val变量，并且超类的构造器中使用了该变量，那么可能会产生不可预期的错误。下面给出一个示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  println(<span class="string">"父类的默认构造器"</span>)</span><br><span class="line">  <span class="keyword">val</span> range: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">val</span> array: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](range)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  println(<span class="string">"子类的默认构造器"</span>)</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> range = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> employee = <span class="keyword">new</span> <span class="type">Employee</span></span><br><span class="line">  println(employee.array.mkString(<span class="string">"("</span>, <span class="string">","</span>, <span class="string">")"</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里初始化array用到了变量range，这里你会发现实际上array既不会被初始化Array(10)，也不会被初始化为Array(2)，实际的输出应该如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父类的默认构造器</span><br><span class="line">子类的默认构造器</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<p>可以看到array被初始化为Array(0)，主要原因在于父类构造器的执行顺序先于子类构造器，这里给出实际的执行步骤：</p>
<ol>
<li>父类的构造器被调用，执行<code>new Array[Int](range)</code>语句;</li>
<li>这里想要得到range的值，会去调用子类range()方法，因为<code>override val</code>重写变量的同时也重写了其get方法；</li>
<li>调用子类的range()方法，自然也是返回子类的range值，但是由于子类的构造器还没有执行，这也就意味着对range赋值的<code>range = 2</code>语句还没有被执行，所以自然返回range的默认值，也就是0。</li>
</ol>
<p>这里可能比较疑惑的是为什么<code>val range = 2</code>没有被执行，却能使用range变量，这里因为在虚拟机层面，是先对成员变量先分配存储空间并赋给默认值，之后才赋予给定的值。想要证明这一点其实也比较简单，代码如下:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// val range: Int = 10 正常代码 array为Array(10)</span></span><br><span class="line">  <span class="keyword">val</span> array: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](range)</span><br><span class="line">  <span class="keyword">val</span> range: <span class="type">Int</span> = <span class="number">10</span>  <span class="comment">//如果把变量的声明放在使用之后，此时数据array为array(0)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> person = <span class="keyword">new</span> <span class="type">Person</span></span><br><span class="line">    println(person.array.mkString(<span class="string">"("</span>, <span class="string">","</span>, <span class="string">")"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-提前定义"><a href="#2-提前定义" class="headerlink" title="2. 提前定义"></a><strong>2. 提前定义</strong></h4><p>想要解决上面的问题，有以下几种方法：</p>
<p>(1) . 将变量用final修饰，代表不允许被子类重写，即 <code>final val range: Int = 10</code>；</p>
<p>(2) . 将变量使用lazy修饰，代表懒加载，即只有当你实际使用到array时候，才去进行初始化；</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> array: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](range)</span><br></pre></td></tr></table></figure>
<p>(3) . 采用提前定义，代码如下，代表range的定义优先于超类构造器。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> </span>&#123;</span><br><span class="line">  <span class="comment">//这里不能定义其他方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> range = <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">with</span> <span class="type">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 定义其他变量或者方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pr</span></span>(): <span class="type">Unit</span> = &#123;println(<span class="string">"Employee"</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种语法也有其限制：你只能在上面代码块中重写已有的变量，而不能定义新的变量和方法，定义新的变量和方法只能写在下面代码块中。</p>
<blockquote>
<p><strong>注意事项</strong>：类的继承和下文特质(trait)的继承都存在这个问题，也同样可以通过提前定义来解决。虽然如此，但还是建议合理设计以规避该类问题。</p>
</blockquote>
<p><br></p>
<h2 id="二、抽象类"><a href="#二、抽象类" class="headerlink" title="二、抽象类"></a>二、抽象类</h2><p>Scala中允许使用<code>abstract</code>定义抽象类，并且通过<code>extends</code>关键字继承它。</p>
<p>定义抽象类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1.定义字段</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">val</span> age: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.定义抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">geDetail</span></span>: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. scala的抽象类允许定义具体方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"抽象类中的默认方法"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承抽象类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 覆盖抽象类中变量</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"employee"</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> age: <span class="type">Int</span> = <span class="number">12</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 覆盖抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">geDetail</span></span>: <span class="type">String</span> = name + <span class="string">":"</span> + age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br></p>
<h2 id="三、特质"><a href="#三、特质" class="headerlink" title="三、特质"></a>三、特质</h2><h3 id="3-1-trait-amp-with"><a href="#3-1-trait-amp-with" class="headerlink" title="3.1 trait &amp; with"></a>3.1 trait &amp; with</h3><p>Scala中没有interface这个关键字，想要实现类似的功能，可以使用特质(trait)。trait等价于Java 8中的接口，因为trait中既能定义抽象方法，也能定义具体方法，这和Java 8中的接口是类似的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.特质使用trait关键字修饰</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.定义抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.定义具体方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">logInfo</span></span>(msg: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"INFO:"</span> + msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想要使用特质，需要使用<code>extends</code>关键字，而不是<code>implements</code>关键字，如果想要添加多个特质，可以使用<code>with</code>关键字。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用extends关键字,而不是implements,如果想要添加多个特质，可以使用with关键字</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> <span class="keyword">with</span> <span class="title">Serializable</span> <span class="keyword">with</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 实现特质中的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"CONSOLE:"</span> + msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-特质中的字段"><a href="#3-2-特质中的字段" class="headerlink" title="3.2 特质中的字段"></a>3.2 特质中的字段</h3><p>和方法一样，特质中的字段可以是抽象的，也可以是具体的：</p>
<ul>
<li>如果是抽象字段，则混入特质的类需要重写覆盖该字段；</li>
<li>如果是具体字段，则混入特质的类获得该字段，但是并非是通过继承关系得到，而是在编译时候，简单将该字段加入到子类。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 抽象字段</span></span><br><span class="line">  <span class="keyword">var</span> <span class="type">LogLevel</span>:<span class="type">String</span></span><br><span class="line">  <span class="comment">// 具体字段</span></span><br><span class="line">  <span class="keyword">var</span> <span class="type">LogType</span> = <span class="string">"FILE"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>覆盖抽象字段：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InfoLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 覆盖抽象字段</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">var</span> <span class="type">LogLevel</span>: <span class="type">String</span> = <span class="string">"INFO"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-带有特质的对象"><a href="#3-3-带有特质的对象" class="headerlink" title="3.3 带有特质的对象"></a>3.3 带有特质的对象</h3><p>Scala支持在类定义的时混入<code>父类trait</code>，而在类实例化为具体对象的时候指明其实际使用的<code>子类trait</code>。示例如下：</p>
<div align="center"> <img src="/img/bigdata/scaladx.png"> </div>

<p>trait Logger：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义空方法 日志打印</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trait ErrorLogger：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误日志打印，继承自Logger</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 覆盖空方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"Error:"</span> + msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>trait InfoLogger：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知日志打印，继承自Logger</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">InfoLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 覆盖空方法</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>(msg: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"INFO:"</span> + msg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的使用类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 混入trait Logger</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用定义的抽象方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printDetail</span></span>(detail: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    log(detail)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过main方法来测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ScalaApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用with指明需要具体使用的trait  </span></span><br><span class="line">  <span class="keyword">val</span> person01 = <span class="keyword">new</span> <span class="type">Person</span> <span class="keyword">with</span> <span class="type">InfoLogger</span></span><br><span class="line">  <span class="keyword">val</span> person02 = <span class="keyword">new</span> <span class="type">Person</span> <span class="keyword">with</span> <span class="type">ErrorLogger</span></span><br><span class="line">  <span class="keyword">val</span> person03 = <span class="keyword">new</span>  <span class="type">Person</span> <span class="keyword">with</span> <span class="type">InfoLogger</span> <span class="keyword">with</span> <span class="type">ErrorLogger</span></span><br><span class="line">  person01.log(<span class="string">"scala"</span>)  <span class="comment">//输出 INFO:scala</span></span><br><span class="line">  person02.log(<span class="string">"scala"</span>)  <span class="comment">//输出 Error:scala</span></span><br><span class="line">  person03.log(<span class="string">"scala"</span>)  <span class="comment">//输出 Error:scala</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里前面两个输出比较明显，因为只指明了一个具体的<code>trait</code>，这里需要说明的是第三个输出，<strong>因为trait的调用是由右到左开始生效的</strong>，所以这里打印出<code>Error:scala</code>。</p>
<h3 id="3-4-特质构造顺序"><a href="#3-4-特质构造顺序" class="headerlink" title="3.4 特质构造顺序"></a>3.4 特质构造顺序</h3><p><code>trait</code>有默认的无参构造器，但是不支持有参构造器。一个类混入多个特质后初始化顺序应该如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">with</span> <span class="title">InfoLogger</span> <span class="keyword">with</span> <span class="title">ErrorLogger</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>超类首先被构造，即Person的构造器首先被执行；</li>
<li>特质的构造器在超类构造器之前，在类构造器之后；特质由左到右被构造；每个特质中，父特质首先被构造；<ul>
<li>Logger构造器执行（Logger是InfoLogger的父类）；</li>
<li>InfoLogger构造器执行；</li>
<li>ErrorLogger构造器执行;</li>
</ul>
</li>
<li>所有超类和特质构造完毕，子类才会被构造。</li>
</ol>
<p><br></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>Martin Odersky . Scala编程(第3版)[M] . 电子工业出版社 . 2018-1-1  </li>
<li>凯.S.霍斯特曼  . 快学Scala(第2版)[M] . 电子工业出版社 . 2017-7</li>
</ol>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2019/07/100453.html" class="pre-post btn btn-default" title='Scala函数和闭包'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Scala函数和闭包</span>
        </a>
    
    
        <a href="/archives/2019/07/100451.html" class="next-post btn btn-default" title='Scala类和对象'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Scala类和对象</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、继承"><span class="toc-text">一、继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Scala中的继承结构"><span class="toc-text">1.1 Scala中的继承结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-extends-amp-override"><span class="toc-text">1.2 extends &amp; override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-调用超类构造器"><span class="toc-text">1.3 调用超类构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-类型检查和转换"><span class="toc-text">1.4 类型检查和转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-构造顺序和提前定义"><span class="toc-text">1.5 构造顺序和提前定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-构造顺序"><span class="toc-text">1. 构造顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-提前定义"><span class="toc-text">2. 提前定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、抽象类"><span class="toc-text">二、抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、特质"><span class="toc-text">三、特质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-trait-amp-with"><span class="toc-text">3.1 trait &amp; with</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-特质中的字段"><span class="toc-text">3.2 特质中的字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-带有特质的对象"><span class="toc-text">3.3 带有特质的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-特质构造顺序"><span class="toc-text">3.4 特质构造顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2023&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>