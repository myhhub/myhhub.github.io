<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>来唧唧歪歪(Ljjyy.com) - 多读书多实践，勤思考善领悟</title>
  
  <subtitle>来唧唧歪歪,来叽叽歪歪,唧唧歪歪,叽叽歪歪,云计算,大数据,人工智能,知识图谱,PaaS,Kubenetes,k8s,微服务,docker,敏捷开发平台,快速开发平台,自定义表单,自定义流程,破解,渗透,Ljjyy.com,Ljjww.com,ljjyy,ljjww,jjyy,jjww</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.ljjyy.com/"/>
  <updated>2024-07-16T03:48:13.971Z</updated>
  <id>https://www.ljjyy.com/</id>
  
  <author>
    <name>Ljjyy.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟机ubuntu系统下对lvm系统盘扩容的方法</title>
    <link href="https://www.ljjyy.com/archives/2024/07/100721.html"/>
    <id>https://www.ljjyy.com/archives/2024/07/100721.html</id>
    <published>2024-07-16T04:00:00.000Z</published>
    <updated>2024-07-16T03:48:13.971Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机系统盘的根目录空间不够用，在无加盘条件下，只能考虑给系统盘空间扩容。这种方法风险较高，开始之前，在虚拟机内创建了快照。</p><h1 id="一、修改分配内存"><a href="#一、修改分配内存" class="headerlink" title="一、修改分配内存"></a>一、修改分配内存</h1><p><strong>在主机中对虚拟机的分配内存进行修改</strong><br>通常使用esxi，对虚拟机进行扩容操作，我这里直接加了40G，由原来的40G空间，扩容至80G。更改完成后保存即可，接下来就要到机器内继续进行后续操作。</p><p>VirtualBox中也可以用以下方法：</p><p>a.下VirtualBox安装目录下，在命令行中输入：<code>VBoxManage list hdds</code><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">C:</span>\Program Files\Oracle\VirtualBox&gt;VBoxManage list hdds</span><br><span class="line"><span class="string">UUID:</span>           e7543ad8<span class="number">-6667</span><span class="number">-4</span>cb9-bf40<span class="number">-84627</span>a31371d</span><br><span class="line">Parent <span class="string">UUID:</span>    base</span><br><span class="line"><span class="string">State:</span>          created</span><br><span class="line"><span class="string">Type:</span>           normal (base)</span><br><span class="line"><span class="string">Location:</span>       <span class="string">C:</span>\Users\mmm\VirtualBox VMs\ubuntu22\ubuntu22.vdi</span><br><span class="line">Storage <span class="string">format:</span> VDI</span><br><span class="line"><span class="string">Capacity:</span>       <span class="number">40960</span> MBytes</span><br><span class="line"><span class="string">Encryption:</span>     disabled</span><br></pre></td></tr></table></figure></p><p>b.查看当前各个虚拟机的状态，在命令行中输入：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VBoxManage modifyhd UUID <span class="comment">--resize xxxx</span></span><br><span class="line"><span class="comment">#修改要修改虚拟机的内存大小。UUID为修改虚拟机的ID，xxxx填自己想要修改的大小。</span></span><br></pre></td></tr></table></figure></p><h1 id="二、登录检查分区"><a href="#二、登录检查分区" class="headerlink" title="二、登录检查分区"></a>二、登录检查分区</h1><p><strong>登录后使用lsblk命令检查发现，增加的空间到了硬盘，并没有到所需要的分区。</strong><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lsblk</span></span><br></pre></td></tr></table></figure></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@0-125:~<span class="comment"># lsblk</span></span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0   <span class="number"> 0 </span>63.3M <span class="number"> 1 </span>loop /snap/core20/1778</span><br><span class="line">loop1                       7:1   <span class="number"> 0 </span>63.3M <span class="number"> 1 </span>loop /snap/core20/1822</span><br><span class="line">loop2                       7:2   <span class="number"> 0 </span>67.2M <span class="number"> 1 </span>loop /snap/lxd/21835</span><br><span class="line">loop3                       7:3   <span class="number"> 0 </span>49.8M <span class="number"> 1 </span>loop /snap/snapd/17950</span><br><span class="line">loop4                       7:4   <span class="number"> 0 </span>91.9M <span class="number"> 1 </span>loop /snap/lxd/24061</span><br><span class="line">loop5                       7:5   <span class="number"> 0 </span>49.9M <span class="number"> 1 </span>loop /snap/snapd/18357</span><br><span class="line">sda                         8:0   <span class="number"> 0 </span>  80G <span class="number"> 0 </span>disk</span><br><span class="line">├─sda1                      8:1   <span class="number"> 0 </span>   1M <span class="number"> 0 </span>part</span><br><span class="line">├─sda2                      8:2   <span class="number"> 0 </span> 1.5G <span class="number"> 0 </span>part /boot</span><br><span class="line">└─sda3                      8:3   <span class="number"> 0 </span>38.5G <span class="number"> 0 </span>part</span><br><span class="line">  └─vgubuntu-root          253:0   <span class="number"> 0 </span>38.5G <span class="number"> 0 </span>lvm  /</span><br><span class="line">sr0                        11:0   <span class="number"> 1 </span>1024M <span class="number"> 0 </span>rom</span><br><span class="line">root@0-125:~<span class="comment"># df -Th</span></span><br><span class="line">Filesystem                        Type      Size  Used Avail Use% Mounted on</span><br><span class="line">udev                              devtmpfs  7.8G    <span class="number"> 0 </span> 7.8G   0% /dev</span><br><span class="line">tmpfs                             tmpfs     1.6G  1.3M  1.6G   1% /run</span><br><span class="line">/dev/mapper/vgubuntu-root         ext4       78G  8.6G   66G  12% /</span><br><span class="line">tmpfs                             tmpfs     7.9G    <span class="number"> 0 </span> 7.9G   0% /dev/shm</span><br><span class="line">tmpfs                             tmpfs     5.0M    <span class="number"> 0 </span> 5.0M   0% /run/lock</span><br><span class="line">tmpfs                             tmpfs     7.9G    <span class="number"> 0 </span> 7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/loop1                        squashfs   64M   64M    <span class="number"> 0 </span>100% /snap/core20/1822</span><br><span class="line">/dev/loop2                        squashfs   68M   68M    <span class="number"> 0 </span>100% /snap/lxd/21835</span><br><span class="line">/dev/loop0                        squashfs   64M   64M    <span class="number"> 0 </span>100% /snap/core20/1778</span><br><span class="line">/dev/sda2                         ext4      1.5G  303M  1.1G  22% /boot</span><br><span class="line">/dev/loop3                        squashfs   50M   50M    <span class="number"> 0 </span>100% /snap/snapd/17950</span><br><span class="line">/dev/loop4                        squashfs   92M   92M    <span class="number"> 0 </span>100% /snap/lxd/24061</span><br><span class="line">/dev/loop5                        squashfs   50M   50M    <span class="number"> 0 </span>100% /snap/snapd/18357</span><br><span class="line">tmpfs                             tmpfs     1.6G    <span class="number"> 0 </span> 1.6G   0% /run/user/0</span><br></pre></td></tr></table></figure><p>其实这里可以重新对硬盘进行分区，创建lvm逻辑卷进行扩容，本着折腾为主，尝试直接对/dev/sda3进行扩容。</p><h1 id="三、对硬盘分区"><a href="#三、对硬盘分区" class="headerlink" title="三、对硬盘分区"></a>三、对硬盘分区</h1><p><strong>使用fdisk命令对硬盘进行分区操作。</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk <span class="regexp">/dev/</span>sda</span><br></pre></td></tr></table></figure><blockquote><p>这里我先输入p，查看扇区，记录下起始扇区，后面重新分区时，要保持一致。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">root@0-125:~<span class="comment"># fdisk /dev/sda</span></span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Command (m for <span class="keyword">help</span>): p   <span class="comment">#查看扇区，记录sda3起始扇区号</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: <span class="number">80</span> GiB, <span class="number">85899345920</span> <span class="keyword">bytes</span>, <span class="number">167772160</span> sectors</span><br><span class="line">Disk <span class="keyword">model</span>: <span class="keyword">Virtual</span> disk</span><br><span class="line">Units: sectors <span class="keyword">of</span> <span class="number">1</span> * <span class="number">512</span> = <span class="number">512</span> <span class="keyword">bytes</span></span><br><span class="line">Sector <span class="keyword">size</span> (<span class="keyword">logical</span>/<span class="keyword">physical</span>): <span class="number">512</span> <span class="keyword">bytes</span> / <span class="number">512</span> <span class="keyword">bytes</span></span><br><span class="line">I/O <span class="keyword">size</span> (<span class="keyword">minimum</span>/<span class="keyword">optimal</span>): <span class="number">512</span> <span class="keyword">bytes</span> / <span class="number">512</span> <span class="keyword">bytes</span></span><br><span class="line">Disklabel <span class="keyword">type</span>: gpt</span><br><span class="line">Disk identifier: <span class="number">7</span>F13220A-DDDB<span class="number">-44</span>AD-BC0D-E3F369DDE708</span><br><span class="line"></span><br><span class="line">Device       <span class="keyword">Start</span>      <span class="keyword">End</span>  Sectors  <span class="keyword">Size</span> <span class="keyword">Type</span></span><br><span class="line">/dev/sda1     <span class="number">2048</span>     <span class="number">4095</span>     <span class="number">2048</span>    <span class="number">1</span>M BIOS boot</span><br><span class="line">/dev/sda2     <span class="number">4096</span>  <span class="number">3149823</span>  <span class="number">3145728</span>  <span class="number">1.5</span>G Linux filesystem</span><br><span class="line">/dev/sda3  <span class="number">3149824</span> <span class="number">83884031</span> <span class="number">80734208</span> <span class="number">38.5</span>G Linux filesystem    <span class="comment">#扇区起始号为3149824</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="keyword">help</span>): d   <span class="comment">#删除分区</span></span><br><span class="line"><span class="keyword">Partition</span> <span class="built_in">number</span> (<span class="number">1</span><span class="number">-3</span>, <span class="keyword">default</span> <span class="number">3</span>): <span class="number">3</span>   <span class="comment">#删除3号分区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Partition</span> <span class="number">3</span> has been deleted.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="keyword">help</span>): n   <span class="comment">#新建分区</span></span><br><span class="line"><span class="keyword">Partition</span> <span class="built_in">number</span> (<span class="number">3</span><span class="number">-128</span>, <span class="keyword">default</span> <span class="number">3</span>): <span class="number">3</span>   <span class="comment">#分区号为3，与之前的保持一致</span></span><br><span class="line"><span class="keyword">First</span> sector (<span class="number">3149824</span><span class="number">-167772126</span>, <span class="keyword">default</span> <span class="number">3149824</span>): <span class="number">3149824</span>    <span class="comment">#扇区起始号，与之前的保持一致</span></span><br><span class="line"><span class="keyword">Last</span> sector, +/-sectors <span class="keyword">or</span> +/-<span class="keyword">size</span>&#123;K,M,G,T,P&#125; (<span class="number">3149824</span><span class="number">-167772126</span>, <span class="keyword">default</span> <span class="number">167772126</span>):   <span class="comment">#结束扇区，这里直接回车默认使用所有</span></span><br><span class="line"></span><br><span class="line">Created a <span class="keyword">new</span> <span class="keyword">partition</span> <span class="number">3</span> <span class="keyword">of</span> <span class="keyword">type</span> <span class="string">'Linux filesystem'</span> <span class="keyword">and</span> <span class="keyword">of</span> <span class="keyword">size</span> <span class="number">78.5</span> GiB.</span><br><span class="line"><span class="keyword">Partition</span> <span class="comment">#3 contains a LVM2_member signature.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Do</span> you want <span class="keyword">to</span> remove the signature? [Y]es/[N]o: n    <span class="comment">#这里一定要选n，不然原来存在的lvm卷就会被干掉</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="keyword">help</span>): w    <span class="comment">#最后输入w，保存退出</span></span><br><span class="line"></span><br><span class="line">The <span class="keyword">partition</span> <span class="keyword">table</span> has been altered.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><blockquote><p>然后执行lsblk查看/dev/sda3的空间已经由原来的38.5G增加至78.5G</p></blockquote><h1 id="四、物理卷大小调整"><a href="#四、物理卷大小调整" class="headerlink" title="四、物理卷大小调整"></a>四、物理卷大小调整</h1><p><strong>使用lvm命令查看，此时虽然增加了/dev/sda3的可用空间，但是lvm物理卷空间是没有增加的</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">lvm</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lvm&gt; vgdisplay</span><br><span class="line">  --- Volume<span class="built_in"> group </span>---</span><br><span class="line">  VG Name               vgubuntu</span><br><span class="line"> <span class="built_in"> System </span>ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence <span class="literal">No</span>  3</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;38.50 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              9855</span><br><span class="line">  Alloc PE / Size       9855 / &lt;38.50 GiB</span><br><span class="line">  Free  PE / Size       0 / 0              #可用空间为0</span><br><span class="line">  VG UUID               que55V-3g38-XqKx-yKdZ-QjQZ-Sy8S-JyQ6bn</span><br></pre></td></tr></table></figure><blockquote><p>接着折腾lvm物理卷，使用pvresize命令对物理卷大小进行调整</p></blockquote><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lvm&gt; vgs     <span class="meta">#查看空间</span></span><br><span class="line">  VG        <span class="meta">#PV #LV #SN Attr   VSize   VFree</span></span><br><span class="line">  ubuntu-vg   <span class="number">1</span>   <span class="number">1</span>   <span class="number">0</span> wz--n- &lt;<span class="number">38.50</span>g    <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">lvm&gt; pvresize -t /dev/sda3     <span class="meta">#先测试一下</span></span><br><span class="line">  TEST MODE: Metadata will <span class="keyword">NOT</span> be updated <span class="keyword">and</span> volumes will <span class="keyword">not</span> <span class="built_in">be</span> (de)activated.</span><br><span class="line">  Physical <span class="built_in">volume</span> <span class="string">"/dev/sda3"</span> changed</span><br><span class="line">  <span class="number">1</span> physical <span class="built_in">volume</span>(s) resized <span class="keyword">or</span> updated / <span class="number">0</span> physical <span class="built_in">volume</span>(s) <span class="keyword">not</span> resized</span><br><span class="line">  </span><br><span class="line">lvm&gt; pvresize  /dev/sda3     <span class="meta">#测试成功去掉 -t 执行</span></span><br><span class="line">  Physical <span class="built_in">volume</span> <span class="string">"/dev/sda3"</span> changed</span><br><span class="line">  <span class="number">1</span> physical <span class="built_in">volume</span>(s) resized <span class="keyword">or</span> updated / <span class="number">0</span> physical <span class="built_in">volume</span>(s) <span class="keyword">not</span> resized</span><br><span class="line">  </span><br><span class="line">lvm&gt; pvs         <span class="meta">#再次查看空间大小已经更改</span></span><br><span class="line">  PV         VG        Fmt  Attr PSize   PFree</span><br><span class="line">  /dev/sda3  vgubuntu lvm2 a--  &lt;<span class="number">78.50</span>g <span class="number">40.00</span>g</span><br></pre></td></tr></table></figure><blockquote><p>稳妥起见，退出检查可用空间是否增加</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@0-125:~# vgdisplay vgubuntu</span><br><span class="line">  --- Volume<span class="built_in"> group </span>---</span><br><span class="line">  VG Name               vgubuntu</span><br><span class="line"> <span class="built_in"> System </span>ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence <span class="literal">No</span>  4</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;78.50 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              20095</span><br><span class="line">  Alloc PE / Size       9855 / &lt;38.50 GiB</span><br><span class="line">  Free  PE / Size       10240 / 40.00 GiB       #这里可用空间已经增加</span><br><span class="line">  VG UUID               que55V-3g38-XqKx-yKdZ-QjQZ-Sy8S-JyQ6bn</span><br></pre></td></tr></table></figure><blockquote><p>这里还需要将可用的物理卷空间扩容至逻辑卷</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@<span class="number">0</span><span class="number">-125</span>:~<span class="comment"># lvextend -l +100%FREE /dev/vgubuntu/root      #将可用空间全部给逻辑卷</span></span><br><span class="line">  Size <span class="keyword">of</span> logical volume vgubuntu/root changed <span class="keyword">from</span> &lt;<span class="number">38.50</span> GiB (<span class="number">9855</span> extents) <span class="keyword">to</span> &lt;<span class="number">78.50</span> GiB (<span class="number">20095</span> extents).</span><br><span class="line">  Logical volume vgubuntu/root successfully resized.</span><br><span class="line"></span><br><span class="line">root@<span class="number">0</span><span class="number">-125</span>:~<span class="comment"># resize2fs /dev/vgubuntu/root    #重新调整一下大小</span></span><br><span class="line">resize2fs <span class="number">1.45</span><span class="number">.5</span> (<span class="number">07</span>-Jan<span class="number">-2020</span>)</span><br><span class="line">Filesystem <span class="keyword">at</span> /dev/vgubuntu/root <span class="keyword">is</span> mounted <span class="keyword">on</span> /; <span class="keyword">on</span>-line resizing required</span><br><span class="line">old_desc_blocks = <span class="number">5</span>, new_desc_blocks = <span class="number">10</span></span><br><span class="line">The filesystem <span class="keyword">on</span> /dev/vgubuntu/root <span class="keyword">is</span> now <span class="number">20577280</span> (<span class="number">4</span>k) blocks long.</span><br></pre></td></tr></table></figure><blockquote><p>最后看看根目录空间是否已经增加</p></blockquote><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@0-125:~<span class="comment"># lsblk</span></span><br><span class="line">NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">loop0                       7:0   <span class="number"> 0 </span>63.3M <span class="number"> 1 </span>loop /snap/core20/1778</span><br><span class="line">loop1                       7:1   <span class="number"> 0 </span>63.3M <span class="number"> 1 </span>loop /snap/core20/1822</span><br><span class="line">loop2                       7:2   <span class="number"> 0 </span>67.2M <span class="number"> 1 </span>loop /snap/lxd/21835</span><br><span class="line">loop3                       7:3   <span class="number"> 0 </span>49.8M <span class="number"> 1 </span>loop /snap/snapd/17950</span><br><span class="line">loop4                       7:4   <span class="number"> 0 </span>91.9M <span class="number"> 1 </span>loop /snap/lxd/24061</span><br><span class="line">loop5                       7:5   <span class="number"> 0 </span>49.9M <span class="number"> 1 </span>loop /snap/snapd/18357</span><br><span class="line">sda                         8:0   <span class="number"> 0 </span>  80G <span class="number"> 0 </span>disk</span><br><span class="line">├─sda1                      8:1   <span class="number"> 0 </span>   1M <span class="number"> 0 </span>part</span><br><span class="line">├─sda2                      8:2   <span class="number"> 0 </span> 1.5G <span class="number"> 0 </span>part /boot</span><br><span class="line">└─sda3                      8:3   <span class="number"> 0 </span>78.5G <span class="number"> 0 </span>part</span><br><span class="line">  └─vgubuntu-root          253:0   <span class="number"> 0 </span>78.5G <span class="number"> 0 </span>lvm  /</span><br><span class="line">sr0                        11:0   <span class="number"> 1 </span>1024M <span class="number"> 0 </span>rom</span><br><span class="line">root@0-125:~<span class="comment"># df -Th</span></span><br><span class="line">Filesystem                        Type      Size  Used Avail Use% Mounted on</span><br><span class="line">udev                              devtmpfs  7.8G    <span class="number"> 0 </span> 7.8G   0% /dev</span><br><span class="line">tmpfs                             tmpfs     1.6G  1.3M  1.6G   1% /run</span><br><span class="line">/dev/mapper/vgubuntu-root         ext4       78G  8.6G   66G  12% /</span><br><span class="line">tmpfs                             tmpfs     7.9G    <span class="number"> 0 </span> 7.9G   0% /dev/shm</span><br><span class="line">tmpfs                             tmpfs     5.0M    <span class="number"> 0 </span> 5.0M   0% /run/lock</span><br><span class="line">tmpfs                             tmpfs     7.9G    <span class="number"> 0 </span> 7.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/loop1                        squashfs   64M   64M    <span class="number"> 0 </span>100% /snap/core20/1822</span><br><span class="line">/dev/loop2                        squashfs   68M   68M    <span class="number"> 0 </span>100% /snap/lxd/21835</span><br><span class="line">/dev/loop0                        squashfs   64M   64M    <span class="number"> 0 </span>100% /snap/core20/1778</span><br><span class="line">/dev/sda2                         ext4      1.5G  303M  1.1G  22% /boot</span><br><span class="line">/dev/loop3                        squashfs   50M   50M    <span class="number"> 0 </span>100% /snap/snapd/17950</span><br><span class="line">/dev/loop4                        squashfs   92M   92M    <span class="number"> 0 </span>100% /snap/lxd/24061</span><br><span class="line">/dev/loop5                        squashfs   50M   50M    <span class="number"> 0 </span>100% /snap/snapd/18357</span><br><span class="line">tmpfs                             tmpfs     1.6G    <span class="number"> 0 </span> 1.6G   0% /run/user/0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虚拟机系统盘的根目录空间不够用，在无加盘条件下，只能考虑给系统盘空间扩容。这种方法风险较高，开始之前，在虚拟机内创建了快照。&lt;/p&gt;
&lt;h1 id=&quot;一、修改分配内存&quot;&gt;&lt;a href=&quot;#一、修改分配内存&quot; class=&quot;headerlink&quot; title=&quot;一、修改分配
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="ubuntu" scheme="https://www.ljjyy.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言简明教程</title>
    <link href="https://www.ljjyy.com/archives/2024/02/100720.html"/>
    <id>https://www.ljjyy.com/archives/2024/02/100720.html</id>
    <published>2024-02-20T04:00:00.000Z</published>
    <updated>2024-02-26T08:35:23.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><hr><h2 id="1、指令"><a href="#1、指令" class="headerlink" title="1、指令"></a>1、指令</h2><p>机器指令：CPU能直接识别并执行的二进制编码</p><p>汇编指令：汇编指令是机器指令的助记符，同机器指令一一对应。</p><p>指令：指令通常由操作码和地址码（操作数）两部分组成</p><p>指令集：每种CPU都有自己的汇编指令集。</p><p>汇编语言由3类指令组成。</p><ul><li>汇编指令</li><li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行</li><li>其他符号：如+、-、＊、/等，由编译器识别，没有对应的机器码。</li></ul><p>编译器：够将汇编指令转换成机器指令的翻译程序每一种CPU都有自己的汇编指令集。</p><p>在内存或磁盘上，指令和数据没有任何区别，都是二进制信息</p><h2 id="2、存储器"><a href="#2、存储器" class="headerlink" title="2、存储器"></a>2、存储器</h2><p>随机存储器（RAM）在程序的执行过程中可读可写，必须带电存储</p><p>只读存储器（ROM）在程序的执行过程中只读，关机数据不丢失</p><h2 id="3、总线"><a href="#3、总线" class="headerlink" title="3、总线"></a>3、总线</h2><hr><h3 id="1-、总线"><a href="#1-、总线" class="headerlink" title="1)、总线"></a>1)、总线</h3><p>总线是连接各个部件的信息传输线，是<code>各个部件共享的传输介质</code>。</p><p>主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有<strong>CPU、存储器、外围芯片组、扩展插槽</strong>等。扩展插槽上一般插有RAM内存条和各类接口卡</p><p>总线根据位置分类：</p><ul><li><p>片内总线（芯片内部总线）</p></li><li><p>系统总线（计算机各部件之间的信息传输线）</p><p>根据传送信息的不同，系统总线从逻辑上又分为3类，地址总线、控制总线和数据总线。</p></li></ul><p>CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行以下3类信息的交互。</p><ol><li><p><strong>地址总线</strong>：CPU通过地址总线来指定存储单元</p><p>1根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是1或0</p><p>10根地址线即一次可以传输10位，访问存储单元地址为1011，寻址范围为0 ~ (210 - 1)</p></li><li><p><strong>数据总线</strong>：CPU与内存或其他器件之间的数据传送是通过数据总线来进行的</p><p>8根数据线一次可传送一个8位二进制数据（即一个字节），传送2个字节需要两次；16根数据线一次可传送2个字节（内存对齐核心原理）</p></li><li><p><strong>控制总线</strong>：CPU对外部器件的控制是通过控制总线来进行的。<br>有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。<br>所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p></li></ol><h3 id="2-、CPU对存储器的读写"><a href="#2-、CPU对存储器的读写" class="headerlink" title="2)、CPU对存储器的读写"></a>2)、CPU对存储器的读写</h3><p>1、 CPU通过地址线将地址信息3发出。<br>2、 CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。<br>3、 存储器将3号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。<br>联想：在组成原理中用微操作表示：(PC) → MAR; 1 → R; M(MAR) → MDR; …</p><h3 id="3-、CPU对外设的控制"><a href="#3-、CPU对外设的控制" class="headerlink" title="3)、CPU对外设的控制"></a>3)、CPU对外设的控制</h3><p>CPU对外设都不能直接控制，如显示器、音箱、打印机等。</p><p>直接控制这些设备进行工作的是插在扩展插槽上的接口卡。</p><p>扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以直接控制这些接口卡，从而实现CPU对外设的间接控制。</p><p>如：CPU无法直接控制显示器，但CPU可以直接控制显卡，从而实现对显示器的间接控制</p><h2 id="4-、内存地址空间"><a href="#4-、内存地址空间" class="headerlink" title="4)、内存地址空间"></a>4)、内存地址空间</h2><p>CPU将系统中各类存储器看作一个逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。<br>对于CPU，所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力限制。</p><p>每个物理存储器在逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据（对ROM写无效）。</p><h1 id="二、寄存器"><a href="#二、寄存器" class="headerlink" title="二、寄存器"></a>二、寄存器</h1><hr><h2 id="1、寄存器"><a href="#1、寄存器" class="headerlink" title="1、寄存器"></a>1、寄存器</h2><p>CPU由运算器、控制器、寄存器等器件构成，这些器件靠片内总线相连。</p><p>运算器进行信息处理；控制器控制各种器件进行工作；寄存器进行信息存储；</p><p>8086CPU有14个寄存器：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW都是16位</p><p>16位结构CPU具有下面几方面的结构特性。</p><ul><li>运算器一次最多可以处理16位的数据；</li><li>寄存器的最大宽度为16位；</li><li>寄存器和运算器之间的通路为16位。</li></ul><p>8086CPU可以一次性处理以下两种尺寸的数据。</p><ul><li>字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。</li><li>字：记为word，一个字由两个字节组成，可以存在一个16位寄存器中(16位CPU)</li></ul><p>8086采用小端模式：高地址存放高位字节，低地址存放低位字节。</p><h2 id="2、通用寄存器"><a href="#2、通用寄存器" class="headerlink" title="2、通用寄存器"></a>2、通用寄存器</h2><p><strong>通用寄存器</strong>：通常用来存放一般性的数据，有AX、BX、CX、DX，它们可分为两个可独立使用的8位寄存器，</p><table><thead><tr><th>16位</th><th>8高位</th><th>8低位</th></tr></thead><tbody><tr><td>AX</td><td>AH</td><td>AL</td></tr><tr><td>BX</td><td>BH</td><td>BL</td></tr><tr><td>CX</td><td>CH</td><td>CL</td></tr><tr><td>DX</td><td>DH</td><td>DL</td></tr></tbody></table><p>在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的</p><p>一个8位寄存器所能存储的数据范围是0 ~ 28-1。</p><h2 id="3、8086CPU给出物理地址的方法"><a href="#3、8086CPU给出物理地址的方法" class="headerlink" title="3、8086CPU给出物理地址的方法"></a>3、8086CPU给出物理地址的方法</h2><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB寻址能力。<br>8086CPU又是16位结构，在内部一次性处理、传输、暂时存储的地址为16位。<br>从8086CPU的内部结构来看，如果将地址从内部简单地发出，那么它只能送出16位的地址，表现出的寻址能力只有64KB。<br>8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址。</p><p>当8086CPU要读写内存时：</p><ol><li>CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址；</li><li>地址加法器将两个16位地址合成为一个20位的物理地址；</li></ol><p>地址加法器采用物理地址 = 段地址×16 + 偏移地址的方法用段地址和偏移地址合成物理地址。</p><p>例如，8086CPU要访问地址为<code>123C8H</code>的内存单元，<code>1230H</code>左移一位(空出4位)加上<code>00C8H</code>合成<code>123C8H</code></p><h2 id="4、段寄存器"><a href="#4、段寄存器" class="headerlink" title="4、段寄存器"></a>4、段寄存器</h2><p>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元，可以用分段的方式来管理内存。</p><p>用一个段存放数据，将它定义为“数据段”；</p><p>用一个段存放代码，将它定义为“代码段”；</p><p>用一个段当作栈，将它定义为“栈段”。</p><p>注意：</p><ul><li>一个段的起始地址一定是16的倍数；</li><li>偏移地址为16位，变化范围为0-FFFFH，所以一个段的长度最大为64KB。</li><li>CPU可以用不同的段地址和偏移地址形成同一个物理地址。</li></ul><p>段寄存器：8086CPU有4个段寄存器：<code>CS、DS、SS、ES</code>，提供内存单元的段地址。</p><h3 id="1-、CS和IP"><a href="#1-、CS和IP" class="headerlink" title="1)、CS和IP"></a>1)、CS和IP</h3><p>CS为代码段寄存器，IP为指令指针寄存器，</p><p>CPU将CS、IP中的内容当作指令的段地址和偏移地址,用它们合成指令的物理地址,</p><p>CPU将CS:IP指向的内容当作指令执行。(即PC)</p><p>8086CPU的工作过程简要描述</p><ol><li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；</li><li>IP=IP+所读取指令的长度，从而指向下一条指令；</li><li>执行指令。转到步骤1，重复这个过程。</li></ol><p>在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。</p><p>8086CPU提供转移指令修改CS、IP的内容。</p><ul><li>jmp 段地址:偏移地址：用指令中给出的段地址修改CS，偏移地址修改IP。如：<code>jmp 2AE3:3</code></li><li>jmp 某一合法寄存器：仅修改IP的内容。如：<code>jmp ax</code>。在含义上好似：<code>mov IP，ax</code></li></ul><p>8086CPU不支持将数据直接送入段寄存器的操作，这属于8086CPU硬件设计</p><h3 id="2-、DS-和-address"><a href="#2-、DS-和-address" class="headerlink" title="2)、DS 和 [address]"></a>2)、DS 和 [address]</h3><p>DS寄存器：通常用来存放要访问数据的段地址</p><p>[address]表示一个偏移地址为address的内存单元，段地址默认放在ds中</p><p>通过数据段段地址和偏移地址即可定位内存单元。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov bx, <span class="number">1000</span>H ;<span class="number">8086</span>CPU不支持将数据直接送入段寄存器的操作</span><br><span class="line"></span><br><span class="line">mov ds, bx ;ds存放数据段地址</span><br><span class="line"></span><br><span class="line">mov [<span class="number">0</span>], al ;将al数据（<span class="number">1</span>字节）存到<span class="number">1000</span>H段的<span class="number">0</span>偏移地址处，即<span class="number">10000</span>H</span><br><span class="line"></span><br><span class="line">mov ax, [<span class="number">2</span>] ;将数据段偏移地址<span class="number">2</span>处的一个字（<span class="number">8086</span>为<span class="number">2</span>字节）存放到ax寄存器</span><br><span class="line"></span><br><span class="line">add cx, [<span class="number">4</span>] ;将偏移地址<span class="number">4</span>处的一个字数据加上cx寄存器数据放到cx寄存器</span><br><span class="line"></span><br><span class="line">sub dx, [<span class="number">6</span>] ;dx寄存器数据减去数据段偏移地址<span class="number">6</span>处的字数据存到dx</span><br></pre></td></tr></table></figure><h3 id="3-、SS-和-SP"><a href="#3-、SS-和-SP" class="headerlink" title="3)、SS 和 SP"></a>3)、SS 和 SP</h3><p>在基于8086CPU编程的时候，可以将一段内存当作栈来使用。</p><p>栈段寄存器SS，存放段地址，SP寄存器存放偏移地址，任意时刻，<strong>SS:SP</strong>指向栈顶元素</p><p>8086CPU中，入栈时，栈顶从高地址向低地址方向增长。</p><p><code>push ax</code>表示将寄存器ax中的数据送入栈中，由两步完成。</p><ol><li>SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；</li><li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。</li></ol><p><code>pop ax</code>表示从栈顶取出数据送入ax，由以下两步完成。</p><ol><li>将SS:SP指向的内存单元处的数据送入ax中；</li><li>SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li></ol><p><strong>实验</strong></p><ol><li>将10000H~1000FH这段空间当作栈，初始状态栈是空的；</li><li>设置AX=001AH，BX=001BH；</li><li>将AX、BX中的数据入栈；</li><li>然后将AX、BX清零；</li><li>从栈中恢复AX、BX原来的内容。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mov ax, 1000H </span><br><span class="line">mov ss, ax </span><br><span class="line">mov sp, 0010H    ;初始化栈顶</span><br><span class="line">mov ax, 001AH</span><br><span class="line">mov bx, 001BH </span><br><span class="line"></span><br><span class="line">push ax </span><br><span class="line">push bx    ;ax、bx入栈</span><br><span class="line"></span><br><span class="line">sub ax, ax   ;将ax清零，也可以用mov ax，0，</span><br><span class="line">             ;sub ax，ax的机器码为2个字节，</span><br><span class="line">             ;mov ax，0的机器码为3个字节。</span><br><span class="line">        </span><br><span class="line">sub bx, bx </span><br><span class="line"></span><br><span class="line">pop bx  ;从栈中恢复ax、bx原来的数据</span><br><span class="line">pop ax  ;</span><br></pre></td></tr></table></figure><h1 id="四、-bx-和-loop指令"><a href="#四、-bx-和-loop指令" class="headerlink" title="四、[bx] 和 loop指令"></a>四、[bx] 和 loop指令</h1><hr><h2 id="1、-bx-和-loop指令"><a href="#1、-bx-和-loop指令" class="headerlink" title="1、[bx] 和 loop指令"></a>1、[bx] 和 loop指令</h2><p><code>[bx]</code> 的含义：[bx]同样表示一个内存单元，它的偏移地址在bx中，段地址默认在ds中</p><p><code>loop</code>指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作，</p><ol><li>(cx) = (cx) - 1；</li><li>判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li></ol><p>例如：计算212</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">mov ax, 2</span><br><span class="line"></span><br><span class="line">mov cx, 11 ;循环次数</span><br><span class="line">s:  add ax, ax </span><br><span class="line">loop s     ;在汇编语言中，标号代表一个地址，标号s实际上标识了一个地址，</span><br><span class="line">               ;这个地址处有一条指令：add ax，ax。</span><br><span class="line">               ;执行loop s时，首先要将（cx）减1，然后若（cx）不为0，则向前</span><br><span class="line">               ;转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。</span><br><span class="line"></span><br><span class="line">mov ax,4c00h </span><br><span class="line">int 21h </span><br><span class="line">code ends </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><strong>loop 和 [bx] 的联合应用</strong></p><p>计算<code>ffff:0 ~ ffff:b</code>单元中的数据的和，结果存储在dx中</p><p>问题分析：</p><ol><li>这些内存单元都是字节型数据范围0 ~ 255 ，12个字节数据和不会超过65535，dx可以存下</li><li>对于8位数据不能直接加到 dx</li></ol><p>解决方案：</p><p>用一个16位寄存器来做中介。将内存单元中的8位数据赋值到一个16位寄存器a中，再将ax中的数据加到dx</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0ffffh</span> <span class="comment">;在汇编源程序中，数据不能以字母开头，所以要在前面加0。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>   <span class="comment">;初始化ds:bx指向ffff:0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0</span>   <span class="comment">;初始化累加寄存器dx，（dx）= 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">12</span>  <span class="comment">;初始化循环计数寄存器cx，（cx）= 12</span></span><br><span class="line"><span class="symbol">s:</span>  <span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">dx</span>, <span class="built_in">ax</span>  <span class="comment">;间接向dx中加上（（ds）＊ 16 +（bx））单元的数值</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span>      <span class="comment">;ds:bx指向下一个单元</span></span><br><span class="line"><span class="keyword">loop</span> s </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends </span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="2、段前缀"><a href="#2、段前缀" class="headerlink" title="2、段前缀"></a>2、段前缀</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ds</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ss</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">es</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ss</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址<br>的“ds:”，“cs:”，“ss:”，“es:”，在汇编语言中称为段前缀。</p><p><strong>段前缀的使用</strong></p><p>将内存<code>ffff:0 ~ ffff:b</code>单元中的数据复制到<code>0:200 ~ 0:20b</code>单元中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0ffffh</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span>   <span class="comment">;（ds）= 0ffffh </span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0020h</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span>   <span class="comment">;（es）= 0020h     0:200 等效于 0020:0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>    <span class="comment">;（bx）= 0，此时ds:bx指向ffff:0，es:bx指向0020:0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>，<span class="number">12</span>   <span class="comment">;（cx）=12，循环12次</span></span><br><span class="line"><span class="symbol">s:</span>  <span class="keyword">mov</span> <span class="built_in">dl</span>，[<span class="built_in">bx</span>] <span class="comment">;（d1）=（（ds）＊ 16+（bx）），将ffff:bx中的字节数据送入dl </span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>]，<span class="built_in">dl</span> <span class="comment">;（（es）＊16+（bx））=（d1），将dl中的数据送入0020:bx </span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span>  <span class="comment">;（bx）=（bx）+1</span></span><br><span class="line"><span class="keyword">loop</span> s </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends </span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="五、包含多个段的程序"><a href="#五、包含多个段的程序" class="headerlink" title="五、包含多个段的程序"></a>五、包含多个段的程序</h1><p>程序中对段名的引用，将被编译器处理为一个表示段地址的数值。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, data </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="built_in">ds</span>:[<span class="number">6</span>]</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>在代码段中使用数据</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;计算 8 个数据的和存到 ax 寄存器</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line"></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span> <span class="comment">;define word 定义8个字形数据</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>  <span class="comment">;标号start</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">add</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends</span><br><span class="line">end start    <span class="comment">;end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</span></span><br><span class="line">      <span class="comment">;用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。</span></span><br></pre></td></tr></table></figure><p>在代码段中使用栈</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;利用栈，将程序中定义的数据逆序存放。</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg </span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>，<span class="number">0456h</span>，<span class="number">0789h</span>，<span class="number">0abch</span>，<span class="number">0defh</span>，<span class="number">0fedh</span>，<span class="number">0cbah</span>，<span class="number">0987h</span> <span class="comment">; 0-15单元</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span> <span class="comment">; 16-47单元作为栈使用</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">30h</span> <span class="comment">;将设置栈顶ss:sp指向栈底cs:30。   30h = 48d</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">push</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s    <span class="comment">;以上将代码段0~15单元中的8个字型数据依次入栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">pop</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>，<span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s0   <span class="comment">;以上依次出栈8个字型数据到代码段0~15单元中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">codesg ends </span><br><span class="line">end start<span class="comment">;指明程序的入口在start处</span></span><br></pre></td></tr></table></figure><p>将数据、代码、栈放入不同的段</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data,<span class="built_in">ss</span>:stack </span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">dw</span> <span class="number">0123h</span>,<span class="number">0456h</span>,<span class="number">0789h</span>,<span class="number">0abch</span>,<span class="number">0defh</span>,<span class="number">0fedh</span>,<span class="number">0cbah</span>,<span class="number">0987h</span> <span class="comment">;0-15单元</span></span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> <span class="comment">;0-31单元</span></span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>, stack<span class="comment">;将名称为“stack”的段的段地址送入ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">20h</span>  <span class="comment">;设置栈顶ss:sp指向stack:20。 20h = 32d</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, data <span class="comment">;将名称为“data”的段的段地址送入ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span>   <span class="comment">;ds指向data段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>    <span class="comment">;ds:bx指向data段中的第一个单元</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span>    <span class="keyword">push</span> [<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s       <span class="comment">;以上将data段中的0~15单元中的8个字型数据依次入栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">pop</span> [<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">loop</span> s0      <span class="comment">;以上依次出栈8个字型数据到data段的0~15单元中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"><span class="comment">;“end start”说明了程序的入口，这个入口将被写入可执行文件的描述信息，</span></span><br><span class="line"><span class="comment">;可执行文件中的程序被加载入内存后，CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令</span></span><br></pre></td></tr></table></figure><p>关于可执行文件结构与程序入口的详细描述参考：<a href="https://blog.csdn.net/qq_39654127/article/details/97905901" target="_blank" rel="noopener">PE文件结构</a></p><h1 id="六、更灵活的定位内存地址的方法"><a href="#六、更灵活的定位内存地址的方法" class="headerlink" title="六、更灵活的定位内存地址的方法"></a>六、更灵活的定位内存地址的方法</h1><hr><h2 id="1、and-和-or"><a href="#1、and-和-or" class="headerlink" title="1、and 和 or"></a>1、and 和 or</h2><p>and指令：逻辑与指令，按位进行与运算。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">01100011B</span><span class="string">`</span></span><br><span class="line"><span class="string">`and al, 00111011B</span></span><br></pre></td></tr></table></figure><p>执行后：<code>al=00100011B</code>即都为1才为1</p><p>or指令：逻辑或指令，按位进行或运算。</p><p><code>mov al, 01100011B</code><br><code>or al, 00111011B</code><br>执行后：<code>al=01111011B</code> 即只要有一个为1就为1</p><p><strong>关于ASCII码</strong><br>世界上有很多编码方案，有一种方案叫做ASCII编码，是在计算机系统中通常被采用的。简单地说，所谓编码方案，就是一套规则，它约定了用什么样的信息来表示现实对象。比如说，在ASCII编码方案中，用61H表示“a”，62H表示“b”。一种规则需要人们遵守才有意义。</p><p>在文本编辑过程中，我们按一下键盘的a键，就会在屏幕上看到“a”。我们按下键盘的a键，这个按键的信息被送入计算机，计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；文本编辑软件从内存中取出61H，将其送到显卡上的显存中；工作在文本模式下的显卡，用ASCII码的规则解释显存中的内容，<br>61H被当作字符“a”，显卡驱动显示器，将字符“a”的图像画在屏幕上。我们可以看到，显卡在处理文本信息的时候，是按照ASCII码的规则进行的。这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCIⅡ码，61H。如何提供？当然是写入显存中。</p><p><strong>以字符形式给出的数据</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data </span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">db</span> <span class="string">'unIx'</span>   <span class="comment">;相当于“db 75H，6EH，49H，58H”</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'foRK'</span></span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="string">'a'</span>  <span class="comment">;相当于“mov al, 61H”，“a”的ASCI码为61H；</span></span><br><span class="line"><span class="keyword">mov</span> b1, <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><strong>大小写转换的问题</strong></p><p>小写字母的ASCII码值比大写字母的ASCII码值大20H</p><p>大写字母ASCII码的第5位为0，小写字母的第5位为1(其他一致)</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg </span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">db</span> <span class="string">'BaSiC'</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'iNfOrMaTion'</span></span><br><span class="line">datasg end</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>, datasg </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span><span class="comment">;设置ds 指向 datasg段</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span><span class="comment">;设置（bx）=0，ds:bx指向’BaSic’的第一个字母</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">5</span>      <span class="comment">;设置循环次数5，因为’Basic'有5个字母</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">bx</span>]     <span class="comment">;将ASCII码从ds:bx所指向的单元中取出</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">11011111B</span><span class="comment">;将al中的ASCII码的第5位置为0，变为大写字母</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>], <span class="built_in">al</span> <span class="comment">;将转变后的ASCII码写回原单元</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span>     <span class="comment">;（bx）加1，ds:bx指向下一个字母</span></span><br><span class="line"><span class="keyword">loop</span> s </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">5</span><span class="comment">;设置（bx）=5，ds:bx指向，iNfOrMaTion'的第一个字母</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">11</span><span class="comment">;设置循环次数11，因为‘iNfOrMaTion'有11个字母</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>, <span class="number">00100000B</span><span class="comment">;将a1中的ASCII码的第5位置为1，变为小写字母</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>], <span class="built_in">al</span> </span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">loop</span> s0</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">codesg ends</span><br></pre></td></tr></table></figure><h2 id="2、-bx-idata"><a href="#2、-bx-idata" class="headerlink" title="2、[bx+idata]"></a>2、[bx+idata]</h2><p>[bx+idata]表示一个内存单元, 例如：<code>mov ax, [bx+200]</code><br>该指令也可以写成如下格式：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="number">200</span>+<span class="built_in">bx</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">200</span>[<span class="built_in">bx</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>].<span class="number">200</span></span><br></pre></td></tr></table></figure><p>用[bx+idata]的方式进行数组的处理</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg </span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">db</span> <span class="string">'BaSiC'</span><span class="comment">;转为大写</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'MinIx'</span><span class="comment">;转为小写</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, datasg </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>  <span class="comment">;初始ds:bx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">5</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0</span>[<span class="built_in">bx</span>]  </span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">11011111b</span> <span class="comment">;转为大写字母</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">0</span>[<span class="built_in">bx</span>], <span class="built_in">al</span> <span class="comment">;写回</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">5</span>[<span class="built_in">bx</span>]  <span class="comment">;[5 + bx]</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">al</span>, <span class="number">00100000b</span> <span class="comment">;转为小写字母</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">5</span>[<span class="built_in">bx</span>], <span class="built_in">al</span> </span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>C语言描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> a[] = <span class="string">"BaSic"</span>;</span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">"MinIX"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">a[i] = a[i] &amp; <span class="number">0xDF</span>;</span><br><span class="line">b[i] = b[i] | <span class="number">0x20</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125; <span class="keyword">while</span>(i &lt; <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="3、SI-、DI-与-寻址方式的灵活应用"><a href="#3、SI-、DI-与-寻址方式的灵活应用" class="headerlink" title="3、SI 、DI 与 寻址方式的灵活应用"></a>3、SI 、DI 与 寻址方式的灵活应用</h2><p><strong>1、si 、di</strong></p><p>si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>: codesg, <span class="built_in">ds</span>: datasg </span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">db</span> <span class="string">'welcome to masm!'</span><span class="comment">;用si和di实现将字符串‘welcome to masm！"复制到它后面的数据区中。</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'................'</span></span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>, datasg </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span>[<span class="built_in">si</span>] <span class="comment">;[0 + si]</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">16</span>[<span class="built_in">si</span>], <span class="built_in">ax</span> <span class="comment">;[16 + si] 使用[bx +idata]方式代替di，使程序更简洁</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">si</span>, <span class="number">2</span> </span><br><span class="line"><span class="keyword">loop</span> s </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">codesg ends </span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><strong>2、[bx + si] 和 [bx + di]</strong></p><p>[bx+si]和[bx+di]的含义相似</p><p>[bx+si]表示一个内存单元，它的偏移地址为（bx）+（si）</p><p>指令<code>mov ax, [bx + si]</code>的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p><p>该指令也可以写成如下格式：<code>mov ax, [bx][si]</code></p><p><strong>3、[bx+si+idata]和[bx+di+idata]</strong><br>[bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+idata</p><p>指令<code>mov ax，[bx+si+idata]</code>的含义：将一个内存单元字数据的内容送入ax，段地址在ds中</p><p><strong>4、不同的寻址方式的灵活应用</strong><br><code>[idata]</code>用一个常量来表示地址，可用于直接定位一个内存单元；<br><code>[bx]</code>用一个变量来表示内存地址，可用于间接定位一个内存单元；<br><code>[bx+idata]</code>用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；<br><code>[bx+si]</code>用两个变量表示地址；<br><code>[bx+si+idata]</code>用两个变量和一个常量表示地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;将datasg段中每个单词改为大写字母</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg,<span class="built_in">ds</span>:datasg,<span class="built_in">ss</span>:stacksg </span><br><span class="line"></span><br><span class="line">datasg <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'ibm            '</span> <span class="comment">;16</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'dec            '</span> </span><br><span class="line"><span class="built_in">db</span> <span class="string">'dos            '</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'vax            '</span>  <span class="comment">;看成二维数组</span></span><br><span class="line">datasg ends </span><br><span class="line"></span><br><span class="line">stacksg <span class="meta">segment</span> <span class="comment">;定义一个段，用来做栈段，容量为16个字节</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">stacksg ends </span><br><span class="line"></span><br><span class="line">codesg <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>, stacksg </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">16</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, datasg </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span> <span class="comment">;初始ds:bx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;cx为默认循环计数器，二重循环只有一个计数器，所以外层循环先保存cx值，再恢复，我们采用栈保存</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">4</span></span><br><span class="line"><span class="symbol">s0:</span><span class="keyword">push</span> <span class="built_in">cx</span><span class="comment">;将外层循环的cx值入栈</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">3</span><span class="comment">;cx设置为内层循环的次数</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">11011111b</span> <span class="comment">;每个字符转为大写字母</span></span><br><span class="line"><span class="keyword">mov</span> [<span class="built_in">bx</span>+<span class="built_in">si</span>], <span class="built_in">al</span> </span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">loop</span> s </span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">16</span> <span class="comment">;下一行</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">cx</span><span class="comment">;恢复cx值</span></span><br><span class="line"><span class="keyword">loop</span> s0 <span class="comment">;外层循环的loop指令将cx中的计数值减1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00H</span> </span><br><span class="line"><span class="keyword">int</span> <span class="number">21H</span> </span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="七、数据处理的两个基本问题"><a href="#七、数据处理的两个基本问题" class="headerlink" title="七、数据处理的两个基本问题"></a>七、数据处理的两个基本问题</h1><h2 id="1、-bx、si、di和bp"><a href="#1、-bx、si、di和bp" class="headerlink" title="1、 bx、si、di和bp"></a>1、 bx、si、di和bp</h2><p>在8086CPU中，只有这4个寄存器可以用在“[…]”中来进行内存单元的寻址。</p><p>在[ ]中，这4个寄存器可以单个出现，或只能以4种组合出现：<code>bx和si、bx和di</code>、<code>bp和si、bp和di</code>。</p><p>只要在[……]中使用寄存器bp，而指令中没有显性地给出段地址, 段地址就默认在ss中</p><p>bx和bp当做基址寄存器，si和di当做变址寄存器。</p><h3 id="bx-bp基址寄存器的区别："><a href="#bx-bp基址寄存器的区别：" class="headerlink" title="bx,bp基址寄存器的区别："></a>bx,bp基址寄存器的区别：</h3><p>bx可以寻址数据(ds)段，默认为ds段的基址，也可以寻址附加段（段跨越）。</p><p>bp只能寻址堆栈(ss)段，默认为ss段的基址，不允许段跨越。</p><p>注意是默认，也就是在不被特别指定时，作为这个段的基址。</p><h3 id="CPU寻址过程"><a href="#CPU寻址过程" class="headerlink" title="CPU寻址过程"></a>CPU寻址过程</h3><ol><li>通过地址总线读取相应CS:IP地址指令</li><li>通过数据总线将读取的指令放入CPU中</li><li>将读取指令放入指令缓冲寄存器中</li><li>执行读取的指令将相应的指令操作完成，从bx偏移地址取值</li><li>将取出来的值通过数据总线放入ax</li></ol><h2 id="2、机器指令处理的数据在什么地方"><a href="#2、机器指令处理的数据在什么地方" class="headerlink" title="2、机器指令处理的数据在什么地方"></a>2、机器指令处理的数据在什么地方</h2><p>数据处理大致可分为3类：读取、写入、运算。</p><p>在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口</p><h2 id="3、汇编语言中数据位置的表达"><a href="#3、汇编语言中数据位置的表达" class="headerlink" title="3、汇编语言中数据位置的表达"></a>3、汇编语言中数据位置的表达</h2><p>汇编语言中用3个概念来表达数据的位置</p><ul><li>立即数（idata）</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1</span>                 <span class="comment">;对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中）</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2000h</span>             <span class="comment">;在汇编语言中称为：立即数（idata）</span></span><br><span class="line"><span class="keyword">or</span> <span class="built_in">bx</span>, <span class="number">00010000b</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="string">'a'</span></span><br></pre></td></tr></table></figure><ul><li>寄存器</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">bx</span>     <span class="comment">;指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">push</span> <span class="built_in">bx</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">bx</span> </span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ds</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="built_in">ax</span></span><br></pre></td></tr></table></figure><ul><li>段地址（SA）和偏移地址（EA）</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;指令要处理的数据在内存中，在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="number">0</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">di</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>+<span class="number">8</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bx</span>+<span class="built_in">si</span>+<span class="number">8</span>]   <span class="comment">;以上段地址默认在ds中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="number">8</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, [<span class="built_in">bp</span>+<span class="built_in">si</span>+<span class="number">8</span>]   <span class="comment">;以上段地址默认在ss中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ds</span>:[<span class="built_in">bp</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">es</span>:[<span class="built_in">bx</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">ss</span>:[<span class="built_in">bx</span>+<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="built_in">bx</span>+<span class="built_in">si</span>+<span class="number">8</span>] <span class="comment">;显式给出存放段地址的寄存器</span></span><br></pre></td></tr></table></figure><h2 id="4、指令要处理的数据有多长"><a href="#4、指令要处理的数据有多长" class="headerlink" title="4、指令要处理的数据有多长"></a>4、指令要处理的数据有多长</h2><p>8086CPU的指令，可以处理两种尺寸的数据，byte和word</p><ol><li>通过寄存器名指明要处理的数据的尺寸。<br>例如： <code>mov al, ds:[0]</code> 寄存器al指明了数据为1字节</li><li>在没有寄存器名存在的情况下，用操作符<code>X ptr</code>指明内存单元的长度，X在汇编指令中可以为<code>word</code>或<code>byte</code>。<br>例如：<code>mov byte ptr ds:[0], 1</code> byte ptr 指明了指令访问的内存单元是一个字节单元</li><li>有些指令默认了访问的是字单元还是字节单元<br>例如，<code>push [1000H]</code>，push 指令只进行字操作。</li></ol><h2 id="5、寻址方式的综合应用"><a href="#5、寻址方式的综合应用" class="headerlink" title="5、寻址方式的综合应用"></a>5、寻址方式的综合应用</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">seg</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">60h</span>   <span class="comment">;确定记录地址，ds:bx </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">0ch</span>], <span class="number">38</span>   <span class="comment">;排名字段改为38  [bx].0ch</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">word</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">0eh</span>], <span class="number">70</span>   <span class="comment">;收入字段增加70  [bx].0eh</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span>   <span class="comment">;用si来定位产品字符串中的字符</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">10h</span>+<span class="built_in">si</span>], <span class="string">'V'</span>   <span class="comment">;[bx].10h[si]</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">10h</span>+<span class="built_in">si</span>], <span class="string">'A'</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>+<span class="number">10h</span>+<span class="built_in">si</span>], <span class="string">'X'</span></span><br></pre></td></tr></table></figure><p>C语言描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/＊定义一个公司记录的结构体＊/</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">company</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> cn[<span class="number">3</span>];/＊公司名称＊/</span><br><span class="line">    <span class="keyword">char</span> hn[<span class="number">9</span>];/＊总裁姓名＊/</span><br><span class="line">    <span class="keyword">int</span> pm;/＊排名＊/</span><br><span class="line">    <span class="keyword">int</span> sr;/＊收入＊/</span><br><span class="line">    <span class="keyword">char</span> cp[<span class="number">3</span>];/＊著名产品＊/</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//sizeof (struct company) == 24</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    /＊定义一个公司记录的变量，内存中将存有一条公司的记录＊/</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">company</span> <span class="title">dec</span> = &#123;</span><span class="string">"DEC"</span>, <span class="string">"Ken Olsen"</span>, <span class="number">137</span>, <span class="number">40</span>, <span class="string">"PDP"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    dec.pm = <span class="number">38</span>;</span><br><span class="line">    dec.sr = dec.sr + <span class="number">70</span>;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    dec.cp[i] = <span class="string">'V'</span>; <span class="comment">//mov byte ptr [bx].10h[si], 'V'</span></span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i] = <span class="string">'A'</span>;</span><br><span class="line">    i++;</span><br><span class="line">    dec.cp[i] = <span class="string">'X'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、div指令、dd、dup、mul指令"><a href="#6、div指令、dd、dup、mul指令" class="headerlink" title="6、div指令、dd、dup、mul指令"></a>6、div指令、dd、dup、mul指令</h2><p><strong>div是除法指令</strong></p><ol><li>除数：有8位和16位两种，在一个<code>寄存器</code>或<code>内存单元</code>中。</li><li>被除数：默认放在<code>AX</code>或<code>DX和AX</code>中，<br>如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li><li>结果：<br>如果除数为8位，则<code>AL存储除法操作的商</code>，<code>AH存储除法操作的余数</code>；<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;利用除法指令计算100001/100。</span></span><br><span class="line"><span class="comment">;100001D = 186A1H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">86A1H</span> <span class="comment">;(dx)＊10000H+(ax)=100001</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">100</span></span><br><span class="line"><span class="keyword">div</span> <span class="built_in">bx</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;利用除法指令计算1001/100</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1001</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bl</span>, <span class="number">100</span></span><br><span class="line"><span class="keyword">div</span> b1</span><br></pre></td></tr></table></figure><p><strong>伪指令dd</strong></p><p>db和dw定义字节型数据和字型数据。</p><p>dd是用来定义dword（double word，双字）型数据的伪指令</p><p><strong>操作符dup</strong></p><p>dup在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。<br>它和db、dw、dd等数据定义伪指令配合使用，用来进行数据的重复</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db <span class="number">3</span> dup (<span class="number">0</span>)       ;定义了<span class="number">3</span>个字节，它们的值都是<span class="number">0</span>，相当于db <span class="number">0</span>，<span class="number">0</span>，<span class="number">0</span>。</span><br><span class="line">db <span class="number">3</span> dup (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>) ;定义了<span class="number">9</span>个字节，它们是<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>、<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>，相当于db <span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">0</span>，<span class="number">1</span>，<span class="number">2</span>。</span><br><span class="line">db <span class="number">3</span> dup ('abc', 'ABC') ;定义了<span class="number">18</span>个字节，它们是abcABCabcABCabcABCC，相当于db 'abc', 'ABC' ,'abc' , 'ABC, 'abc', 'ABC'。</span><br></pre></td></tr></table></figure><p><strong>mul 指令</strong></p><p>mul是乘法指令，使用 mul 做乘法的时候：相乘的两个数：要么都是8位，要么都是16位。</p><ul><li>8 位： <code>AL</code>中和 <code>8位寄存器</code>或<code>内存字节单元</code>中；</li><li>16 位： <code>AX</code>中和 <code>16 位寄存器</code>或<code>内存字单元</code>中。</li></ul><p>结果</p><ul><li>8位：AX中；</li><li>16位：DX（高位）和 AX（低位）中。</li></ul><p>格式：<code>mul 寄存器</code> 或 <code>mul 内存单元</code></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">;计算<span class="number">100</span>＊<span class="number">10</span></span><br><span class="line">;<span class="number">100</span>和<span class="number">10</span>小于<span class="number">255</span>，可以做<span class="number">8</span>位乘法</span><br><span class="line">mov al,<span class="number">100</span></span><br><span class="line">mov bl,<span class="number">10</span></span><br><span class="line">mul bl</span><br><span class="line"></span><br><span class="line">;结果： (ax)=<span class="number">1000</span>（<span class="number">03E8</span>H） </span><br><span class="line"></span><br><span class="line"><span class="number">12345678</span></span><br><span class="line">;计算<span class="number">100</span>＊<span class="number">10000</span></span><br><span class="line">;<span class="number">100</span>小于<span class="number">255</span>，可<span class="number">10000</span>大于<span class="number">255</span>，所以必须做<span class="number">16</span>位乘法，程序如下：</span><br><span class="line">mov ax,<span class="number">100</span></span><br><span class="line">mov bx,<span class="number">10000</span></span><br><span class="line">mul bx</span><br><span class="line"></span><br><span class="line">;结果： (ax)=<span class="number">4240</span>H，(dx)=<span class="number">000</span>FH     （F4240H=<span class="number">1000000</span>）</span><br></pre></td></tr></table></figure><h1 id="八、转移指令的原理"><a href="#八、转移指令的原理" class="headerlink" title="八、转移指令的原理"></a>八、转移指令的原理</h1><hr><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p><p>8086CPU的转移行为有以下几类。</p><ul><li>只修改IP时，称为<code>段内转移</code>，比如：<code>jmp ax</code>。</li><li>同时修改CS和IP时，称为<code>段间转移</code>，比如：<code>jmp 1000:0</code>。</li></ul><p>由于转移指令对IP的修改范围不同，段内转移又分为：<code>短转移和近转移</code>。</p><ul><li>短转移IP的修改范围为<code>-128 ~ 127</code>。</li><li>近转移IP的修改范围为<code>-32768 ~ 32767</code>。</li></ul><p>8086CPU的转移指令分为以下几类。</p><ul><li>无条件转移指令（如：jmp）</li><li>条件转移指令</li><li>循环指令（如：loop）</li><li>过程</li><li>中断</li></ul><h2 id="1、操作符offset"><a href="#1、操作符offset" class="headerlink" title="1、操作符offset"></a>1、操作符offset</h2><p>操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;将s处的一条指令复制到s0处</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol"> s:</span>   <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">bx</span>           <span class="comment">;（mov ax,bx 的机器码占两个字节）</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">si</span>, offset s     <span class="comment">;获得标号s的偏移地址</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">di</span>, offset s0    <span class="comment">;获得标号s0的偏移地址</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">cs</span>:[<span class="built_in">di</span>], <span class="built_in">ax</span></span><br><span class="line"><span class="symbol"> s0:</span>  <span class="keyword">nop</span>                     <span class="comment">;（nop的机器码占一个字节）</span></span><br><span class="line">      <span class="keyword">nop</span></span><br><span class="line"> codesg ends</span><br><span class="line"> ends</span><br></pre></td></tr></table></figure><h2 id="2、jmp指令"><a href="#2、jmp指令" class="headerlink" title="2、jmp指令"></a>2、jmp指令</h2><p>jmp为无条件转移，转到标号处执行指令可以只修改IP，也可以同时修改CS和IP；</p><p>jmp指令要给出两种信息：</p><ul><li>转移的目的地址</li><li><p>转移的距离（段间转移、段内短转移，段内近转移）</p><p><code>jmp short 标号</code> <code>jmp near ptr 标号</code> <code>jcxz 标号</code> <code>loop 标号</code> 等几种汇编指令，它们对 IP的修改</p></li></ul><p>是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移距离。</p><h3 id="1-、依据位移进行转移的jmp指令"><a href="#1-、依据位移进行转移的jmp指令" class="headerlink" title="1)、依据位移进行转移的jmp指令"></a>1)、依据位移进行转移的jmp指令</h3><p><code>jmp short 标号</code>（段内短转移）</p><p>指令“<code>jmp short 标号</code>”的功能为<code>(IP)=(IP)+8位位移</code>，转到标号处执行指令</p><p>（1）8位位移 = “标号”处的地址 - jmp指令后的第一个字节的地址；</p><p>（2）short指明此处的位移为8位位移；</p><p>（3）8位位移的范围为-128~127，用补码表示</p><p>（4）8位位移由编译程序在编译时算出。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">  start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">jmp</span> short s <span class="comment">;s不是被翻译成目的地址</span></span><br><span class="line">        <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="number">1</span></span><br><span class="line"><span class="symbol">      s:</span><span class="keyword">inc</span> <span class="built_in">ax</span> <span class="comment">;程序执行后， ax中的值为 1 </span></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>CPU不需要这个目的地址就可以实现对IP的修改。这里是依据位移进行转移</p><p><strong>jmp short s指令的读取和执行过程：</strong></p><ol><li>(CS)=0BBDH，(IP)=0006，上一条指令执行结束后CS:IP指向EB 03（jmp short s的机器码）；</li><li>读取指令码EB 03进入指令缓冲器；</li><li>(IP) = (IP) + 所读取指令的长度 = (IP) + 2 = 0008，CS:IP指向add ax,1；</li><li>CPU指行指令缓冲器中的指令EB 03；</li><li>指令EB 03执行后，(IP)=000BH，CS:IP指向inc ax</li></ol><p><code>jmp near ptr 标号</code> （段内近转移）</p><p>指令“<code>jmp near ptr 标号</code>”的功能为：<code>(IP) = (IP) + 16位位移</code>。</p><h3 id="2-、转移的目的地址在指令中的jmp指令"><a href="#2-、转移的目的地址在指令中的jmp指令" class="headerlink" title="2)、转移的目的地址在指令中的jmp指令"></a>2)、转移的目的地址在指令中的jmp指令</h3><p><code>jmp far ptr 标号</code>（段间转移或远转移）</p><p>指令 “<code>jmp far ptr 标号</code>” 功能如下：</p><ul><li>(CS) = 标号所在段的段地址；</li><li>(IP) = 标号所在段中的偏移地址。</li><li>far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:codesg</span><br><span class="line">codesg <span class="meta">segment</span></span><br><span class="line"><span class="symbol">   start:</span> <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span></span><br><span class="line">          <span class="keyword">jmp</span> <span class="built_in">far</span> <span class="built_in">ptr</span>  s <span class="comment">;s被翻译成转移的目的地址0B01 BD0B</span></span><br><span class="line">          <span class="built_in">db</span> <span class="number">256</span> dup (<span class="number">0</span>) <span class="comment">;转移的段地址：0BBDH，偏移地址：010BH</span></span><br><span class="line"><span class="symbol">    s:</span>    <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">          <span class="keyword">inc</span> <span class="built_in">ax</span></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="3-、转移地址在寄存器或内存中的jmp指令"><a href="#3-、转移地址在寄存器或内存中的jmp指令" class="headerlink" title="3)、转移地址在寄存器或内存中的jmp指令"></a>3)、转移地址在寄存器或内存中的jmp指令</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp <span class="number">16</span>位寄存器` 功能：`IP =（<span class="number">16</span>位寄存器）</span><br></pre></td></tr></table></figure><p>转移地址在内存中的jmp指令有两种格式：</p><ul><li><code>jmp word ptr 内存单元地址</code>（段内转移）</li></ul><p>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0123H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">;执行后，(IP)=0123H</span></span><br></pre></td></tr></table></figure><ul><li><code>jmp dword ptr 内存单元地址</code>（段间转移）</li></ul><p>功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。</p><ol><li>(CS)=(内存单元地址+2)</li><li>(IP)=(内存单元地址)</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0123H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">ax</span><span class="comment">;偏移地址</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">2</span>], <span class="number">0</span><span class="comment">;段地址</span></span><br><span class="line"><span class="keyword">jmp</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">;执行后，</span></span><br><span class="line"><span class="comment">;(CS)=0</span></span><br><span class="line"><span class="comment">;(IP)=0123H</span></span><br><span class="line"><span class="comment">;CS:IP 指向 0000:0123。</span></span><br></pre></td></tr></table></figure><h3 id="4-、jcxz指令和loop指令"><a href="#4-、jcxz指令和loop指令" class="headerlink" title="4)、jcxz指令和loop指令"></a>4)、jcxz指令和loop指令</h3><p><strong>jcxz指令</strong></p><p>jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，</p><p>在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。</p><p>指令格式：<code>jcxz 标号</code>（如果(cx)=0，则转移到标号处执行。）</p><p>当(cx) = 0时，(IP) = (IP) + 8位位移</p><ul><li>8位位移 = “标号”处的地址 - jcxz指令后的第一个字节的地址；</li><li>8位位移的范围为-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出。</li></ul><p>当(cx)!=0时，什么也不做（程序向下执行）</p><p><strong>loop指令</strong></p><p>loop指令为循环指令，所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。</p><p>对IP的修改范围都为-128~127。</p><p>指令格式：<code>loop 标号</code> ((cx) = (cx) - 1，如果(cx) ≠ 0，转移到标号处执行)。</p><p>(cx) = (cx) - 1；如果 (cx) != 0，(IP) = (IP) + 8位位移。</p><ul><li>8位位移 = 标号处的地址 - loop指令后的第一个字节的地址；</li><li>8位位移的范围为-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出。</li></ul><p>如果（cx）= 0，什么也不做（程序向下执行）。</p><h1 id="九、call和ret指令"><a href="#九、call和ret指令" class="headerlink" title="九、call和ret指令"></a>九、call和ret指令</h1><hr><p>call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。</p><h2 id="1、ret-和-retf"><a href="#1、ret-和-retf" class="headerlink" title="1、ret 和 retf"></a>1、ret 和 retf</h2><ul><li>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</li><li>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。</li></ul><p>CPU执行ret指令时，相当于进行： <code>pop IP</code>：</p><p>（1）(IP) = ( (ss) ＊ 16 + (sp) )</p><p>（2）(sp) = (sp) + 2</p><p>CPU执行retf指令时，相当于进行：<code>pop IP, pop CS</code>：</p><p>（1）(IP) = ( (ss) ＊ 16 + (sp) )</p><p>（2）(sp) = (sp) + 2</p><p>（3）(CS) = ( (ss) ＊ 16 + (sp) )</p><p>（4）(sp) = (sp) + 2</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line">stack seqment</span><br><span class="line"><span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line"><span class="symbol"> start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>, stack </span><br><span class="line"> <span class="keyword">mov</span> <span class="built_in">ss</span>, <span class="built_in">ax</span></span><br><span class="line"> <span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">16</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span> <span class="comment">;ax入栈</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">ret</span> <span class="comment">;ret指令执行后，(IP)=0，CS:IP指向代码段的第一条指令。可以push cs  push ax  retf</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="2、call-指令"><a href="#2、call-指令" class="headerlink" title="2、call 指令"></a>2、call 指令</h2><p>call指令经常跟ret指令配合使用，因此CPU执行call指令，进行两步操作：</p><p>（1）将当前的 IP 或 CS和IP 压入栈中；</p><p>（2）转移（jmp）。</p><p>call指令不能实现短转移，除此之外，call指令实现转移的方法和 jmp 指令的原理相同。</p><p><code>call 标号</code>（近转移）</p><p>CPU执行此种格式的call指令时，相当于进行 <code>push IP</code> <code>jmp near ptr 标号</code></p><p><code>call far ptr 标号</code>（段间转移）</p><p>CPU执行此种格式的call指令时，相当于进行：<code>push CS，push IP</code> <code>jmp far ptr 标号</code></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">call</span> <span class="number">16</span>位寄存器</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，相当于进行： <code>push IP</code> <code>jmp 16位寄存器</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> 内存单元地址</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，相当于进行：<code>push IP</code> <code>jmp word ptr 内存单元地址</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">10h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0123h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">;执行后，(IP)=0123H，(sp)=0EH</span></span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> 内存单元地址</span><br></pre></td></tr></table></figure><p>CPU执行此种格式的call指令时，相当于进行：<code>push CS</code> <code>push IP</code> <code>jmp dword ptr 内存单元地址</code></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>, <span class="number">10h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0123h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="number">0</span>], <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">2</span>], <span class="number">0</span></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="comment">;执行后，(CS)=0，(IP)=0123H，(sp)=0CH</span></span><br></pre></td></tr></table></figure><h2 id="3、call-和-ret-的配合使用"><a href="#3、call-和-ret-的配合使用" class="headerlink" title="3、call 和 ret 的配合使用"></a>3、call 和 ret 的配合使用</h2><p>分析下面程序</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">3</span></span><br><span class="line">     <span class="keyword">call</span> s <span class="comment">;（1）CPU指令缓冲器存放call指令，IP指向下一条指令（mov bx, ax），执行call指令，IP入栈，jmp</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="built_in">ax</span><span class="comment">;（4）IP重新指向这里  bx = 8</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">     s:</span> <span class="keyword">add</span> <span class="built_in">ax</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">loop</span> s<span class="comment">;（2）循环3次ax = 8</span></span><br><span class="line">    <span class="keyword">ret</span><span class="comment">;（3）return : pop IP</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>call 与 ret 指令共同支持了汇编语言编程中的模块化设计</p><p>编写子程序</p><h1 id="十、标志寄存器"><a href="#十、标志寄存器" class="headerlink" title="十、标志寄存器"></a>十、标志寄存器</h1><hr><h2 id="1、标志寄存器"><a href="#1、标志寄存器" class="headerlink" title="1、标志寄存器"></a>1、标志寄存器</h2><p>CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）具有以下3种作用。</p><p>（1）用来存储相关指令的某些执行结果；</p><p>（2）用来为CPU执行相关指令提供行为依据；</p><p>（3）用来控制CPU的相关工作方式。</p><p>这种特殊的寄存器在8086CPU中，被称为标志寄存器（flag）。</p><p>8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW-Program Status Word）</p><p>flag寄存器是按位起作用的，它的每一位都有专门的含义，记录特定的信息。</p><p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令</p><h3 id="1-、零标志位-ZF"><a href="#1-、零标志位-ZF" class="headerlink" title="1)、零标志位 (ZF)"></a>1)、零标志位 (ZF)</h3><p>零标志位（Zero Flag）。它记录相关指令执行后，其结果是否为0。</p><p>如果结果为0，那么zf = 1(表示结果是0)；如果结果不为0，那么zf = 0。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax, <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>, 1 </span>;执行后，结果为<span class="number">0</span>，则zf = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">mov ax, <span class="number">2</span></span><br><span class="line"><span class="function"><span class="keyword">sub</span> <span class="title">ax</span>, 1 </span>;执行后，结果不为<span class="number">0</span>，则zf = <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="2-、奇偶标志位-PF"><a href="#2-、奇偶标志位-PF" class="headerlink" title="2)、奇偶标志位 (PF)"></a>2)、奇偶标志位 (PF)</h3><p>奇偶标志位（Parity Flag）。它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。</p><p>如果1的个数为偶数，pf = 1，如果为奇数，那么pf = 0。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al, <span class="number">1</span></span><br><span class="line">add al, <span class="number">10</span> ;执行后，结果为<span class="number">00001011</span>B，其中有<span class="number">3</span>（奇数）个<span class="number">1</span>，则pf = <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">mov al, <span class="number">1</span></span><br><span class="line">or al, <span class="number">2</span>  ;执行后，结果为<span class="number">00000011</span>B，其中有<span class="number">2</span>（偶数）个<span class="number">1</span>，则pf = <span class="number">1</span>；</span><br></pre></td></tr></table></figure><h3 id="3-、符号标志位-SF"><a href="#3-、符号标志位-SF" class="headerlink" title="3)、符号标志位(SF)"></a>3)、符号标志位(SF)</h3><p>符号标志位(Symbol Flag)。它记录相关指令执行后，其结果是否为负。</p><p>如果结果为负，sf = 1；如果非负，sf = 0。</p><p>计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。</p><p><code>00000001B</code>，可以看作为无符号数1，或有符号数+1；<br><code>10000001B</code>，可以看作为无符号数129，也可以看作有符号数-127。</p><p>对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算</p><p>CPU在执行add等指令的时候，就包含了两种含义:可以将add指令进行的运算当作无符号数的运算，也可以将add指令进行的运算当作有符号数的运算</p><p>SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10000001B</span> </span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>, <span class="number">1</span>   <span class="comment">;执行后，结果为10000010B，sf = 1，表示：如果指令进行的是有符号数运算，那么结果为负；</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10000001B</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>, <span class="number">01111111B</span>   <span class="comment">;执行后，结果为0，sf = 0，表示：如果指令进行的是有符号数运算，那么结果为非负</span></span><br></pre></td></tr></table></figure><h3 id="4-、进位标志位-CF"><a href="#4-、进位标志位-CF" class="headerlink" title="4)、进位标志位(CF)"></a>4)、进位标志位(CF)</h3><p>进位标志位(Carry Flag)。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p><p>97H - 98H 产生借位CF = 1 ==》 (al) = 197H - 98H = FFH</p><h3 id="5-、溢出标志位-OF"><a href="#5-、溢出标志位-OF" class="headerlink" title="5)、溢出标志位(OF)"></a>5)、溢出标志位(OF)</h3><p>溢出标志位(Overflow Flag)。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。</p><p>如果发生溢出，OF = 1；如果没有，OF = 0。</p><p>CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位</p><p>CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。</p><ul><li>对于无符号数运算，CPU用CF位来记录是否产生了进位；</li><li>对于有符号数运算，CPU用OF位来记录是否产生了溢出，当然，还要用SF位来记录结果的符号。</li></ul><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov al, <span class="number">98</span></span><br><span class="line">add al, <span class="number">99</span>   ;执行后将产生溢出。因为进行的<span class="string">"有符号数"</span>运算是：（al）=（al）+ <span class="number">99</span> = <span class="number">98</span> + <span class="number">99</span>=<span class="number">197</span> = C5H 为<span class="number">-59</span>的补码</span><br><span class="line">             ;而结果<span class="number">197</span>超出了机器所能表示的<span class="number">8</span>位有符号数的范围：<span class="number">-128</span><span class="number">-127</span>。</span><br><span class="line">             ;add 指令执行后：无符号运算没有进位CF=<span class="number">0</span>，有符号运算溢出OF=<span class="number">1</span></span><br><span class="line">             ;当取出的数据C5H按无符号解析C5H = <span class="number">197</span>, 当按有符号解析通过SP得知数据为负,即C5H为<span class="number">-59</span>补码存储，</span><br><span class="line">             </span><br><span class="line">mov al，<span class="number">0</span>F0H  ;F0H，为有符号数<span class="number">-16</span>的补码   -Not(F0 - <span class="number">1</span>)</span><br><span class="line">add al，<span class="number">088</span>H  ;<span class="number">88</span>H，为有符号数<span class="number">-120</span>的补码   -Not(<span class="number">88</span>- <span class="number">1</span>)</span><br><span class="line">              ;执行后，将产生溢出。因为add al, <span class="number">088</span>H进行的有符号数运算结果是：（al）= <span class="number">-136</span> </span><br><span class="line">              ;而结果<span class="number">-136</span>超出了机器所能表示的<span class="number">8</span>位有符号数的范围：<span class="number">-128</span><span class="number">-127</span>。</span><br><span class="line">              ;add 指令执行后：无符号运算有进位CF=<span class="number">1</span>，有符号运算溢出OF=<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="2、adc指令和sbb指令"><a href="#2、adc指令和sbb指令" class="headerlink" title="2、adc指令和sbb指令"></a>2、adc指令和sbb指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p><p>指令格式：<code>adc 操作对象1, 操作对象2</code></p><p>功能：操作对象1 = 操作对象1 + 操作对象2 + CF</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax, <span class="number">2</span></span><br><span class="line">mov bx, <span class="number">1</span></span><br><span class="line">sub bx, ax  ;无符号运算借位CF=<span class="number">1</span>，有符号运算OF = <span class="number">0</span></span><br><span class="line">adc ax, <span class="number">1</span>   ;执行后，（ax）= <span class="number">4</span>。adc执行时，相当于计算：(ax)+<span class="number">1</span>+CF = <span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span> = <span class="number">4</span>。</span><br><span class="line"></span><br><span class="line">;计算<span class="number">1</span>EF000H+<span class="number">201000</span>H，结果放在ax（高<span class="number">16</span>位）和bx（低<span class="number">16</span>位）中。</span><br><span class="line">;将计算分两步进行，先将低<span class="number">16</span>位相加，然后将高<span class="number">16</span>位和进位值相加。</span><br><span class="line">mov ax, <span class="number">001</span>EH </span><br><span class="line">mov bx, <span class="number">0</span>F000H </span><br><span class="line">add bx, <span class="number">1000</span>H</span><br><span class="line">adc ax, <span class="number">0020</span>H</span><br></pre></td></tr></table></figure><p><strong>sbb指令</strong></p><p>sbb是带借位减法指令，它利用了CF位上记录的借位值。</p><p>指令格式：<code>sbb 操作对象1, 操作对象2</code></p><p>功能：操作对象1 = 操作对象1 - 操作对象2 - CF</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;计算 003E1000H - 00202000H，结果放在ax，bx中，程序如下：</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">1000H</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">003EH</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">bx</span>, <span class="number">2000H</span></span><br><span class="line"><span class="keyword">sbb</span> <span class="built_in">ax</span>, <span class="number">0020H</span></span><br></pre></td></tr></table></figure><h2 id="3、cmp指令"><a href="#3、cmp指令" class="headerlink" title="3、cmp指令"></a>3、cmp指令</h2><p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令执行后，将对标志寄存器产生影响。</p><p>其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。</p><p>cmp指令格式：<code>cmp 操作对象1，操作对象2</code></p><p>例如：<br>指令<code>cmp ax, ax</code>，做（ax）-（ax）的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。<br>指令执行后：zf=1，pf=1，sf=0，cf=0，of=0。</p><p>CPU在执行cmp指令的时候，也包含两种含义：进行无符号数运算和进行有符号数运算。</p><table><thead><tr><th>cmp ax, bx</th><th>无符号比较时</th></tr></thead><tbody><tr><td>(ax) = (bx)</td><td>zf = 1</td></tr><tr><td>(ax) ≠ (bx)</td><td>zf = 0</td></tr><tr><td>(ax) &lt; (bx)</td><td>cf = 1</td></tr><tr><td>(ax) ≥ (bx)</td><td>cf = 0</td></tr><tr><td>(ax) &gt; (bx)</td><td>cf = 0 且 zf = 0</td></tr><tr><td>(ax) ≤ (bx)</td><td>cf = 1 且 zf = 1</td></tr></tbody></table><p>上面的表格可以正推也可以逆推</p><p>如果用cmp来进行有符号数比较时<br>SF只能记录实际结果的正负，发生溢出的时候，实际结果的正负不能说明逻辑上真正结果的正负。<br>但是逻辑上的结果的正负，才是cmp指令所求的真正结果，所以我们在考察SF的同时考察OF，就可以得知逻辑上真正结果的正负，同时就知道比较的结果。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah, <span class="number">08</span>AH  ; -Not(<span class="number">8</span>A<span class="number">-1</span>) = <span class="number">-118</span>  即当成有符号数时为<span class="number">-118</span></span><br><span class="line">mov bh, <span class="number">070</span>H  ; 有符号数时最高位为<span class="number">0</span>为正数， <span class="number">70</span>H = <span class="number">112</span></span><br><span class="line">cmp ah, bh    ;（ah）-（bh）实际得到的结果是<span class="number">1</span>AH </span><br><span class="line">      ; 在逻辑上，运算所应该得到的结果是：（<span class="number">-118</span>）- <span class="number">112</span> = <span class="number">-230</span></span><br><span class="line">      ; sf记录实际结果的正负，所以sf=<span class="number">0</span></span><br></pre></td></tr></table></figure><blockquote><p><code>cmp ah, bh</code><br>（1）如果sf=1，而of=0 。 of=0说明没有溢出，逻辑上真正结果的正负=实际结果的正负； sf=1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）&lt;（bh）</p><p>（2）如果sf=1，而of=1： of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负； sf=1，实际结果为负。<br>实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负，，如果因为溢出导致了实际结果为负，那么逻辑上真正的结果必然为正。 这样，sf=1，of=1，说明了（ah）&gt;（bh）。</p><p>（3）如果sf=0，而of=1。of=1，说明有溢出，逻辑上真正结果的正负≠实际结果的正负；sf=0，实际结果非负。而of=1说明有溢出，则结果非0，所以，实际结果为正。<br>实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，如果因为溢出导致了实际结果为正，那么逻辑上真正的结果必然为负。这样，sf=0，of=1，说明了（ah）&lt;（bh）。<br>（4）如果sf=0，而of=0<br>of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；sf=0，实际结果非负，所以逻辑上真正的结果非负，所以（ah）≥（bh）。</p></blockquote><h2 id="4、检测比较结果的条件转移指令"><a href="#4、检测比较结果的条件转移指令" class="headerlink" title="4、检测比较结果的条件转移指令"></a>4、检测比较结果的条件转移指令</h2><p>可以根据某种条件，决定是否修改IP的指令</p><p>jcxz它可以检测cx中的数值，如果（cx）=0，就修改IP，否则什么也不做。</p><p>所有条件转移指令的转移位移都是[-128，127]。</p><p>多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP</p><p>这些条件转移指令通常都和cmp相配合使用,它们所检测的标志位，都是cmp指令进行无符号数比较的时记录比较结果的标志位</p><p>根据无符号数的比较结果进行转移的条件转移指令（它们检测zf、cf的值）</p><table><thead><tr><th>指令</th><th>含义</th><th>检测的相关标志位</th></tr></thead><tbody><tr><td>je</td><td>等于则转移</td><td>zf = 1</td></tr><tr><td>jne</td><td>不等于则转移</td><td>zf = 0</td></tr><tr><td>jb</td><td>低于则转移</td><td>cf = 1</td></tr><tr><td>jnb</td><td>不低于则转移</td><td>cf = 0</td></tr><tr><td>ja</td><td>高于则转移</td><td>cf = 0 且 zf = 0</td></tr><tr><td>jna</td><td>不高于则转移</td><td>cf = 1 且 zf = 1</td></tr></tbody></table><p>j：jump，e：equal，b：below，a：above，n：not</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;编程，统计data段中数值为8的字节的个数，用ax保存统计结果。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, data </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0</span>   <span class="comment">;ds:bx指向第一个字节</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span>   <span class="comment">;初始化累加器mov cx，8</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">bx</span>], <span class="number">8</span>   <span class="comment">;和8进行比较</span></span><br><span class="line"><span class="keyword">jne</span> next  <span class="comment">;如果不相等转到next，继续循环</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">ax</span>  <span class="comment">;如果相等就将计数值加1</span></span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">loop</span> s <span class="comment">;程序执行后：（ax）=3</span></span><br></pre></td></tr></table></figure><h2 id="5、DF标志和串传送指令"><a href="#5、DF标志和串传送指令" class="headerlink" title="5、DF标志和串传送指令"></a>5、DF标志和串传送指令</h2><p>方向标志位。在串处理指令中，控制每次操作后si、di的增减。</p><ul><li>df = 0每次操作后si、di递增；</li><li>df = 1每次操作后si、di递减。</li></ul><p>格式：<code>movsb</code><br>功能：将ds:si指向的内存单元中的字节送入es:di中，然后根据标志寄存器df位的值，将si和di递增或递减</p><p>格式：<code>movsw</code><br>功能：将ds:si指向的内存字单元中的字送入es:di中，然后根据标志寄存器df位的值，将si和di递增2或递减2。</p><p>格式：<code>rep movsb</code><br>movsb和movsw进行的是串传送操作中的一个步骤，一般来说，movsb和movsw都和rep配合使用，<br>功能：rep的作用是根据cx的值，重复执行后面的串传送指令</p><p>8086CPU提供下面两条指令对df位进行设置。</p><ul><li><code>cld</code>指令：将标志寄存器的df位置0</li><li><code>std</code>指令：将标志寄存器的df位置1</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;将data段中的第一个字符串复制到它后面的空间中。</span></span><br><span class="line">data <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">db</span> <span class="string">'Welcome to masm!'</span></span><br><span class="line"><span class="built_in">db</span> <span class="number">16</span> dup (<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, data </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span>   <span class="comment">;ds:si 指向data:0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">16</span>  <span class="comment">;es:di指向data:0010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">16</span>  <span class="comment">;（cx）=16，rep循环16次</span></span><br><span class="line"><span class="keyword">cld</span>  <span class="comment">;设置df=0，正向传送</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span></span><br></pre></td></tr></table></figure><h2 id="6、pushf和popf"><a href="#6、pushf和popf" class="headerlink" title="6、pushf和popf"></a>6、pushf和popf</h2><p>pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中</p><p>pushf和popf，为直接访问标志寄存器提供了一种方法。</p><h1 id="十一、内中断"><a href="#十一、内中断" class="headerlink" title="十一、内中断"></a>十一、内中断</h1><h2 id="1、内中断的产生"><a href="#1、内中断的产生" class="headerlink" title="1、内中断的产生"></a>1、内中断的产生</h2><p>任何一个通用的CPU，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从CPU外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，而是转去处理这个特殊信息。</p><p>中断信息可以来自CPU的内部和外部（内中断，外中断）</p><p>内中断：当CPU的内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自CPU的内部</p><p>8086CPU的内中断（下面四种情况将产生中断信息）</p><ul><li>除法错误，比如，执行div指令产生的除法溢出；</li><li>单步执行；</li><li>执行 into指令；</li><li>执行 int指令。</li></ul><p>中断信息中包含中断类型码，中断类型码为一个字节型数据，可以表示256种中断信息的来源（中断源）</p><p>上述的4种中断源，在8086CPU中的中断类型码如下。</p><ul><li>除法错误：0</li><li>单步执行：1</li><li>执行into指令：4</li><li>执行int指令，该指令的格式为int n，指令中的n为字节型立即数，是提供给CPU的中断类型码。</li></ul><h2 id="2、中断处理程序、中断向量表、中断过程"><a href="#2、中断处理程序、中断向量表、中断过程" class="headerlink" title="2、中断处理程序、中断向量表、中断过程"></a>2、中断处理程序、中断向量表、中断过程</h2><p><strong>中断处理程序</strong></p><p>用来处理中断信息的程序被称为中断处理程序。</p><p>根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。比如CPU根据中断类型码4，就可以找到4号中断的处理程序</p><p><strong>中断向量表</strong></p><p>中断向量就是中断处理程序的入口地址。中断向量表就是中断处理程序入口地址的列表</p><p>CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址</p><p><strong>中断过程</strong></p><p>中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置CS和IP</p><p>简要描述如下</p><ol><li>取得中断类型码N；</li><li>pushf</li><li>TF=0，IF=0 （为什么这样参考单步中断）</li><li>push CS , push IP</li><li>（IP）=（N ＊ 4），（CS）=（N ＊ 4 + 2）</li></ol><p>硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。</p><h2 id="3、iret指令"><a href="#3、iret指令" class="headerlink" title="3、iret指令"></a>3、iret指令</h2><p>CPU随时都可能执行中断处理程序，中断处理程序必须一直存储在内存某段空间之中<br>而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。</p><p>中断处理程序的常规编写步骤：</p><ol><li>保存用到的寄存器；</li><li>处理中断；</li><li>恢复用到的寄存器；</li><li>用<code>iret</code>指令返回。</li></ol><p>iret 指令描述为：<code>pop IP</code> <code>pop CS</code> <code>popf</code></p><p>iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序</p><h2 id="4、除法错误中断的处理"><a href="#4、除法错误中断的处理" class="headerlink" title="4、除法错误中断的处理"></a>4、除法错误中断的处理</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">1000h</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">div</span> <span class="number">bh</span> <span class="comment">;除法溢出错误</span></span><br></pre></td></tr></table></figure><p>1、当CPU执行div bh时，发生了除法溢出错误，产生0号中断信息，从而引发中断过程，</p><p>2、CPU执行0号中断处理程序</p><p>3、系统中的0号中断处理程序的功能：显示提示信息“Divide overflow”后，返回到操作系统中。</p><p><strong>编程实验</strong></p><p>编程：编写0号中断处理程序do0，当发生除法溢出时，在屏幕中间显示“overflow！”，返回DOS。</p><p>1、0000:0200至0000:02FF的256个字节的空间所对应的中断向量表项都是空的，可以将中断处理程序do0传送到内存0000:0200处。</p><p>2、中断处理程序do0放到<code>0000:0200</code>,再将其地址登记在中断向量表对应表项</p><ul><li>0号表项的地址<code>0:0</code>。<code>0:0</code>字单元存放偏移地址，<code>0:2</code>字单元存放段地址</li><li>将do0的段地址0存放在<code>0000:0002</code>字单元中，将偏移地址200H存放在<code>0000:0000</code>字单元</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>, offset do0<span class="comment">;设置ds:si指向源地址</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">200h</span><span class="comment">;设置es:di指向目的地址0000:0200</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>, offset do0end - offset do0<span class="comment">;设置cx为传输长度 编译时给出do0部分代码长度</span></span><br><span class="line"><span class="keyword">cld</span>        <span class="comment">;设置传输方向为正</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span> <span class="comment">;将do0的代码送入0:200处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span>               <span class="comment">;设置中断向量表</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>＊<span class="number">4</span>], <span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">0</span>＊<span class="number">4</span>+<span class="number">2</span>], <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;do0程序的主要任务是显示字符串</span></span><br><span class="line"><span class="symbol">do0:</span><span class="keyword">jmp</span> short do0 start </span><br><span class="line">      <span class="built_in">db</span> <span class="string">"overflow!"</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">do0start:</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="built_in">cs</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">202h</span><span class="comment">;设置ds:si指向字符串</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0b800h</span></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>, <span class="number">12</span>＊<span class="number">160</span>+<span class="number">36</span>＊<span class="number">2</span><span class="comment">;设置es:di指向显存空间的中间位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">9</span><span class="comment">;设置cx为字符串长度</span></span><br><span class="line"><span class="symbol">s:</span><span class="keyword">mov</span> <span class="built_in">al</span>, [<span class="built_in">si</span>]</span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>], <span class="built_in">al</span></span><br><span class="line">      <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">      <span class="keyword">add</span> <span class="built_in">di</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">02h</span>             <span class="comment">;设置颜色</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">di</span>], <span class="built_in">al</span>        </span><br><span class="line"><span class="keyword">add</span> <span class="built_in">di</span>, <span class="number">1</span></span><br><span class="line">      <span class="keyword">loop</span> s</span><br><span class="line"></span><br><span class="line">      <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></span><br><span class="line">      <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"><span class="symbol">do0end:</span><span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="5、单步中断"><a href="#5、单步中断" class="headerlink" title="5、单步中断"></a>5、单步中断</h2><ol><li><ul><li>TF陷阱标志(trap flag)：用于调试的单步方式操作</li><li>TF = 1时每条指令执行后产生陷阱，由系统控制计算机</li><li>TF = 0时CPU正常工作</li></ul></li><li><ul><li>IF中断标志(interrupt flag)</li><li>IF = 1允许CPU响应可屏蔽中断请求</li><li>IF = 0关闭中断</li></ul></li></ol><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1</p><p>Debug是如何利用CPU所提供的单步中断的功能进行调试？如使用t命令查看寄存器状态</p><p>Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令</p><p>在使用t命令执行指令时，Debug将TF设置为1，在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。</p><p>在进入中断处理程序之前，设置TF=0。从而避免CPU在执行中断处理程序的时候发生单步中断</p><h2 id="6、int指令"><a href="#6、int指令" class="headerlink" title="6、int指令"></a>6、int指令</h2><p>int指令的格式为：<code>int n</code> ，n为中断类型码，它的功能是引发中断过程。</p><p>CPU执行int n指令，相当于引发一个n号中断的中断过程</p><p>在程序中使用int指令调用任何一个中断的中断处理程序(中断例程)</p><p><strong>编写供应用程序调用的中断例程</strong></p><p><strong>实验1</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;求2 ＊ 3456^2</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span> </span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">3456</span> <span class="comment">;(ax)=3456</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">7ch</span>  <span class="comment">; 调用中断7ch的中断例程，计算ax中的数据的平方</span></span><br><span class="line">     <span class="keyword">add</span> <span class="built_in">ax</span>, <span class="built_in">ax</span>  </span><br><span class="line">     <span class="keyword">adc</span> <span class="built_in">dx</span>, <span class="built_in">dx</span>  <span class="comment">;存放结果，将结果乘以2</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start </span><br><span class="line"></span><br><span class="line"><span class="comment">;编程：安装中断7ch的中断例程</span></span><br><span class="line"><span class="comment">;功能：求一word型数据的平方。</span></span><br><span class="line"><span class="comment">;参数：(ax) = 要计算的数据。</span></span><br><span class="line"><span class="comment">;返回值：dx、ax中存放结果的高16位和低16位。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,offset sqr<span class="comment">;设置ds:si指向源地址</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">200h</span><span class="comment">;设置es:di指向目的地址</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,offset sqrend - offset sqr<span class="comment">;设置cx为传输长度</span></span><br><span class="line"><span class="keyword">cld</span><span class="comment">;设置传输方向为正</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>＊<span class="number">4</span>], <span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>＊<span class="number">4</span>+<span class="number">2</span>], <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">  sqr:</span>  </span><br><span class="line"><span class="keyword">mul</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">iret</span>  <span class="comment">;CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈</span></span><br><span class="line">      <span class="comment">;在执行完中断例程后，应该用iret 指令恢复int 7ch执行前的标志寄存器和CS、IP的</span></span><br><span class="line"><span class="symbol">sqrend:</span><span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p><strong>实验2</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;功能：将一个全是字母，以0结尾的字符串，转化为大写。</span></span><br><span class="line"><span class="comment">;参数：ds:si指向字符串的首地址。</span></span><br><span class="line"><span class="comment">;应用举例：将data段中的字符串转化为大写。</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="string">'conversation'</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>, data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">7ch</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start   </span><br><span class="line"></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">si</span>,offset capital</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">di</span>,<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>,offset capitalend - offset capital</span><br><span class="line"><span class="keyword">cld</span></span><br><span class="line"><span class="keyword">rep</span> <span class="keyword">movsb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>＊<span class="number">4</span>],<span class="number">200h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">7ch</span>＊<span class="number">4</span>+<span class="number">2</span>],<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">capital:</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">change:</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>,[<span class="built_in">si</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="number">ch</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">jcxz</span> ok</span><br><span class="line"><span class="keyword">and</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">si</span>],<span class="number">11011111b</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">jmp</span> short change</span><br><span class="line"><span class="symbol">ok:</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line"><span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">capitalend:</span><span class="keyword">nop</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="7、BIOS和DOS所提供的中断例程"><a href="#7、BIOS和DOS所提供的中断例程" class="headerlink" title="7、BIOS和DOS所提供的中断例程"></a>7、BIOS和DOS所提供的中断例程</h2><p>在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统）</p><p>BIOS中主要包含以下几部分内容</p><ul><li>硬件系统的检测和初始化程序；</li><li>外部中断和内部中断的中断例程；</li><li>用于对硬件设备进行I/O操作的中断例程；</li><li>其他和硬件系统相关的中断例程。</li></ul><p>程序员在编程的时候，可以用int 指令直接调用BIOS和DOS系统提供的中断例程，来完成某些工作。<br>和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。</p><p><strong>BIOS和DOS中断例程的安装过程</strong></p><p>BIOS和DOS提供的中断例程是如何安装到内存中的呢？</p><p>1、开机后，CPU一加电，初始化（CS）= 0FFFFH，（IP）= 0，自动从FFFF:0单元开始执行程序。FFFF:0处有一条转跳指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。</p><p>2、初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。<br>注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到ROM中的程序，一直在内存中存在。</p><p>3、硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。从此将计算机交由操作系统控制。</p><p>4、DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p><p><strong>BIOS中断例程应用</strong></p><p>一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。</p><p>BIOS和DOS提供的中断例程，都用 ah 来传递内部子程序的编号。</p><p>编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的“al。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="comment">;int 10h中断例程的"设置光标位置"功能</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">2</span><span class="comment">;设置光标调用第10h号中断例程的2号子程序，功能为设置光标位置(可以提供光标所在的行号、列号和页号作为参数)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;设置光标到第0页，第5行，第12列</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">0</span>；第<span class="number">0</span>页</span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>, <span class="number">5</span>；<span class="number">dh</span>中放行号</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>, <span class="number">12</span>；<span class="built_in">dl</span>中放列号</span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;int10h中断例程的"在光标位置显示字符"功能。</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>，<span class="number">9</span> <span class="comment">;调用第10h号中断例程的9号子程序，功能为在光标位置显示字符</span></span><br><span class="line"><span class="comment">;提供要显示的字符、颜色属性、页号、字符重复个数作为参数</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>，<span class="string">'a'</span>  <span class="comment">;字符</span></span><br><span class="line"><span class="keyword">mov</span> b1，<span class="number">11001010b</span>  <span class="comment">;颜色属性</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>，<span class="number">0</span>  <span class="comment">;第0页</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cx</span>，<span class="number">3</span>  <span class="comment">;字符重复个数</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span></span><br><span class="line"></span><br><span class="line">code ends </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>bh中页号的含义：内存地址空间中，<code>B8000H~BFFFFH</code>共32kB的空间，为80＊25彩色字符模式的显示缓冲区。<br>一屏的内容在显示缓冲区中共占4000个字节。显示缓冲区分为8页，每页4KB（约4000B），显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说，通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。</p><p><strong>DOS中断例程应用</strong><br><code>int 21h</code>中断例程是DOS提供的中断例程，<code>4ch</code>号功能，即程序返回功能</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">4ch</span> <span class="comment">;调用第21h号中断例程的4ch号子程序，功能为程序返回,可以提供返回值作为参数</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">0</span> <span class="comment">;返回值</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br></pre></td></tr></table></figure><p>编程：在屏幕的5行12列显示字符串“Welcome to <a href="https://so.csdn.net/so/search?q=masm&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">masm</a>！”。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code </span><br><span class="line"> </span><br><span class="line">data <span class="meta">segment</span> </span><br><span class="line"><span class="built_in">db</span><span class="string">'Welcome to masm'</span>,  <span class="string">'$'</span>     <span class="comment">;“$”本身并不显示，只起到边界的作用</span></span><br><span class="line">data ends </span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">2</span> <span class="comment">;10号中断设置光标位置功能</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">0</span> <span class="comment">;第0页</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">dh</span>, <span class="number">5</span>；<span class="number">dh</span>中放行号</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dl</span>, <span class="number">12</span> <span class="comment">;dl中放列号</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">10h</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, data </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0</span> <span class="comment">;ds:dx指向字符串的首地址data:0  （参数）</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">9</span> <span class="comment">;调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，可以提供要显示字符串的地址作为参数</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span> <span class="comment">;21号中断程序返回功能</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span> </span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="十二、端口"><a href="#十二、端口" class="headerlink" title="十二、端口"></a>十二、端口</h1><p>在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片。</p><ul><li>各种接口卡（比如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作；</li><li>主板上的接口芯片，CPU通过它们对部分外设进行访问；</li><li>其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。</li></ul><p>在这些芯片中，都有一组可以由CPU读写的寄存器。这些寄存器，它们在物理上可能处于不同的芯片中，<br>但是它们在以下两点上相同。</p><ul><li>都和CPU的总线相连，这种连接是通过它们所在的芯片进行的；</li><li>CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。</li></ul><p>从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。<br>每一个端口在地址空间中都有一个地址。在访问端口的时候，CPU通过端口地址来定位端口。因为端口所在的芯片和CPU通过总线相连，</p><p>CPU可以直接读写以下3个地方的数据。</p><ul><li>CPU内部的寄存器；</li><li>内存单元；</li><li>端口。</li></ul><h2 id="1、端口的读写"><a href="#1、端口的读写" class="headerlink" title="1、端口的读写"></a>1、端口的读写</h2><p>端口地址和内存地址一样，通过地址总线来传送。在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为<code>0-65535</code>。</p><p>端口的读写指令只有两条：<code>in</code>和<code>out</code>，分别用于从端口读取数据和往端口写入数据。</p><p>在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;对0~255以内的端口进行读写时：</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">20h</span>  <span class="comment">;从20h端口读入一个字节</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">20h</span>, <span class="built_in">al</span>  <span class="comment">;往20h端口写入一个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;对256~65535的端口进行读写时，端口号放在dx中：</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">3f8h</span>  <span class="comment">;将端口号3f8h送入dx</span></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="built_in">dx</span>  <span class="comment">;从3f8h端口读入一个字节</span></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span> <span class="comment">;向3f8h端口写入一个字节</span></span><br></pre></td></tr></table></figure><h2 id="2、CMOS-RAM芯片"><a href="#2、CMOS-RAM芯片" class="headerlink" title="2、CMOS RAM芯片"></a>2、CMOS RAM芯片</h2><p>PC机中，有一个CMOS RAM芯片，一般简称为CMOS。此芯片的特征如下</p><ul><li>包含一个实时钟和一个有128个存储单元的RAM存储器</li><li>该芯片靠电池供电。关机后内部的实时钟正常工作，RAM中的信息不丢失</li><li>128个字节的RAM中，内部实时钟占用<code>0~0dh</code>单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。</li><li>该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM</li><li>70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。<br>可见，CPU对CMOS RAM的读写分两步进行，比如，读CMOS RAM的2号单元：<br>①将2送入端口70h；<br>②从端口71h读出2号单元的内容。</li></ul><p><strong>CMOS RAM中存储的时间信息</strong></p><p>在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。长度都为1个字节，<br>存放单元为：</p><table><thead><tr><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody><tr><td>年</td><td>月</td><td>日</td><td></td><td></td><td>时</td><td></td><td>分</td><td></td><td>秒</td></tr></tbody></table><p>BCD码是以4位二进制数表示十进制数码的编码方法 4 == 0100B</p><p>一个字节可表示两个BCD码。则CMOS RAM存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，高4位的BCD码表示十位，低4位的BCD码表示个位。比如，00010100b表示14。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;编程，在屏幕中间显示当前的月份。</span></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span> </span><br><span class="line"><span class="symbol">start:</span><span class="keyword">mov</span> <span class="built_in">al</span>，<span class="number">8</span> <span class="comment">;从CMOS RAM的8号单元读出当前月份的BCD码。</span></span><br><span class="line"><span class="keyword">out</span> <span class="number">70h</span>，<span class="built_in">al</span> </span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">71h</span> <span class="comment">;从数据端口71h中取得指定单元中的数据：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>, <span class="built_in">al</span> <span class="comment">;al中为从CMOS RAM的8号单元中读出的数据</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="number">4</span></span><br><span class="line"><span class="keyword">shr</span> <span class="number">ah</span>, <span class="built_in">cl</span> <span class="comment">;ah中为月份的十位数码值,左移四位空出四位</span></span><br><span class="line"><span class="keyword">and</span> <span class="built_in">al</span>, <span class="number">00001111b</span> <span class="comment">;al中为月份的个位数码值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span> <span class="number">ah</span>, <span class="number">30h</span> <span class="comment">;BCD码值+30h=十进制数对应的ASCII</span></span><br><span class="line"><span class="keyword">add</span> <span class="built_in">al</span>, <span class="number">30h</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0b800h</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">bx</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">160</span>＊<span class="number">12</span>+<span class="number">40</span>＊<span class="number">2</span>], <span class="number">ah</span> <span class="comment">;显示月份的十位数码</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">160</span>＊<span class="number">12</span>+<span class="number">40</span>＊<span class="number">2</span>+<span class="number">2</span>], <span class="built_in">al</span> <span class="comment">;接着显示月份的个位数码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>，<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="3、shl和shr指令"><a href="#3、shl和shr指令" class="headerlink" title="3、shl和shr指令"></a>3、shl和shr指令</h2><p>shl和shr是逻辑移位指令</p><p>shl是逻辑左移指令，它的功能为：</p><ol><li>将一个寄存器或内存单元中的数据向左移位；</li><li>将最后移出的一位写入CF中；</li><li>最低位用0补充。</li></ol><p>shr是逻辑右移指令，同理</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">01001000b</span> </span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">al</span>, <span class="number">1</span> <span class="comment">;将a1中的数据左移一位执行后（al）=10010000b，CF=0。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">01010001b</span> </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="number">3</span> <span class="comment">;如果移动位数大于1时，必须将移动位数放在cl中</span></span><br><span class="line"><span class="keyword">shl</span> <span class="built_in">al</span>, c1</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">10000001b</span> </span><br><span class="line"><span class="keyword">shr</span> <span class="built_in">al</span>, <span class="number">1</span>  <span class="comment">;将al中的数据右移一位执行后（al）=01000000b，CF=1。</span></span><br></pre></td></tr></table></figure><p>将X逻辑左移一位，相当于执行X=X＊2。<br>将X逻辑右移一位，相当于执行X=X/2</p><h1 id="十三、外中断"><a href="#十三、外中断" class="headerlink" title="十三、外中断"></a>十三、外中断</h1><h2 id="1、外中断"><a href="#1、外中断" class="headerlink" title="1、外中断"></a>1、外中断</h2><p>CPU在计算机系统中，除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出（I/O能力）</p><p>PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问</p><p>外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；<br>CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。<br>CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。</p><p>即：CPU通过端口和外部设备进行联系</p><p>当CPU外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。</p><p><strong>PC系统中，外中断源有两类</strong></p><p>1、可屏蔽中断</p><p>可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。<br>当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应可屏蔽中断。</p><p>可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；而内中断的中断类型码是在CPU内部产生的。</p><p>中断过程中将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。<br>如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。</p><p>8086CPU提供的设置IF的指令：<code>sti</code>，设置IF=1；<code>cli</code>，设置IF=0。</p><p>2、不可屏蔽中断</p><p>不可屏蔽中断是CPU必须响应的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。</p><p>对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：①标志寄存器入栈，IF=0，TF=0；②CS、IP入栈；③（IP）=（8），（CS）=（0AH）。</p><p>几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。</p><h2 id="2、PC机键盘的处理过程"><a href="#2、PC机键盘的处理过程" class="headerlink" title="2、PC机键盘的处理过程"></a>2、PC机键盘的处理过程</h2><p>键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为<code>60h</code>。松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入60h端口中。</p><p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p><p>扫描码长度为一个字节，通码的第7位为0，断码的第7位为1<br>即：断码 = 通码 + 80h。比如，g键的通码为22h，断码为a2h</p><p>键盘的输入到达60h端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int 9中断例程。</p><p>BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下：<br>（1）读出60h端口中的扫描码；<br>（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）送入内存中的BIOS键盘缓冲区； 如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，则将其转变为状态字节写入内存中存储状态字节的单元；<br>（3）对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。</p><p>BIOS键盘缓冲区可以存储15个键盘输入，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。</p><p><code>0040:17</code>单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下。</p><table><thead><tr><th>0</th><th>右shift状态</th><th>置1表示按下右shift键</th></tr></thead><tbody><tr><td>1</td><td>左shift状态</td><td>置1表示按下左shift键</td></tr><tr><td>2</td><td>Ctrl状态</td><td>置1表示按下Ctrl键</td></tr><tr><td>3</td><td>Alt状态</td><td>置1表示按下Alt键</td></tr><tr><td>4</td><td>ScrollLock状态</td><td>置1表示Scroll指示灯亮</td></tr><tr><td>5</td><td>NumLock状态</td><td>置1表示小键盘输入的是数字</td></tr><tr><td>6</td><td>CapsLock状态</td><td>置1表示输入大写字母</td></tr><tr><td>7</td><td>Insert状态</td><td>置1表示处于删除态</td></tr></tbody></table><p><strong>编写int 9中断例程</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。在显示的过程中，按下'Esc'键后，改变显示的颜色。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;完整功能代码：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">stack <span class="meta">segment</span></span><br><span class="line"><span class="built_in">db</span> <span class="number">128</span> dup (<span class="number">0</span>)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line"><span class="built_in">dw</span> <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,stack</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">128</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>＊<span class="number">4</span>]</span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">push</span> <span class="built_in">es</span>:[<span class="number">9</span>＊<span class="number">4</span>+<span class="number">2</span>]</span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ds</span>:[<span class="number">2</span>]<span class="comment">;将原来的int 9中断例程的入口地址保存在ds:0、ds:2单元中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">word</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">9</span>＊<span class="number">4</span>], offset int9</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">9</span>＊<span class="number">4</span>+<span class="number">2</span>], <span class="built_in">cs</span><span class="comment">;在中断向量表中设置新的int 9中断例程的入口地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;显示字符串</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0b800h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">mov</span> <span class="number">ah</span>, <span class="string">'a'</span></span><br><span class="line"><span class="symbol">s:</span></span><br><span class="line"><span class="keyword">mov</span>  <span class="built_in">es</span>:[<span class="number">160</span>＊<span class="number">12</span>+<span class="number">40</span>＊<span class="number">2</span>], <span class="number">ah</span></span><br><span class="line"><span class="keyword">call</span> delay</span><br><span class="line"><span class="keyword">inc</span> <span class="number">ah</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="number">ah</span>, <span class="string">'z'</span></span><br><span class="line"><span class="keyword">jna</span> s</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ds</span>:[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">es</span>:[<span class="number">9</span>＊<span class="number">4</span>]</span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ds</span><span class="comment">;[2]</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">es</span><span class="comment">;[9＊4+2]   ;将中断向量表中int 9中断例程的入口恢复为原来的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line"><span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;将循环延时的程序段写为一个子程序</span></span><br><span class="line"><span class="symbol">delay:</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span> </span><br><span class="line"><span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">2000h</span>  <span class="comment">;用两个16位寄存器来存放32位的循环次数</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line"><span class="symbol">s1:</span> </span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">ax</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">sbb</span> <span class="built_in">dx</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">ax</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">jne</span> s1</span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">dx</span>, <span class="number">0</span></span><br><span class="line"><span class="keyword">jne</span> s1</span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;------以下为新的int 9中断例程--------------------</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9:</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="number">60h</span><span class="comment">;从端口60h读出键盘的输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pushf</span> <span class="comment">;标志寄存器入栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pushf</span>   </span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">and</span> <span class="number">bh</span>,<span class="number">11111100b</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">popf</span><span class="comment">;TF=0,IF=0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ds</span>:[<span class="number">0</span>] <span class="comment">;对int指令进行模拟，调用原来的int 9中断例程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cmp</span> <span class="built_in">al</span>,<span class="number">1</span></span><br><span class="line"><span class="keyword">jne</span> int9ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line"><span class="keyword">inc</span> <span class="built_in">byte</span> <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="number">160</span>＊<span class="number">12</span>+<span class="number">40</span>＊<span class="number">2</span>+<span class="number">1</span>]  <span class="comment">;属性增加1，改变颜色</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">int9ret:</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>CPU对外设输入的通常处理方法<br>（1）外设的输入送入端口；<br>（2）向CPU发出外中断（可屏蔽中断）信息；<br>（3）CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，执行相应的中断例程；<br>（4）可在中断例程中实现对外设输入的处理。</p><p>端口和中断机制，是CPU进行I/O的基础。</p><h1 id="十四、直接定址表"><a href="#十四、直接定址表" class="headerlink" title="十四、直接定址表"></a>十四、直接定址表</h1><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">         a : <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>  <span class="comment">;在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。</span></span><br><span class="line">         b : <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">start :<span class="keyword">mov</span> <span class="built_in">si</span>,offset a</span><br><span class="line">         <span class="keyword">mov</span> <span class="built_in">bx</span>,offset b</span><br><span class="line">         <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line">    s : <span class="keyword">mov</span> <span class="built_in">al</span>,<span class="built_in">cs</span>:[<span class="built_in">si</span>]</span><br><span class="line">         <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">         <span class="keyword">add</span> <span class="built_in">cs</span>:[<span class="built_in">bx</span>],<span class="built_in">ax</span></span><br><span class="line">         <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">         <span class="keyword">loop</span> s</span><br><span class="line">         <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">         <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>程序中，code、a、b、start、s都是标号。这些标号仅仅表示了内存单元的地址</p><p><strong>描述了单位长度的标号</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line">          a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> <span class="comment">;标号a、b后面没有":"，因此它们是可以同时描述内存地址和单元长度的标号。</span></span><br><span class="line">                               <span class="comment">;标号a，描述了地址code:0，和从这个地址开始，以后的内存单元都是字节单元</span></span><br><span class="line">          b <span class="built_in">dw</span> <span class="number">0</span>               <span class="comment">;标号b描述了地址code:8，和从这个地址开始，以后的内存单元都是字单元。</span></span><br><span class="line">start :  <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line">    s :   <span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>]</span><br><span class="line">          <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">          <span class="keyword">add</span> b,<span class="built_in">ax</span></span><br><span class="line">          <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">          <span class="keyword">loop</span> s</span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">          <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>使用<strong>数据标号</strong>来描述存储数据的单元的地址和长度。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data ；用伪指令<span class="meta">assume</span>将标号所在的段和一个段寄存器联系起来(编译器需要)</span><br><span class="line">data <span class="meta">segment</span>          </span><br><span class="line">          a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">          b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span> <span class="comment">;真正确定ds寄存器</span></span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span></span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">8</span></span><br><span class="line"><span class="symbol">s:</span>       <span class="keyword">mov</span> <span class="built_in">al</span>,a[<span class="built_in">si</span>] <span class="comment">;编译为：mov al,[si+0] 默认所访问单元的段地址在ds</span></span><br><span class="line">          <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">0</span></span><br><span class="line">          <span class="keyword">add</span> b,<span class="built_in">ax</span> <span class="comment">;编译为：add [8],ax</span></span><br><span class="line">          <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">          <span class="keyword">loop</span> s</span><br><span class="line">          <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">          <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">c <span class="built_in">dw</span> a, b <span class="comment">;等价于c dw offset a, offset b</span></span><br><span class="line"><span class="comment">;数据标号c处存储的两个字型数据为标号a、b 的偏移地址</span></span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">a <span class="built_in">db</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span></span><br><span class="line">b <span class="built_in">dw</span> <span class="number">0</span></span><br><span class="line">c <span class="built_in">dd</span> a,b <span class="comment">;等价于c dw offset a, seg a, offset b, seg b</span></span><br><span class="line"><span class="comment">;数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b 的偏移地址和段地址</span></span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>seg操作符，功能为取得某一标号的段地址</p><p>建立一张表，表中依次存储字符“0”~“F”，我们可以通过数值0 ~ 15直接查找到对应的字符</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>  </span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">al</span>,<span class="number">0eh</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">call</span> showbyte</span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">        <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;子程序：</span></span><br><span class="line"><span class="comment">;用al传送要显示的数据</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">showbyte:</span></span><br><span class="line">        <span class="keyword">jmp</span> short show</span><br><span class="line"></span><br><span class="line">        table <span class="built_in">db</span> <span class="string">'0123456789ABCDEF'</span><span class="comment">;字符表</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show:</span>   <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">ah</span>,<span class="built_in">al</span></span><br><span class="line">        <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span>           </span><br><span class="line">        <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span></span><br><span class="line">        <span class="keyword">shr</span> <span class="number">ah</span>,<span class="number">1</span>    <span class="comment">;右移4位，ah中得到高4位的值</span></span><br><span class="line">        <span class="keyword">and</span> <span class="built_in">al</span>,<span class="number">00001111b</span><span class="comment">;al中为低4位的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="number">ah</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">ah</span>,table[<span class="built_in">bx</span>]<span class="comment">;用高4位的值作为相对于table的偏移，取得对应的字符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0b800h</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>＊<span class="number">12</span>+<span class="number">40</span>＊<span class="number">2</span>],<span class="number">ah</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bl</span>,<span class="built_in">al</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">bh</span>,<span class="number">0</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">al</span>,table[<span class="built_in">bx</span>]<span class="comment">;用低4位的值作为相对于table的偏移，取得对应的字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="number">160</span>＊<span class="number">12</span>+<span class="number">40</span>＊<span class="number">2</span>+<span class="number">2</span>],<span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="十五、-总结"><a href="#十五、-总结" class="headerlink" title="十五、 总结"></a>十五、 总结</h1><h2 id="1、寄存器分类"><a href="#1、寄存器分类" class="headerlink" title="1、寄存器分类"></a>1、寄存器分类</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器:       <span class="built_in">EAX</span>、<span class="built_in">EBX</span>、<span class="built_in">ECX</span>、<span class="built_in">EDX</span>：是<span class="built_in">ax</span>,<span class="built_in">bx</span>,<span class="built_in">cx</span>,<span class="built_in">dx</span>的延伸，各为<span class="number">32</span>位</span><br><span class="line">    <span class="number">AH</span>＆<span class="built_in">AL</span>=<span class="built_in">AX</span>(accumulator)           :累加寄存器</span><br><span class="line">    <span class="number">BH</span>＆<span class="built_in">BL</span>=<span class="built_in">BX</span>(base)                  :基址寄存器</span><br><span class="line">    <span class="number">CH</span>＆<span class="built_in">CL</span>=<span class="built_in">CX</span>(count)                 :计数寄存器</span><br><span class="line">    <span class="number">DH</span>＆<span class="built_in">DL</span>=<span class="built_in">DX</span>(data)                  :数据寄存器</span><br><span class="line">特殊功能寄存器:    <span class="built_in">ESP</span>、<span class="built_in">EBP</span>、<span class="built_in">ESI</span>、<span class="built_in">EDI</span>、<span class="built_in">EIP</span>：是<span class="built_in">sp</span>,<span class="built_in">bp</span>,<span class="built_in">si</span>,<span class="built_in">di</span>,<span class="built_in">ip</span>的延伸，<span class="number">32</span>位</span><br><span class="line">    <span class="built_in">SP</span>(Stack Pointer)                :堆栈指针寄存器(存放栈顶的偏移地址)</span><br><span class="line">    <span class="built_in">BP</span>(Base Pointer)                 :基址指针寄存器(堆栈区中的一个基址地址)</span><br><span class="line">    <span class="built_in">SI</span>(Source Index)                 :源变址寄存器</span><br><span class="line">    <span class="built_in">DI</span>(Destination Index)            :目的变址寄存器</span><br><span class="line">    <span class="built_in">IP</span>(Instruction Pointer)          :指令指针寄存器</span><br><span class="line">段寄存器：</span><br><span class="line">    <span class="built_in">CS</span>(Code <span class="meta">Segment</span>)                 :代码段寄存器</span><br><span class="line">    <span class="built_in">DS</span>(Data <span class="meta">Segment</span>)                 :数据段寄存器</span><br><span class="line">    <span class="built_in">SS</span>(Stack <span class="meta">Segment</span>)                :堆栈段寄存器</span><br><span class="line">    <span class="built_in">ES</span>(Extra <span class="meta">Segment</span>)                :附加段寄存器</span><br><span class="line">标志寄存器：        </span><br><span class="line">    FR--flag register（程序状态字PSW--program status <span class="built_in">word</span>）,PSW常用的标志有：    </span><br><span class="line">    标志                值为<span class="number">1</span>时的标记      值为<span class="number">0</span>时的标记      说明</span><br><span class="line">    OF(overflow flag)   OV(overflow)     NV(<span class="keyword">not</span> overflow) 溢出标志 操作数超出机器能表示的范围表示溢出.溢出时为<span class="number">1</span>.</span><br><span class="line">    ZF(<span class="meta">zero</span> flag)       ZR(<span class="meta">zero</span>)         NZ(<span class="keyword">not</span> <span class="meta">zero</span>)     零标志 运算结果等于<span class="number">0</span>时为<span class="number">1</span>.否则为<span class="number">0</span>.</span><br><span class="line">    PF(parity flag)     PE(parity even)  PO(parity odd)   奇偶标志 运算结果操作数位为<span class="number">1</span>的个数为偶数个时为<span class="number">1</span>.否则为<span class="number">0</span>.</span><br><span class="line">    CF(carry flag)      CY(carried)      NC(<span class="keyword">not</span> carried)  进位标志 最高有效位产生进位时为<span class="number">1</span>.否则为<span class="number">0</span>.</span><br><span class="line">    DF(direction flag)  DN(<span class="meta">down</span>)         <span class="meta">UP</span>(<span class="meta">up</span>)           方向标志 用于串处理.DF=<span class="number">1</span>时.每次操作后使<span class="built_in">SI</span>和<span class="built_in">DI</span>减小.DF=<span class="number">0</span>时则增大.</span><br><span class="line">    SF(sign flag)       NG(negtive)      PL(plus)         符号标志 记录运算结果的符号.结果负时为<span class="number">1</span>.</span><br><span class="line">    TF(trap flag)                                         陷阱标志 用于调试单步操作.</span><br><span class="line">    IF(interrupt flag)                                    中断标志 IF=<span class="number">1</span>时.允许<span class="meta">CPU</span>响应可屏蔽中断.否则关闭中断.</span><br><span class="line">    AF(auxiliary flag)                                    辅助进位标志 运算时.第<span class="number">3</span>位向第<span class="number">4</span>位产生进位时为<span class="number">1</span>.否则为<span class="number">0</span>.</span><br></pre></td></tr></table></figure><h2 id="2、指令分类"><a href="#2、指令分类" class="headerlink" title="2、指令分类"></a>2、指令分类</h2><h3 id="2-1、数据传输指令"><a href="#2-1、数据传输指令" class="headerlink" title="2.1、数据传输指令"></a>2.1、数据传输指令</h3><p>它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据。<br>1)、通用数据传送指令<br>MOV 传送字或字节。<br>MOVSX 先符号扩展，再传送。<br>MOVZX 先零扩展，再传送。<br>PUSH 把字压入堆栈。<br>POP 把字弹出堆栈。<br>PUSHA 把AX，CX，DX，BX，SP，BP，SI，DI依次压入堆栈。<br>POPA 把DI，SI，BP，SP，BX，DX，CX，AX依次弹出堆栈。<br>PUSHAD 把EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI依次压入堆栈。<br>POPAD 把EDI，ESI，EBP，ESP，EBX，EDX，ECX，EAX依次弹出堆栈。<br>BSWAP 交换32位寄存器里字节的顺序<br>XCHG 交换字或字节。( 至少有一个操作数为寄存器，段寄存器不可作为操作数)<br>CMPXCHG 比较并交换操作数。( 第二个操作数必须为累加器AL/AX/EAX )<br>XADD 先交换再累加。( 结果在第一个操作数里 )<br>XLAT 字节查表转换。<br>── BX 指向一张 256 字节的表的起点， AL 为表的索引值 (0-255，即<br>0-FFH); 返回 AL 为查表结果。 ( [BX+AL]-&gt;AL )</p><p>2)、输入输出端口传送指令<br>IN I/O端口输入。 ( 语法: IN 累加器， {端口号│DX} )<br>OUT I/O端口输出。 ( 语法: OUT {端口号│DX}，累加器 )<br>输入输出端口由立即方式指定时， 其范围是 0-255; 由寄存器 DX 指定时，<br>其范围是 0-65535。</p><p>3)、 目的地址传送指令<br>LEA 装入有效地址。<br>例: LEA DX，string ;把偏移地址存到DX。<br>LDS 传送目标指针，把指针内容装入DS。<br>例: LDS SI，string ;把段地址:偏移地址存到DS:SI。<br>LES 传送目标指针，把指针内容装入ES。<br>例: LES DI，string ;把段地址:偏移地址存到ES:DI。<br>LFS 传送目标指针，把指针内容装入FS。<br>例: LFS DI，string ;把段地址:偏移地址存到FS:DI。<br>LGS 传送目标指针，把指针内容装入GS。<br>例: LGS DI，string ;把段地址:偏移地址存到GS:DI。<br>LSS 传送目标指针，把指针内容装入SS。<br>例: LSS DI，string ;把段地址:偏移地址存到SS:DI。</p><p>4)、 标志传送指令<br>LAHF 标志寄存器传送，把标志装入AH。<br>SAHF 标志寄存器传送，把AH内容装入标志寄存器。<br>PUSHF 标志入栈。<br>POPF 标志出栈。<br>PUSHD 32位标志入栈。<br>POPD 32位标志出栈。</p><h3 id="2-2、算术运算指令"><a href="#2-2、算术运算指令" class="headerlink" title="2.2、算术运算指令"></a>2.2、算术运算指令</h3><p>ADD 加法。<br>ADC 带进位加法。<br>INC 加 1。<br>AAA 加法的ASCII码调整。<br>DAA 加法的十进制调整。<br>SUB 减法。<br>SBB 带借位减法。<br>DEC 减 1。<br>NEC 求反(以 0 减之)。<br>CMP 比较。(两操作数作减法，仅修改标志位，不回送结果)。<br>AAS 减法的ASCII码调整。<br>DAS 减法的十进制调整。<br>MUL 无符号乘法。<br>IMUL 整数乘法。<br>以上两条，结果回送AH和AL(字节运算)，或DX和AX(字运算)，<br>AAM 乘法的ASCII码调整。<br>DIV 无符号除法。<br>IDIV 整数除法。<br>以上两条，结果回送:<br>商回送AL，余数回送AH， (字节运算);<br>或 商回送AX，余数回送DX， (字运算)。<br>AAD 除法的ASCII码调整。<br>CBW 字节转换为字。 (把AL中字节的符号扩展到AH中去)<br>CWD 字转换为双字。 (把AX中的字的符号扩展到DX中去)<br>CWDE 字转换为双字。 (把AX中的字符号扩展到EAX中去)<br>CDQ 双字扩展。 (把EAX中的字的符号扩展到EDX中去)</p><h3 id="2-3、逻辑运算指令"><a href="#2-3、逻辑运算指令" class="headerlink" title="2.3、逻辑运算指令"></a>2.3、逻辑运算指令</h3><p>AND 与运算。<br>OR 或运算。<br>XOR 异或运算。<br>NOT 取反。<br>TEST 测试。(两操作数作与运算，仅修改标志位，不回送结果)。<br>SHL 逻辑左移。<br>SAL 算术左移。(=SHL)<br>SHR 逻辑右移。<br>SAR 算术右移。(=SHR)<br>ROL 循环左移。<br>ROR 循环右移。<br>RCL 通过进位的循环左移。<br>RCR 通过进位的循环右移。<br>以上八种移位指令，其移位次数可达255次。<br>移位一次时， 可直接用操作码。 如 SHL AX，1。<br>移位&gt;1次时， 则由寄存器CL给出移位次数。<br>如 MOV CL，04<br>SHL AX，CL</p><h3 id="2-4、串指令"><a href="#2-4、串指令" class="headerlink" title="2.4、串指令"></a>2.4、串指令</h3><p>DS:SI 源串段寄存器 :源串变址。<br>ES:DI 目标串段寄存器:目标串变址。<br>CX 重复次数计数器。<br>AL/AX 扫描值。<br>D标志 0表示重复操作中SI和DI应自动增量; 1表示应自动减量。<br>Z标志 用来控制扫描或比较操作的结束。<br>MOVS 串传送。<br>( MOVSB 传送字符。 MOVSW 传送字。 MOVSD 传送双字。 )<br>CMPS 串比较。<br>( CMPSB 比较字符。 CMPSW 比较字。 )<br>SCAS 串扫描。<br>把AL或AX的内容与目标串作比较，比较结果反映在标志位。<br>LODS 装入串。<br>把源串中的元素(字或字节)逐一装入AL或AX中。<br>( LODSB 传送字符。 LODSW 传送字。 LODSD 传送双字。 )<br>STOS 保存串。<br>是LODS的逆过程。<br>REP 当CX/ECX&lt;&gt;0时重复。<br>REPE/REPZ 当ZF=1或比较结果相等，且CX/ECX&lt;&gt;0时重复。<br>REPNE/REPNZ 当ZF=0或比较结果不相等，且CX/ECX&lt;&gt;0时重复。<br>REPC 当CF=1且CX/ECX&lt;&gt;0时重复。<br>REPNC 当CF=0且CX/ECX&lt;&gt;0时重复。</p><h3 id="2-5、程序转移指令"><a href="#2-5、程序转移指令" class="headerlink" title="2.5、程序转移指令"></a>2.5、程序转移指令</h3><p>1)、无条件转移指令 (长转移)<br>JMP 无条件转移指令<br>CALL 过程调用<br>RET/RETF过程返回。</p><p>2)、条件转移指令 (短转移，-128到+127的距离内)<br>( 当且仅当(SF XOR OF)=1时，OP1 JA/JNBE 不小于或不等于时转移。<br>JAE/JNB 大于或等于转移。<br>JB/JNAE 小于转移。<br>JBE/JNA 小于或等于转移。<br>以上四条，测试无符号整数运算的结果(标志C和Z)。<br>JG/JNLE 大于转移。<br>JGE/JNL 大于或等于转移。<br>JL/JNGE 小于转移。<br>JLE/JNG 小于或等于转移。<br>以上四条，测试带符号整数运算的结果(标志S，O和Z)。<br>JE/JZ 等于转移。<br>JNE/JNZ 不等于时转移。<br>JC 有进位时转移。<br>JNC 无进位时转移。<br>JNO 不溢出时转移。<br>JNP/JPO 奇偶性为奇数时转移。<br>JNS 符号位为 “0” 时转移。<br>JO 溢出转移。<br>JP/JPE 奇偶性为偶数时转移。<br>JS 符号位为 “1” 时转移。</p><p>3)、循环控制指令(短转移)<br>LOOP CX不为零时循环。<br>LOOPE/LOOPZ CX不为零且标志Z=1时循环。<br>LOOPNE/LOOPNZ CX不为零且标志Z=0时循环。<br>JCXZ CX为零时转移。<br>JECXZ ECX为零时转移。</p><p>4)、中断指令<br>INT 中断指令<br>INTO 溢出中断<br>IRET 中断返回</p><p>5)、处理器控制指令<br>HLT 处理器暂停， 直到出现中断或复位信号才继续。<br>WAIT 当芯片引线TEST为高电平时使CPU进入等待状态。<br>ESC 转换到外处理器。<br>LOCK 封锁总线。<br>NOP 空操作。<br>STC 置进位标志位。<br>CLC 清进位标志位。<br>CMC 进位标志取反。<br>STD 置方向标志位。<br>CLD 清方向标志位。<br>STI 置中断允许位。<br>CLI 清中断允许位。</p><h3 id="2-6、伪指令"><a href="#2-6、伪指令" class="headerlink" title="2.6、伪指令"></a>2.6、伪指令</h3><p>DW 定义字(2字节)。<br>PROC 定义过程。<br>ENDP 过程结束。<br>SEGMENT 定义段。<br>ASSUME 建立段寄存器寻址。<br>ENDS 段结束。<br>END 程序结束。</p><h2 id="3、指令详解"><a href="#3、指令详解" class="headerlink" title="3、指令详解"></a>3、指令详解</h2><table><thead><tr><th>指令</th><th>使用介绍</th><th>补充说明</th></tr></thead><tbody><tr><td>AAA</td><td>未组合的十进制加法调整指令 AAA(ASCII Adgust for Addition) 格式: AAA 功能: 对两个组合的十进制数相加运算(存在AL中)的结果进行调整,产生一个未组合的十进制数放在AX中.</td><td>说明: 1. 组合的十进制数和未组合的十进制数:在计算中,十进制数可用四位二进制数编码,称为BCD码. 当一个节(8位)中存放一位BCD码,且放在字节的低4位, 高4位为时称为未组合的BCD码. 2. AAA的调整操作 若(AL) and 0FH&gt;9 或 AF=1,则调整如下: (AL)&lt;–(AL)+6,(AH)&lt;–(AH)+1,AF=1,CF&lt;–AF,(AL)&lt;–(AL) and 0FH</td></tr><tr><td>AAD</td><td>未组合十进制数除法调整指令 AAD(ASCII Adjust for Division) 格式: AAD 功能: 在除法指令前对AX中的两个未组合十进制数进行调整,以便能用DIV指令实现两个未组合的十进制数的除法运算,其结果为未组合的十进制数,商(在AL中)和余数(在AH中).</td><td>说明: 1. AAD指令是在执行除法DIV之前使用的,以便得到二进制结果存于AL中,然后除以OPRD,得到的商在AL中,余数在AH中. 2. 示例: MOV BL,5 MOV AX,0308H AAD ;(AL)&lt;–1EH+08H=26H,(AH)<--0 div bl ;商＝07h-->(AL),余数＝03H–&gt;(AH).</--0></td></tr><tr><td>AAM</td><td>未组合十进制数乘法调整指令 AAM(ASCII Adjust MULtiply) 格式: AAM 功能: 对两个未组合的十进制数相乘后存于AX中的结果进行调整,产生一个未组合的十进制数存在AL中.</td><td>说明: 1. 实际上是两个未组合的十进制数字节相乘,一个0～9的数与另一个0～9的数相乘其积最大为81.为了得到正确的结果,应进行如下调整: 乘积: (AH)&lt;–(AL)/10 (AL)&lt;–(AL)MOD10 2. 本指令应跟在MUL指令后使用,乘积的两位十进制结果,高位放在AH中,低位放在AL中.AH内容是MUL指令的结果被10除的商,即(AL)/10,而最后的AL内容是乘积被10整除的余数(即个位数).</td></tr><tr><td>AAS</td><td>未组合十进制减法调整指令 AAS(ASCII Adjust for Subtraction) 格式: AAS 功能: 对两个未组合十进制数相减后存于AL中的结果进行调整,调整后产生一个未组合的十进制数数且仍存于AL中.</td><td>说明: 1. 本指令影响标志位CF及AF. 2. 调整操作 若(AL) and 0FH &gt; 9 或 AF=1 则(AL)&lt;–(AL)-6,(AH)&lt;–(AH)-1,CF&lt;–AF,(AL)&lt;–(AL) and 0FH, 否则(AL)&lt;–(AL) and 0FH</td></tr><tr><td>ADC</td><td>带进位加法指令 ADC(Addition Carry) 格式: ADC OPRD1,OPRD2 功能: OPRD1&lt;–OPRD1 + OPRD2 + CF</td><td>说明: 1. OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数. OPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数. 2. OPRD1和OPRD2均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的,但不允许两个都是存储器操作数. 3. 加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响.以上标志也称为结果标志. 4. 该指令对标志位的影响同ADD指令.</td></tr><tr><td>ADD</td><td>加法指令 ADD(Addition) 格式: ADD OPRD1,OPRD2 功能: 两数相加</td><td>说明: 1. OPRD1为任一通用寄存器或存储器操作数,可以是任意一个通用寄存器,而且还可以是任意一个存储器操作数. OPRD2为立即数,也可以是任意一个通用寄存器操作数.立即数只能用于源操作数. 2. OPRD1和OPRD2均为寄存器是允许的,一个为寄存器而另一个为存储器也是允许的, 但不允许两个都是存储器操作数. 3. 加法指令运算的结果对CF、SF、OF、PF、ZF、AF都会有影响.以上标志也称为结果标志.加法指令适用于无符号数或有符号数的加法运算.</td></tr><tr><td>AND</td><td>逻辑与运算指令 AND 格式: AND OPRD1,OPRD2 功能: 对两个操作数实现按位逻辑与运算,结果送至目的操作数.本指令可以进行字节或字的‘与’运算, OPRD1&lt;–OPRD1 and OPRD2.</td><td>说明: 1. 目的操作数OPRD1为任一通用寄存器或存储器操作数.源操作数OPRD2为立即数,任一通用寄存器或存储器操作数. 2. 示例: AND AL,0FH ;(AL)&lt;–(AL) AND 0FH AND AX,BX ;(AX)&lt;–(AX) AND (BX) AND DX,BUFFER[SI+BX] AND BETA[BX],00FFH 注意: 两数相与，有一个数假则值为假</td></tr><tr><td>CALL</td><td>过程调用指令 CALL 格式: CALL OPRD 功能: 过程调用指令</td><td>说明: 1. 其中OPRD为过程的目的地址. 2. 过程调用可分为段内调用和段间调用两种.寻址方式也可以分为直接寻址和间接寻址两种. 3. 本指令不影响标志位.</td></tr><tr><td>CBW</td><td>字节扩展指令 CBW(Convert Byte to Word) 格式: CBW 功能: 将字节扩展为字,即把AL寄存器的符号位扩展到AH中.</td><td>说明: 1. 两个字节相除时,先使用本指令形成一个双字节长的被除数. 2. 本指令不影响标志位. 3. 示例: MOV AL,25 CBW IDIV BYTE PTR DATA1</td></tr><tr><td>CLC</td><td>处理器控制指令－标志位操作指令 格式: CLC ;置CF=0 STC ;置CF=1 CMC ;置CF=(Not CF)进位标志求反 CLD ;置DF=0 STD ;置DF＝1 CLI ;置IF=0，CPU禁止响应外部中断 STI ;置IF=1，使CPU允许向应外部中断 功能: 完成对标志位的置位、复位等操作.</td><td>说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.</td></tr><tr><td>CLD</td><td>处理器控制指令－标志位操作指令 格式: CLC ;置CF=0 STC ;置CF=1 CMC ;置CF=(Not CF)进位标志求反 CLD ;置DF=0 STD ;置DF＝1 CLI ;置IF=0，CPU禁止响应外部中断 STI ;置IF=1，使CPU允许向应外部中断 功能: 完成对标志位的置位、复位等操作.</td><td>说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.</td></tr><tr><td>CLI</td><td>处理器控制指令－标志位操作指令 格式: CLC ;置CF=0 STC ;置CF=1 CMC ;置CF=(Not CF)进位标志求反 CLD ;置DF=0 STD ;置DF＝1 CLI ;置IF=0，CPU禁止响应外部中断 STI ;置IF=1，使CPU允许向应外部中断 功能: 完成对标志位的置位、复位等操作.</td><td>说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.</td></tr><tr><td>CMC</td><td>处理器控制指令－标志位操作指令 格式: CLC ;置CF=0 STC ;置CF=1 CMC ;置CF=(Not CF)进位标志求反 CLD ;置DF=0 STD ;置DF＝1 CLI ;置IF=0，CPU禁止响应外部中断 STI ;置IF=1，使CPU允许向应外部中断 功能: 完成对标志位的置位、复位等操作.</td><td>说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.</td></tr><tr><td>CMP</td><td>比效指令 CMP(CoMPare) 格式: CMP OPRD1,OPRD2 功能: 对两数进行相减,进行比较.</td><td>说明: 1. OPRD1为任意通用寄存器或存储器操作数. OPRD2为任意通用寄存器或存储器操作数,立即数也可用作源操作数OPRD2. 2. 对标志位的影响同SUB指令,完成的操作与SUB指令类似,唯一的区别是不将OPRD1-OPRD2的结果送回OPRD1,而只是比较. 3. 在8088/8086指令系统中,专门提供了一组根据带符号数比较大小后,实现条件转移的指令.</td></tr><tr><td>CMPS</td><td>字符串比较指令 格式: CMPS OPRD1,OPRD2 CMPSB CMPSW 功能: 由SI寻址的源串中数据与由DI寻址的目的串中数据进行比较,比较结果送标志位,而不改变操作数本身. 同时SI,DI将自动调整.</td><td>说明: 1. 其中OPRD2为源串符号地址,OPRD1为目的串符号地址. 2. 本指令影响标志位AF、CF、OF、SF、PF、ZF.本指令可用来检查二个字符串是否相同,可以使用循环控制方法对整串进行比较. 3. 与MOVS相似,CMPS指令也可以不使用操作数,此时可用指令CMPSB或CMPSW分别表示字节串比较或字串比较.</td></tr><tr><td>CMPSB</td><td>字符串比较指令 格式: CMPS OPRD1,OPRD2 CMPSB CMPSW 功能: 由SI寻址的源串中数据与由DI寻址的目的串中数据进行比较,比较结果送标志位,而不改变操作数本身. 同时SI,DI将自动调整.</td><td>说明: 1. 其中OPRD2为源串符号地址,OPRD1为目的串符号地址. 2. 本指令影响标志位AF、CF、OF、SF、PF、ZF.本指令可用来检查二个字符串是否相同,可以使用循环控制方法对整串进行比较. 3. 与MOVS相似,CMPS指令也可以不使用操作数,此时可用指令CMPSB或CMPSW分别表示字节串比较或字串比较.</td></tr><tr><td>CMPSW</td><td>字符串比较指令 格式: CMPS OPRD1,OPRD2 CMPSB CMPSW 功能: 由SI寻址的源串中数据与由DI寻址的目的串中数据进行比较,比较结果送标志位,而不改变操作数本身. 同时SI,DI将自动调整.</td><td>说明: 1. 其中OPRD2为源串符号地址,OPRD1为目的串符号地址. 2. 本指令影响标志位AF、CF、OF、SF、PF、ZF.本指令可用来检查二个字符串是否相同,可以使用循环控制方法对整串进行比较. 3. 与MOVS相似,CMPS指令也可以不使用操作数,此时可用指令CMPSB或CMPSW分别表示字节串比较或字串比较.</td></tr><tr><td>CWD</td><td>字扩展指令 CWD(Convert Word to Double Word) 格式: CWD 功能: 将字扩展为双字长,即把AX寄存器的符号位扩展到DX中.</td><td>说明: 1. 两个字或字节相除时,先用本指令形成一个双字长的的被除数. 2. 本指令不影响标志位. 3. 示例: 在B1、B2、B3字节类型变量中,分别存有8们带符号数a、b、c,实现(a*b+c)/a运算。</td></tr><tr><td>DAA</td><td>组合的十进制加法调整指令 DAA(Decimal Adjust for Addition) 格式: DAA 功能: 对AL中的两个组合进制数相加的结果进行调整,调整结果仍放在AL中,进位标志放在CF中.</td><td>说明: 1. 调整操作如下 (1) 若(AL) and 0FH&gt;9 或 AF=1,则(AL)&lt;–(AL)+6,AF&lt;–1,对低四位的调整. (2) 若(AL) and 0F0H&gt;90H 或 CF=1,则(AL)&lt;–(AL)+60H,CF&lt;–1. 2. 示例: (AL)=18H,(BL)=06H ADD AL,BL ; (AL)&lt;–(AL)+(BL) ; (AL)=1EH DAA ; (AL)</td></tr><tr><td>DAS</td><td>组合十进制减法调整指令 DAS(Decimal Adjust for Subtraction) 格式: DAS 功能: 对两个组合十进制数相减后存于AL中的结果进行调整,调整后产生一个组合的十进制数且仍存于AL中.</td><td>说明: 调整操作 若(AL) and 0FH &gt; 9 或 AF=1,则(AL)&lt;–(AL)-6,AF=1 若(AL) and 0F0H &gt; 90H 或 CF=1,则(AL)&lt;–(AL)-60,CF=1</td></tr><tr><td>DEC</td><td>减一指令 DEC(Decrement by 1) 格式: DEC OPRD 功能: OPRD&lt;–OPRD-1</td><td>说明: 1. OPRD 为寄存器或存储器操作数. 2. 这条指令执行结果影响AF、OF、PF、SF、ZF标志位，但不影响CF标志位. 3. 示例 DEC AX DEC CL DEC WORD PTR[DI] DEC ALFA[DI+BX]</td></tr><tr><td>DIV</td><td>无符号数除法指令 DIV(DIVision) 格式: DIV OPRD 功能: 实现两个无符号二进制数除法运算.</td><td>说明: 1. 其中OPRD为任一个通用寄存器或存储器操作数. 2. 字节相除,被除数在AX中;字相除,被除数在DX,AX中,除数在OPRD中. 字节除法: (AL)&lt;–(AX)/OPRD,(AH)&lt;–(AX)MOD OPRD 字除法: (AX)&lt;–(DX)(AX)/OPRD,(DX)&lt;–(DX)(AX) MOD OPRD</td></tr><tr><td>ESC</td><td>处理器交权指令 ESC 格式: ESC EXTOPRD,OPRD 功能: 使用本指令可以实现协处理器出放在ESC指令代码中的6位常数,该常数指明协处理器要完成的功能. 当源操作数为存储器变量时,则取出该存储器操作数传送给协处理器.</td><td>说明: 1. 其中EXTOPRD为外部操作码,OPRD为源操作数. 2. 本指不影响标志位.</td></tr><tr><td>HLT</td><td>处理器暂停指令 HLT 格式: HLT 功能: 使处理器处于暂时停机状态.</td><td>说明: 1. 本指令不影响标志位. 2. 由执行HLT引起的暂停,只有RESET(复位)、NMI(非屏蔽中断请求)、INTR(可屏蔽的外部中断请求)信号可以使 其退出暂停状态.它可用于等待中断的到来或多机系统的同步操作.</td></tr><tr><td>IDIV</td><td>带符号数除法指定 IDIV(Interger DIVision) 格式: IDIV OPRD 功能: 这实现两个带符号数的二进制除法运算.</td><td>说明: 1. 其中OPRD为任一通用寄存器或存储器操作数. 2. 理由与IMUL相同,只有IDIV指令,才能得到符号数相除的正确结果. 3. 当被除数为8位,在进行字节除法前,应把AL的符号位扩充至AH中.在16位除法时,若被除数为16位,则应将AX中的符号位扩到DX中.</td></tr><tr><td>IMUL</td><td>带符号数乘法指令 IMUL(Integer MULtiply) 格式: IMUL OPRD 功能: 完成两个带符号数的相乘</td><td>说明: 1. 其中OPRD为任一通用寄存器或存储器操作数. 2. MUL指令对带符号相乘时,不能得到正确的结果. 例如: (AL)=255 (CL)=255 MUL CL (AX)=65025 注意: 这对无符号数讲,结果是正确的,但对带符号数讲,相当于(-1)*(-1)结果应为+1,而65025对应的带符号数为-511,显然是不正确的.</td></tr><tr><td>IN</td><td>输入指令 IN 格式: IN AL,n ;(AL)&lt;–(n) IN AX,n ;(AX)&lt;–(n+1),(n) IN AL,DX ;(AL)&lt;–[(DX)] IN AX,DX ;(AX)&lt;–[(DX)+1],[(DX)] 功能: 输入指令</td><td>说明: 1. 其中n为8位的端口地址,当字节输入时,将端口地址n+1的内容送至AH中,端口地址n的内容送AL中. 2. 端口地址也可以是16位的,但必须将16位的端口地址送入DX中.当字节寻址时,由DX内容作端口地址的内容送至AL中; 当输入数据字时,[(DX)+1]送AH,[(DX)]送AL中,用符号:(AX)&lt;–[(DX)+1],[(DX)]表示.</td></tr><tr><td>INC</td><td>加1指令 INC(INCrement by 1) 格式: INC OPRD 功能: OPRD&lt;–OPRD+1</td><td>说明: 1. OPRD 为寄存器或存储器操作数. 2. 这条指令执行结果影响AF、OF、PF、SF、ZF标志位,但不影响CF标志位. 3. 示例: INC SI;(SI)&lt;–(SI)+1 INC WORD PTR[BX] INC BYTE PTR[BX+DI] INC CL;(CL)&lt;–(CL)+1 注意: 上述第二,三两条指令,是对存储字及存储字节的内容加1以替代原来的内容.</td></tr><tr><td>INT</td><td>软中断指令 INT 格式: INT n 其中n为软中断的类型号. 功能: 本指令将产生一个软中断,把控制转向一个类型号为n的软中断,该中断处理程序入口地址在中断向量表的n*4地址 处的二个存储器字(4个单元)中.</td><td>说明: 操作过程与INTO指令雷同,只需将10H改为n*4即可.所以,本指令也将影响标志位IF及TF.</td></tr><tr><td>INTO</td><td>溢出中断指令 INTO(INTerrupt if Overflow) 格式: INTO 功能: 本指令检测OF标志位,当OF=1时,说明已发生溢出,立即产生一个中断类型4的中断,当OF＝0时,本指令不起作用.</td><td>说明: 1. 本指令影响标志位IF及TF. 2. 本指令可用于溢出处理,当OF=1时,产生一个类型4的软中断.在中断处理程序中完成溢出的处理操作.</td></tr><tr><td>IRET</td><td>中断返回指令 IRET 格式: IRET 功能: 用于中断处理程序中,从中断程序的断点处返回,继续执行原程序.</td><td>说明: 1. 本指令将影响所有标志位. 2. 无论是软中断,还是硬中断,本指令均可使其返回到中断程序的断点处继续执行原程序.</td></tr><tr><td>JA</td><td>条件转移指令JA/JNBE 格式: JA/JNBE标号 功能: 为高于/不低于等于的转移指令</td><td>说明: 1. 例如两个符号数a,b比较时,a&gt;b(即CF=0,ZF=0)时转移.因为单一标志位CF=0,只表示a&gt;=b. 2. JA/JNBE是同一条指令的两种不同的助记符. 3. 该指令用于无符号数进行条件转移</td></tr><tr><td>JAE</td><td>条件转移指令JAE/JNB 格式: JAE/JNB 标号 功能: 为高于等于/不低于的转移指令</td><td>说明: 1. JAE/JNB是同一条指令的两种不同的助记符. 2. 该指令用于无符号数进行条件转移.</td></tr><tr><td>JB</td><td>条件转移指令JB/JNAE 格式: JB/JNAE 标号 功能: 低于/不高于等于时转移</td><td>说明: 该指令用于无符号数的条件转移</td></tr><tr><td>JBE</td><td>条件转移指令JBE/JNA 格式: JBE/JNA 标号 功能: 低于等于/不高于时转移</td><td>说明: 该指令用于无符号数的条件转移</td></tr><tr><td>JC</td><td>条件转移指令 JC 格式: JC 标号 功能: CF＝1,转至标号处执行</td><td>说明: JC为根据标志位CF进行转移的指令</td></tr><tr><td>JE</td><td>条件转移指令JE/JZ 格式: JE/JZ标号 功能: ZF＝1,转至标号处执</td><td>说明: 1. 指令JE与JZ等价,它们是根据标志位ZF进行转移的指令 2. JE,JZ均为一条指令的两种助记符表示方法</td></tr><tr><td>JG</td><td>条件转移指令JG/JNLE 格式: JG/JNLE 标号 功能: 大于/不小于等于时转移</td><td>说明: 用于带符号数的条件转移指令</td></tr><tr><td>JGE</td><td>条件转移指令JGE/JNL 格式: JGE/JNL标号 功能: 大于等于/不小于时转移</td><td>说明: 用于带符号数的条件转移指令</td></tr><tr><td>JL</td><td>条件转移指令JL/JNGE 格式: JL/JNGE标号 功能: 小于/不大于等于时转移</td><td>说明: 用于带符号数的条件转移指令</td></tr><tr><td>JLE</td><td>条件转移指令JLE/JNG 格式: JLE/JNG 标号 功能: 小于等于/不大于时转移</td><td>说明: 用于带符号数的条件转移指令</td></tr><tr><td>JMP</td><td>无条件转移指令JMP 格式: JMP OPRD 功能: JMP指令将无条件地控制程序转移到目的地址去执行.当目的地址仍在同一个代码段内,称为段内转移;当目标地址不在同一个代码段内,则称为段间转移.这两种情况都将产生不同的指令代码,以便能正确地生成目的地址,在段内转移时,指令只要能提供目的地址的段内偏移量即够了;而在段间转移时,指令应能提供目的地址的段地址及段内偏移地址值.</td><td>说明: 1. 其中OPRD为转移的目的地址.程序转移到目的地址所指向的指令继续往下执行. 2. 本组指令对标志位无影响. 3. <1> 段内直接转移指令: JMP NEAR 标号 <2> 段内间接转移指令: JMP OPRD <3> 段间直接转移指令: JMP FAR 标号 <4> 段间间接转移指令:JMP OPRD其中的OPRD为存储器双字操作数.段间间接转移只能通过存储器操作数来实现.</4></3></2></1></td></tr><tr><td>JNA</td><td>条件转移指令JBE/JNA 格式: JBE/JNA 标号 功能: 低于等于/不高于时转移</td><td>说明: 该指令用于无符号数的条件转移</td></tr><tr><td>JNAE</td><td>条件转移指令JB/JNAE 格式: JB/JNAE 标号 功能: 低于/不高于等于时转移</td><td>说明: 该指令用于无符号数的条件转移</td></tr><tr><td>JNB</td><td>条件转移指令JAE/JNB 格式: JAE/JNB 标号 功能: 为高于等于/不低于的转移指令</td><td>说明: 1. JAE/JNB是同一条指令的两种不同的助记符. 2. 该指令用于无符号数进行条件转移.</td></tr><tr><td>JNBE</td><td>条件转移指令JA/JNBE 格式: JA/JNBE标号 功能: 为高于/不低于等于的转移指令</td><td>说明: 1. 例如两个符号数a,b比较时,a&gt;b(即CF=0,ZF=0)时转移.因为单一标志位CF=0,只表示a&gt;=b. 2. JA/JNBE是同一条指令的两种不同的助记符. 3. 该指令用于无符号数进行条件转移</td></tr><tr><td>JNC</td><td>条件转移指令JNC 格式: JNC标号 功能: CF＝0,转至标号处执行</td><td>说明: JNC为根据标志位CF进行转移的指令</td></tr><tr><td>JNE</td><td>条件转移指令JNE/JNZ 格式: JNE/JNZ 标号 功能: ZF＝0,转至标号处执行</td><td>说明: 1. 指令JNE与JNZ等价,它们是根据标志位ZF进行转移的指令 2. JNE,JNZ均为一条指令的两种助记符表示方法</td></tr><tr><td>JNG</td><td>条件转移指令JLE/JNG 格式: JLE/JNG 标号 功能: 小于等于/不大于时转移</td><td>说明: 用于带符号数的条件转移指令</td></tr><tr><td>JNGE</td><td>条件转移指令JL/JNGE 格式: JL/JNGE标号 功能: 小于/不大于等于时转移</td><td>说明: 用于带符号数的条件转移指令</td></tr><tr><td>JNL</td><td>条件转移指令JGE/JNL 格式: JGE/JNL标号 功能: 大于等于/不小于时转移</td><td>说明: 用于带符号数的条件转移指令</td></tr><tr><td>JNLE</td><td>条件转移指令JG/JNLE 格式: JG/JNLE 标号 功能: 大于/不小于等于时转移</td><td>说明: 用于带符号数的条件转移指令</td></tr><tr><td>JNO</td><td>条件转移指令JNO 格式: JNO 标号 功能: OF＝0,转至标号处执行</td><td>说明: JNO是根椐溢出标志位OF进行转移的指令</td></tr><tr><td>JNP</td><td>条件转移指令JNP/JPO 格式: JNP/JPO 标号 功能: PF＝0,转至标号处执行</td><td>说明: 1. 指令JNP与JPO,它们是根据奇偶标志位PF进行转移的指令 2. JNP,JPO均为一条指令的两种助记符表示方法</td></tr><tr><td>JNS</td><td>条件转移指令JNS 格式: JNS 标号 功能: SF＝0,转至标号处执行</td><td>说明: JNS是根据符号标志位SF进行转移的指令</td></tr><tr><td>JNZ</td><td>条件转移指令JNE/JNZ 格式: JNE/JNZ 标号 功能: ZF＝0,转至标号处执行</td><td>说明: 1. 指令JNE与JNZ等价,它们是根据标志位ZF进行转移的指令 2. JNE,JNZ均为一条指令的两种助记符表示方法</td></tr><tr><td>JO</td><td>条件转移指令JO 格式: JO 标号 功能: OF＝1,转至标号处执行</td><td>说明: JO是根椐溢出标志位OF进行转移的指令</td></tr><tr><td>JP</td><td>条件转移指令JP/JPE 格式: JP/JPE 标号 功能: PF＝1,转至标号处执行</td><td>说明: 1. 指令JP与JPE,它们是根据奇偶标志位PF进行转移的指令 2. JP,JPE均为一条指令的两种助记符表示方法</td></tr><tr><td>JPE</td><td>条件转移指令JP/JPE 格式: JP/JPE 标号 功能: PF＝1,转至标号处执行</td><td>说明: 1. 指令JP与JPE,它们是根据奇偶标志位PF进行转移的指令 2. JP,JPE均为一条指令的两种助记符表示方法</td></tr><tr><td>JPO</td><td>条件转移指令JNP/JPO 格式: JNP/JPO 标号 功能: PF＝0,转至标号处执行</td><td>说明: 1. 指令JNP与JPO,它们是根据奇偶标志位PF进行转移的指令 2. JNP,JPO均为一条指令的两种助记符表示方法</td></tr><tr><td>JS</td><td>条件转移指令JS 格式: JS 标号 功能: SF＝1,转至标号处执行</td><td>说明: JS是根据符号标志位SF进行转移的指令</td></tr><tr><td>JZ</td><td>条件转移指令JE/JZ 格式: JE/JZ标号 功能: ZF＝1,转至标号处执</td><td>说明: 1. 指令JE与JZ等价,它们是根据标志位ZF进行转移的指令 2. JE,JZ均为一条指令的两种助记符表示方法</td></tr><tr><td>LAHF</td><td>标志传送指令 LAHF 格式: LAHF 功能: 取FLAG标志寄存器低8位至AH寄存器.(AH)&lt;–(FLAG)7~0</td><td>说明: 该指令不影响FLAG的原来内容,AH只是复制了原FLAG的低8位内容.</td></tr><tr><td>LDS</td><td>从存储器取出32位地址的指令 LDS 格式: LDS OPRD1,OPRD2 功能: 从存储器取出32位地址的指令.</td><td>说明: OPRD1 为任意一个16位的寄存器. OPRD2 为32位的存储器地址. 示例: LDS SI,ABCD LDS BX,FAST[SI] LDS DI,[BX] 注意: 上面LDS DI,[BX]指令的功能是把BX所指的32位地址指针的段地址送入DS,偏移地址送入DI.</td></tr><tr><td>LEA</td><td>有效地址传送指令 LEA 格式: LEA OPRD1,OPRD2 功能: 将源操作数给出的有效地址传送到指定的的寄存器中.</td><td>说明: 1. OPRD1 为目的操作数,可为任意一个16位的通用寄存器. OPRD2 为源操作数,可为变量名、标号或地址表达式. 示例: LEA BX,DATA1 LEA DX,BETA[BX+SI] LEA BX BX,[BP],[DI] 2. 本指令对标志位无影响。</td></tr><tr><td>LES</td><td>从存储器取出32位地址的指令 LES 格式: LES OPRD1,OPRD2 功能: 从存储器取出32位地址的指令.</td><td>说明: OPRD1 为任意一个16位的寄存器. OPRD2 为32位的存储器地址. 示例: LES SI,ABCD LES BX,FAST[SI] LES DI,[BX] 注意: 上面LES DI,[BX]指令的功能是把BX所指的32位地址指针的段地址送入ES,偏移地址送入DI.</td></tr><tr><td>LOCK</td><td>封锁总线指令 LOCK 格式: LOCK 功能: 指令是一个前缀,可放在指令的前面,告诉CPU在执行该指令时,不允许其它设备对总线进行访问.</td><td>无可用信息!用户可自行添加!</td></tr><tr><td>LODS</td><td>取字符串元素指令 LODS 格式: LODS OPRD 其中OPRD为源字符串符号地址. 功能: 把SI寻址的源串的数据字节送AL或数据字送AX中去, 并根据DF的值修改地址指针SI进行自动调整.</td><td>说明: 1. 本指令不影响标志位. 2. 当不使用操作数时,可用LODS(字节串)或LODSW(字串)指令.</td></tr><tr><td>LOOP</td><td>循环控制指令LOOP 格式: LOOP 标号 功能: (CX)&lt;–(CX)-1,(CX)&lt;&gt;0,则转移至标号处循环执行, 直至(CX)=0,继续执行后继指令.</td><td>说明: 1. 本指令是用CX寄存器作为计数器,来控制程序的循环. 2. 它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内.</td></tr><tr><td>LOOPE</td><td>循环控制指令LOOPZ/LOOPE 格式: LOOPZ/LOOPE 标号 功能: (CX)&lt;–(CX)-1,(CX)&lt;&gt;0 且ZF＝1时,转至标号处循环</td><td>说明: 1. 本指令是用CX寄存器作为计数器,来控制程序的循环. 2. 它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内. 3. 以上两种助记符等价.</td></tr><tr><td>LOOPNE</td><td>循环控制指令LOOPNZ/LOOPNE 格式: LOOPNZ/LOOPNE 标号 功能: (CX)&lt;–(CX)-1,(CX)&lt;&gt;0 且ZF＝0时,转至标号处循环</td><td>说明: 1. 本指令是用CX寄存器作为计数器,来控制程序的循环. 2. 它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内. 3. 以上两种助记符等价.</td></tr><tr><td>LOOPNZ</td><td>循环控制指令LOOPNZ/LOOPNE 格式: LOOPNZ/LOOPNE 标号 功能: (CX)&lt;–(CX)-1,(CX)&lt;&gt;0 且ZF＝0时,转至标号处循环</td><td>说明: 1. 本指令是用CX寄存器作为计数器,来控制程序的循环. 2. 它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内. 3. 以上两种助记符等价.</td></tr><tr><td>LOOPZ</td><td>循环控制指令LOOPZ/LOOPE 格式: LOOPZ/LOOPE 标号 功能: (CX)&lt;–(CX)-1,(CX)&lt;&gt;0 且ZF＝1时,转至标号处循环</td><td>说明: 1. 本指令是用CX寄存器作为计数器,来控制程序的循环. 2. 它属于段内SHORT短类型转移,目的地址必须距本指令在-128到+127个字节的范围内. 3. 以上两种助记符等价.</td></tr><tr><td>MOVE</td><td>数据传送指令 MOV 格式: MOV OPRD1,OPRD2 功能: 本指令将一个源操作数送到目的操作数中,即OPRD1&lt;–OPRD2.</td><td>说明: 1. OPRD1 为目的操作数,可以是寄存器、存储器、累加器. OPRD2 为源操作数,可以是寄存器、存储器、累加器和立即数. 2. MOV 指令以分为以下四种情况: <1> 寄存器与寄存器之间的数据传送指令 <2> 立即数到通用寄存器数据传送指令 <3> 寄存器与存储器之间的数据传送指令 <4> 立即数到存储器的数据传送 3. 本指令不影响状态标志位</4></3></2></1></td></tr><tr><td>MOVS</td><td>字符串传送指令 MOVS 格式: MOVS OPRD1,OPRD2 MOVSB MOVSW 功能: OPRD1&lt;–OPRD2.</td><td>说明: 1. 其中OPRD2为源串符号地址,OPRD1为目的串符号地址. 2. 字节串操作: 若DF=0,则作加, 若DF=1,则作减. 3. 对字串操作时: 若DF=0,则作加,若DF=1,则作减,. 4. 在指令中不出现操作数时,字节串传送格式为MOVSB、字串传送格式为MOVSW. 5. 本指令不影响标志位.</td></tr><tr><td>MOVSB</td><td>字符串传送指令 MOVS 格式: MOVS OPRD1,OPRD2 MOVSB MOVSW 功能: OPRD1&lt;–OPRD2.</td><td>说明: 1. 其中OPRD2为源串符号地址,OPRD1为目的串符号地址. 2. 字节串操作: 若DF=0,则作加, 若DF=1,则作减. 3. 对字串操作时: 若DF=0,则作加,若DF=1,则作减,. 4. 在指令中不出现操作数时,字节串传送格式为MOVSB、字串传送格式为MOVSW. 5. 本指令不影响标志位.</td></tr><tr><td>MOVSW</td><td>字符串传送指令 MOVS 格式: MOVS OPRD1,OPRD2 MOVSB MOVSW 功能: OPRD1&lt;–OPRD2.</td><td>说明: 1. 其中OPRD2为源串符号地址,OPRD1为目的串符号地址. 2. 字节串操作: 若DF=0,则作加, 若DF=1,则作减. 3. 对字串操作时: 若DF=0,则作加,若DF=1,则作减,. 4. 在指令中不出现操作数时,字节串传送格式为MOVSB、字串传送格式为MOVSW. 5. 本指令不影响标志位.</td></tr><tr><td>MUL</td><td>无符号数乘法指令 MUL(MULtiply) 格式: MUL OPRD 功能: 乘法操作.</td><td>说明: 1. OPRD为通用寄存器或存储器操作数. 2. OPRD为源操作数,即作乘数.目的操作数是隐含的,即被乘数总是指定为累加器AX或AL的内容. 3. 16位乘法时,AX中为被乘数.8位乘法时,AL为被乘数.当16位乘法时,32位的乘积存于DX及AX中;8位乘法的16位乘积存于AX中. 4. 操作过程: 字节相乘:(AX)&lt;–(AL)*OPRD,当结果的高位字节(AH)不等于0时,则CF＝1、OF＝1.</td></tr><tr><td>NEG</td><td>取补指令 NEG(NEGate) 格式: NEG OPRD 功能: 对操作数OPRD进行取补操作,然后将结果送回OPRD.取补操作也叫作求补操作,就是求一个数的相反数的补码.</td><td>说明: 1. OPRD为任意通用寄存器或存储器操作数. 2. 示例: (AL)=44H,取补后,(AL)=0BCH(-44H). 3. 本指令影响标志位CF、OF、SF、PF、ZF及AF.</td></tr><tr><td>NOP</td><td>空操作指令 NOP 格式: NOP 功能: 本指令不产生任何结果,仅消耗几个时钟周期的时间,接着执行后续指令,常用于程序的延时等.</td><td>说明: 本指令不影响标志位.</td></tr><tr><td>NOT</td><td>逻辑非运算指令 NOT 格式: NOT OPRD 功能: 完成对操作数按位求反运算(即0变1,1变0),结果关回原操作数.</td><td>说明: 1. 其中OPRD可为任一通用寄存器或存储器操作数. 2. 本指梳令可以进行字或字节‘非’运算. 3. 本指令不影响标志位.</td></tr><tr><td>OR</td><td>逻辑或指令 OR 格式: OR OPRD1,OPRD2 功能: OR指令完成对两个操作数按位的‘或’运算,结果送至目的操作数中,本指令可以进行字节或字的‘或’运算. OPRD1&lt;–OPRD1 OR OPRD2.</td><td>说明: 1. 其中OPRD1,OPRD2含义与AND指令相同,对标志位的影响也与AND指令相同. 2. 两数相或,有一个数为真则值为真.</td></tr><tr><td>OUT</td><td>输出指令 OUT 格式: OUT n,AL ;(n)&lt;–(AL) 功能: 输出指令</td><td>说明: 1. OUT n,AX ;(n+1),(n)&lt;–(AX) OUT DX,AL ;[(DX)]&lt;–(AL) OUT DX,AX ;[(DX)+1],[(DX)]&lt;–(AX) 2. 输入指令及输出指令对标志位都不影响.</td></tr><tr><td>POP</td><td>堆栈操作指令 PUSH和POP 格式: PUSH OPRD POP OPRD 功能: 实现压入操作的指令是PUSH指令;实现弹出操作的指令是POP指令.</td><td>说明: 1. OPRD为16位(字)操作数,可以是寄存器或存储器操作数. 2. POP指令的操作过程是: POP OPRD:OPRD&lt;–((SP)),(SP)&lt;–(SP)+2 它与压入操作相反,是先弹出栈顶的数顶,然后再修改指针SP的内容. 3. 示例: POP AX POP DS POP DATA1 POP ALFA[BX][DI] 4. PUSH和POP指令对状态标志位没有影响.</td></tr><tr><td>POPF</td><td>标志传送指令 POPF 格式: POPF 功能: 本指令的功能与PUSHF相反,在子程序调用和中断服务程序中,往往用PUSHF指令保护FLAG的内容,用POPF指令将保护的FLAG内容恢复.</td><td>说明: 如果对堆栈中的原FLAG内容进行修改,如对TF等标志位进行修改,然后再弹回标志位寄存器FLAG.这是通过指令修改TF标志的唯一方法.</td></tr><tr><td>PUSH</td><td>堆栈操作指令 PUSH和POP 格式: PUSH OPRD POP OPRD 功能: 实现压入操作的指令是PUSH指令;实现弹出操作的指令是POP指令.</td><td>说明: 1. OPRD为16位(字)操作数,可以是寄存器或存储器操作数. 2. PUSH的操作过程是: (SP)&lt;–(SP)-2,((sp))&lt;–OPRD 即先修改堆栈指针SP(压入时为自动减2),然后,将指定的操作数送入新的栈顶位置. 此处的((SP))&lt;–OPRD,也可以理解为: [(SS)*16+(SP)]&lt;–OPRD 或 [SS:SP]&lt;–OPRD</td></tr><tr><td>PUSHF</td><td>标志传送指令 PUSHF 格式: PUSHF 功能: 本指令可以把标志寄存器的内容保存到堆栈中去</td><td></td></tr><tr><td>RCL</td><td>循环移位指令 格式: ROL OPRD1,COUNT ;不含进位标志位CF在循环中的左循环移位指令. ROR OPRD1,COUNT ;不含进位示志位CF在循环中的右循环移位指令. RCL OPRD1,COUNT ;带进位的左循环移位指令. RCR OPRD1,COUNT ;带进位的右循环移位指令.</td><td>说明: 1. 本指令组只影响标志CF、OF.OF由移入CF的内容决定,OF取决于移位一次后符号位是否改变,如改变,则OF=1. 2. 由于是循环移位,所以对字节移位8次; 对字移位16次,就可恢复为原操作数.由于带CF的循环移位,可以将CF的内容移入, 所以可以利用它实现多字节的循环.</td></tr><tr><td>RCR</td><td>循环移位指令 格式: ROL OPRD1,COUNT ;不含进位标志位CF在循环中的左循环移位指令. ROR OPRD1,COUNT ;不含进位示志位CF在循环中的右循环移位指令. RCL OPRD1,COUNT ;带进位的左循环移位指令. RCR OPRD1,COUNT ;带进位的右循环移位指令.</td><td>说明: 1. 本指令组只影响标志CF、OF.OF由移入CF的内容决定,OF取决于移位一次后符号位是否改变,如改变,则OF=1. 2. 由于是循环移位,所以对字节移位8次; 对字移位16次,就可恢复为原操作数.由于带CF的循环移位,可以将CF的内容移入,所以可以利用它实现多字节的循环. 注意: 以上程序中的指令SHR AL,CL如改为SAR AL,CL,虽然最高4位可移入低4位,但最高位不为0,故应加入一条指令AND AL,0FH.否则,若最高位不为0时,将得到错误结果.</td></tr><tr><td>REP</td><td>重复前缀的说明 格式: REP ;CX&lt;&gt;0 重复执行字符串指令 REPZ/REPE ;CX&lt;&gt;0 且ZF＝1重复执行字符串指令 REPNZ/REPNE ;CX&lt;&gt;0 且ZF＝0重复执行字符串指令 功能: 在串操作指令前加上重复前缀,可以对字符串进重复处理.由于加上重复前缀后,对应的指令代码是不同的,所以指令的功能便具有重复处理的功能,重复的次数存放在CX寄存器中.</td><td>说明: 1. REP与MOVS或STOS串操作指令相结合使用,完成一组字符的传送或建立一组相同数据的字符串. 2. REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较. 3. REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字. 4. REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令.</td></tr><tr><td>REPE</td><td>重复前缀的说明 格式: REP ;CX&lt;&gt;0 重复执行字符串指令 REPZ/REPE ;CX&lt;&gt;0 且ZF＝1重复执行字符串指令 REPNZ/REPNE ;CX&lt;&gt;0 且ZF＝0重复执行字符串指令 功能: 在串操作指令前加上重复前缀,可以对字符串进重复处理.由于加上重复前缀后,对应的指令代码是不同的,所以指令的功能便具有重复处理的功能,重复的次数存放在CX寄存器中.</td><td>说明: 1. REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较. 2. REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字. 3. REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令. 4. REPNZ/REPNE与SCAS指令结合使用,表示串未结束(CX=1)且当关键字与串元素不相同(ZF=0)时,继续重复执行串搜索指令.</td></tr><tr><td>REPNE</td><td>重复前缀的说明 格式: REP ;CX&lt;&gt;0 重复执行字符串指令 REPZ/REPE ;CX&lt;&gt;0 且ZF＝1重复执行字符串指令 REPNZ/REPNE ;CX&lt;&gt;0 且ZF＝0重复执行字符串指令</td><td>说明: 1. REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较. 2. REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字. 3. REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令. 4. REPNZ/REPNE与SCAS指令结合使用,表示串未结束(CX=1)且当关键字与串元素不相同(ZF=0)时,继续重复执行串搜索指令.</td></tr><tr><td>REPNZ</td><td>重复前缀的说明 格式: REP ;CX&lt;&gt;0 重复执行字符串指令 REPZ/REPE ;CX&lt;&gt;0 且ZF＝1重复执行字符串指令 REPNZ/REPNE ;CX&lt;&gt;0 且ZF＝0重复执行字符串指令</td><td>说明: 1. REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较. 2. REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字. 3. REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令. 4. REPNZ/REPNE与SCAS指令结合使用,表示串未结束(CX=1)且当关键字与串元素不相同(ZF=0)时,继续重复执行串搜索指令.</td></tr><tr><td>REPZ</td><td>重复前缀的说明 格式: REP ;CX&lt;&gt;0 重复执行字符串指令 REPZ/REPE ;CX&lt;&gt;0 且ZF＝1重复执行字符串指令 REPNZ/REPNE ;CX&lt;&gt;0 且ZF＝0重复执行字符串指令 功能: 在串操作指令前加上重复前缀,可以对字符串进重复处理.由于加上重复前缀后,对应的指令代码是不同的,所以指令的功能便具有重复处理的功能,重复的次数存放在CX寄存器中.</td><td>说明: 1. REPZ/REPE常用与CMPS串操作指令结合使用, 可以完成两组字符串的比较. 2. REPZ/REPE常与SCAS指令结合使用,可以完成在一个字符串中搜索一个关键字. 3. REPNZ/REPNE与CMPS指令结合使用,表示当串未结束(CX=1)且当对应串元素不相同(ZF=0)时,继续重复执行串比较指令. 4. REPNZ/REPNE与SCAS指令结合使用,表示串未结束(CX=1)且当关键字与串元素不相同(ZF=0)时,继续重复执行串搜索指令.</td></tr><tr><td>RET</td><td>返回指令 RET 格式: RET 功能: 当调用的过程结束后实现从过程返回至原调用程序的下一条指令,本指令不影响标志位.</td><td>说明: 由于在过程定义时,已指明其近(NEAR)或远(FAR)的属性,所以RET指令根据段内调用与段间调用,执行不同的操作 对段内调用: 返回时,由堆栈弹出一个字的返回地址的段内偏移量至IP. 对段外调用: 返回时,由堆栈弹出的第一个字为返回地址的段内偏移量,将其送入IP中,由堆栈弹出第二个字为返回地址的段基址,将其送入CS中.</td></tr><tr><td>ROL</td><td>循环移位指令 格式: ROL OPRD1,COUNT ;不含进位标志位CF在循环中的左循环移位指令. ROR OPRD1,COUNT ;不含进位示志位CF在循环中的右循环移位指令. RCL OPRD1,COUNT ;带进位的左循环移位指令. RCR OPRD1,COUNT ;带进位的右循环移位指令.</td><td>说明: 1. 本指令组只影响标志CF、OF.OF由移入CF的内容决定,OF取决于移位一次后符号位是否改变,如改变,则OF=1. 2. 由于是循环移位,所以对字节移位8次; 对字移位16次,就可恢复为原操作数.由于带CF的循环移位,可以将CF的内容移入, 所以可以利用它实现多字节的循环.</td></tr><tr><td>ROR</td><td>循环移位指令 格式: ROL OPRD1,COUNT ;不含进位标志位CF在循环中的左循环移位指令. ROR OPRD1,COUNT ;不含进位示志位CF在循环中的右循环移位指令. RCL OPRD1,COUNT ;带进位的左循环移位指令. RCR OPRD1,COUNT ;带进位的右循环移位指令.</td><td>说明: 1. 本指令组只影响标志CF、OF.OF由移入CF的内容决定,OF取决于移位一次后符号位是否改变,如改变,则OF=1. 2. 由于循环移位,所以对字节移位8次; 对字移位16次,可恢复为原操作数.</td></tr><tr><td>SAHF</td><td>标志传送指令 SAHF 格式: SAHF 功能: 将AH存至FLAG低8位</td><td>说明: 本指令将用AH的内容改写FLAG标志寄存器中的SF、ZF、AF、PF、和CF标志,从而改变原来的标志位.</td></tr><tr><td>SAL</td><td>算术左移指令 SAL(Shift Arithmetic Left) 格式: SAL OPRD1,COUNT 功能: 其中OPRD1,COUNT与指令SHL相同.本指令与SHL的功能也完全相同,这是因为逻辑左移指令与算术左移指令所要完成的操作是一样的.</td><td>说明: 1. 其中OPRD1为目的操作数,可以是通用寄存器或存储器操作数. 2. COUNT代表移位的次数(或位数).移位一次,COUNT=1;移位多于1次时,COUNT=(CL),(CL)中为移位的次数.</td></tr><tr><td>SAR</td><td>算术右移指令 SAR 格式: SAR OPRD1,COUNT 功能: 本指令通常用于对带符号数减半的运算中,因而在每次右移时,保持最高位(符号位)不变,最低位右移至CF中.</td><td>说明: 1. 其中OPRD1为目的操作数,可以是通用寄存器或存储器操作数. 2. COUNT代表移位的次数(或位数).移位一次,COUNT=1;移位多于1次时,COUNT=(CL),(CL)中为移位的次数.</td></tr><tr><td>SBB</td><td>带借位减去指令 SBB(SuBtraction with Borrow) 格式: SBB OPRD1,OPRD2 功能: 是进行两个操作数的相减再减去CF进位标志位,即从OPRD1&lt;–OPRD1-OPRD2-CF,其结果放在OPDR1中.</td><td>说明: 示例 SBB DX,CX SBB AX,DATA1 SBB BX,2000H SBB ALFA[BX+SI],SI SBB BETAP[DI,030AH</td></tr><tr><td>SCAS</td><td>字符串搜索指令 SCAS 格式: SCAS OPRD SCASB SCASW 功能: 把AL(字节串)或AX(字串)的内容与由DI寄存器寻址的目的串中的数据相减,结果置标志位,但不改变任一操作数本身. 地址指针DI自动调整.</td><td>说明: 1. 其中OPRD为目的串符号地址. 2. 本指令影响标志AF、CF、OF、PF、SF、ZF.该指令可查找字符串中的一个关键字,只需在本指令执行前, 把关键字放在AL(字节)或AX(字串 )中,用重复前缀可在整串中查找. 指令中不使用操作数时,可用指令格式SCASB,SCASW,分别表示字节串或字串搜索指令.</td></tr><tr><td>SCASB</td><td>字符串搜索指令 SCAS 格式: SCAS OPRD SCASB SCASW 功能: 把AL(字节串)或AX(字串)的内容与由DI寄存器寻址的目的串中的数据相减,结果置标志位,但不改变任一操作数本身. 地址指针DI自动调整.</td><td>说明: 1. 其中OPRD为目的串符号地址. 2. 本指令影响标志AF、CF、OF、PF、SF、ZF.该指令可查找字符串中的一个关键字,只需在本指令执行前, 把关键字放在AL(字节)或AX(字串 )中,用重复前缀可在整串中查找. 指令中不使用操作数时,可用指令格式SCASB,SCASW,分别表示字节串或字串搜索指令.</td></tr><tr><td>SCASW</td><td>字符串搜索指令 SCAS 格式: SCAS OPRD SCASB SCASW 功能: 把AL(字节串)或AX(字串)的内容与由DI寄存器寻址的目的串中的数据相减,结果置标志位,但不改变任一操作数本身. 地址指针DI自动调整.</td><td>说明: 1. 其中OPRD为目的串符号地址. 2. 本指令影响标志AF、CF、OF、PF、SF、ZF.该指令可查找字符串中的一个关键字,只需在本指令执行前, 把关键字放在AL(字节)或AX(字串 )中,用重复前缀可在整串中查找. 指令中不使用操作数时,可用指令格式SCASB,SCASW,分别表示字节串或字串搜索指令.</td></tr><tr><td>SHL</td><td>逻辑左移指令 SHL(Shift logical left) 格式: SHL OPRD1,COUNT 功能: 对给定的目的操作数左移COUNT次,每次移位时最高位移入标志位CF中,最低位补零.</td><td>说明: 1. 其中OPRD1为目的操作数,可以是通用寄存器或存储器操作数. 2. COUNT代表移位的次数(或位数).移位一次,COUNT=1;移位多于1次时,COUNT=(CL),(CL)中为移位的次数. 3. 例如: SHL AL,1 SHL CX,1 SHL ALFA[DI] 或者: MOV CL,3 SHL DX,CL SHL ALFA[DI],CL</td></tr><tr><td>SHR</td><td>逻辑右移指令 SHR 格式: SHR OPRD1,COUNT 功能: 本指令实现由COUNT决定次数的逻辑右移操作,每次移位时,最高位补0,最低位移至标志位CF中.</td><td>说明: 1. 其中OPRD1为目的操作数,可以是通用寄存器或存储器操作数. 2. COUNT代表移位的次数(或位数).移位一次,COUNT=1;移位多于1次时,COUNT=(CL),(CL)中为移位的次数. 3. 影响标志位OF,PF,SF,ZF,CF.</td></tr><tr><td>STC</td><td>处理器控制指令－标志位操作指令 格式: CLC ;置CF=0 STC ;置CF=1 CMC ;置CF=(Not CF)进位标志求反 CLD ;置DF=0 STD ;置DF＝1 CLI ;置IF=0，CPU禁止响应外部中断 STI ;置IF=1，使CPU允许向应外部中断 功能: 完成对标志位的置位、复位等操作.</td><td>说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.</td></tr><tr><td>STD</td><td>处理器控制指令－标志位操作指令 格式: CLC ;置CF=0 STC ;置CF=1 CMC ;置CF=(Not CF)进位标志求反 CLD ;置DF=0 STD ;置DF＝1 CLI ;置IF=0，CPU禁止响应外部中断 STI ;置IF=1，使CPU允许向应外部中断 功能: 完成对标志位的置位、复位等操作.</td><td>说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.</td></tr><tr><td>STI</td><td>处理器控制指令－标志位操作指令 格式: CLC ;置CF=0 STC ;置CF=1 CMC ;置CF=(Not CF)进位标志求反 CLD ;置DF=0 STD ;置DF＝1 CLI ;置IF=0，CPU禁止响应外部中断 STI ;置IF=1，使CPU允许向应外部中断 功能: 完成对标志位的置位、复位等操作.</td><td>说明: 例如串操作中的程序,经常用CLD指令清方向标志使DF＝0,在串操作指令执行时,按增量的方式修改吕指针.</td></tr><tr><td>STOS</td><td>字符串存储指令 STOS 格式: STOS OPRD 功能: 把AL(字节)或AX(字)中的数据存储到DI为目的串地址指针所寻址的存储器单元中去.指针DI将根据DF的值进行自动调整.</td><td>说明: 1. 其中OPRD为目的串符号地址. 2. 本指令不影响标志位.当不使用操作数时,可用STOSB或STOSW分别表示字节串或字串的操作.</td></tr><tr><td>SUB</td><td>减法指令SUB(SUBtract) 格式: SUB OPRD1,OPRD2 功能: 两个操作数的相减,即从OPRD1中减去OPRD2,其结果放在OPDR1中.</td><td>说明: 示例 SUB DX,CX SUB [BX+25],AX SUB DI,ALFA[SI] SUB CL,20 SUB DATA1[DI][BX],20A5H</td></tr><tr><td>TEST</td><td>测试指令 TEST 格式: TEST OPRD1,OPRD2 功能: 其中OPRD1、OPRD2的含义同AND指令一样,也是对两个操作数进行按位的’与’运算,唯一不同之处是不将’与’的结 果送目的操作数,即本指令对两个操作数 的内容均不进行修改,仅是在逻辑与操作后,对标志位重新置位.</td><td>说明: TEST与AND指令的关系,有点类似于CMP与SUB指令之间的关系.</td></tr><tr><td>WAIT</td><td>处理器等待指令 WAIT 格式: WAIT 功能: 本指令将使处理器检测TEST端脚,当TEST有效时,则退出等待状态执行下条指令,否则处理器处于等待状态,直到TEST有效.</td><td>说明: 本指令不影响标志位.</td></tr><tr><td>XCHG</td><td>数据交换指令 XCHG 格式: XCHG OPRD1,OPRD2 其中的OPRD1为目的操作数,OPRD2为源操作数 功能: 将两个操作数相互交换位置,该指令把源操作数OPRD2与目的操数OPRD1交换.</td><td>说明: 1. OPRD1及OPRD2可为通用寄存器或存储器,但是两个存储器之间是不能用XCHG指令实现的. 2. 段寄存器内容不能用XCHG指令来交换. 3. 若要实现两个存储器操作数DATA1及DATA2的交换,可用以下指令实现: 示例: PUSH DATA1 PUSH DATA2 POP DATA1 POP DATA2 4. 本指令不影响状态标志位.</td></tr><tr><td>XLAT</td><td>查表指令 XLAT 格式: XLAT TABLE其中TABLE为一待查表格的首地址. 功能: 把待查表格的一个字节内容送到AL累加器中.</td><td>说明: 1. 在执行该指令前,应将TABLE先送至BX寄存器中,然后将待查字节与在表格中距表首地址位移量送AL,即 (AL)&lt;–((BX)+(AL)). 2. 本指令不影响状态标位,表格长度不超过256字节.</td></tr><tr><td>XOR</td><td>逻辑异或运算指令 XOR 格式: XOR OPRD1,OPRD2 功能: 实现两个操作数按位‘异或’运算,结果送至目的操作数中. OPRD1&lt;–OPRD1 XOR OPRD2</td><td>说明: 1. 其在OPRD1、OPRD2的含义与AND指令相同,对标志位的影响与与AND指令相同. 2. 相异为真,相同为假.</td></tr></tbody></table><h2 id="4、x86和amd64指令参考"><a href="#4、x86和amd64指令参考" class="headerlink" title="4、x86和amd64指令参考"></a>4、x86和amd64指令参考</h2><p>AAA-添加后进行ASCII调整<br>AAD-ASCII分割前调整AX<br>AAM-ASCII调整AX后乘以<br>AAS-ASCII减法后调整AL<br>ADC-带进位加法<br>ADCX - 带进位标志的两个操作数的无符号整数相加<br>ADD-加<br>ADDPD-Add打包的双精度浮点值<br>ADDPS-Add打包的单精度浮点值<br>ADDSD-Add标量双精度浮点值<br>ADDSS - add标量单精度浮点值<br>ADDSUBPD-压缩双FP加/减<br>ADDSUBPS-压缩单FP加/减<br>ADOX - 带有溢出标志的两个操作数的无符号整数<br>AESDEC - 执行一轮AES解密流程<br>AESDECLAST - 执行AES解密流的最后一轮<br>AESENC - 执行一轮AES加密流程<br>AESENCLAST - 执行AES加密流的最后一轮<br>AESIMC - 执行AES InvMixColumn转换<br>AESKEYGENASSIST-AES轮回密钥生成辅助<br>AND-逻辑与<br>ANDN - 逻辑AND NOT<br>ANDPD-压缩双精度浮点值的按位逻辑与<br>ANDPS—压缩单精度浮点值的按位逻辑与<br>ANDNPD—压缩双精度浮点值的按位逻辑AND NOT<br>ANDNPS—压缩单精度浮点值的按位逻辑AND NOT<br>ARPL—调整段选择器的RPL字段<br>BLENDPD — 混合封装双精度浮点值<br>BEXTR — 位字段提取<br>BLENDPS — 混合封装的单精度浮点值<br>BLENDVPD — 可变混合封装双精度浮点值<br>BLENDVPS — 可变混合封装单精度浮点值<br>BLSI — 提取最低设置隔离位<br>BLSMSK — 获取掩码到最低设置位<br>BLSR — 复位最低设置位<br>BNDCL—检查下限<br>BNDCU/BNDCN—检查上边界<br>BNDLDX—使用地址转换加载扩展边界<br>BNDMK—制作界限<br>BNDMOV—移动边界<br>BNDSTX—使用地址转换存储扩展边界<br>BOUND—检查阵列索引对边界<br>BSF—位扫描转发<br>BSR—位扫描反转<br>BSWAP—字节交换<br>BT—位测试<br>BTC—位测试和补码<br>BTR—位测试和复位<br>BTS—位测试和设置<br>BZHI — 从指定位位置开始的零高位<br>CALL—调用过程<br>CBW/CWDE/CDQE—将字节转换为字/将字转换为双字/将双字转换为四字<br>CLAC—清除EFLAGS寄存器中的AC标志<br>CLC—清除进位标志<br>CLD—清除方向标志<br>CLFLUSH—刷新缓存行<br>CLFLUSHOPT—刷新缓存行已优化<br>CLI — 清除中断标志<br>CLTS—清除CR0中的任务切换标志<br>CLWB—高速缓存行回写<br>CMC—补充进位标志<br>CMOVcc—条件移动<br>CMP—比较两个操作数<br>CMPPD—比较打包的双精度浮点值<br>CMPPS—比较打包的单精度浮点值<br>CMPS/CMPSB/CMPSW/CMPSD/CMPSQ—比较字符串操作数<br>CMPSD—比较标量双精度浮点值<br>CMPSS—比较标量单精度浮点值<br>CMPXCHG—比较和交流<br>CMPXCHG8B/CMPXCHG16B—比较和交换字节<br>COMISD—比较标量有序双精度浮点值和设置EFLAGS<br>COMISS—比较标量有序单精度浮点值和设置EFLAGS<br>CPUID—CPU识别<br>CRC32 — 累加CRC32值<br>CVTDQ2PD—将打包的双字整数转换为打包的双精度浮点值<br>CVTDQ2PS—将打包的双字整数转换为打包的单精度浮点值<br>CVTPD2DQ—将打包的双精度浮点值转换为打包的双字整数<br>CVTPD2PI—将打包的双精度FP值转换为打包的双字整数<br>CVTPD2PS—将打包的双精度浮点值转换为打包的单精度浮点值<br>CVTPI2PD—将打包的双字整数转换为打包的双精度FP值<br>CVTPI2PS—将打包的双字整数转换为打包的单精度FP值<br>CVTPS2DQ—将打包的单精度浮点值转换为打包签名的双字整数值<br>CVTPS2PD—将打包的单精度浮点值转换为打包的双精度浮点值<br>CVTPS2PI—将打包的单精度FP值转换为打包的双字整数<br>CVTSD2SI—将标量双精度浮点值转换为双字整数<br>CVTSD2SS—将标量双精度浮点值转换为标量单精度浮点值<br>CVTSI2SD—将双字整数转换为标量双精度浮点值<br>CVTSI2SS—将双字整数转换为标量单精度浮点值<br>CVTSS2SD—将标量单精度浮点值转换为标量双精度浮点值<br>CVTSS2SI—将标量单精度浮点值转换为双字整数<br>CVTTPD2DQ—转换为截断打包的双精度浮点值到打包的双字整数<br>CVTTPD2PI—转换为截断打包的双精度FP值到打包的双字整数<br>CVTTPS2DQ—将截断转换为打包的单精度浮点值到打包签名的双字整数值<br>CVTTPS2PI—转换为截断打包的单精度FP值到打包的双字整数<br>CVTTSD2SI—将截断的标量双精度浮点值转换为有符号整数<br>CVTTSS2SI—将截断标量单精度浮点值转换为整数<br>CWD/CDQ/CQO—将字转换为双字/将双字转换为四字<br>DAA—十进制加法后调整AL<br>DAS—十进制减法后调整AL<br>DEC—减少1<br>DIV—无符号除法<br>DIVPD—除法包装的双精度浮点值<br>DIVPS—分割打包的单精度浮点值<br>DIVSD—除法标量双精度浮点值<br>DIVSS—除法标量单精度浮点值<br>DPPD — 封装双精度浮点值的点积<br>DPPS — 封装单精度浮点值的点积<br>EMMS—空MMX技术状态<br>ENTER—为过程参数创建堆栈框架<br>EXTRACTPS—提取打包的浮点值<br>F2XM1—计算2x-1<br>FABS—绝对值<br>FADD/FADDP/FIADD—Add<br>FBLD—加载二进制编码十进制<br>FBSTP—存储BCD整数和弹出<br>FCHS—更改标志<br>FCLEX/FNCLEX—清除例外<br>FCMOVcc—浮点条件移动<br>FCOM/FCOMP/FCOMPP—比较浮点值<br>FCOMI/FCOMIP/ FUCOMI/FUCOMIP—比较浮点值和设置EFLAGS<br>FCOS— 余弦<br>FDECSTP—减少堆栈顶指针<br>FDIV/FDIVP/FIDIV—划分<br>FDIVR/FDIVRP/FIDIVR—反向分割<br>FFREE—自由浮点寄存器<br>FICOM/FICOMP—比较整数<br>FILD—加载整数<br>FINCSTP—增加堆栈顶指针<br>FINIT/FNINIT—初始化浮点单元<br>FIST/FISTP—存储整数<br>FISTTP—存储整数与截断<br>FLD—加载浮点值<br>FLD1/FLDL2T/FLDL2E/FLDPI/FLDLG2/FLDLN2/FLDZ—负载常数<br>FLDCW—加载x87 FPU控制字<br>FLDENV—加载x87 FPU环境<br>FMUL/FMULP/FIMUL—乘<br>FNOP—无操作<br>FPATAN—部分反正切<br>FPREM—部分剩余<br>FPREM1—部分剩余<br>FPTAN—部分切线<br>FRNDINT—舍入为整数<br>FRSTOR—恢复x87 FPU状态<br>FSAVE/FNSAVE—存储x87 FPU状态<br>FSCALE—规模<br>FSIN—正弦<br>FSINCOS—正弦和余弦<br>FSQRT—平方根<br>FST/FSTP—存储浮点值<br>FSTCW/FNSTCW—存储x87 FPU控制字<br>FSTENV/FNSTENV—存储x87 FPU环境<br>FSTSW/FNSTSW—存储x87 FPU状态字<br>FSUB/FSUBP/FISUB—减去<br>FSUBR/FSUBRP/FISUBR—反向减<br>FTST—TEST<br>FUCOM/FUCOMP/FUCOMPP—无序比较浮点值<br>FXAM—检查浮点<br>FXCH—交换寄存器内容<br>FXRSTOR—恢复x87 FPU，MMX，XMM和MXCSR状态<br>FXSAVE—保存x87 FPU，MMX技术和SSE状态<br>FXTRACT—提取指数和指标<br>FYL2X—计算y <em> log2x<br>FYL2XP1—计算y </em> log2（x + 1）<br>HADDPD—包装双FP水平添加<br>HADDPS—包装单FP水平添加<br>HLT—停<br>HSUBPD—压缩双FP水平减法<br>HSUBPS—打包单FP水平减法<br>IDIV—签名除法<br>IMUL—签名乘法<br>IN—从端口输入<br>INC—递增1<br>INS/INSB/INSW/INSD—从端口到字符串的输入<br>INSERTPS—插入标量单精度浮点值<br>INT n/INTO/INT 3—调用中断过程<br>INVD—无效内部缓存<br>INVLPG—使TLB条目无效<br>INVPCID—使过程上下文标识符无效<br>IRET/IRETD—中断返回<br>Jcc—如果条件满足则跳转<br>JMP—跳<br>KADDW/KADDB/KADDQ/KADDD—ADD两个面具<br>KANDW/KANDB/KANDQ/KANDD—按位逻辑和掩码<br>KANDNW/KANDNB/KANDNQ/KANDND—按位逻辑AND NOT掩码<br>KMOVW/KMOVB/KMOVQ/KMOVD—从和到掩码寄存器<br>KNOTW/KNOTB/KNOTQ/KNOTD—NOT屏蔽寄存器<br>KORW/KORB/KORQ/KORD—按位逻辑或掩码<br>KORTESTW/KORTESTB/KORTESTQ/KORTESTD—OR Masks And Set Flags<br>KSHIFTLW/KSHIFTLB/KSHIFTLQ/KSHIFTLD—移位左掩码寄存器<br>KSHIFTRW/KSHIFTRB/KSHIFTRQ/KSHIFTRD—Shift右掩码寄存器<br>KTESTW/KTESTB/KTESTQ/KTESTD—打包位测试掩码和设置标志<br>KUNPCKBW/KUNPCKWD/KUNPCKDQ—解包掩码寄存器<br>KXNORW/KXNORB/KXNORQ/KXNORD—按位逻辑XNOR掩码<br>KXORW/KXORB/KXORQ/KXORD—按位逻辑异或掩码<br>LAHF—将状态标志加载到AH寄存器中<br>LAR—加载访问权限字节<br>LDDQU—加载未对齐的整数128位<br>LDMXCSR—加载MXCSR寄存器<br>LDS/LES/LFS/LGS/LSS—加载远程指针<br>LEA—加载有效地址<br>LEAVE—高级过程退出<br>LFENCE—负载栅栏<br>LGDT/LIDT—加载全局/中断描述符表寄存器<br>LLDT—加载本地jubu描述符表寄存器<br>LMSW—加载机器状态字<br>LOCK—置位LOCK＃信号前缀<br>LODS/LODSB/LODSW/LODSD/LODSQ—加载字符串<br>LOOP/LOOPcc—根据ECX计数器循环<br>LSL—负载段限制<br>LTR—加载任务寄存器<br>LZCNT— 计数前导零位的数量</p><p>MASKMOVDQU—存储双字双字的所选字节<br>MASKMOVQ—存储选定的四字节字节<br>MAXPD—最大打包双精度浮点值<br>MAXPS—最大打包单精度浮点值<br>MAXSD—返回最大标量双精度浮点值<br>MAXSS—返回最大标量单精度浮点值<br>MFENCE—内存围栏<br>MINPD—最小包装双精度浮点值<br>MINPS—最小打包单精度浮点值<br>MINSD—返回最小标量双精度浮点值<br>MINSS—返回最小标量单精度浮点值<br>MONITOR—设置监视器地址<br>MOV—移动<br>MOVAPD—移动对齐打包的双精度浮点值<br>MOVAPS—移动对齐打包的单精度浮点值<br>MOVBE—在交换字节后移动数据<br>MOVD/MOVQ—移动双字/移动四字<br>MOVDDUP—复制双精度浮点值<br>MOVDQA,VMOVDQA32/64—移动对齐的打包整数值<br>MOVDQU,VMOVDQU8/16/32/64—移动未对齐的打包整数值<br>MOVDQ2Q—将四字从XMM移动到MMX技术寄存器<br>MOVHLPS—将打包的单精度浮点值从高到低移动<br>MOVHPD—移动高压缩双精度浮点值<br>MOVHPS—移动高度封装的单精度浮点值<br>MOVLHPS—将打包的单精度浮点值从低到高移动<br>MOVLPD—移动低压缩双精度浮点值<br>MOVLPS—移动低压缩单精度浮点值<br>MOVMSKPD—提取封装的双精度浮点符号掩码<br>MOVMSKPS—提取打包的单精度浮点符号掩码<br>MOVNTDQA—加载双字体非时间对齐提示<br>MOVNTDQ—使用非时间提示存储打包的整数<br>MOVNTI—使用非时间提示存储双字<br>MOVNTPD—使用非时间提示存储打包的双精度浮点值<br>MOVNTPS—使用非时间提示存储打包的单精度浮点值<br>MOVNTQ—使用非时间提示的四字存储<br>MOVQ—移动四字<br>MOVQ2DQ—将四字从MMX技术移动到XMM寄存器<br>MOVS/MOVSB/MOVSW/MOVSD/MOVSQ—将数据从字符串移动到字符串<br>MOVSD—移动或合并标量双精度浮点值<br>MOVSHDUP—复制单个FP值<br>MOVSLDUP—复制单个FP值<br>MOVSS—移动或合并标量单精度浮点值<br>MOVSX/MOVSXD—使用符号扩展移动<br>MOVUPD—移动非对齐打包的双精度浮点值<br>MOVUPS—移动不对齐打包的单精度浮点值<br>MOVZX—用零扩展移动<br>MPSADBW — 计算多个封装的绝对差的和<br>MUL—无符号乘法<br>MULPD—乘法封装的双精度浮点值<br>MULPS—乘法封装的单精度浮点值<br>MULSD—乘以标量双精度浮点值<br>MULSS—乘以标量单精度浮点值<br>MULX — 无符号乘法不影响标志<br>MWAIT—监视等待<br>NEG—二的互补阴性<br>NOP—无操作<br>NOT—一个补码阴性<br>OR—逻辑包含OR<br>ORPD—压缩双精度浮点值的按位逻辑或<br>ORPS—压缩单精度浮点值的按位逻辑或<br>OUT—输出到端口<br>OUTS/OUTSB/OUTSW/OUTSD—输出字符串到端口<br>PABSB/PABSW/PABSD/PABSQ — 压缩绝对值<br>PACKSSWB/PACKSSDW—包含有符号饱和度<br>PACKUSDW—具有无符号饱和度的包<br>PACKUSWB—具有无符号饱和度的包<br>PADDB/PADDW/PADDD/PADDQ—添加打包的整数<br>PADDSB/PADDSW—添加带签名饱和度的打包签名整数<br>PADDUSB/PADDUSW—添加带有无符号饱和的打包的无符号整数<br>PALIGNR — 包装对齐<br>PAND—逻辑AND<br>PANDN—逻辑AND NOT<br>PAUSE—旋转环提示<br>PAVGB/PAVGW—平均打包整数<br>PBLENDVB — 可变混合打包字节<br>PBLENDW — 混合包装的词<br>PCLMULQDQ - 无载乘法四字<br>PCMPEQB/PCMPEQW/PCMPEQD— 比较打包数据以等于<br>PCMPEQQ — 比较打包的Qword数据<br>PCMPESTRI — 压缩比较显式长度字符串，返回索引<br>PCMPESTRM — 压缩比较显式长度字符串，返回掩码<br>PCMPGTB/PCMPGTW/PCMPGTD—比较打包签名的整数大于<br>PCMPGTQ — 比较打包数据大于<br>PCMPISTRI — 压缩比较隐式长度字符串，返回索引<br>PCMPISTRM — 压缩比较隐式长度字符串，返回掩码<br>PDEP — 平行位存款<br>PEXT — 平行位提取<br>PEXTRB/PEXTRD/PEXTRQ — 提取字节/双字/ Qword<br>PEXTRW—提取 Word<br>PHADDW/PHADDD — 包装水平添加<br>PHADDSW — 包装水平添加和饱和<br>PHMINPOSUW — 包装水平词最小<br>PHSUBW/PHSUBD — 打包水平减法<br>PHSUBSW — 包装水平扣除和饱和<br>PINSRB/PINSRD/PINSRQ — 插入字节/双字/ Qword<br>PINSRW—插入字<br>PMADDUBSW — 乘法和添加打包签名和无符号字节<br>PMADDWD—乘法和添加打包整数<br>PMAXSB/PMAXSW/PMAXSD/PMAXSQ—最大打包签名整数<br>PMAXUB/PMAXUW—最大打包的无符号整数<br>PMAXUD/PMAXUQ—最大打包的无符号整数<br>PMINSB/PMINSW—最小打包签名整数<br>PMINSD/PMINSQ—最小打包签名整数<br>PMINUB/PMINUW—最小打包的无符号整数<br>PMINUD/PMINUQ—最小打包的无符号整数<br>PMOVMSKB—移动字节掩码<br>PMOVSX—包装移动与符号扩展<br>PMOVZX—带零扩展的打包移动<br>PMULDQ—乘以压缩双字整数<br>PMULHRSW — 包装高与圆和规模<br>PMULHUW—乘法打包的无符号整数和存储高结果<br>PMULHW—乘法打包签名整数和存储高结果<br>PMULLD/PMULLQ—乘以压缩整数和存储低结果<br>PMULLW—乘以打包的有符号整数和存储低结果<br>PMULUDQ—乘法打包的无符号双字整数<br>POP—从堆栈中弹出一个值<br>POPA/POPAD—弹出所有通用寄存器<br>POPCNT — 返回设置为1的位数计数<br>POPF/POPFD/POPFQ—弹出堆栈到 EFLAGS 寄存器<br>POR—按位逻辑或<br>PREFETCHh—预取数据到缓存<br>PREFETCHW—在写入预期中将数据预取到缓存中<br>PREFETCHWT1—将向量数据预取到具有意图写入和T1提示的高速缓存中<br>PSADBW—计算绝对差的和<br>PSHUFB — 打包的随机字节<br>PSHUFD—随机打包双字<br>PSHUFHW—随机包装高字<br>PSHUFLW—随机包装低字<br>PSHUFW—随机包装的词<br>PSIGNB/PSIGNW/PSIGND — 打包标志<br>PSLLDQ—移位双四字左逻辑<br>PSLLW/PSLLD/PSLLQ—移位数据打包左逻辑<br>PSRAW/PSRAD/PSRAQ—移位打包数据右算术<br>PSRLDQ—移位双四字右逻辑<br>PSRLW/PSRLD/PSRLQ—移位打包数据右逻辑<br>PSUBB/PSUBW/PSUBD—减去打包的整数<br>PSUBQ—减去打包的四字整数<br>PSUBSB/PSUBSW—减去带有符号饱和的打包有符号整数<br>PSUBUSB/PSUBUSW—使用无符号饱和度减去打包的无符号整数<br>PTEST- 逻辑比较<br>PTWRITE - 将数据写入处理器跟踪数据包<br>PUNPCKHBW/PUNPCKHWD/PUNPCKHDQ/PUNPCKHQDQ— 解压高数据<br>PUNPCKLBW/PUNPCKLWD/PUNPCKLDQ/PUNPCKLQDQ—解压低数据<br>PUSH—将字，双字或四字推到堆栈上<br>PUSHA/PUSHAD—推送所有通用寄存器<br>PUSHF/PUSHFD—将EFLAGS寄存器推送到堆栈<br>PXOR—逻辑异或<br>RCL/RCR/ROL/ROR—旋转<br>RCPPS—计算包装的单精度浮点值的倒数<br>RCPSS—计算标量单精度浮点值的倒数<br>RDFSBASE/RDGSBASE—读取FS / GS段基址<br>RDMSR—从模型专用寄存器读取<br>RDPID—读取处理器ID<br>RDPKRU—读取用户页面的保护关键权限<br>RDPMC—读取性能监视计数器<br>RDRAND—读随机数<br>RDSEED—阅读随机SEED<br>RDTSC—读取时间戳计数器<br>RDTSCP—读取时间戳计数器和处理器ID<br>REP/REPE/REPZ/REPNE/REPNZ—重复字符串操作前缀<br>RET—从程序返回<br>RORX — 向右旋转逻辑而不影响标志<br>ROUNDPD — 圆形双精度浮点值<br>ROUNDPS — 圆形封装单精度浮点值<br>ROUNDSD — 圆形标量双精度浮点值<br>ROUNDSS — 圆形标量单精度浮点值<br>RSM—从系统管理模式恢复<br>RSQRTPS—计算压缩单精度浮点值的平方根的倒数<br>RSQRTSS—计算标量单精度浮点值的平方根的倒数<br>SAHF—将AH存储到标志<br>SAL/SAR/SHL/SHR—转移<br>SARX/SHLX/SHRX — 转移不影响标志<br>SBB—借用整数减法<br>SCAS/SCASB/SCASW/SCASD—扫描字符串<br>SETcc—在字段上设置字节<br>SFENCE—商店栅栏<br>SGDT—存储全局描述符表寄存器<br>SHA1RNDS4—执行四轮SHA1操作<br>SHA1NEXTE—计算四轮后的SHA1状态变量E.<br>SHA1MSG1—对下四个SHA1消息双字执行中间计算<br>SHA1MSG2—对下四个SHA1消息双字执行最终计算<br>SHA256RNDS2—执行两轮SHA256操作<br>SHA256MSG1—对下四个SHA256消息双字执行中间计算<br>SHA256MSG2—对下四个SHA256消息双字执行最终计算<br>SHLD—双精度位移左<br>SHRD—双精度平移<br>SHUFPD—包装交错双精度浮点值对的随机<br>SHUFPS—Packed Interleave单精度浮点值四重串交替<br>SIDT—存储中断描述符表寄存器<br>SLDT—存储本地描述符表寄存器<br>SMSW—存储机器状态字<br>SQRTPD—双精度浮点值的平方根<br>SQRTPS—单精度浮点值的平方根<br>SQRTSD—计算平方根的标量双精度浮点值<br>SQRTSS—计算标量单精度值的平方根<br>STAC—在EFLAGS寄存器中设置AC标志<br>STC—设置进位标志<br>STD—设置方向标志<br>STI—设置中断标志<br>STMXCSR—存储MXCSR寄存器状态<br>STOS/STOSB/STOSW/STOSD/STOSQ—存储字符串<br>STR—存储任务寄存器<br>SUB—减去<br>SUBPD—减去打包的双精度浮点值<br>SUBPS—减去打包的单精度浮点值<br>SUBSD—减去标量双精度浮点值<br>SUBSS—减去标量单精度浮点值<br>SWAPGS—交换GS基址寄存器<br>SYSCALL—快速系统调用<br>SYSENTER—快速系统调用<br>SYSEXIT—从快速系统调用快速返回<br>SYSRET—从快速系统调用返回<br>TEST—逻辑比较<br>TZCNT — 计算零位的位数<br>UCOMISD—无序比较标量双精度浮点值并设置EFLAGS<br>UCOMISS—无序比较标量单精度浮点值并设置EFLAGS<br>UD2—未定义指令<br>UNPCKHPD—解包和交织高压双精度浮点值<br>UNPCKHPS—解包和交织高度封装的单精度浮点值<br>UNPCKLPD—解包和交织低压双精度浮点值<br>UNPCKLPS—解包和交织低压缩单精度浮点值</p><p>VALIGND/VALIGNQ—对齐双字/四字向量<br>VBLENDMPD/VBLENDMPS—使用OpMask控件的Blend Float64 / Float32向量<br>VBROADCAST—加载广播浮点数据<br>VPBROADCASTM—广播掩码到向量寄存器<br>VCOMPRESSPD—将稀疏压缩双精度浮点值存储到密集存储器中<br>VCOMPRESSPS—将稀疏打包的单精度浮点值存储到密集存储器中<br>VCVTPD2QQ—将打包的双精度浮点值转换为打包的四字整数<br>VCVTPD2UDQ—将打包的双精度浮点值转换为打包的无符号双字整数<br>VCVTPD2UQQ—将打包的双精度浮点值转换为打包的无符号四字整数<br>VCVTPH2PS—将16位FP值转换为单精度FP值<br>VCVTPS2PH—将Single-Precision FP值转换为16位FP值<br>VCVTPS2UDQ—将打包的单精度浮点值转换为打包的无符号双字整数值<br>VCVTPS2QQ—将打包的单精度浮点值转换为打包的有符号四字整数值<br>VCVTPS2UQQ—将打包的单精度浮点值转换为打包的无符号四字整数值<br>VCVTQQ2PD—将打包的四字整数转换为打包的双精度浮点值<br>VCVTQQ2PS—将打包的四字整数转换为打包的单精度浮点值<br>VCVTSD2USI—将标量双精度浮点值转换为无符号双字整数<br>VCVTSS2USI—将标量单精度浮点值转换为无符号双字整数<br>VCVTTPD2QQ—将截断打包的双精度浮点值转换为打包的四字整数<br>VCVTTPD2UDQ—转换为截断打包的双精度浮点值到打包的无符号双字整数<br>VCVTTPD2UQQ—将截断的双精度浮点值转换为打包的无符号四字整数<br>VCVTTPS2UDQ—将截断转换为打包的单精度浮点值到打包的无符号双字整数值<br>VCVTTPS2QQ—将截断转换为打包的单精度浮点值到打包的有符号四字整数值<br>VCVTTPS2UQQ—将截断转换为打包的单精度浮点值到打包的无符号四字整数值<br>VCVTTSD2USI—将截断的标量双精度浮点值转换为无符号整数<br>VCVTTSS2USI—将截断标量单精度浮点值转换为无符号整数<br>VCVTUDQ2PD—将打包的无符号双字整数转换为打包的双精度浮点值<br>VCVTUDQ2PS—将打包的无符号双字整数转换为打包的单精度浮点值<br>VCVTUQQ2PD—将打包的无符号四字整数转换为打包的双精度浮点值<br>VCVTUQQ2PS—将打包的无符号四字整数转换为打包的单精度浮点值<br>VCVTUSI2SD—将无符号整数转换为标量双精度浮点值<br>VCVTUSI2SS—将无符号整数转换为标量单精度浮点值<br>VDBPSADBW—对无符号字节的双块打包和绝对差（SAD）<br>VEXPANDPD—从密集存储器加载稀疏压缩双精度浮点值<br>VEXPANDPS—从密集存储器加载稀疏打包的单精度浮点值<br>VERR/VERW—验证读取或写入的段<br>VEXP2PD—近似于指数2 ^ x的打包双精度浮点值，小于2 ^ -23相对误差<br>VEXP2PS—近似于包装的单精度浮点值的指数2 ^ x小于2 ^ -23相对误差<br>VEXTRACTF128/VEXTRACTF32x4/VEXTRACTF64x2/VEXTRACTF32x8/VEXTRACTF64x4—Extr act打包浮点值<br>VEXTRACTI128/VEXTRACTI32x4/VEXTRACTI64x2/VEXTRACTI32x8/VEXTRACTI64x4—提取打包的整数值<br>VFIXUPIMMPD—修复特殊打包的Float64值<br>VFIXUPIMMPS—修复特殊打包的Float32值<br>VFIXUPIMMSD—修复特殊标量Float64价值<br>VFIXUPIMMSS—修复特殊标量Float32价值<br>VFMADD132PD/VFMADD213PD/VFMADD231PD—熔丝乘法 - 加上双精度浮点值<br>VFMADD132PS/VFMADD213PS/VFMADD231PS—融合乘法 - 加上单精度浮点值<br>VFMADD132SD/VFMADD213SD/VFMADD231SD—熔丝乘加 - 标量双精度浮点值<br>VFMADD132SS/VFMADD213SS/VFMADD231SS—融合乘法 - 加上标量单精度浮点值<br>VFMADDSUB132PD/VFMADDSUB213PD/VFMADDSUB231PD—熔断乘法 - 交替加/减包装的双精度浮点值<br>VFMADDSUB132PS/VFMADDSUB213PS/VFMADDSUB231PS—封装单精度浮点值的融合乘法交替加法/减法<br>VFMSUBADD132PD/VFMSUBADD213PD/VFMSUBADD231PD—融合乘法交替减法/增加的双精度浮点值<br>VFMSUBADD132PS/VFMSUBADD213PS/VFMSUBADD231PS—融合乘法交替减法/添加的单精度浮点值<br>VFMSUB132PD/VFMSUB213PD/VFMSUB231PD—压缩双精度浮点值的乘法减法<br>VFMSUB132PS/VFMSUB213PS/VFMSUB231PS—压缩单精度浮点值的乘法减法<br>VFMSUB132SD/VFMSUB213SD/VFMSUB231SD—标量双精度浮点值的融合乘法 - 减法<br>VFMSUB132SS/VFMSUB213SS/VFMSUB231SS—标量单精度浮点值的融合乘减<br>VFNMADD132PD/VFNMADD213PD/VFNMADD231PD—熔丝负精度浮点值的乘积 - 加法<br>VFNMADD132PS/VFNMADD213PS/VFNMADD231PS—熔丝负精度浮点值的乘积 - 加法<br>VFNMADD132SD/VFNMADD213SD/VFNMADD231SD—熔丝负精度浮点值的乘积 - 加法<br>VFNMADD132SS/VFNMADD213SS/VFNMADD231SS—熔丝负精度浮点值的乘积 - 加法<br>VFNMSUB132PD/VFNMSUB213PD/VFNMSUB231PD—压缩双精度浮点值的负值乘法减法<br>VFNMSUB132PS/VFNMSUB213PS/VFNMSUB231PS—封装单精度浮点值的熔丝负负乘法 - 减法<br>VFNMSUB132SD/VFNMSUB213SD/VFNMSUB231SD—标量双精度浮点值的熔融负乘法 - 减法<br>VFNMSUB132SS/VFNMSUB213SS/VFNMSUB231SS—标量单精度浮点值的熔点负乘减<br>VFPCLASSPD—测试打包的Float64值的类型<br>VFPCLASSPS—测试打包的Float32值的类型<br>VFPCLASSSD—测试标量Float64值的类型<br>VFPCLASSSS—测试Scalar Float32值的类型<br>VGATHERDPD/VGATHERQPD — 使用有符号的双字/ Qword指数收集打包的DP FP值<br>VGATHERDPS/VGATHERQPS — 使用签名的双字/ Qword索引收集打包的SP FP值<br>VGATHERDPS/VGATHERDPD—收集包装单，包装双与签署双剑<br>VGATHERPF0DPS/VGATHERPF0QPS/VGATHERPF0DPD/VGATHERPF0QPD—稀疏预取打包SP / DP数据值与签名双字，签名的Qword指数使用T0提示<br>VGATHERPF1DPS/VGATHERPF1QPS/VGATHERPF1DPD/VGATHERPF1QPD—稀疏预取打包SP / DP数据值与签名双字，签名的Qword指数使用T1提示<br>VGATHERQPS/VGATHERQPD—收集包装单，包装双与签名的Qword指数<br>VPGATHERDD/VPGATHERQD — 使用签名的双字/ Qword指数收集打包的双字值<br>VPGATHERDD/VPGATHERDQ—收集包装双剑，包装的Qword和双重指数<br>VPGATHERDQ/VPGATHERQQ — 使用签名的双字/ Qword指数收集打包的Qword值<br>VPGATHERQD/VPGATHERQQ—收集包装双剑，包装的Qword与已签名的Qword指数<br>VGETEXPPD—将打包的DP FP值的指数转换为DP FP值<br>VGETEXPPS—将打包的SP FP值的指数转换为SP FP值<br>VGETEXPSD—将标量DP FP值的指数转换为DP FP值<br>VGETEXPSS—将标量SP FP值的指数转换为SP FP值<br>VGETMANTPD—从Float64 Vector中提取Float64 Vector of Normalized Mantissas<br>VGETMANTPS—从Float32 Vector中提取Float32向量的Normalized Mantissas<br>VGETMANTSD—从Float64标量提取Float64的规范化尾数<br>VGETMANTSS—从Float32向量提取标准化尾数Float32矢量<br>VINSERTF128/VINSERTF32x4/VINSERTF64x2/VINSERTF32x8/VINSERTF64x4—插入打包的浮点值<br>VINSERTI128/VINSERTI32x4/VINSERTI64x2/VINSERTI32x8/VINSERTI64x4—插入打包的整数值<br>VMASKMOV—条件SIMD打包荷载和商店<br>VPBLENDD — 混合包装双字<br>VPBLENDMB/VPBLENDMW—使用opmask控制的混合字节/字向量<br>VPBLENDMD/VPBLENDMQ—使用OpMask控件混合Int32 / Int64向量<br>VPBROADCASTB/W/D/Q—从通用寄存器加载广播整数数据<br>VPBROADCAST—加载整数和广播<br>VPCMPB/VPCMPUB—将打包的字节值比较到掩码中<br>VPCMPD/VPCMPUD—将打包的整数值与掩码进行比较<br>VPCMPQ/VPCMPUQ—将打包的整数值与掩码进行比较<br>VPCMPW/VPCMPUW—比较打包的词值到掩码<br>VPCOMPRESSD—将稀疏压缩双字整数值存储到密集存储器/寄存器中<br>VPCOMPRESSQ—将稀疏压缩四字整数值存储到密集存储器/寄存器中<br>VPCONFLICTD/Q—检测在打包的双字/ Qword值的向量内的冲突到密集存储器/寄存器中<br>VPERM2F128 — 允许浮点值<br>VPERM2I128 — 允许整数值<br>VPERMD/VPERMW—Permute打包双字/字元素<br>VPERMI2W/D/Q/PS/PD—两个表的完全权限覆盖索引<br>VPERMILPD—允许双精度浮点值对的内部通道<br>VPERMILPS—允许四精度浮点值的内部通道<br>VPERMPD—允许双精度浮点元素<br>VPERMPS—允许单精度浮点元素<br>VPERMQ—四字节元素置换<br>VPEXPANDD—从密集存储器/寄存器加载稀疏压缩双字整数值<br>VPEXPANDQ—从密集存储器/寄存器加载稀疏压缩四字整数值<br>VPLZCNTD/Q—计算打包双字，打包的Qword值的前导零位数<br>VPMASKMOV — 条件SIMD整数打包荷载和商店<br>VPMOVM2B/VPMOVM2W/VPMOVM2D/VPMOVM2Q—将屏蔽寄存器转换为向量寄存器<br>VPMOVB2M/VPMOVW2M/VPMOVD2M/VPMOVQ2M—将矢量寄存器转换为掩码<br>VPMOVQB/VPMOVSQB/VPMOVUSQB—Down将QWord转换为字节<br>VPMOVQW/VPMOVSQW/VPMOVUSQW—Down将QWord转换为Word<br>VPMOVQD/VPMOVSQD/VPMOVUSQD—Down将QWord转换为DWord<br>VPMOVDB/VPMOVSDB/VPMOVUSDB—Down将DWord转换为字节<br>VPMOVDW/VPMOVSDW/VPMOVUSDW—Down将DWord转换为Word<br>VPMOVWB/VPMOVSWB/VPMOVUSWB—向下将字转换为字节<br>PROLD/PROLVD/PROLQ/PROLVQ—位向左旋转<br>PRORD/PRORVD/PRORQ/PRORVQ—位向右旋转<br>VPSCATTERDD/VPSCATTERDQ/VPSCATTERQD/VPSCATTERQQ—分散包装双字，带有符号双字的打包字，签名的Qword指数<br>VPSLLVW/VPSLLVD/VPSLLVQ—可变位移左逻辑<br>VPSRAVW/VPSRAVD/VPSRAVQ—可变位移右算术<br>VPSRLVW/VPSRLVD/VPSRLVQ—可变位移右逻辑<br>VPTERNLOGD/VPTERNLOGQ—按位三进制逻辑<br>VPTESTMB/VPTESTMW/VPTESTMD/VPTESTMQ—逻辑与和设置掩码<br>VPTESTNMB/W/D/Q—逻辑NAND和设置<br>VRANGEPD—对于Float64值的打包对的范围限制计算<br>VRANGEPS—对于Float32值的打包对的范围限制计算<br>VRANGESD—范围限制计算从一对Scalar Float64值<br>VRANGESS—从一对标量Float32值计算范围限制<br>VRCP14PD—计算压缩Float64值的近似倒数<br>VRCP14SD—计算标量Float64值的近似倒数<br>VRCP14PS—计算压缩Float32值的近似倒数<br>VRCP14SS—计算标量Float32值的近似倒数<br>VRCP28PD—近似于具有小于2 ^ -28相对误差的封装双精度浮点值的倒数<br>VRCP28SD—近似于标量双精度浮点值的倒数，小于2 ^ -28相对误差<br>VRCP28PS—近似于具有小于2 ^ -28相对误差的封装单精度浮点值的倒数<br>VRCP28SS—近似于标量单精度浮点值的倒数，小于2 ^ -28相对误差<br>VREDUCEPD—对压缩的Float64值执行压缩转换<br>VREDUCESD—对标量Float64值执行减少转换<br>VREDUCEPS—对已压缩的Float32值执行减少转换<br>VREDUCESS—对标量Float32值执行减少转换<br>VRNDSCALEPD—圆形压缩Float64值以包括给定数目的分数位<br>VRNDSCALESD—圆形标量浮点值包括给定数量的比特位<br>VRNDSCALEPS—圆形压缩Float32值以包括给定数目的分数位<br>VRNDSCALESS—圆形标量浮点值包括给定数量的比特位<br>VRSQRT14PD—计算压缩Float64值的平方根的近似倒数<br>VRSQRT14SD—计算标量Float64值的平方根的近似倒数<br>VRSQRT14PS—计算压缩Float32值的平方根的近似倒数<br>VRSQRT14SS—计算标量Float32值的平方根的近似倒数<br>VRSQRT28PD—近似于包装的双精度浮点值的倒数平方根，小于2 ^ -28相对误差<br>VRSQRT28SD—近似于标量双精度浮点值的倒数平方根，小于2 ^ -28相对误差<br>VRSQRT28PS—近似于包装的单精度浮点值的倒数平方根，小于2 ^ -28相对误差<br>VRSQRT28SS—近似于标量单精度浮点值的倒数平方根，小于2 ^ -28相对误差<br>VSCALEFPD—使用Float64值缩放打包的Float64值<br>VSCALEFSD—使用Float64值缩放Scalar Float64值<br>VSCALEFPS—使用Float32值缩放打包的Float32值<br>VSCALEFSS—使用Float32值缩放标量浮点32值<br>VSCATTERDPS/VSCATTERDPD/VSCATTERQPS/VSCATTERQPD—分散包装单，包装双与签署的双剑和指数<br>VSCATTERPF0DPS/VSCATTERPF0QPS/VSCATTERPF0DPD/VSCATTERPF0QPD—稀疏预取打包SP / DP数据值与签名双字，签名的Qword指数使用T0提示与意图写<br>VSCATTERPF1DPS/VSCATTERPF1QPS/VSCATTERPF1DPD/VSCATTERPF1QPD—稀疏预取打包SP / DP数据值与签名双字，签名的Qword指数使用T1提示与意图写<br>VSHUFF32x4/VSHUFF64x2/VSHUFI32x4/VSHUFI64x2—随机播放128位粒度的打包值<br>VTESTPD/VTESTPS—压缩位测试<br>VZEROALL—零所有YMM寄存器<br>VZEROUPPER—YMM寄存器的零上限位<br>WAIT/FWAIT—等待<br>WBINVD—回写并使缓存无效<br>WRFSBASE/WRGSBASE—写FS / GS段基<br>WRMSR—写入模型专用寄存器<br>WRPKRU—将数据写入用户页密钥寄存器<br>XACQUIRE/XRELEASE — 硬件锁Elision Prefix提示<br>XABORT — 事务中止<br>XADD—交换和添加<br>XBEGIN — 事务开始<br>XCHG—与寄存器交换寄存器/存储器<br>XEND — 事务结束<br>XGETBV—获取扩展控制寄存器的值<br>XLAT/XLATB—表查找翻译<br>XOR—逻辑异或<br>XORPD—压缩双精度浮点值的按位逻辑异或<br>XORPS—压缩单精度浮点值的按位逻辑异或<br>XRSTOR—恢复处理器扩展状态<br>XRSTORS—恢复处理器扩展状态主管<br>XSAVE—保存处理器扩展状态<br>XSAVEC—使用压缩保存处理器扩展状态<br>XSAVEOPT—保存处理器扩展状态优化<br>XSAVES—保存处理器扩展状态主管<br>XSETBV—设置扩展控制寄存器<br>XTEST — 测试如果在事务执行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、基础知识&quot;&gt;&lt;a href=&quot;#一、基础知识&quot; class=&quot;headerlink&quot; title=&quot;一、基础知识&quot;&gt;&lt;/a&gt;一、基础知识&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1、指令&quot;&gt;&lt;a href=&quot;#1、指令&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="汇编" scheme="https://www.ljjyy.com/tags/assemble/"/>
    
  </entry>
  
  <entry>
    <title>FLEXLM ECC 椭圆曲线加密分析</title>
    <link href="https://www.ljjyy.com/archives/2023/06/100678.html"/>
    <id>https://www.ljjyy.com/archives/2023/06/100678.html</id>
    <published>2023-06-20T06:20:00.000Z</published>
    <updated>2023-06-20T01:01:01.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-FLEXLM简介"><a href="#1-FLEXLM简介" class="headerlink" title="1. FLEXLM简介"></a><strong>1. FLEXLM简介</strong></h1><p>FLEXlm是应用广泛的License管理工具。DS、ANSYS、MathWorks、80%以上的 EDA软件公司等等采用它管理授权，是目前最流行的加密方法，保护着世界上价值上兆亿美元的软件，不过在破解者面前，它其实非常脆弱。<br>FLEXlm对厂商来说，它的优点是证书管理功能强大， 支持平台众多。<br>对最终用户来说，它的缺点是不够友好， 比如Windows下，经常由于某些原因，flexlm服务启动错误。维基百科上的条目为：<a href="http://en.wikipedia.org/wiki/FLEXlm" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/FLEXlm</a></p><p>FLEXLM本来属于GLOBEtrotter。Macrovision曾经收购GLOBEtrotter。<br>2006年的时候，FLEXLM原来的开发组跑路，另起灶头，产品叫RLM。<br><a href="http://www.reprisesoftware.com/index.php" target="_blank" rel="noopener">http://www.reprisesoftware.com/index.php</a></p><p>2008年Macrovision把FLEXLM卖了。现在叫FlexNet Publisher。<br><a href="http://www.flexerasoftware.com/products/flexnet-publisher.htm" target="_blank" rel="noopener">http://www.flexerasoftware.com/products/flexnet-publisher.htm</a></p><h1 id="2-FLexLM-的ECC（椭圆曲线加密）来由"><a href="#2-FLexLM-的ECC（椭圆曲线加密）来由" class="headerlink" title="2. FLexLM 的ECC（椭圆曲线加密）来由"></a><strong>2. FLexLM 的ECC（椭圆曲线加密）来由</strong></h1><p>早期的flexlm采用的常规加密，不安全，能被做出lic。这样的教程是很多的。<br>flexlm的安全性完全得不到保障，所以，自 v8(大约2001-2002)版本引入了公钥加密算法：椭圆曲线加密。<br>从此，它一直是flexlm的金钟罩。包括v9(2003-) , v10(2004-) , v11(2007-), 到最新的版本 v11.17 (2021) 。</p><p>FlexLm的ECC没有它自己的东西，完全采购自椭圆曲线加密系统的专利拥有者：Certicom公司。<br>换而言之， flexlm ecc是购买自certicom的一套代码，相当于在腐朽的木门上套一层黄金甲。<br>OK， 从此它是不破金身了。</p><h1 id="3-Certicom公司简介"><a href="#3-Certicom公司简介" class="headerlink" title="3. Certicom公司简介"></a><strong>3. Certicom公司简介</strong></h1><p>RSA和ECC是两大主流的公钥密码算法体系。相比RSA，ECC晚出生10多年，推广不如前者。<br>Certicom公司是ECC的主要商业支持者，它拥有多项专利。其地位可与RSA公司匹敌（RSA于2006年被EMC公司收购）。<br>有一则消息说，2003年美国国家安全局（NSA）以2500万美元支付了Certicom的26项技术许可。<br>另外有一则消息， Certicom 2007年起诉索尼公司，要求其支付PS3，DVD播放器等涉及加密技术侵权的专利费用。</p><p>Certicom的创办人Scott Vanstone，是加拿大滑铁卢大学的数学系教授和皇家科学院院士。<br>以前是研究椭圆曲线加密的，后来创办Certicom公司，努力把ECC从数学界推广到工业界。<br>Scott写过一本《椭圆曲线密码学导论》， 颇有名气。</p><h1 id="4-FLEXLM-如何使用ECC"><a href="#4-FLEXLM-如何使用ECC" class="headerlink" title="4. FLEXLM 如何使用ECC"></a><strong>4. FLEXLM 如何使用ECC</strong></h1><p>说来话长。一句话说：FLexLM 在license验证上，主要用的ECDSA（椭圆曲线数字签名算法）。</p><p>具体的讲： flexlm针对ECDSA有一些自己定义的东西以抵抗破解。 后面会说到，这些自定义的<br>东西也不是那么牢固。</p><h1 id="5-FLEXLM-ECC的通用破解方法"><a href="#5-FLEXLM-ECC的通用破解方法" class="headerlink" title="5. FLEXLM ECC的通用破解方法"></a><strong>5. FLEXLM ECC的通用破解方法</strong></h1><p>FLEXLM ECC的通用破解方法就是：<br>完全按照它的ECDSA算法签名， 只替换公钥和checksum， 写一个keygen生成license。<br>从逻辑上讲，生成license的方法和原厂的完全一致。</p><p>具体该怎么做呢：</p><p>首先， 实现标准的ECDSA签名算法。椭圆曲线的具体算法，可以用现成的miracl，cryptopp等加密库代码。 只需要搞清楚ECDSA的使用方法就可以。</p><p>从早期版本 v9.2 (2004) , 到最新版本v11.17 (2021) 。它的ecc公钥都是有checksum的。<br>替换公钥，首先得搞清楚checksum。它只有一个函数，不算复杂，后面会给出代码。<br>计算这个checksum， 对所有版本都是适合的。</p><p>其次， 公钥在文件里是加密打散的，有大量垃圾代码。这些干扰使得flexlm可读性很差。获取公钥需要调试。</p><p>那么，有没有更方便的方法获取公钥呢？</p><p>ECC验证代码在它执行过程中有其自身的特点。正如游戏辅助工具可以搜索血量，我们也可以写一个辅助工具从内存中获取公钥。</p><p>在很多次研究之后，找出一个通用的方法。不需要再拘泥于具体的代码，可以dump出公钥 ，然后用ecctool生成自己的公私钥对，替换公钥，然后可以就写keygen。</p><p>由此写了一个工具，对windows平台可直接操作。 对其它平台，把内存镜像出来操作即可。<br>对于非Windows平台，可以在VMware里面操作，制作一份snapshot，得到内存镜像。<br>算法上经过多次优化和排除错误数据，从2GB的内存镜像里找出正确的公钥，平均只需要6秒钟。</p><p>所以，对于纯粹采用flexlm ecc sign的license，是可以做出通用的patch_keygen的，<br>不需要去考虑它有没有反调试，也不用管具体的细节。</p><p>只要dump 公钥， 替换公钥和checksum， 写patch_keygen就可以了。</p><h1 id="6-研究flexlm主要资料"><a href="#6-研究flexlm主要资料" class="headerlink" title="6. 研究flexlm主要资料"></a><strong>6. 研究flexlm主要资料</strong></h1><p>flexlm相对来说资源丰富，基本上每个版本的sdk都有泄漏。<br>如果想深入研究flexlm的加密算法，flexlm sdk是必需的。</p><p>写kg是必须要读sdk的，值得注意的是v9.2 sdk sourcecode泄漏。这个网上可搜索到。<br>sdk有一部分是c代码，里面最有用的是l_prikey.c， 这里有ECDSA验证的函数。<br>这个文件的尾部有300行comments，其中有一封email很值得一读。</p><p>ECC核心库没有源文件，只有lib文件。<br>在certicom目录下的lib里面，主要为libsb.lib等（Certicom 的加密库：Security Builder）。<br>lib是混淆过了的，但是不影响ida反编译，只是不便于做sig文件。<br>主要依靠人脑识别函数，需要经验和时间。</p><h1 id="7-flexlm的key加密强度种类"><a href="#7-flexlm的key加密强度种类" class="headerlink" title="7. flexlm的key加密强度种类"></a><strong>7. flexlm的key加密强度种类</strong></h1><p>以flexlm sdk v9为例，用宏定义表示LM_SIGN_LEVEL。<br>#define LM_SIGN2 2 /<em> SIGN2= </em>/<br>#define LM_SIGN 1 /<em> SIGN= the default </em>/<br>#define LM_NO_SIGN 0 /<em> license key </em>/</p><p>v9以后，默认就采用ECC PUBKEY加密。SIGN支持ECC，所以大部分情况下用SIGN比较多，有些用SIGN2。<br>LM_NO_SIGN 是传统的license key， 强度最弱，不建议使用。<br>ECC PUBKEY 只有3种类别， 113， 163， 239 bits。<br>对应的sign长度（字符数） , 字节为( bits + 7 )/8 字节数 , 打印出来，<br>用hex digits表示，ECC的SIGN长度分别是一对 30，42，60 [0-9,A-F]。</p><p>采用ECC的，pubkey_strength 必须定义为下面的一个类别，否则l_pubkey_verify会出错：<br>LM_STRENGTH_113BIT，LM_STRENGTH_163BIT，LM_STRENGTH_239BIT。</p><p>#define LM_STRENGTH_LICENSE_KEY 0<br>#define LM_STRENGTH_DEFAULT 1<br>#define LM_STRENGTH_113BIT 2<br>#define LM_STRENGTH_163BIT 3<br>#define LM_STRENGTH_239BIT 4<br>#define LM_STRENGTH_PUBKEY LM_STRENGTH_113BIT<br>#define LM_STRENGTH_VERYHIGH LM_STRENGTH_239BIT</p><p>在l_pubkey_verify 有这么一段初始化代码， 判断pubkey_strength。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(pubkey_strength)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> LM_STRENGTH_LICENSE_KEY:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> LM_STRENGTH_113BIT: ellipticCurve = &amp;LM_PUBKEY_CURVE113BIT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LM_STRENGTH_163BIT: ellipticCurve = &amp;LM_PUBKEY_CURVE163BIT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LM_STRENGTH_239BIT: ellipticCurve = &amp;LM_PUBKEY_CURVE239BIT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">        <span class="string">"LM_STRENGTH in lm_code.h has invalid value %d\n"</span>,</span><br><span class="line">                        pubkey_strength);</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">            <span class="string">"Use only LM_STRENGTH_[113|163|239]BIT, LM_STRENGTH_DEFAULT, OR LM_STRENGTH_LICENSE_KEY, exiting\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，演示 113， 163， 239 bits的ECDSA签名一段最简单的文本，<br>msg: “123”<br>sha hash：40BD001563085FC35165329EA1FF5C5ECBDBBEEF</p><p>#define LM_SEED1 0x47d381a0<br>#define LM_SEED2 0x4fadf97c<br>#define LM_SEED3 0xc4ae244c<br>l_genkeys: seed[3]=A081D3477CF9AD4F4C24AEC4</p><p>LM_PUBKEY_CURVE113BIT<br>prvlen=15, prv=00CFDF0247BF6EC0C8D1AA16DD505F<br>publen=16, pub=0301523DD4646BB65FE4238B8AB44D01<br>>&gt; l_prikey_sign_dbg start &gt;&gt;<br>signing “123”<br>hash=40BD001563085FC35165329EA1FF5C5ECBDBBEEF<br>>&gt; l_prikey_sign_dbg done &gt;&gt;<br>siglen=30<br>sig.r=0048D5DD2A57B1A1B357E98C193E63<br>sig.s=000A6FFDF76899F05ABFD2EDD9E065</p><p>LM_PUBKEY_CURVE163BIT<br>prvlen=21, prv=03DC603CB1683D43FF5631BBEEC5396D7BD4067300<br>publen=22, pub=0300368FE93082E1ACDD35222AD76782DBA8237B66EC<br>>&gt; l_prikey_sign_dbg start &gt;&gt;<br>signing “123”<br>hash=40BD001563085FC35165329EA1FF5C5ECBDBBEEF<br>>&gt; l_prikey_sign_dbg done &gt;&gt;<br>siglen=42<br>sig.r=039283F2FEA664BE7628F89BBA9D014E89E3868D2C<br>sig.s=017DA34A68C3FC64CB6EBE2B13676B04BE97EB5C20</p><p>LM_PUBKEY_CURVE239BIT<br>prvlen=30, prv=13C0E251A5130072A8D2D953EB2C94FAD487C0141B3197863BCC115D7B7E<br>publen=31, pub=035875A53B693A2861837E08FC6A7C58529DF52B565111C3DF55F18E34C9FA<br>>&gt; l_prikey_sign_dbg start &gt;&gt;<br>signing “123”<br>hash=40BD001563085FC35165329EA1FF5C5ECBDBBEEF<br>>&gt; l_prikey_sign_dbg done &gt;&gt;<br>inputlen=3, input=123<br>siglen=60<br>sig.r=1589FCFE91F988D28F7072DBF129424F0D71FA5E7AAC39258F3C408A656A<br>sig.s=0B50642E8ED77FC6A1E6F805CFA0299F44BC7B8035FE17142812B79EA576</p><p>sig.r sig.s组成一个完整的SIGN， 输出lic的时候，为了可读性， 一般切分为16 bit的分组（4个hex char）。<br>比如：<br>sig.r=038B9BE995B887B2665C02940C00155DD557C278AC95EADC1BD668DF185B<br>sig.s=1C50F25E81044E4DD9AD072699AAB4A63F4C99249AC8C091F476A6C73682<br>转化为：<br>SIGN=“ 038B9BE995B887B2665C02940C00155DD557C278AC95EADC1BD668DF185B<br>1C50F25E81044E4DD9AD072699AAB4A63F4C99249AC8C091F476A6C73682”<br>或者：<br>SIGN=”038B 9BE9 95B8 87B2 665C 0294 0C00 155D D557 C278 AC95 EADC 1BD6 68DF 185B 1C50 F25E 8104 4E4D D9AD 0726 99AA B4A6 3F4C 9924 9AC8 C091 F476 A6C7 3682”</p><p>对flexlm的程序来说，是没有差别的。 都能处理。</p><h1 id="8-flexlm所用到的椭圆曲线"><a href="#8-flexlm所用到的椭圆曲线" class="headerlink" title="8. flexlm所用到的椭圆曲线"></a><strong>8. flexlm所用到的椭圆曲线</strong></h1><p>flexlm用到三条椭圆曲线，都是有来历的， 名字分别为sect113r1， sect163k1， sect239k1。<br>具体参数可以参看：<a href="http://en.wikipedia.org/wiki/SECG" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SECG</a><br>SEC 2: Recommended Elliptic Curve Domain Parameters (Version 2.0)</p><p>在flexlm lib里面， 它是写死的静态变量。位置在<br>certicom\libcrvs.lib</p><p>保存为3个结构体：<br>struct ellipticCurveParameters sect113r1<br>struct ellipticCurveParameters ec163a02<br>struct ellipticCurveParameters ec239a03</p><p>头文件在<br>erticom\i86_n3\include\curves.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*=== Curves Definitions ==================</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sect113r1 (K-163 NIST), ec163a02 (SEC2, sect163k1) , ec239a03 (sec2, sect239k1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LM_PUBKEY_CURVE113BIT   sect113r1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LM_PUBKEY_CURVE163BIT   ec163a02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LM_PUBKEY_CURVE239BIT   ec239a03</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXIM_OID_CHARS   31</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ellipticCurveParameters</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> oid[ MAXIM_OID_CHARS + <span class="number">1</span> ];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> major[ <span class="number">1</span> ];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> minor[ <span class="number">1</span> ];</span><br><span class="line">    &#125; version;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> checksum[ <span class="number">4</span> ];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> fieldSize[ <span class="number">2</span> ]; <span class="comment">/* bits */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> fieldSizeOctets[ <span class="number">1</span> ]; <span class="comment">/* octets */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> basisType[ <span class="number">1</span> ];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> modulus[ <span class="number">32</span> ];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ident1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ident2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> a[ <span class="number">32</span> ];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> b[ <span class="number">32</span> ];</span><br><span class="line">    &#125; curveParameter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> value[ <span class="number">64</span> ];</span><br><span class="line">    &#125; generatingPoint;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> size[ <span class="number">2</span> ]; <span class="comment">/* bits */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> value[ <span class="number">32</span> ];</span><br><span class="line">    &#125; pointOrder;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> size[ <span class="number">2</span> ]; <span class="comment">/* bits */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> value[ <span class="number">32</span> ];</span><br><span class="line">    &#125; cofactor;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> size[ <span class="number">2</span> ]; <span class="comment">/* bits */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> value[ <span class="number">32</span> ];</span><br><span class="line">    &#125; curveOrder;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(2)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> A[ <span class="number">32</span> ];</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> B[ <span class="number">32</span> ];</span><br><span class="line">    &#125; reserved;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure><h1 id="9-flexlm-ecc-ellipticCurveParameters-结构体中-checksum的计算方法"><a href="#9-flexlm-ecc-ellipticCurveParameters-结构体中-checksum的计算方法" class="headerlink" title="9. flexlm ecc ellipticCurveParameters 结构体中 checksum的计算方法"></a><strong>9. flexlm ecc ellipticCurveParameters 结构体中 checksum的计算方法</strong></h1><p>ellipticCurveParameters 带有4字节checksum，<br>每次初始化ECC计算时，都会校验checksum。一方面为了避错， 另一方面为了反对篡改。<br>修改其中的公钥，必须重新计算checksum。</p><p>从libsb.lib里面分析反汇编代码， 逆向为c代码，经测试无误的代码：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">int checksum(unsigned int len, void *src , int *val)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int i<span class="comment">;</span></span><br><span class="line">  unsigned int h<span class="comment">;</span></span><br><span class="line">  unsigned int c<span class="comment">;</span></span><br><span class="line">  unsigned char *p = (unsigned char *)src<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">  if((p == <span class="number">0</span>) <span class="title">||</span> (val == <span class="number">0</span>) <span class="title">||</span> (len == <span class="number">0</span>))</span><br><span class="line">      return <span class="number">1</span><span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">  i = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">  c = *val<span class="comment">;</span></span><br><span class="line">  while(i &lt; len)</span><br><span class="line">  &#123;</span><br><span class="line">      c =  p[i] + c * <span class="number">16</span><span class="comment">;</span></span><br><span class="line">      h = c &amp; <span class="number">0xF0000000</span><span class="comment">;</span></span><br><span class="line">      if ( h != <span class="number">0</span>)</span><br><span class="line">          c ^= (h &gt;&gt; <span class="number">24</span>)<span class="comment">;</span></span><br><span class="line">      c &amp;= ~h<span class="comment">;</span></span><br><span class="line">      i++<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  *val = c<span class="comment">;</span></span><br><span class="line">  return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unsigned int getbits(unsigned char *p, unsigned int len)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int val<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">    val = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">    while(len --) &#123;</span><br><span class="line">        val &lt;&lt;= <span class="number">8</span><span class="comment">;</span></span><br><span class="line">        val += *p++<span class="comment">;   </span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    return val <span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unsigned int getbytes(unsigned char *p, unsigned int len)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int <span class="keyword">bits </span>= getbits(p , len)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">    return  ((<span class="keyword">bits </span>+ <span class="number">7</span>) &gt;&gt; <span class="number">3</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">int do_ecp_checksum(struct ellipticCurveParameters *e, int *sum1, int *sum2)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned int val = getbytes(e-&gt;fieldSize, <span class="number">2</span>)<span class="comment">;</span></span><br><span class="line">    unsigned int <span class="keyword">bytes </span>= val<span class="comment">;</span></span><br><span class="line">    unsigned char *p = (unsigned char *)e<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#if 1</span></span><br><span class="line">    checksum(sizeof(e-&gt;oid), &amp;e-&gt;oid,  sum2)<span class="comment">;</span></span><br><span class="line">    checksum(sizeof(e-&gt;version.major), &amp;e-&gt;version.major,  sum2)<span class="comment">;</span></span><br><span class="line">    checksum(sizeof(e-&gt;version.minor), &amp;e-&gt;version.minor,  sum2)<span class="comment">;</span></span><br><span class="line">    checksum(sizeof(e-&gt;fieldSize), &amp;e-&gt;fieldSize,  sum2)<span class="comment">;</span></span><br><span class="line">    checksum(sizeof(e-&gt;fieldSizeOctets), &amp;e-&gt;fieldSizeOctets,  sum2)<span class="comment">;</span></span><br><span class="line">    checksum(sizeof(e-&gt;<span class="keyword">basisType), </span>&amp;e-&gt;<span class="keyword">basisType, </span> sum2)<span class="comment">;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"> </span><br><span class="line">    checksum(<span class="number">32</span>u, p, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(<span class="number">1</span>u, p + <span class="number">32</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(<span class="number">1</span>u, p + <span class="number">33</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(<span class="number">2</span>u, p + <span class="number">38</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(<span class="number">1</span>u, p + <span class="number">40</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(<span class="number">1</span>u, p + <span class="number">41</span>, sum1)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#if 1  </span></span><br><span class="line">    checksum(<span class="keyword">bytes, </span> &amp;e-&gt;modulus,  sum2)<span class="comment">;</span></span><br><span class="line">    checksum(<span class="keyword">bytes, </span> &amp;e-&gt;curveParameter.a,  sum2)<span class="comment">;  </span></span><br><span class="line">    checksum(<span class="keyword">bytes, </span> &amp;e-&gt;curveParameter.<span class="keyword">b, </span> sum2)<span class="comment">;  </span></span><br><span class="line">    checksum(<span class="number">2</span> * <span class="keyword">bytes, </span> &amp;e-&gt;generatingPoint.value,  sum2)<span class="comment">;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"> </span><br><span class="line">    checksum(val, p + <span class="number">42</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(val, p + <span class="number">84</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(val, p + <span class="number">116</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(<span class="number">2</span> * val, p + <span class="number">148</span>, sum1)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#if 1</span></span><br><span class="line">    checksum(<span class="number">2</span>,  &amp;e-&gt;pointOrder.size,  sum2)<span class="comment">;   </span></span><br><span class="line">    checksum(getbytes(e-&gt;pointOrder.size, <span class="number">2</span>),  &amp;e-&gt;pointOrder.value,  sum2)<span class="comment">;</span></span><br><span class="line">     </span><br><span class="line">    checksum(<span class="number">2</span>,  &amp;e-&gt;cofactor.size,  sum2)<span class="comment">; </span></span><br><span class="line">    checksum(getbytes(e-&gt;cofactor.size, <span class="number">2</span>),  &amp;e-&gt;cofactor.value,  sum2)<span class="comment">; </span></span><br><span class="line"> </span><br><span class="line">    checksum(<span class="number">2</span>,  &amp;e-&gt;curveOrder.size,  sum2)<span class="comment">;   </span></span><br><span class="line">    checksum(getbytes(e-&gt;curveOrder.size, <span class="number">2</span>),  &amp;e-&gt;curveOrder.value,  sum2)<span class="comment">; </span></span><br><span class="line">     </span><br><span class="line">    checksum(<span class="keyword">bytes, </span> &amp;e-&gt;reserved.A,  sum2)<span class="comment">;</span></span><br><span class="line">    checksum(<span class="keyword">bytes, </span> &amp;e-&gt;reserved.<span class="keyword">B, </span> sum2)<span class="comment">;</span></span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"> </span><br><span class="line">    checksum(<span class="number">2</span>u, p + <span class="number">212</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(getbytes(e-&gt;pointOrder.size, <span class="number">2</span>), p + <span class="number">214</span>, sum1)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">    checksum(<span class="number">2</span>u, p + <span class="number">246</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(getbytes(e-&gt;cofactor.size, <span class="number">2</span>), p + <span class="number">248</span>, sum1)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">    checksum(<span class="number">2</span>u, p + <span class="number">280</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(getbytes(e-&gt;curveOrder.size, <span class="number">2</span>), p + <span class="number">282</span>, sum1)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">    checksum(val, p + <span class="number">314</span>, sum1)<span class="comment">;</span></span><br><span class="line">    checksum(val, p + <span class="number">346</span>, sum1)<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">    return val<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-flexlm-ecc三条椭圆曲线的参数"><a href="#10-flexlm-ecc三条椭圆曲线的参数" class="headerlink" title="10. flexlm ecc三条椭圆曲线的参数"></a><strong>10. flexlm ecc三条椭圆曲线的参数</strong></h1><p>flexlm 采用GF(2^m)椭圆曲线。这三条椭圆曲线， 在openssl也有描述的。<br>在certicom\libcrvs.lib是纯数据保存。</p><p>openssl描述：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">EcRecommendedParameters<span class="symbol">&lt;EC2N&gt;</span>(ASN1::sect113r1(),</span><br><span class="line"><span class="number">113</span>, <span class="number">9</span>, <span class="number">0</span>,</span><br><span class="line">A/a2 = <span class="string">"003088250CA6E7C7FE649CE85820F7"</span>,</span><br><span class="line">B/a6 = <span class="string">"00E8BEE4D3E2260744188BE0E9C723"</span>,</span><br><span class="line"><span class="string">"04009D73616F35F4AB1407D73562C10F00A52830277958EE84D1315ED31886"</span>,</span><br><span class="line"><span class="string">"0100000000000000D9CCEC8A39E56F"</span>,</span><br><span class="line"><span class="number">2</span>),</span><br><span class="line"> </span><br><span class="line">EcRecommendedParameters<span class="symbol">&lt;EC2N&gt;</span>(ASN1::sect239k1(),</span><br><span class="line"><span class="number">239</span>, <span class="number">158</span>, <span class="number">0</span>,</span><br><span class="line"><span class="string">"000000000000000000000000000000000000000000000000000000000000"</span>,</span><br><span class="line"><span class="string">"000000000000000000000000000000000000000000000000000000000001"</span>,</span><br><span class="line"><span class="comment">"04</span></span><br><span class="line"><span class="number">29</span>A0B6A887A983E9730988A68727A8B2D126C44CC2CC7B2A6555193035DC7</span><br><span class="line"><span class="number">6310804</span>F12E549BDB011C103089E73510ACB275FC312A5DC6B76553F0CA<span class="comment">",</span></span><br><span class="line"><span class="string">"2000000000000000000000000000005A79FEC67CB6E91F1C1DA800E478A5"</span>,</span><br><span class="line"><span class="number">4</span>),</span><br><span class="line"> </span><br><span class="line">EcRecommendedParameters<span class="symbol">&lt;EC2N&gt;</span>(ASN1::sect163k1(),</span><br><span class="line"><span class="number">163</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>,</span><br><span class="line"><span class="string">"000000000000000000000000000000000000000001"</span>,</span><br><span class="line"><span class="string">"000000000000000000000000000000000000000001"</span>,</span><br><span class="line"><span class="string">"0402FE13C0537BBC11ACAA07D793DE4E6D5E5C94EEE80289070FB05D38FF58321F2E800536D538CCDAA3D9"</span>,</span><br><span class="line"><span class="string">"04000000000000000000020108A2E0CC0D99F8A5EF"</span>,</span><br><span class="line"><span class="number">2</span>),</span><br></pre></td></tr></table></figure><p>flexlm sdk<br>\certicom\libcrvs.lib 内存dump, checksum只需要签名378 bytes的结构体。</p><p>为了调试和区分的方便， 在尾部增加了标志：<br>‘E’ ‘C’ ‘1’ ‘1’ ， ‘E’ ‘C’ ‘1’ ‘6’ ， ‘E’ ‘C’ ‘2 ‘3’ ， 分别表示ecc 113, 163, 239 bits。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">unsigned char ec113[<span class="number">384</span>] = &#123;</span><br><span class="line">    <span class="number">0x06</span>, <span class="number">0x05</span>, <span class="number">0x2B</span>, <span class="number">0x81</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x43</span>, <span class="number">0x8E</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x71</span>, <span class="number">0x0F</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0xCB</span>, <span class="number">0x46</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0xF0</span>, <span class="number">0xCA</span>, <span class="number">0x46</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x30</span>, <span class="number">0x88</span>, <span class="number">0x25</span>, <span class="number">0x0C</span>, <span class="number">0xA6</span>, <span class="number">0xE7</span>, <span class="number">0xC7</span>, <span class="number">0xFE</span>, <span class="number">0x64</span>, <span class="number">0x9C</span>, <span class="number">0xE8</span>,</span><br><span class="line">    <span class="number">0x58</span>, <span class="number">0x20</span>, <span class="number">0xF7</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE8</span>, <span class="number">0xBE</span>, <span class="number">0xE4</span>, <span class="number">0xD3</span>, <span class="number">0xE2</span>, <span class="number">0x26</span>, <span class="number">0x07</span>, <span class="number">0x44</span>, <span class="number">0x18</span>, <span class="number">0x8B</span>, <span class="number">0xE0</span>,</span><br><span class="line">    <span class="number">0xE9</span>, <span class="number">0xC7</span>, <span class="number">0x23</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x9D</span>, <span class="number">0x73</span>, <span class="number">0x61</span>, <span class="number">0x6F</span>, <span class="number">0x35</span>, <span class="number">0xF4</span>, <span class="number">0xAB</span>, <span class="number">0x14</span>, <span class="number">0x07</span>, <span class="number">0xD7</span>, <span class="number">0x35</span>,</span><br><span class="line">    <span class="number">0x62</span>, <span class="number">0xC1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0xA5</span>, <span class="number">0x28</span>, <span class="number">0x30</span>, <span class="number">0x27</span>, <span class="number">0x79</span>, <span class="number">0x58</span>, <span class="number">0xEE</span>, <span class="number">0x84</span>, <span class="number">0xD1</span>, <span class="number">0x31</span>, <span class="number">0x5E</span>, <span class="number">0xD3</span>,</span><br><span class="line">    <span class="number">0x18</span>, <span class="number">0x86</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x71</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xD9</span>, <span class="number">0xCC</span>,</span><br><span class="line">    <span class="number">0xEC</span>, <span class="number">0x8A</span>, <span class="number">0x39</span>, <span class="number">0xE5</span>, <span class="number">0x6F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x72</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0xB3</span>, <span class="number">0x99</span>, <span class="number">0xD9</span>, <span class="number">0x14</span>, <span class="number">0x73</span>, <span class="number">0xCA</span>, <span class="number">0xDE</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, 'E', 'C',  '<span class="number">1</span>',  '<span class="number">1</span>'</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">unsigned char ec163[<span class="number">384</span>] = &#123;</span><br><span class="line">    <span class="number">0x06</span>, <span class="number">0x05</span>, <span class="number">0x2B</span>, <span class="number">0x81</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x07</span>, <span class="number">0x48</span>, <span class="number">0x77</span>, <span class="number">0x70</span>, <span class="number">0x00</span>, <span class="number">0xA3</span>, <span class="number">0x15</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xC9</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xB0</span>, <span class="number">0xD4</span>, <span class="number">0x4D</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xD3</span>, <span class="number">0x4D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0xFE</span>, <span class="number">0x13</span>, <span class="number">0xC0</span>, <span class="number">0x53</span>, <span class="number">0x7B</span>, <span class="number">0xBC</span>, <span class="number">0x11</span>, <span class="number">0xAC</span>, <span class="number">0xAA</span>, <span class="number">0x07</span>, <span class="number">0xD7</span>,</span><br><span class="line">    <span class="number">0x93</span>, <span class="number">0xDE</span>, <span class="number">0x4E</span>, <span class="number">0x6D</span>, <span class="number">0x5E</span>, <span class="number">0x5C</span>, <span class="number">0x94</span>, <span class="number">0xEE</span>, <span class="number">0xE8</span>, <span class="number">0x02</span>, <span class="number">0x89</span>, <span class="number">0x07</span>, <span class="number">0x0F</span>, <span class="number">0xB0</span>, <span class="number">0x5D</span>, <span class="number">0x38</span>,</span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0x58</span>, <span class="number">0x32</span>, <span class="number">0x1F</span>, <span class="number">0x2E</span>, <span class="number">0x80</span>, <span class="number">0x05</span>, <span class="number">0x36</span>, <span class="number">0xD5</span>, <span class="number">0x38</span>, <span class="number">0xCC</span>, <span class="number">0xDA</span>, <span class="number">0xA3</span>, <span class="number">0xD9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xA3</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x02</span>, <span class="number">0x01</span>, <span class="number">0x08</span>, <span class="number">0xA2</span>, <span class="number">0xE0</span>, <span class="number">0xCC</span>, <span class="number">0x0D</span>, <span class="number">0x99</span>, <span class="number">0xF8</span>, <span class="number">0xA5</span>, <span class="number">0xEF</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xA4</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, <span class="number">0x02</span>, <span class="number">0x11</span>, <span class="number">0x45</span>, <span class="number">0xC1</span>, <span class="number">0x98</span>, <span class="number">0x1B</span>, <span class="number">0x33</span>, <span class="number">0xF1</span>, <span class="number">0x4B</span>, <span class="number">0xDE</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,'E', 'C',  '<span class="number">1</span>',  '<span class="number">6</span>'</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">unsigned char ec239[<span class="number">384</span>] = &#123;</span><br><span class="line">    <span class="number">0x06</span>, <span class="number">0x05</span>, <span class="number">0x2B</span>, <span class="number">0x81</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x0A</span>, <span class="number">0xD7</span>, <span class="number">0xBD</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xEF</span>, <span class="number">0x1E</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xE0</span>, <span class="number">0xCA</span>, <span class="number">0x46</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x30</span>, <span class="number">0xC9</span>, <span class="number">0x46</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x29</span>, <span class="number">0xA0</span>, <span class="number">0xB6</span>, <span class="number">0xA8</span>, <span class="number">0x87</span>, <span class="number">0xA9</span>, <span class="number">0x83</span>, <span class="number">0xE9</span>, <span class="number">0x73</span>, <span class="number">0x09</span>, <span class="number">0x88</span>, <span class="number">0xA6</span>,</span><br><span class="line">    <span class="number">0x87</span>, <span class="number">0x27</span>, <span class="number">0xA8</span>, <span class="number">0xB2</span>, <span class="number">0xD1</span>, <span class="number">0x26</span>, <span class="number">0xC4</span>, <span class="number">0x4C</span>, <span class="number">0xC2</span>, <span class="number">0xCC</span>, <span class="number">0x7B</span>, <span class="number">0x2A</span>, <span class="number">0x65</span>, <span class="number">0x55</span>, <span class="number">0x19</span>, <span class="number">0x30</span>,</span><br><span class="line">    <span class="number">0x35</span>, <span class="number">0xDC</span>, <span class="number">0x76</span>, <span class="number">0x31</span>, <span class="number">0x08</span>, <span class="number">0x04</span>, <span class="number">0xF1</span>, <span class="number">0x2E</span>, <span class="number">0x54</span>, <span class="number">0x9B</span>, <span class="number">0xDB</span>, <span class="number">0x01</span>, <span class="number">0x1C</span>, <span class="number">0x10</span>, <span class="number">0x30</span>, <span class="number">0x89</span>,</span><br><span class="line">    <span class="number">0xE7</span>, <span class="number">0x35</span>, <span class="number">0x10</span>, <span class="number">0xAC</span>, <span class="number">0xB2</span>, <span class="number">0x75</span>, <span class="number">0xFC</span>, <span class="number">0x31</span>, <span class="number">0x2A</span>, <span class="number">0x5D</span>, <span class="number">0xC6</span>, <span class="number">0xB7</span>, <span class="number">0x65</span>, <span class="number">0x53</span>, <span class="number">0xF0</span>, <span class="number">0xCA</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xEE</span>, <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5A</span>, <span class="number">0x79</span>, <span class="number">0xFE</span>, <span class="number">0xC6</span>, <span class="number">0x7C</span>, <span class="number">0xB6</span>, <span class="number">0xE9</span>, <span class="number">0x1F</span>, <span class="number">0x1C</span>, <span class="number">0x1D</span>, <span class="number">0xA8</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0xE4</span>, <span class="number">0x78</span>, <span class="number">0xA5</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x03</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF0</span>, <span class="number">0x80</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, <span class="number">0x69</span>, <span class="number">0xE7</span>, <span class="number">0xFB</span>, <span class="number">0x19</span>, <span class="number">0xF2</span>, <span class="number">0xDB</span>, <span class="number">0xA4</span>,</span><br><span class="line">    <span class="number">0x7C</span>, <span class="number">0x70</span>, <span class="number">0x76</span>, <span class="number">0xA0</span>, <span class="number">0x03</span>, <span class="number">0x91</span>, <span class="number">0xE2</span>, <span class="number">0x94</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, 'E', 'C',  '<span class="number">2</span>',  '<span class="number">3</span>'</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="11-ECDSA的一些参考读物"><a href="#11-ECDSA的一些参考读物" class="headerlink" title="11. ECDSA的一些参考读物"></a><strong>11. ECDSA的一些参考读物</strong></h1><p>讲述ECDSA的一般原理， 与flexlm没有任何关系。但是flexlm ecc算法上属于ECDSA。理解了ECDSA就理解了flexlm ecc的基本原理。</p><p>前面说到，flexlm ecc的签名算法是ECDSA(The Elliptic Curve Digital Signature Algorithm). ECDSA 已经成为世界标准。ECDSA was accepted in 1999 as an ANSI standard, and was accepted in 2000 as IEEE and NIST standards. It was also accepted in 1998 as an ISO standard.</p><p>ECDSA是一个比较复杂的数字签名算法。其详细内容不是三言两语能说完的。</p><p>详细内容可以参考：<br>《SEC 1: Elliptic Curve Cryptography》，Certicom Corp.，2000<br>《IEEE P1363a 》，2001</p><p>ECDSA并不是一个从无到有的构思。它的思想来自于DSA（Digital Signature Algorithm），是把DSA推广到椭圆曲线上。<br>从这个角度讲，叫它DSAEC(Digital Signature Algorithm over Elliptic Curve )未尝不可。</p><p>DSA的主要思想来自于离散对数问题（DLP， Discrete Logarithm Problem）。 把DLP推广到椭圆曲线上，就成为ECDLP。<br>离散对数问题与因子分解（Integer Factorization Problem）问题是公钥密码学中两个典型的难题。</p><p>因子分解问题产出了RSA，Rabin等公钥加密、签名算法；离散对数问题产生了DSS/DSA，ElGamal等公钥加密、签名算法。</p><p>在椭圆曲线上，离散对数模型大放光彩，产生了ECDSA，ECNR，ECElGamal等一大批算法。</p><p>椭圆曲线比常见的数学问题要复杂，因为它需要一些初等数论的知识作为铺垫。大学低年级的普通数学基础是必须的。如果忘光了，还得重新翻翻教材。有些人可能学习几个月就能够理解椭圆曲线，那已经是相当不错的了。</p><p>在理解ECDSA之前，需要理解离散对数和椭圆曲线这两个东西。这里面内容太多了，有许多未知的东西。</p><p>11.1<br>离散对数本身的内容很多，常见的密码学教材中都有介绍。</p><p>11.2<br>椭圆曲线也是一个复杂的数学对象。它不是椭圆，它是由Weierstrass方程来描述的一类曲线，<br>具体是否牵涉到椭圆周长积分，椭圆周长积分不是初等函数，是无穷级数。</p><p>密码学里的椭圆曲线，跟几何上的椭圆和曲线完全不相同。<br>这里的椭圆曲线更特殊一些，它是一个有限域，每一个点 G（x，y）都是一个整数点。<br>一条椭圆曲线上的点数是确定的。</p><h1 id="12-一条椭圆曲线上做ECDSA的例子"><a href="#12-一条椭圆曲线上做ECDSA的例子" class="headerlink" title="12. 一条椭圆曲线上做ECDSA的例子"></a><strong>12. 一条椭圆曲线上做ECDSA的例子</strong></h1><p>12.1 描述一条Fp上的椭圆曲线的六个参量</p><p>密码学中，描述一条Fp上的椭圆曲线，常用到六个参量：<br>(p,a,b,G,n,h)。</p><p>p， a，b 用来确定一条椭圆曲线的方程，<br>G为基点，口头上也叫G点，或者 (Base point)，<br>n为点G的阶(Order)，也可以叫模或者周期，<br>h = E/n, 叫co-factor。 其中E是椭圆曲线上所有点的个数.</p><p>我们用乘法来表示椭圆曲线上点的倍加，那么，能找到一个n，<br>对于任何一个点G(x,y), n * G = 0 因此， 它具有循环的性质。<br>这个循环周期就是n。</p><p>对于密码学的应用上，为了抵御Pohlig-Hellman攻击（利用中国剩余定理），<br>采用的椭圆曲线有严格的限制。它要求E具有一个大素数因子，或者E本身就是素数。</p><p>有一个算法Schoof-Elkies-Atkin 用来计算椭圆曲线的点数E(Fp)。<br>需要用到中国剩余定理，具体的算法比较复杂。</p><p>n = E/h , h称之为co-factor.<br>常见的h=1 或者h=2.</p><p>E为什么不是一个参量？ 因为E可以由P,A,B计算出来的。计算完毕以后，E就没用了。<br>有用的是n， 而且E=h*n是一目了然的事。</p><p>附：一段题外话，关于中国剩余定理</p><p>Pohlig-Hellman算法和Schoof-Elkies-Atkin算法都要用到初等到数论里一个重要的定理，<br>也就是一次同余方程组的解法定理。称为中国剩余定理(CRT， Chinese Remainder Thereom)。<br>或称孙子定理，在数学史上，这个发现归根于中国古代的数学家们。</p><p>在这个帝国，两千年来文科生治国，数学毫无地位，剩余定理的发现很了不起。<br>类似于勾股定理一样，中国古代数学家发现此定理，但并没有严格的证明剩余定理。</p><p>剩余定理最早见于《孙子算经》，成书于约公元300年-400年，作者生平都无法考证了。<br>南宋数学家秦九韶编写《算术九章》，总结出“大衍求一术”。<br>和秦九韶同时代的意大利数学家裴波那契（1170—1250），他在《算法之书》中给出了<br>两个一次同余问题，但是没有一般的算法。相当于《孙子算经》的水准。</p><p>德国大数学家高斯（1777—1855）于公元1801年给出了剩余定理的严格证明。</p><p>中国古代的数学书里，剩余定理只有最简单的应用，相当于小学数学奥赛里面的模同余问题。</p><p>剩余定理在数论里用的比较多，初等数论教科书基本上都会提到她。<br>很多密码学库都有一个单独的crt.cpp,crt.c。</p><p>12.2 以NIST-P192为例， 讲述ECDSA</p><p>我们以NIST-P192 , GF (p-192)这条椭圆曲线来说，这是NIST推荐的一条曲线。</p><p>这是最简单的一类椭圆曲线。称之为GF(p)，P是一个素数。<br>GF(2^m)曲线更复杂，不再举例。</p><p>曲线方程：y^2 = x^3 + A*x + B (mod P)</p><p>这里：<br>A = -3<br>B = 64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1<br>P = ( 2^192 - 2^64 - 1 )<br>= FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF<br>P是一个素数。</p><p>对于NIST-P192，<br>E = FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831<br>h = 1<br>n = FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831<br>n是一个素数。</p><p>下面用公式简单描述一下ECDSA签名和验证的步骤：<br>大写字母代表椭圆曲线上的点 Point(x,y)， 小写字母代表一个数。</p><p>注意：这里的乘法是椭圆曲线上点的倍加；除法是整数的模逆运算，可用欧几里得算法。<br>mod是整数求余。</p><p>(1) 签名, Sign：<br>G为基点。h为要签名的hash。私钥为d。 公钥R = d*G（签名时只用到私钥）。<br>取随机数k , k是一个密码学意义上的随机数，范围在(1, n)。</p><p>r = k * G mod n … (1)<br>s = (h + rd)/k mod n … (2)</p><p>(2) 验证, Verify:<br>G为基点， r, s为签名， h为要验证的hash。 公钥为R。（验证时只用到公钥）<br>u = h/s<br>w = r/s<br>v = u <em> G + w </em> R mod n<br>验证(v == r)。</p><p>证明，为什么签名可以被验证？ 我们参照DSA的证明。可得:<br>v = u <em>G + w </em>R = (h/s) <em>G + (r/s) </em> ( d <em>G)<br>= (h/s + rd/s) </em>G<br>= ((h + rd)/s) *G</p><p>从（2） 得出， k<em>s = (h + rd) mod n =&gt; k = (h + rd)/s<br>从而 v = k </em>G， 所以签名和验证能一一对应上。</p><p>为什么说它安全：<br>由于 R = d<em>G是一个椭圆曲线离散对数问题，无法直接求的私钥x；<br>由于 r = k</em>G也是一个椭圆曲线离散对数问题，所以随机数k是也没有办法恢复的。<br>也就是说，在未知x或者k， 无法给出以下方程的一个解(r, s)：<br>h/s <em>G + r/s </em>R = r mod n<br>如果给出一个解，则表示， sign (r,s)可以被伪造。</p><p>这里面，对hash的强度也是有要求的。最基本的要求是sha 160 bit的hash。</p><p>严谨的证明， 见《IEEE P1363a 》等文档。</p><p>例子, NIST-P192 签名。<br>y^2 = x^3 - 3x + 64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1 mod FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF<br>n=FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831<br>G(x,y):<br>Gx=188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012<br>Gy=07192B95FFC8DA78631011ED6B24CDD573F977A11E794811</p><p>取<br>d=16fdbb3f3e4d7d253c421ae5a09f1ce500d973c04ae91564<br>那么公钥<br>R(x,y) = d * G(x,y)<br>Rx=2B443533CFBECB00ABE1F9D0F3A8FFD871EFDDAB4FF93B0C<br>Ry=6EFF3D69042B58F7C726BDB6B495AE75BD09D762259013DB</p><p>签名 “123”.<br>h = hash(sha-160)=40bd001563085fc35165329ea1ff5c5ecbdbbeef<br>取<br>k=CADDC27FEFC3040C1CCA194542218E002F58D504A639B668<br>得</p><p>Sign(用ECCTool计算):<br>sig.r=5C09A23549325C866F0C1D8D6AB81255977C90A9FD6D66C4<br>sig.s=C0DFFC8E4BA4A91EBFFBCE7FE07E202AAF567DC10D69D5E8</p><p>Verify (用ECCTool 和 BigIntCal计算):<br>u = h/s mod n = BBBBED787373E2407BA720D7851CE0895222B5B5DF81BECB<br>w = r/s mod n = 2BBC84EA2E318FC5666B50CEE41845F3EB1DF40C838FA86C<br>V(x,y) = u <em>G + w </em>R mod n =<br>V.x = 5C09A23549325C866F0C1D8D6AB81255977C90A9FD6D66C4<br>V.y = 70360EEEC1C42D5AC10226B8BE0EA507E3FF54290737B02C<br>So,<br>v = V mod n = 5C09A23549325C866F0C1D8D6AB81255977C90A9FD6D66C4</p><p>v==r 验证完毕。</p><p>打个最简单的比方，如果有一个软件，采用NIST-P192 ECDSA验证，其算法逻辑为：<br>sign = ecdsa(sha-160（name)）， 并且它的公钥，私钥如上所描述：<br>那么：<br>name:<br>123<br>sn:<br>5C09A23549325C866F0C1D8D6AB81255977C90A9FD6D66C4<br>C0DFFC8E4BA4A91EBFFBCE7FE07E202AAF567DC10D69D5E8</p><p>就是一对可用的注册码。</p><p>mybase的算法是标准ECDSA( GF (2^233)，跟这个很相似。只是曲线不同，私钥不同。<br>如果你理解了ECDSA，那么，写mybase的kg是很容易的事情了。</p><p>当然，它的私钥不是那么好计算的。 你可能需要几年的功底。</p><h1 id="13-FlexLM-ECDSA的公私钥对生成方法"><a href="#13-FlexLM-ECDSA的公私钥对生成方法" class="headerlink" title="13. FlexLM ECDSA的公私钥对生成方法"></a><strong>13. FlexLM ECDSA的公私钥对生成方法</strong></h1><p>FlexLM 生成公私钥对的方法是有固定标准的，它是一种IEEE-1363的弱化方法。<br>seed只有96 bits（3个32bit的digit）。<br>尽管如此，穷举96 bit在实际操作上不可行的，v9 - v11的版本是足够安全的。</p><p>下面对flexlm ECDSA密钥生成的分析，主要基于v9.x - v11.x 的SDK。核心代码在l_prikey.c。</p><p>(1) gen seed<br>(2) gen keys</p><p>(1)首先分析genseed：</p><p>lmrand1调用l_genseed产生三个强随机数，然后由它初始化rng，产生私钥。</p><p>对于Flexlm ECC来说，113, 163, 239只是椭圆曲线类型不一样，其他的算法完全一样。没有区别。</p><p>LM_SEED1,LM_SEED2,LM_SEED3除了出现在license gen中，不出现在任何地方。<br>从程序中无法恢复出LM_SEED1,LM_SEED2,LM_SEED3。</p><p>flexlm v8.0的版本，l_genseed()的随机性不够好，有bug，能够被恢复seed。<br>flexlm v9的版本已经修复。</p><p>它添加了一段hardware dependent的代码，给rng初始化的sha buffer添了大量数据。<br>意味着在不同的机器上，lmrand1产生的结果是不同的。</p><p>l_genseed() 函数增加了补丁， 代码如下。</p><p>找了一些资料，对比了v8.0c, v8.3b和v9.2的版本。<br>在 v8.0c时有此bug。 v8.3b时补丁已经打上了。查了histroy，是v8.1 (2002年)打的补丁。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">char</span> cmd[<span class="number">200</span>];</span><br><span class="line">      <span class="keyword">char</span> letter[<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">memset</span>(letter, <span class="number">0</span>, <span class="keyword">sizeof</span>(letter));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"."</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">memset</span>(additional_seed, <span class="number">0</span>, <span class="keyword">sizeof</span>(additional_seed));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PC</span></span><br><span class="line">        letter[<span class="number">0</span>] = (randcnt % <span class="number">25</span>) + <span class="string">'A'</span>;</span><br><span class="line">        <span class="keyword">if</span> (randcnt % <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">sprintf</span>(cmd, <span class="string">"dir \"c:\\documents and settings\\%s*.*\" /s"</span>, randcnt &gt; <span class="number">2</span> ? letter : <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">sprintf</span>(cmd, <span class="string">"dir %%SYSTEMROOT%%\\%s*.* /s /ta /od"</span>, randcnt &gt; <span class="number">2</span> ? letter : <span class="string">""</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(fp = _popen(cmd, <span class="string">"r"</span>)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">strcpy</span>(cmd, <span class="string">"sh -c \"ps auxww 2&gt;/dev/null\""</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(fp = popen(cmd, <span class="string">"r"</span>)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't open c:\\documents and settings, exiting\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (((c = fgetc(fp)) != EOF) &amp;&amp; (i &lt; MAX_SEED_LEN))</span><br><span class="line">            additional_seed[i++] = c;</span><br><span class="line">        fclose(fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PC</span></span><br><span class="line">        <span class="keyword">if</span> (!(fp = _popen(<span class="string">"dir \\"</span>, <span class="string">"r"</span>)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (!(fp = popen(<span class="string">"sh -c \"ps -ef 2&gt;/dev/null\""</span>, <span class="string">"r"</span>)))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Can't open \\, exiting\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (((c = fgetc(fp)) != EOF) &amp;&amp; (i &lt; MAX_SEED_LEN))</span><br><span class="line">            additional_seed[i++] = c;</span><br><span class="line"> </span><br><span class="line">        fclose(fp);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ret = sb_sha1Begin(global_data, &amp;hc))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error 4: "</span>);</span><br><span class="line">            <span class="keyword">goto</span> exit_seed;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        lenbuf = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"len = %d\n"</span>, lenbuf);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ret = sb_sha1Hash(global_data, i, additional_seed, &amp;hc))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error 5: "</span>);</span><br><span class="line">            <span class="keyword">goto</span> exit_seed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret = sb_sha1End(global_data, &amp;hc, &amp;md))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error 6: "</span>);</span><br><span class="line">            <span class="keyword">goto</span> exit_seed;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ret = sb_fipsRngOptionalInput(global_data, md.size, md.digest))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error 7: "</span>);</span><br><span class="line">            <span class="keyword">goto</span> exit_seed;</span><br><span class="line">        &#125;</span><br><span class="line">moreseeds:</span><br><span class="line">        ret = sb_rngFIPS186Session(</span><br><span class="line">            global_data,</span><br><span class="line">            <span class="number">3</span>*<span class="number">4</span>,</span><br><span class="line">            returned);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (ret != SB_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error 8: "</span>);</span><br><span class="line">            <span class="keyword">goto</span> exit_seed;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      Convert to ints and test for reasonableness</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        seed1 = seed2 = seed3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            seed1 |= returned[j++] &lt;&lt; (i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            seed2 |= returned[j++] &lt;&lt; (i * <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            seed3 |= returned[j++] &lt;&lt; (i * <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">        randcnt++;</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"%d\n"</span>,randcnt );</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line"> </span><br><span class="line">    &#125; <span class="keyword">while</span> ((randcnt &lt; <span class="number">5</span>) ||</span><br><span class="line">        (returned[<span class="number">0</span>] % <span class="number">40</span> )</span><br><span class="line">        || (!l_reasonable_seed(seed1) || !l_reasonable_seed(seed2) ||</span><br><span class="line">                        !l_reasonable_seed(seed3)));</span><br></pre></td></tr></table></figure><p>​    </p><p>(2) 接着分析gen keys</p><p>函数原型：<br>int l_genkeys( unsigned int lmseed1,<br>unsigned int lmseed2,<br>unsigned int lmseed3,<br>int pubkey_strength,<br>int <em>prikey_size,<br>char </em>prikey,<br>int <em>pubkey_size,<br>char </em>pubkey)</p><p>它调用另一函数实现，这里面的核心如下代码. rng是基于IEEE 1363， sha-160实现的。<br>FIPS_RNG没有分析价值。<br>到了sb_genKeyPair()以内，里面全部是certicom的算法库libsb.lib， 没有源代码。<br>sb_genKeyPair()完整的跟踪可以用上几个小时。 但是不会有什么惊喜的结论。</p><p>这意味着即使从私钥中，也无法恢复种子LM_SEED1,LM_SEED2,LM_SEED3.<br>实际上， 私钥产生以后， LM_SEED1,LM_SEED2,LM_SEED3.<br>对于开发商来说，只有存档的价值，不再有使用的价值。</p><p>有的开发商从v8等老版本升级而来，没有改变私钥，存在安全隐患。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">int genkeys(unsigned int *seed,</span><br><span class="line">    int pubkey_strength,</span><br><span class="line">    <span class="keyword">sb_PrivateKey </span>*privateKey,</span><br><span class="line">    <span class="keyword">sb_PublicKey </span>*publicKey)</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Set the initialization options.</span></span><br><span class="line"><span class="comment"> *  The selected options are:</span></span><br><span class="line"><span class="comment"> *  1) point compression is on.</span></span><br><span class="line"><span class="comment"> *  2) use new point compression.</span></span><br><span class="line"><span class="comment"> *  3) maximum length of the random number generator seed is</span></span><br><span class="line"><span class="comment"> *          SB_MAX_SEED_LEN.</span></span><br><span class="line"><span class="comment"> *  4) random number generator used is FIPS186.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">sb_Options.pointCompressionFlag </span>= <span class="keyword">SB_ON;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">sb_Options.ecesCompressionFlag </span>= <span class="keyword">SB_P1363_13FEB1998;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">sb_Options.rngInfo.seed.size </span>= <span class="keyword">SB_MAX_SEED_LEN;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">sb_Options.rngInfo.type </span>= <span class="keyword">SB_FIPS_RNG;</span></span><br><span class="line"><span class="keyword"> </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Set seed to sb_Options using the value contained in seedValue.</span></span><br><span class="line"><span class="comment"> *  Note that it is assumed that the value in seedValue is obtained</span></span><br><span class="line"><span class="comment"> *  from a random source.  In practice, a real random value from</span></span><br><span class="line"><span class="comment"> *  a secure random source must be set here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    memset(seedValue, <span class="number">0</span>, sizeof(seedValue))<span class="comment">;</span></span><br><span class="line"><span class="comment">#if 0 /* P5308 */</span></span><br><span class="line">    for (i = <span class="number">0</span><span class="comment">;i &lt; 4; i++)</span></span><br><span class="line">        seedValue[i] = (seed3 &gt;&gt; (<span class="number">1</span> &lt;&lt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>)<span class="comment">;</span></span><br><span class="line">    for (i = <span class="number">0</span><span class="comment">;i &lt; 4; i++)</span></span><br><span class="line">        seedValue[i + <span class="number">4</span>] = (seed4 &gt;&gt; (<span class="number">1</span> &lt;&lt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>)<span class="comment">;</span></span><br><span class="line"><span class="comment">#endif /* P5308 */</span></span><br><span class="line">    for (i = <span class="number">0</span><span class="comment">;i &lt; 4; i++)</span></span><br><span class="line">        seedValue[i] = ((seed[<span class="number">0</span>] &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>)<span class="comment">;</span></span><br><span class="line">    for (i = <span class="number">0</span><span class="comment">;i &lt; 4; i++)</span></span><br><span class="line">        seedValue[i + <span class="number">4</span>] = ((seed[<span class="number">1</span>] &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>)<span class="comment">;</span></span><br><span class="line">    if (seed[<span class="number">2</span>]) <span class="comment">/* added 3rd int in v8.1 */</span></span><br><span class="line">    &#123;</span><br><span class="line">        for (i = <span class="number">0</span><span class="comment">;i &lt; 4; i++)</span></span><br><span class="line">            seedValue[i + <span class="number">8</span>] = ((seed[<span class="number">2</span>] &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>)<span class="comment">;</span></span><br><span class="line">        <span class="comment">/* And added strength into seed */</span></span><br><span class="line">        for (i = <span class="number">0</span><span class="comment">;i &lt; sizeof(pubkey_strength); i++)</span></span><br><span class="line">            seedValue[i + <span class="number">12</span>] = ((pubkey_strength &gt;&gt; (i * <span class="number">8</span>)) &amp; <span class="number">0xff</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    memcpy( <span class="keyword">sb_Options.rngInfo.seed.value, </span>seedValue, <span class="keyword">SB_MAX_SEED_LEN);</span></span><br><span class="line"><span class="keyword"> </span></span><br><span class="line">    ret = <span class="keyword">sb_initialize(</span></span><br><span class="line"><span class="keyword"> </span>       ellipticCurve,</span><br><span class="line">        &amp;<span class="keyword">sb_Options,</span></span><br><span class="line"><span class="keyword"> </span>       dataSize,</span><br><span class="line">        heapSize,</span><br><span class="line">        global_data,</span><br><span class="line">        heap_space</span><br><span class="line">    )<span class="comment">;</span></span><br><span class="line">    if (ret != <span class="keyword">SB_SUCCESS)</span></span><br><span class="line"><span class="keyword"> </span>   &#123;</span><br><span class="line">        <span class="keyword">displayErrorMsg(ret);</span></span><br><span class="line"><span class="keyword"> </span>       exit(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 2. Generate ECC key pairs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    ret = <span class="keyword">sb_genKeyPair(</span></span><br><span class="line"><span class="keyword"> </span>       global_data,</span><br><span class="line">        privateKey,</span><br><span class="line">        publicKey</span><br><span class="line">    )<span class="comment">;</span></span><br><span class="line">    if (ret != <span class="keyword">SB_SUCCESS)</span></span><br><span class="line"><span class="keyword"> </span>   &#123;</span><br><span class="line">        <span class="keyword">displayErrorMsg(ret);</span></span><br><span class="line"><span class="keyword"> </span>       exit(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * End Security Builder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    ret = <span class="keyword">sb_end(global_data);</span></span><br><span class="line"><span class="keyword"> </span>   if (ret != <span class="keyword">SB_SUCCESS)</span></span><br><span class="line"><span class="keyword"> </span>   &#123;</span><br><span class="line">        <span class="keyword">displayErrorMsg(ret);</span></span><br><span class="line"><span class="keyword"> </span>       exit(<span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Free the memory space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    free(heap_space)<span class="comment">;</span></span><br><span class="line">    free(global_data)<span class="comment">;</span></span><br><span class="line">    return <span class="number">0</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-FlexLM-ECDSA签名过程的漏洞"><a href="#14-FlexLM-ECDSA签名过程的漏洞" class="headerlink" title="14. FlexLM ECDSA签名过程的漏洞"></a><strong>14. FlexLM ECDSA签名过程的漏洞</strong></h1><p>IEEE-163对ECDSA的签名过程是有严格规定的。FlexLM的做法和它不一致。它的确减弱了签名的安全性，但是漏洞目前并不能被利用。</p><p>首先，给出一个线性rng下ECDSA不安全的示范。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) </span><br><span class="line"><span class="symbol">r1</span> = <span class="symbol">k1</span> * G</span><br><span class="line"><span class="symbol">s1</span> = (<span class="symbol">h1</span> + d*<span class="symbol">r1</span>)/<span class="symbol">k1</span> <span class="built_in">mod</span> <span class="built_in">n</span></span><br><span class="line"> </span><br><span class="line">(<span class="number">2</span>)</span><br><span class="line"><span class="symbol">r2</span> = <span class="symbol">k2</span> * G</span><br><span class="line"><span class="symbol">s2</span> = (<span class="symbol">h2</span> + d*<span class="symbol">r2</span>)/<span class="symbol">k2</span> <span class="built_in">mod</span> <span class="built_in">n</span></span><br><span class="line"> </span><br><span class="line">可以得到：</span><br><span class="line">(<span class="number">3</span>)</span><br><span class="line">(<span class="symbol">h1</span> + d*<span class="symbol">r1</span>) / <span class="symbol">s1</span> - (<span class="symbol">h2</span> + d*<span class="symbol">r2</span>) / <span class="symbol">s2</span> = <span class="symbol">k1</span> - <span class="symbol">k2</span>  <span class="built_in">mod</span> <span class="built_in">n</span></span><br><span class="line"> </span><br><span class="line">=&gt;</span><br><span class="line">d *(<span class="symbol">r1</span>/<span class="symbol">s1</span> - <span class="symbol">r2</span>/<span class="symbol">s2</span>) + (<span class="symbol">h1</span>/<span class="symbol">s1</span> - <span class="symbol">h2</span>/<span class="symbol">s2</span>) = C(k)   <span class="built_in">mod</span> <span class="built_in">n</span></span><br><span class="line"> </span><br><span class="line">注意到，这是一个线性方程：</span><br><span class="line">d * A + B = C(k)  <span class="built_in">mod</span> <span class="built_in">n</span></span><br></pre></td></tr></table></figure><p>可见，如果rng是h的线性函数，只要有两对sign， 并能获取k1与k2的差值，<br>并不需要知道k1，k2本身的值。就能解一个线性方程得出d来。<br>d = (C - B ) / A mod n<br>这里的除法是模逆运算， n是一个素数，它是有解且唯一的。</p><p>(1) 一个典型是，rng没有初始化或者初始化为一个常量；那么 k为常量。 差值C=0。</p><p>(2) 另一个典型是，某些不安全的rng，在seed session 时采用了系统时间。<br>prng=f( f1(Privkey), f2(Message), f3(Tickcount) ), 在Windows下， GetTickCount得到的是一个毫秒数。如果连续两次签名在1毫秒内完成， 那么它们的sign是同一个k生成的。从而差值C = 0。</p><p>因此，连续两次签名时需要检测， 它们的前半部分sign.r必须不同。以抵御攻击。</p><p>这里有一个案例， CloneCD v4，曾经采用ECNR-241签名（与ECDSA有所不同）。<br>被人做出keygen，原理和(3)一样。</p><p>FlexLM签名过程的rng分析</p><p>FlexLM rng有线性部分，也有非线性部分。它的Signing有如下特点：<br>参考l_prikey.c。<br>a) Seed with Private key, hash of message<br>b) Signature will be guaranteed repeatable given the same FEATURE data.<br>c) Requires a different certicom “context” for each signature.</p><p>这里面的b)是很诡异的做法，它充分暴露了FlexLM的k不是纯随机，而是与私钥和hash有关的伪随机。<br>但是这里要注意，它里面的确有大数相加的部分，但是那是一种保证bits的方法。</p><p>它的rng，并不是线性相加两个大数那么简单，而是拿它们Private key和hash去填充rng的buffer。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">k = f1(<span class="name">privkey</span>) + f2(<span class="name">privkey</span>, msghash, curve)</span><br><span class="line"> </span><br><span class="line">C(<span class="name">k</span>) = f2(<span class="name">privkey</span>, msghash1, curve)  - f2(<span class="name">privkey</span>, msghash2, curve)</span><br></pre></td></tr></table></figure><p>的确，对于同一个priveky来说，在任何一次签名，rng在f2时初始状态是固定的。<br>但是，f2并不是一个线性函数，它被非线性的sha hash给冲掉了。<br>C(k)是与privkey有关的非线性量。</p><p>在分析了：<br>(1)多个不同privkey对同一条msg签名<br>(2) 同一个privkey对多条msg签名<br>都没有找到可供利用的线性差值。 不再有冗余信息可以得出签名的k。</p><p>所以，前面说的线性攻击方法对FlexLM ECDSA无效。<br><strong><br>那么，是否还有其它的攻击方法，恢复出k的信息，从而计算出privkey？<br>目前看来，没有直接的答案。</strong></p><p>FlexLM的ECDSA的签名过程，b)点是一个非常不必要的做法。<br>为什么他们要做这么一个怪胎呢？显然不是为了制造一个漏洞假象。它只是保证签名的唯一性而已。</p><p>p.s. 关于RLM的题外话</p><p>这里要说到RLM (Reprise License Manager):<br>Flexlm原班开发人马，2006年从Macrovision跑路后，另起灶头，产品叫RLM。<br><a href="http://www.reprisesoftware.com/index.php" target="_blank" rel="noopener">http://www.reprisesoftware.com/index.php</a></p><p>它用的DSA-512签名。基于离散对数。 里面在签名的时候， 会把k加上若干个Q，填充到161 bit (or 163 bit ? 具体数值忘了 )。</p><p>这也是一个怪胎。因为 k + nQ mod Q 仍然是k。 开发者的意思是，在k上加上n倍模长，掩盖掉<br>k本身的bits信息，防止利用计时攻击，估算签名的时间，得出k。</p><p>RLM的开发者果然是有一鼓呆子气，如果攻击者都能物理接触到你的license maker Server了，<br>那直接复制你的文件就可以，还计时攻击个啥呢？对于PC来说，签名DSA-512在200 us内完成。<br>计时攻击要求：接触到服务器，能在服务器上运行纳秒级的计时器， 也就是能直接读取CPU的计时器(RDTSC)；可以执行签名程序，进行上万次的签名试验。这除了开发者本人蛋疼的测试，其他人能有这条件吗？ 这就是从自己口袋里掏钥匙的游戏。</p><p>这里说一个结论，RLM从 v1- v8，patch DSA verfiy， 写license maker，是很容易的事情。<br>v9之后checksum有所增强， 但是也不复杂。</p><p>包括RLM的Windows， linux， macos平台都一样。</p><p>RLM除了开发起来简单些，从Sign保护方面来说，只是把ECDSA Sign换成了DSA， 基本上是老虎变大猫的游戏。</p><h1 id="15-FlexLM-License服务器启动"><a href="#15-FlexLM-License服务器启动" class="headerlink" title="15. FlexLM License服务器启动"></a><strong>15. FlexLM License服务器启动</strong></h1><p>说明： 本篇主要是基本知识简单介绍，与ECDSA无关。详见用户文档。</p><p>FlexLM的license是一种格式化的文件，关于这种格式的说明，可以参考FlexLM用户文档。<br>&lt; License Administration Guide &gt; ( fnp_LicAdmin.pdf )</p><p>一般来说，发行软件本身会带证书管理指南文档。包括证书格式，服务器配置，故障排除等内容。</p><p>比如， Cadence v16.5 (采用FlexNet v11.9.1.0 build 89952 i86_n3)，安装完毕，<br>可以找到用户文档：FlexNet Publisher Licensing Toolkit 11.9.1，日期为 2010.12。</p><p>许可证服务器管理器是TCP/IP方式通讯的。一般可采用lmgrd + daemon（守护程序） 方式检查licensefile。<br>licensefile 可采用如下命令行启用：<br>lmgrd -c licensefile<br>licensefile 中描述了守护程序的名字。</p><p>许可证服务器管理器 lmgrd 的用途是：<br>• 启动并维护许可证文件的 VENDOR 行中列出的所有供应商守护程序。<br>• 向合适的供应商守护程序发出应用程序检出（或其它）请求。</p><p>lmgrd 命令行具体语法可以参考文档中《lmgrd 命令行语法》这一节。<br>lmgrd主要的用法为：<br>lmgrd [-c license_file_list] [-l [+]debug_log_path]<br>[-2 -p] [-local] [-x lmdown] [-x lmremove] [-z ] [-v] [-help]</p><h1 id="16-FlexLM-License文件格式"><a href="#16-FlexLM-License文件格式" class="headerlink" title="16. FlexLM License文件格式"></a><strong>16. FlexLM License文件格式</strong></h1><p>License文件采用文本格式，可以手工编辑，合并。对用户来说，比二进制格式要直观。<br>FlexLM特别强调它能灵活管理多种license。</p><p>可以参看<a href="https://docs.nomagic.com/download/attachments/70388394/fnp_LicAdmin_11_17_0.pdf?version=1&amp;modificationDate=1611149745747&amp;api=v2" target="_blank" rel="noopener">&lt; License Administration Guide &gt;</a> 这个文档。<br>Reading a License File， 这一章， 描述了license文件的格式。摘要如下：</p><p>许可证文件（license file）通常以一个 SERVER 行开始，<br>后跟一个或多个 VENDOR 行，然后是一个或多个 FEATURE 或 INCREMENT 行。<br>在某些情况下，许可证文件不需要 SERVER 行和 VENDOR 行（单机版，运行时不需要lmgrd和守护程序）。</p><p>许可证的类型有：<br>（1）流动许可证<br>流动许可证在各个FEATURE 行中没有 hostid这一项目。流动许可证要求运行 lmgrd 和 供应商守护程序以对许可证<br>的并发使用情况进行计数。lmgrd 使用FLEXnet Licensing TCP/IP 端口，缺省范围 (27000-27009) 。<br>也可以指定其它的端口。</p><p>文档里，给出浮动license的一个例子是：<br>SERVER lulu 17007ea8<br>VENDOR sampled<br>FEATURE f1 sampled 1.00 1-jan-2005 2 SIGN=signature1<br>FEATURE f2 sampled 1.00 1-jan-2005 6 SIGN=signature2<br>FEATURE f3 sampled 1.00 1-jan-2005 1 SIGN=signature3<br>此许可证文件指定许可证服务器为“lulu”，服务器hostid为17007ea8， 端口为默认。<br>客户可访问功能“f1”的 2 个许可证、功能“f2”的 6 个许可证以及功能“f3”的 1 个许可证。</p><p>（2）节点锁定许可证<br>节点锁定意味着，FLEXenabled 软件只能在一台或一组计算机上使用。节点锁定的许可证在某个 FEATURE 行中包含 hostid，该许可证将节点锁定到特定主机上。<br>共有两种类型的节点锁定许可证；不计数许可证和计数许可证。</p><p>如果将许可证数量设置为 0 （或 uncounted），则不对该许可证进行计数，并且允许在指定计算机上无限制地使用该许可证。<br>此配置不需要 lmgrd 或供应商守护程序，因为它不对功能的并发使用情况进行计数。</p><p>即使有hostid这一项目，如果hostid=ANY, 则不绑定硬件。</p><p>这里给出本地license的一个例子(SlickEdit 13, FlexNet v11.5)，<br>说明，这只是一个例子，不是一个valid的license（Sign修改了的）：</p><p>INCREMENT vswb vsflex 13.00 9-jul-2008 uncounted HOSTID=00117b8a597b \<br>    ISSUER=”SlickEdit Inc.” ISSUED=24-jun-2008 \<br>    NOTICE=” <strong>**</strong> “ \<br>    SN=SERIAL:WB_TRIAL|LICTYPE:TRL START=23-jun-2008 TS_OK \<br>    SIGN=”01D2 87C9 CAA9 C2B9 3FA9 48B1 5668 AE7F 8097 71CE 7602 \<br>    72F7 863C 82AD 422E 0802 ACDD D4B8 D4DE FADB EF50”</p><p>在这里，HOSTID 锁定为mac地址00117b8a597b。</p><p>在这里，守护程序是vsflex，本地license一样可以用lmgrd启动管理的。<br>本地slickedit.lic改为：<br>SERVER 127.0.0.1 ANY 27000<br>VENDOR vsflex<br>USE_SERVER</p><p>那么， slickedit将通过访问127.0.0.1:27000获取license。<br>我们在本地启动: lmgrd -z -c license.dat , license.dat如下：<br>SERVER this_host ANY<br>VENDOR vsflex<br>INCREMENT vswb vsflex 13.00 9-jul-2008 uncounted HOSTID=00117b8a597b \<br>    ISSUER=”SlickEdit Inc.” ISSUED=24-jun-2008 \<br>    NOTICE=” <strong>**</strong> “ \<br>    SN=SERIAL:WB_TRIAL|LICTYPE:TRL START=23-jun-2008 TS_OK \<br>    SIGN=”01D2 87C9 CAA9 C2B9 3FA9 48B1 5668 AE7F 8097 71CE 7602 \<br>    72F7 863C 82AD 422E 0802 ACDD D4B8 D4DE FADB EF50”</p><p>因此，采用本地license或是网络license主要看管理上的方便。</p><h1 id="17-FlexLM对FEATURE-INCREMENT进行ECDSA签名方法"><a href="#17-FlexLM对FEATURE-INCREMENT进行ECDSA签名方法" class="headerlink" title="17. FlexLM对FEATURE/INCREMENT进行ECDSA签名方法"></a><strong>17. FlexLM对FEATURE/INCREMENT进行ECDSA签名方法</strong></h1><p>FEATURE/INCREMENT 行的基本格式为：<br>{FEATURE|INCREMENT} feature vendor feat_version exp_date num_lic SIGN=sign [optional_attributes]</p><p>（1）必选属性<br>FEATURE/INCREMENT 行关有6个必选字段，并且它们具有固定的顺序。这些字段是由供应商定义的，不能对其进行更改。</p><p>（2）可选属性<br>可选属性由供应商自行提供的，以便提供特定的许可行为。这些属性采用keyword=value 语法，其中，keyword 为大写形式。<br>所以在 FEATURE 或 INCREMENT 行中，它们必须保留在该位置，最终用户不能对其进行更改。<br>常见的有：<br>ISSUED=dd-mmm-yyyy 签发日期。<br>ISSUER=”…” 许可证签发者。<br>NOTICE=”…” 用于知识产权通告的字段。<br>PLATFORMS=”…” 使用情况受所列出平台限制。<br>START=dd-mmm-yyyy 开始日期。<br>VENDOR_STRING=”…” 供应商定义的字符串，用双引号引起来。</p><p>签名过程中，这些属性会按照固定的顺序处理。因此保证了用户不能更改FEATURE中的属性或者Sign。</p><p>在SDK中，l_crypt_private()这个函数用来处理feature的属性。它调用real_crypt()实现。<br>real_crypt()其实并不是一个crypt， 它是一个字符处理函数，FEATURE 或 INCREMENT 经过它的处理，然后才会进行ECDSA签名。<br>接下来就是ECDSA签名， 签名的算法和RNG，前面的文章已有说明，因此不再重复。</p><p>这里给出一个例子, 采用是FlexNet 11.5， ECDSA-163。</p><p>INCREMENT vsee vsflex 13.01 16-jul-2099 uncounted HOSTID=ANY \<br> ISSUER=”SLICKEDIT KG READYU#2K8” ISSUED=28-jun-2008 \<br> NOTICE=”readyu” \<br> SN=SERIAL:FWC123-74973876|LICTYPE:STD TS_OK \<br> SIGN=”023843740B3B1FBF51630285E892CF2E3D4AC88CEF 010FBFCB08A51D71423825CB84C5CD63905679F60A”</p><p>对于ECDSA来说，这个签名其实是：<br>hash(msg)=5b176716984bf0e4c0f2016785612e0ad31690e2<br>sign.r=023843740B3B1FBF51630285E892CF2E3D4AC88CEF<br>sign.s=010FBFCB08A51D71423825CB84C5CD63905679F60A</p><p>ECDSA的签名hash来自于msg的sha-160。</p><p>msg并不是直接的把这一行“INCREMENT vsee vsflex 13.01 16-jul-2099 uncounted HOSTID=ANY ….” 连接起来。</p><p>它是对INCREMENT行，real_crypt() 之后得来的。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">它的签名msg如下：</span><br><span class="line"> </span><br><span class="line">unsigned char msg[] = &#123;</span><br><span class="line">    <span class="number">0xD2</span>, <span class="number">0x0F</span>, <span class="number">0x37</span>, <span class="number">0xAB</span>, <span class="number">0xEF</span>, <span class="number">0x28</span>, <span class="number">0x01</span>, <span class="number">0xD0</span>, <span class="number">0x00</span>, <span class="number">0x56</span>, <span class="number">0x53</span>, <span class="number">0x45</span>, <span class="number">0x45</span>, <span class="number">0x0D</span>, <span class="number">0x64</span>, <span class="number">0x10</span>,</span><br><span class="line">    <span class="number">0xC7</span>, <span class="number">0x6A</span>, <span class="number">0x75</span>, <span class="number">0x6C</span>, <span class="number">0x87</span>, <span class="number">0xC5</span>, <span class="number">0xD0</span>, <span class="number">0x73</span>, <span class="number">0x54</span>, <span class="number">0x59</span>, <span class="number">0x50</span>, <span class="number">0x45</span>, <span class="number">0x3D</span>, <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x38</span>,</span><br><span class="line">    <span class="number">0x49</span>, <span class="number">0x53</span>, <span class="number">0x53</span>, <span class="number">0x55</span>, <span class="number">0x45</span>, <span class="number">0x52</span>, <span class="number">0x3D</span>, <span class="number">0x53</span>, <span class="number">0x4C</span>, <span class="number">0x49</span>, <span class="number">0x43</span>, <span class="number">0x4B</span>, <span class="number">0x45</span>, <span class="number">0x44</span>, <span class="number">0x49</span>, <span class="number">0x54</span>,</span><br><span class="line">    <span class="number">0x4B</span>, <span class="number">0x47</span>, <span class="number">0x52</span>, <span class="number">0x45</span>, <span class="number">0x41</span>, <span class="number">0x44</span>, <span class="number">0x59</span>, <span class="number">0x55</span>, <span class="number">0x23</span>, <span class="number">0x32</span>, <span class="number">0x4B</span>, <span class="number">0x38</span>, <span class="number">0x1C</span>, <span class="number">0x6C</span>, <span class="number">0x6A</span>, <span class="number">0x75</span>,</span><br><span class="line">    <span class="number">0x6E</span>, <span class="number">0x4E</span>, <span class="number">0x4F</span>, <span class="number">0x54</span>, <span class="number">0x49</span>, <span class="number">0x43</span>, <span class="number">0x45</span>, <span class="number">0x3D</span>, <span class="number">0x52</span>, <span class="number">0x45</span>, <span class="number">0x41</span>, <span class="number">0x44</span>, <span class="number">0x59</span>, <span class="number">0x55</span>, <span class="number">0x53</span>, <span class="number">0x4E</span>,</span><br><span class="line">    <span class="number">0x3D</span>, <span class="number">0x53</span>, <span class="number">0x45</span>, <span class="number">0x52</span>, <span class="number">0x49</span>, <span class="number">0x41</span>, <span class="number">0x4C</span>, <span class="number">0x3A</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x43</span>, <span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x2D</span>, <span class="number">0x37</span>,</span><br><span class="line">    <span class="number">0x34</span>, <span class="number">0x39</span>, <span class="number">0x37</span>, <span class="number">0x33</span>, <span class="number">0x38</span>, <span class="number">0x37</span>, <span class="number">0x36</span>, <span class="number">0x7C</span>, <span class="number">0x4C</span>, <span class="number">0x49</span>, <span class="number">0x43</span>, <span class="number">0x54</span>, <span class="number">0x59</span>, <span class="number">0x50</span>, <span class="number">0x45</span>, <span class="number">0x3A</span>,</span><br><span class="line">    <span class="number">0x53</span>, <span class="number">0x54</span>, <span class="number">0x44</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"> </span><br><span class="line">msg里面的非ASCII字符，是一些常数。比如：</span><br><span class="line">ANY_CODE (<span class="number">0xab370fd2</span>)，INCREMENT_FLAGv(<span class="number">0xd00128ef</span>)， NO_START_DATE_FLAG (<span class="number">0x73D0c587</span>)，</span><br><span class="line"> </span><br><span class="line">msg如果直接打印，这里面有<span class="number">00</span>字符，还有非ASCII字符,因此会出现部分”乱码“。</span><br><span class="line">?<span class="number">7</span>(?VSEEd莏ul嚺衧TYPE=128ISSUER=SLICKEDITKGREADYU#2K8ljunNOTICE=READYUSN=SERIAL:FWC123-<span class="number">74973876</span>|LICTYPE:<span class="keyword">STD</span></span><br></pre></td></tr></table></figure><p>x86的字节序是little-edian。所以在内存里，ANY_CODE (0xab370fd2) 的顺序为：<br>0xD2, 0x0F, 0x37, 0xAB</p><p>事实上，在flexlm-enabled的程序中，搜这四个字节，可以定位 real_crypt()函数。</p><p>附录： l_crypt 的一些常数定义：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  Some constants for flags going into the string</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">#define ANY_CODE         ((<span class="name">long</span>) <span class="number">0</span>xab370fd2)</span><br><span class="line">#define USER_CODE        ((<span class="name">long</span>) <span class="number">0</span>xba1584a2)</span><br><span class="line">#define DISPLAY_CODE     ((<span class="name">long</span>) <span class="number">0</span>xab8543cc)</span><br><span class="line">#define HOSTNAME_CODE    ((<span class="name">long</span>) <span class="number">0</span>xbadaef01)</span><br><span class="line">#define HOSTID_DOMAIN_CODE    ((<span class="name">long</span>) <span class="number">0</span>x49D654F9)</span><br><span class="line">#define HOSTID_COMPOSITE_CODE   ((<span class="name">long</span>) <span class="number">0</span>x2388341c)</span><br><span class="line">#define HOSTID_METER_BORROW_CODE    ((<span class="name">long</span>) <span class="number">0</span>x4aa87607)</span><br><span class="line">#define HOSTID_VENDOR_CODE ((<span class="name">long</span>) <span class="number">0</span>x12fe93a)</span><br><span class="line">#define NO_EXTENDED_CODE ((<span class="name">long</span>) <span class="number">0</span>x74ab99)</span><br><span class="line">#define DEMO_CODE        ((<span class="name">long</span>) <span class="number">0</span>x122345a)</span><br><span class="line">#define FLEXLOCK_CODE   ((<span class="name">long</span>) <span class="number">0</span>x1c8c6f21)</span><br><span class="line">#define FLEXID1_CODE    ((<span class="name">long</span>) <span class="number">0</span>x61420b1)</span><br><span class="line">#define FLEXID2_CODE    ((<span class="name">long</span>) <span class="number">0</span>x19481954)</span><br><span class="line">#define FLEXID3_CODE    ((<span class="name">long</span>) <span class="number">0</span>x29ab7264)</span><br><span class="line">#define FLEXID4_CODE    ((<span class="name">long</span>) <span class="number">0</span>x01181954)</span><br><span class="line">#define FLEXID_FILE_CODE    ((<span class="name">long</span>) <span class="number">0</span>x8adf678a)</span><br><span class="line">#define DISK_SERIAL_NUM_CODE    ((<span class="name">long</span>) <span class="number">0</span>x78131a7c)</span><br><span class="line">#define ID_STRING_CODE  ((<span class="name">long</span>) <span class="number">0</span>xaabb007c)</span><br><span class="line">#define SERNUM_ID_STRING_CODE   ((<span class="name">long</span>) <span class="number">0</span>x5c7b549c)</span><br><span class="line">#define INTERNET_CODE   ((<span class="name">long</span>) <span class="number">0</span>x7c7cfea0)</span><br><span class="line">             </span><br><span class="line">#define INCREMENT_FLAG   ((<span class="name">long</span>) <span class="number">0</span>xd00128ef)</span><br><span class="line">#define PACKAGE_FLAG     ((<span class="name">long</span>) <span class="number">0</span>x038ddeed)</span><br><span class="line">#define UPGRADE_FLAG     ((<span class="name">long</span>) <span class="number">0</span>x11052f73)</span><br><span class="line">#define NO_START_DATE_FLAG ((<span class="name">long</span>) <span class="number">0</span>x73D0c587)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-FLEXLM简介&quot;&gt;&lt;a href=&quot;#1-FLEXLM简介&quot; class=&quot;headerlink&quot; title=&quot;1. FLEXLM简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;1. FLEXLM简介&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;FLEXlm是应用广泛的License
      
    
    </summary>
    
      <category term="破解" scheme="https://www.ljjyy.com/categories/crack/"/>
    
    
      <category term="逆向" scheme="https://www.ljjyy.com/tags/reverse/"/>
    
      <category term="汇编" scheme="https://www.ljjyy.com/tags/assemble/"/>
    
  </entry>
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="https://www.ljjyy.com/archives/2023/06/100682.html"/>
    <id>https://www.ljjyy.com/archives/2023/06/100682.html</id>
    <published>2023-06-20T06:20:00.000Z</published>
    <updated>2023-06-20T00:59:09.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>在数据爆炸的年代，单表数据达到千万级别，甚至过亿的量，都是很常见的情景。这时候再对数据库进行操作就是非常吃力的事情了，select个半天都出不来数据，这时候业务已经难以维系。技术在进步虽然有了NoSQL、NewSQL数据库，但是它们都有各自的应用场景，在不适合的场景下还只能老老实实的使用关系型数据库。</p><h2 id="1-1-数据库的不同类型"><a href="#1-1-数据库的不同类型" class="headerlink" title="1.1 数据库的不同类型"></a>1.1 <strong>数据库的不同类型</strong></h2><h3 id="1-1-1-常用的关系型数据库"><a href="#1-1-1-常用的关系型数据库" class="headerlink" title="1.1.1 常用的关系型数据库"></a>1.1.1 常用的关系型数据库</h3><ul><li><p><strong>Oracle：</strong>功能强大，主要缺点就是贵。</p></li><li><p><strong>MySQL：</strong>互联网行业中最流行的数据库，这不仅仅是因为MySQL的免费。可以说关系数据库场景中你需要的功能，MySQL都能很好的满足，后面详解部分会详细介绍MySQL的一些知识点。</p></li><li><p><strong>MariaDB：</strong>是MySQL的分支，由开源社区维护，MariaDB虽然被看作MySQL的替代品，但它在扩展功能、存储引擎上都有非常好的改进。</p></li><li><p><strong>PostgreSQL：</strong>也叫PGSQL，PGSQL类似于Oracle的多进程框架，可以支持高并发的应用场景，PG几乎支持所有的SQL标准，支持类型相当丰富。PG更加适合严格的企业应用场景，而MySQL更适合业务逻辑相对简单、数据可靠性要求较低的互联网场景。</p></li></ul><h3 id="1-1-2-NoSQL数据库（非关系型数据库）"><a href="#1-1-2-NoSQL数据库（非关系型数据库）" class="headerlink" title="1.1.2 NoSQL数据库（非关系型数据库）"></a>1.1.2 NoSQL数据库（非关系型数据库）</h3><ul><li><p><strong>Redis：</strong>提供了持久化能力，支持多种数据类型。Redis适用于数据变化快且数据大小可预测的场景。</p></li><li><p><strong>MongoDB：</strong>一个基于分布式文件存储的数据库，将数据存储为一个文档，数据结构由键值对组成。MongoDB比较适合表结构不明确，且数据结构可能不断变化的场景，不适合有事务和复杂查询的场景。</p></li><li><p><strong>HBase：</strong>建立在HDFS，也就是Hadoop文件系统之上的分布式面向列的数据库。类似于谷歌的大表设计，HBase可以提供快速随机访问海量结构化数据。在表中它由行排序，一个表有多个列族以及每一个列族可以有任意数量的列。HBase依赖HDFS可以实现海量数据的可靠存储，适用于数据量大，写多读少，不需要复杂查询的场景。</p></li><li><p><strong>Cassandra：</strong>一个高可靠的大规模分布式存储系统。支持分布式的结构化Key-value存储，以高可用性为主要目标。适合写多的场景，适合做一些简单查询，不适合用来做数据分析统计。</p></li><li><p><strong>Pika：</strong>一个可持久化的大容量类Redis存储服务， 兼容五种主要数据结构的大部分命令。Pika使用磁盘存储，主要解决Redis大容量存储的成本问题。</p></li></ul><h3 id="1-1-3-NewSQL数据库（新一代关系型数据库）"><a href="#1-1-3-NewSQL数据库（新一代关系型数据库）" class="headerlink" title="1.1.3 NewSQL数据库（新一代关系型数据库）"></a>1.1.3 NewSQL数据库（新一代关系型数据库）</h3><ul><li><p><strong>TiDB：</strong>开源的分布式关系数据库，几乎完全兼容MySQL，能够支持水平弹性扩展、ACID事务、标准SQL、MySQL语法和MySQL协议，具有数据强一致的高可用特性。既适合在线事务处理，也适合在线分析处理。</p></li><li><p><strong>OceanBase：</strong>OceanBase是蚂蚁金服的数据库，OB是可以满足金融级的可靠性和数据一致性要求的数据库系统。当你需要使用事务，并且数据量比较大，就比较适合使用OB。不过目前OB已经商业化，不再开源。</p></li></ul><h1 id="二、结构设计优化"><a href="#二、结构设计优化" class="headerlink" title="二、结构设计优化"></a>二、结构设计优化</h1><h2 id="2-1-表场设计"><a href="#2-1-表场设计" class="headerlink" title="2.1 表场设计"></a>2.1 表场设计</h2><ul><li>数据库主键设计，推荐带时间属性自增长数字ID（分布式自增长ID生成算法）如：雪花算法、百度分布式ID算法、美团分布式ID算法。</li><li>表字段不为空，因为空值很难查询和优化，占用额外的索引空间，建议默认数字0。</li><li>对于数据状态类型字段，比如status、type等，尽量不要定义负数，比如-1。因为可以加上unseigned，所以数值容量会翻倍。</li><li>如果可能，使用 tinyint，smallint 代替 int，并且尽量不要使用 bigint，因为它占用的空间更少。</li><li>字符串类型的字段会比数字类型的字段占用更多空间，所以尽量使用整数而不是字符串。在许多情况下，编码逻辑可以使用整数来代替。</li><li>字符串类型的长度不能随意设置，在满足业务需求的前提下尽量小。</li><li>使用整数来存储 IP。</li><li>一个表中不要有太多字段。建议20以内。</li><li>提前为可预测的字段预留，因为数据量越大，修改数据结构越耗时。</li></ul><h2 id="2-2-分割"><a href="#2-2-分割" class="headerlink" title="2.2 分割"></a>2.2 分割</h2><ul><li>分区是一种水平分区，它按照一定的规则将一个表分成几个更小、更容易管理的部分。对应用程序完全透明，不影响应用程序的业务逻辑，即无需修改代码。因此，它可以存储更多的数据，查询和删除，还支持分区操作，从而达到优化的目的。如果考虑分区，可以提前做好准备，避免以下限制：</li><li>一张表最多只能有1024个分区 mysql 5.6以后支持8192个分区）。但实际操作时，最好不要一次打开超过100个分区，因为打开分区也有时间损失。</li><li>如果分区字段中有主键或唯一索引列，则必须包括所有主键列和唯一索引列。如果表中有主键或唯一索引，则分区键必须是主键或唯一索引。</li><li>外键约束不能在分区表中使用。</li><li>空值会使分区过滤失效，所以会放入默认分区。请不要让分区字段显示为空。</li><li>所有分区必须使用相同的存储引擎。</li></ul><h2 id="2-3-子表"><a href="#2-3-子表" class="headerlink" title="2.3 子表"></a>2.3 子表</h2><p>子表包括水平子表和垂直子表。</p><p>横向分表拆分成数据结构相同的小表，如table1、table2……以缓解数据库读写压力<br>垂直分表是指一些字段被分离出来形成一个新的表。每张表的数据结构不同，可以优化高低锁表的情况。</p><p>可以想象，在分表的情况下需要修改程序的逻辑。因此，在项目前期预见到大量数据时，一般会考虑分表。后期不建议分表，所以成本很高。</p><h2 id="2-4-子库"><a href="#2-4-子库" class="headerlink" title="2.4 子库"></a>2.4 子库</h2><p>分库一般是主从模式。将数据库服务器的主节点复制到一个或多个从节点和多个数据库。主库负责写操作，从库负责读操作，从而达到主从分离、高可用和数据备份的优化目的。</p><p>当然，主从模式也有一些缺陷，比如主从同步的延迟，binlog文件过大带来的问题等等。</p><h2 id="2-4-其他"><a href="#2-4-其他" class="headerlink" title="2.4 其他"></a>2.4 其他</h2><p>热表和冷表是隔离的。对于历史数据，当查询和使用的人数较少时，可以将其移至另一个冷库，仅用于查询，以缓解热量表数据量大的情况。</p><h2 id="2-5-索引设计"><a href="#2-5-索引设计" class="headerlink" title="2.5 索引设计"></a>2.5 索引设计</h2><ul><li>索引，空间换时间的优化策略，基本根据业务需要设计好的索引，足以应付百万数据，养成使用explain的习惯，关于explain也可以访问：explain让你的SQL写得更多脚踏实地，了解更多。</li><li>一个常识：索引越多越好。索引会降低数据写入的性能。</li><li>索引字段的长度尽可能的短，这样可以节省大量的索引空间；</li><li>取消外键可以通过程序进行约束，具有更好的性能。</li><li>复合索引匹配的最左列规则，索引顺序和查询条件一致，尽可能去掉不必要的单列索引。</li><li>值分布较少（不重复较少）的字段不适合索引。例如，当只有性别等两个或三个值时，对字段进行索引是没有意义的。</li><li>建议对需要排序的字段添加索引，因为索引会进行排序，可以提高查询性能。</li><li>前缀索引用于字符串字段而不是全字段索引，可以大大减少索引空间。</li></ul><h1 id="三、模糊查询优化"><a href="#三、模糊查询优化" class="headerlink" title="三、模糊查询优化"></a>三、模糊查询优化</h1><p>我们经常在数据库中使用 LIKE 操作符来完成对数据的模糊搜索，LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。</p><p>如果需要查找客户表中所有姓氏是“马”的数据，可以使用下面的 SQL 语句：</p><p>SELECT * FROM Customer WHERE Name LIKE ‘马%’</p><p>如果需要查找客户表中所有手机尾号是“阳”的数据，可以使用下面的 SQL 语句：</p><p>SELECT * FROM Customer WHERE Phone LIKE ‘%阳’</p><p>如果需要查找客户表中所有名字中包含“东”的数据，可以使用下面的 SQL 语句：</p><p>SELECT * FROM Customer WHERE Name LIKE ‘%东%’</p><p>以上三种分别对应了：左前缀匹配、右后缀匹配和模糊查询，并且对应了不同的查询优化方式。</p><p>左前缀匹配查询优化：索引就可以</p><p>我们可以采用“以空间换时间”的方式来解决右后缀匹配查询时效率低下的问题。</p><p>简单来说，我们可以将字符串倒过来，让右后缀匹配变成左前缀匹配。以“防着古海回来再抓孙悟空”为例，将其倒置之后的字符串是“空悟孙抓再来回海古着防”。当需要查找结尾为“孙悟空”的数据时，去查找以“空悟孙”开头的数据即可。</p><p>具体做法是：在该表中增加“txt_back”列，将“txt”列的值倒置后，填入“txt_back”列中，最后为 “txt_back”列增加索引。</p><p>模糊查询，根据用户量和接口qps决定使用哪种优化方式，如果用户量级小，是面向B端的系统，可以采用mysql的feature进行查询优化，如果用户量级大，我们需要的就是一个全文检索引擎。</p><h2 id="3-1-MySQL是如何优化模糊匹配like的SQL"><a href="#3-1-MySQL是如何优化模糊匹配like的SQL" class="headerlink" title="3.1 MySQL是如何优化模糊匹配like的SQL"></a>3.1 MySQL是如何优化模糊匹配like的SQL</h2><h3 id="3-1-1-全文索引"><a href="#3-1-1-全文索引" class="headerlink" title="3.1.1 全文索引"></a>3.1.1 全文索引</h3><p>语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> fulltext_test <span class="keyword">add</span> fulltext <span class="keyword">index</span> content_tag_fulltext(<span class="keyword">content</span>,tag);</span><br><span class="line">MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。</span><br><span class="line">从MySQL 5.7开始内置了ngram全文检索插件，用来支持中文分词，并且对MyISAM和InnoDB引擎有效。</span><br></pre></td></tr></table></figure><p>mysql 官方文档对match策略的解释：<a href="https://dev.mysql.com/doc/internals/en/full-text-search.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/internals/en/full-text-search.html</a></p><h3 id="3-1-2-生成列"><a href="#3-1-2-生成列" class="headerlink" title="3.1.2 生成列"></a>3.1.2 生成列</h3><p>MySQL 5.7开始支持生成列，生成列是由表达式的值计算而来，有两种模式：VIRTUAL和STORED，如果不指定默认是VIRTUAL，创建语法如下</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">col_name data_type [GENERATED ALWAYS] <span class="built_in">AS</span> (<span class="keyword">expr</span>) [**VIRTUAL** | **STORED**] [<span class="keyword">NOT</span> <span class="built_in">NULL</span> | <span class="built_in">NULL</span>]</span><br></pre></td></tr></table></figure><p>可以解决右后缀匹配的问题，但是不能解决模糊查询的问题。也是将字符串倒过来。</p><h3 id="3-1-3-索引条件下推ICP"><a href="#3-1-3-索引条件下推ICP" class="headerlink" title="3.1.3 索引条件下推ICP"></a>3.1.3 索引条件下推ICP</h3><p>MySQL 5.6开始支持<strong>ICP（Index Condition Pushdown）</strong>，不支持ICP之前，当进行索引查询时，首先根据索引来查找数据，然后再根据where条件来过滤，扫描了大量不必要的数据，增加了数据库IO操作。在支持ICP后，MySQL在取出索引数据的同时，判断是否可以进行where条件过滤，将where的部分过滤操作放在存储引擎层提前过滤掉不必要的数据，减少了不必要数据被扫描带来的IO开销。在某些查询下，可以减少Server层对存储引擎层数据的读取，从而提供数据库的整体性能。</p><p>开启ICP特性后，由于like条件可以通过索引筛选，存储引擎层通过索引与where条件的比较来去除不符合条件的记录，这个过程不需要读取记录，同时只返回给Server层筛选后的记录，减少不必要的IO开销。</p><h2 id="3-2-全文检索引擎"><a href="#3-2-全文检索引擎" class="headerlink" title="3.2 全文检索引擎"></a>3.2 全文检索引擎</h2><h3 id="3-2-1-Sphinx"><a href="#3-2-1-Sphinx" class="headerlink" title="3.2.1 Sphinx"></a>3.2.1 <a href="http://sphinxsearch.com/" target="_blank" rel="noopener">Sphinx</a></h3><p>如果数据源存放在MySQL，可是使用：<a href="http://sphinxsearch.com/" target="_blank" rel="noopener">Sphinx</a> 。</p><p>其实咱们<strong>KM</strong>早期就是使用<strong>Sphinx</strong>实现全文检索查询的，Sphinx可以非常容易的与SQL数据库和脚本语言集成。当前系统内置MySQL和PostgreSQL 数据库数据源的支持，也支持从标准输入读取特定格式 的XML数据。通过修改源代码，用户可以自行增加新的数据源。现在<strong>KM</strong>使用的是搜搜的底层实现搜索；</p><p>Sphinx：原生支持基于MySQL的表建索引</p><p>ElasticSearch官方文档上，数据都是使用RESTful接口一条一条插入的，也就是增量更新。在数据量非常大的时候，遍历全表重建一次索引会非常消耗时间。而elasticsearch-rivel-mysql这个项目并不是很靠谱，开发者甚至曾经在git上标明deprecated（现在没了）。反正我是自己另外写了一套。</p><p>在导入MySQL数据生成索引时，从易用性、可靠性、速度上来看，Sphinx优于ElasticSearch。</p><p><strong>资源占用</strong>，Sphinx优于ElasticSearch。不得不说，java在这方面比不上C++。CPU还好，差距不大，内存占用方面真心天差地别。</p><h3 id="3-2-2-Elasticsearch"><a href="#3-2-2-Elasticsearch" class="headerlink" title="3.2.2 Elasticsearch"></a>3.2.2 <a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a></h3><p>如果你是使用MongoDB，中文分词同样是个坑！业界通用方案是使用<a href="https://www.elastic.co/products/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a> 实现中文检索。 大致的路数是：使用 <a href="https://github.com/mongodb-labs/mongo-connector" target="_blank" rel="noopener">mongo-connector</a> 将数据同步到Elasticsearch中；</p><p><strong>增量更新支持</strong>，ElasticSearch优于Sphinx。ElasticSearch把增量更新作为首选CURD方式；而Sphinx使用辅助表的方案不但不优雅，还会让你的其他系统变得复杂起来，在你频繁更改单条数据的时候很容易出错。</p><p><strong>搜索算法支持</strong>，ElasthcSearch的搜索底层功能基于Lucene，Sphinx也该有的都有。然而ElasticSearch的<a href="https://link.zhihu.com/?spm=5176.100239.blogcont54636.12.63rqN6&amp;target=https%3A//www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html" target="_blank" rel="noopener">Query DSL</a>支持更复杂的查询逻辑，这一点是超越Sphinx的。</p><p>在自定义Ranker方面，ElasticSearch的<a href="https://link.zhihu.com/?spm=5176.100239.blogcont54636.13.63rqN6&amp;target=https%3A//www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html" target="_blank" rel="noopener">Function Score Query</a>比Sphinx的<a href="https://link.zhihu.com/?spm=5176.100239.blogcont54636.14.63rqN6&amp;target=http%3A//sphinxsearch.com/docs/current.html%23expression-ranker" target="_blank" rel="noopener">expression-ranker</a>强大许多。</p><p><strong>横向扩展与高可用</strong>，ElasticSearch是天生为了集群化而设计的。索引如果没有Replica就会显示黄灯，有才会亮绿灯。每个节点分为Client Node、Data Node、Master Node三种角色，在合理的配置之下，任意一台（甚至多台）机器炸了，整个集群都能正常运行。ElasticSearch还支持动态加机器等等功能，暂不赘述。</p><p>Sphinx也有master searchd和slave searchd的概念，可以分布式，但想实现高可用就相当复杂了。</p><p>ElasticSearch优于Sphinx。Sphinx的劣势不在于做不到，而在于不好用。</p><h3 id="3-2-3-RediSearch"><a href="#3-2-3-RediSearch" class="headerlink" title="3.2.3 RediSearch"></a>3.2.3 <a href="https://github.com/RedisLabsModules/RediSearch" target="_blank" rel="noopener">RediSearch</a></h3><p>最后还有一个好东西<a href="https://github.com/RedisLabsModules/RediSearch" target="_blank" rel="noopener">RediSearch</a>是一款基于redis的搜索组件。基于redis，性能高效，实时更新索引，支持Suggest前缀、拼音查找(AutoComplete 功能) ，支持单个或多个分词搜索 ，可根据字段进行结果排序。RediSearch的吞吐量高、延迟低，速度相比ElasticSearch 和 Solr要快120%到500%，欠缺中文的模糊搜索支持的不是很好。</p><p><strong>主要特性</strong></p><p>RediSearch 是在Redis基础上从0开始开发的一个全文搜索索引，使用新的Redis Modules API来扩展Redis新命令和能力，它的主要特性包括：</p><ul><li>简单，快速索引和搜索</li><li>数据存储在内存中，使用内存-有效的自定义数据结构</li><li>支持多种使用UTF-8编码的语言</li><li>文档和字段评分</li><li>结果的数值过滤</li><li>通过词干扩展查询</li><li>精确的短语搜索</li><li>按特定属性过滤结果（例如仅在标题中搜索“foo”）</li><li>强大的自动提示引擎</li><li>增量索引（不需要对索引进行优化和压缩）</li><li>支持用作存储在另一数据库中的文档的搜索索引</li><li>支持已经在Redis中存在的HASH对象作为文件的索引</li><li>扩展到多个Redis实例</li></ul><h1 id="四、普通SQL查询优化"><a href="#四、普通SQL查询优化" class="headerlink" title="四、普通SQL查询优化"></a>四、普通SQL查询优化</h1><ul><li>尝试使用短查询而不是复杂的内联查询。</li><li>查询不使用select *，尽量查询带索引的字段，避免返回表。</li><li>尝试使用limit来限制查询的数量。</li><li>查询字段应尽可能在索引上，尤其是复合索引。我们应该更加注意最左边的前缀匹配。</li><li>拆分大的删除/插入操作会锁定表，影响其他业务操作。另一方面，MySQL 对 SQL 的长度也有限制。</li><li>不建议使用MySQL函数、计算等，可以先由程序处理。从上面提到的一些点，我们会发现，程序可以处理的，尽量不要把压力转给数据库。因为大部分服务器的性能瓶颈都在数据库中。</li><li>查询计数，性能：count（1）=count（*）&gt;count（主键）&gt;count（其他字段）。</li><li>如果可以使用between，则不需要in。如果可以使用in，则不需要or。</li><li>避免使用=或&lt;&gt;、is null或is not null、in、not in等，因为这些查询不能使用索引。</li><li>SQL 应该尽可能简单，并使用更少的连接。不建议使用两个以上的连接。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h1&gt;&lt;p&gt;在数据爆炸的年代，单表数据达到千万级别，甚至过亿的量，都是很常见的情景。这时候再对数据库进行操作就是非常吃力的事情了，sel
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="sql" scheme="https://www.ljjyy.com/tags/sql/"/>
    
      <category term="mysql" scheme="https://www.ljjyy.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Qt Installer Framework 使用手册</title>
    <link href="https://www.ljjyy.com/archives/2023/06/100677.html"/>
    <id>https://www.ljjyy.com/archives/2023/06/100677.html</id>
    <published>2023-06-19T06:20:00.000Z</published>
    <updated>2023-06-20T01:00:24.723Z</updated>
    
    <content type="html"><![CDATA[<p>使用Qt库开发的应用程序，一般有两种发布方式：（1）静态编译发布。这种方式使得程序在编译的时候会将Qt核心库全部编译到一个可执行文件中。其优势是简单单一，所有的依赖库都集中在一起，其缺点也很明显，可执行程序体量较大，光Qt核心库加起来就得十多兆。（2）制作安装包发布。这种方式的原理也简单，就是将可执行程序和其依赖的库文件一起打包压缩，制作成安装包发布。</p><p>制作安装包的工具挺多，一般使用最多的是Qt官方的安装包制作框架 Qt installer framework  (QtIFW) ，广泛应用于 Qt SDK, Qt Creator 等安装包产品。第三方的如 MSYS2 也是使用的 QTIF。</p><p>制作安装包只需要简单的配置就可以生成安装文件，同时可以通过javascript脚本来定制安装过程。配置文件为config.xml。</p><h1 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h1><p>Qt Installer Framework (QtIFW) 是 Qt 官方提供的安装包制作框架。提供了一组工具和实用程序，用于一次性创建安装程序，并在所有支持的桌面 Qt 平台上部署它们，而无需重写源代码。安装程序将在运行它们的平台上具有本机外观：Linux、Microsoft Windows 和macOS。QT的Qt Creator和Qt Installer Framework (QtIFW) 自身的安装包都是由这个工具制作的，详细说明请访问 <a href="http://doc.qt.io/qtinstallerframework/index.html" target="_blank" rel="noopener">QtIFW的官方文档</a> 。</p><p>Qt Installer Framework  (QtIFW) 工具生成带有一组页面的安装程序，这些页面在安装、更新或卸载过程中指导用户。您提供可安装的内容并指定有关它的信息，例如产品和安装程序的名称以及许可协议的文本。</p><p>您可以通过向预定义页面添加小部件或通过添加整个页面为用户提供其他选项来自定义安装程序。您可以创建脚本以向安装程序添加操作。</p><h2 id="选择安装程序类型"><a href="#选择安装程序类型" class="headerlink" title="选择安装程序类型"></a>选择安装程序类型</h2><p>您可以根据您的用例为最终用户提供<em>离线</em>或<em>在线</em>安装程序，或两者兼而有之。</p><p>两个安装程序都安装了一个<em>维护工具</em>，以后可用于添加、更新和删除组件。脱机安装程序包含所有可安装组件，并且在安装过程中不需要网络连接。在线安装程序只安装维护工具，然后从 Web 服务器上的在线存储库下载和安装组件。因此，与离线安装程序二进制文件相比，在线安装程序二进制文件的大小更小，下载时间也更短。如果最终用户没有安装所有可用的组件，下载和运行在线安装程序的总时间也可能比下载和运行离线安装程序的时间短。</p><p>最终用户可以使用维护工具在初始安装后从服务器安装其他组件，以及在服务器上发布更新后立即接收内容的自动更新。但是，仅当您在离线安装程序配置中指定存储库地址或最终用户在维护工具设置中自己指定存储库地址时，这才适用于离线安装。</p><p>创建离线安装程序，使用户可以直接将安装包下载到介质上，以便稍后安装到计算机上。例如，您还可以在 CD-ROM 或 U 盘上分发安装包。</p><p>创建在线安装程序，使用户能够始终安装最新版本的内容二进制文件。</p><h2 id="促进更新"><a href="#促进更新" class="headerlink" title="促进更新"></a>促进更新</h2><p>提供在线存储库以向安装您的产品的最终用户推广更新。提供更新的最简单方法是重新创建存储库并将其上传到 Web 服务器。对于大型存储库，您只能更新更改的组件。</p><h2 id="为安装人员提供内容"><a href="#为安装人员提供内容" class="headerlink" title="为安装人员提供内容"></a>为安装人员提供内容</h2><p>您可以让其他内容提供商将组件作为附加组件添加到安装程序。组件提供者必须设置包含可安装组件的存储库，并将指向存储库的 URL 传递给最终用户。然后，最终用户必须在安装程序中配置 URL。附加组件在包管理器中可见。</p><h1 id="二-安装-QtIFW"><a href="#二-安装-QtIFW" class="headerlink" title="二. 安装 QtIFW"></a>二. 安装 QtIFW</h1><p>可以通过源代码编译或安装包安装Qt Installer Framework (QtIFW) 。为了简单起见，尽可能下载安装包去安装。</p><h2 id="方式一-通过源代码编译"><a href="#方式一-通过源代码编译" class="headerlink" title="方式一: 通过源代码编译"></a>方式一: 通过源代码编译</h2><p>以下步骤描述了如何自己构建 Qt 安装程序框架。如果您下载了框架的预构建版本，则可以跳过此步骤。</p><h3 id="支持的编译器"><a href="#支持的编译器" class="headerlink" title="支持的编译器"></a>支持的编译器</h3><p>Qt 安装程序框架可以使用 Microsoft Visual Studio 2013 和更新版本、GCC 4.7 和更新版本以及 Clang 3.1 和更新版本进行编译。目前，经过测试的 Windows 组合是 Qt 5.12.4 和 MSVC 2015。</p><h3 id="配置-Qt"><a href="#配置-Qt" class="headerlink" title="配置 Qt"></a>配置 Qt</h3><p>如果您使用<strong>静态构建的 Qt</strong> 来构建 Qt 安装程序框架，则不必提供 Qt 库，这使您能够将安装程序作为一个文件分发。如果您静态链接 OpenSSL 库，请阅读 <a href="http://doc.qt.io/qt-5/ssl.html" target="_blank" rel="noopener">http://doc.qt.io/qt-5/ssl.html</a> 中的 SSL 导入和导出限制。</p><p>支持的 Qt 版本是 5.12.7。</p><h4 id="为-Windows-配置-Qt"><a href="#为-Windows-配置-Qt" class="headerlink" title="为 Windows 配置 Qt"></a>为 Windows 配置 Qt</h4><p>我们建议您在为 Windows 配置 Qt 时使用以下选项：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure -prefix %CD%\qtbase -<span class="keyword">release</span> -<span class="keyword">static</span> -<span class="keyword">static</span>-runtime -accessibility -<span class="keyword">no</span>-icu -<span class="keyword">no</span>-<span class="keyword">sql</span>-sqlite -<span class="keyword">no</span>-qml-debug -nomake examples -nomake tests</span><br></pre></td></tr></table></figure><p>Build Qt:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmake (<span class="keyword">or</span> <span class="string">'mingw32-make'</span>) <span class="keyword">module</span>-qtbase <span class="keyword">module</span>-qtdeclarative <span class="keyword">module</span>-qttools <span class="keyword">module</span>-qttranslations <span class="keyword">module</span>-qtwinextras</span><br></pre></td></tr></table></figure><h4 id="为-Linux-配置-Qt"><a href="#为-Linux-配置-Qt" class="headerlink" title="为 Linux 配置 Qt"></a>为 Linux 配置 Qt</h4><p>我们建议您对 Linux 使用以下配置选项：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">configure</span> -prefix <span class="variable">$PWD</span>/qtbase -release -static -accessibility -qt-zlib -qt-libpng -qt-libjpeg -qt-xcb -qt-pcre -<span class="literal">no</span>-glib -<span class="literal">no</span>-cups -<span class="literal">no</span>-sql-sqlite -<span class="literal">no</span>-qml-<span class="literal">debug</span> -<span class="literal">no</span>-opengl -<span class="literal">no</span>-egl -<span class="literal">no</span>-xinput2 -<span class="literal">no</span>-sm -<span class="literal">no</span>-icu -nomake examples -nomake tests -<span class="literal">no</span>-libudev</span><br></pre></td></tr></table></figure><p>构建 Qt：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="keyword">module</span>-qtbase <span class="keyword">module</span>-qtdeclarative <span class="keyword">module</span>-qttools <span class="keyword">module</span>-qttranslations</span><br></pre></td></tr></table></figure><h4 id="为-macOS-配置-Qt"><a href="#为-macOS-配置-Qt" class="headerlink" title="为 macOS 配置 Qt"></a>为 macOS 配置 Qt</h4><p>我们建议您为macOS使用以下配置选项：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">configure</span> -prefix <span class="variable">$PWD</span>/qtbase -release -static -<span class="literal">no</span>-securetransport -accessibility -qt-zlib -qt-libpng -qt-libjpeg -<span class="literal">no</span>-cups -<span class="literal">no</span>-sql-sqlite -<span class="literal">no</span>-qml-<span class="literal">debug</span> -nomake examples -nomake tests -<span class="literal">no</span>-freetype</span><br></pre></td></tr></table></figure><p>构建 Qt：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make <span class="keyword">module</span>-qtbase <span class="keyword">module</span>-qtdeclarative <span class="keyword">module</span>-qttools <span class="keyword">module</span>-qttranslations</span><br></pre></td></tr></table></figure><h3 id="编译QtIFW"><a href="#编译QtIFW" class="headerlink" title="编译QtIFW"></a>编译QtIFW</h3><ol><li>从<a href="http://code.qt.io/cgit/installer-framework/installer-framework.git/克隆" target="_blank" rel="noopener">http://code.qt.io/cgit/installer-framework/installer-framework.git/克隆</a> Qt 安装程序框架源代码以获取工具的源代码。</li><li>通过从<strong>静态 Qt</strong> 运行“qmake”，然后是“make”或“nmake”来构建工具。</li></ol><h2 id="方式二-通过安装包安装"><a href="#方式二-通过安装包安装" class="headerlink" title="方式二: 通过安装包安装"></a>方式二: 通过安装包安装</h2><p>首先根据自己的平台（Linux或Windows等）去Qt官网下载Qt Installer Framework (QtIFW) 的安装包或者源码。官方下载：<a href="http://download.qt.io/official_releases/qt-installer-framework/" target="_blank" rel="noopener">http://download.qt.io/official_releases/qt-installer-framework/</a> 。</p><h2 id="QtIFW目录结构"><a href="#QtIFW目录结构" class="headerlink" title="QtIFW目录结构"></a>QtIFW目录结构</h2><p>安装好后，并不是一个直接可用的图形界面软件。而是提供了一些可执行的工具程序（Windows下是exe文件），然后根据规则，利用这些工具生成安装包。<br>假设安装在C:\Qt，则生成目录QtIFW-4.1.1，其中4.1.1是版本号。目录结构如下所示。</p><h3 id="1、bin"><a href="#1、bin" class="headerlink" title="1、bin"></a>1、bin</h3><p>bin中包含的就是我们需要用到的工具。最简单地，我们只用其中一个，叫binarycreator.exe</p><h3 id="2、doc"><a href="#2、doc" class="headerlink" title="2、doc"></a>2、doc</h3><p>doc中包含帮助文档。文档的格式是网页（html）。也可以去官方网站上查看文档。文档是英文。不过很详细。</p><h3 id="3、examples"><a href="#3、examples" class="headerlink" title="3、examples"></a>3、examples</h3><p>examples中包含了很多Qt Installer Framework (QtIFW) 的例子，这些示例说明了如何使用组件脚本来自定义安装程序。初学者只需要将例子作为模板，按照自己的情况修改即可。</p><p><strong>自带 Qt Installer Framework (QtIFW) 示例</strong></p><table><thead><tr><th>名称</th><th>简介</th></tr></thead><tbody><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-changeuserinterface-example.html" target="_blank" rel="noopener">Change Installer UI Example</a></td><td>使用组件脚本修改安装程序 UI。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-componenterror-example.html" target="_blank" rel="noopener">Component Error Example</a></td><td>如果无法安装组件，则使用组件脚本停止安装。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-dependencies-example.html" target="_blank" rel="noopener">Dependency Solving Example</a></td><td>使用组件的 package.xml 文件来定义组件之间的依赖关系和自动依赖关系。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-dynamicpage-example.html" target="_blank" rel="noopener">Dynamic Page Installer Example</a></td><td>使用组件脚本和动态页面来构建安装程序。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-hidecheckbox-example.html" target="_blank" rel="noopener">Hide Checkbox Example</a></td><td>使用组件的 package.xml 文件隐藏项目的复选框。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-modifyextract-example.html" target="_blank" rel="noopener">Modify Extract Installer Example</a></td><td>在组件脚本中使用提取归档挂钩来修改目标路径。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-online-example.html" target="_blank" rel="noopener">Online Installer Example</a></td><td>使用repogen 工具和配置文件设置在线安装程序。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-openreadme-example.html" target="_blank" rel="noopener">Open ReadMe Example</a></td><td>使用组件脚本添加一个复选框，用于在最终安装程序页面中打开自述文件。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-quitinstaller-example.html" target="_blank" rel="noopener">Quit Installer Example</a></td><td>使用组件脚本退出安装程序。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-registerfileextension-example.html" target="_blank" rel="noopener">Register File Extension Example</a></td><td>使用组件脚本在 Windows 上注册文件扩展名。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-repositorycategories-example.html" target="_blank" rel="noopener">Repository Categories Example</a></td><td>使用 RepositoryCategories 元素设置一个在线安装程序，其中存储库被分组。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-startmenu-example.html" target="_blank" rel="noopener">Start Menu Shortcut Example</a></td><td>使用组件脚本向 Windows 开始菜单添加条目。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-stylesheet-example.html" target="_blank" rel="noopener">Stylesheet Example</a></td><td>使用样式表自定义 UI。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-systeminfo-example.html" target="_blank" rel="noopener">System Information Example</a></td><td>在组件脚本中使用 systemInfo API 检查操作系统版本和位数。</td></tr><tr><td><a href="https://doc.qt.io/qtinstallerframework/qtinstallerframework-translations-example.html" target="_blank" rel="noopener">Translation Example</a></td><td>使用翻译来本地化安装程序页面和许可证。</td></tr></tbody></table><h3 id="4、Licenses"><a href="#4、Licenses" class="headerlink" title="4、Licenses"></a>4、Licenses</h3><p>Licenses中包含了Qt Installer Framework (QtIFW) 的Licenses，例如LGPL等。</p><h1 id="三-QtIFW制作安装包"><a href="#三-QtIFW制作安装包" class="headerlink" title="三. QtIFW制作安装包"></a>三. QtIFW制作安装包</h1><h2 id="安装程序工作流程"><a href="#安装程序工作流程" class="headerlink" title="安装程序工作流程"></a>安装程序工作流程</h2><p>离线和在线安装程序的最终用户体验是相似的。与您的应用程序一起，安装程序会安装一个维护工具，其中包含一个包管理器、一个更新程序和一个卸载程序。最终用户可以使用维护工具添加、更新和删除组件。维护工具连接到外部存储库以获取要添加或更新的组件。您可以在配置文件中指定存储库，或者最终用户可以在维护工具设置中指定它。</p><p>您可以支持以下最终用户工作流程：</p><ul><li>初始安装</li><li>添加组件</li><li>移除组件</li><li>更新组件</li><li>指定设置</li><li>从命令行使用</li></ul><h2 id="创建安装程序"><a href="#创建安装程序" class="headerlink" title="创建安装程序"></a>创建安装程序</h2><p>创建离线和在线安装程序需要执行以下步骤：</p><ol><li>为可安装组件创建一个<em>包目录</em>。有关更多信息，请参阅<a href="https://doc.qt.io/qtinstallerframework/ifw-component-description.html" target="_blank" rel="noopener">包目录</a>。</li><li>创建一个<code>config.xml</code>在<code>config</code>目录中调用的配置文件。它包含有关如何构建安装程序二进制文件和在线存储库的信息。有关文件格式和可用设置的更多信息，请参阅<a href="https://doc.qt.io/qtinstallerframework/ifw-globalconfig.html" target="_blank" rel="noopener">配置文件</a>。</li><li>创建一个<code>package.xml</code>在<code>packages\{component}\meta</code>目录中调用的包信息文件。它包含部署和安装过程的设置。有关更多信息，请参阅<a href="https://doc.qt.io/qtinstallerframework/ifw-component-description.html#meta-directory" target="_blank" rel="noopener">元目录</a>。</li><li>创建安装程序内容并将其复制到包目录。有关更多信息，请参阅<a href="https://doc.qt.io/qtinstallerframework/ifw-component-description.html#data-directory" target="_blank" rel="noopener">数据目录</a>。</li><li>对于在线安装程序，使用该<code>repogen</code>工具创建包含可安装内容的存储库并将存储库上传到 Web 服务器。</li><li>使用该<code>binarycreator</code>工具创建安装程序。有关更多信息，请参阅<a href="https://doc.qt.io/qtinstallerframework/ifw-tools.html" target="_blank" rel="noopener">工具</a>。</li></ol><h3 id="制作准备"><a href="#制作准备" class="headerlink" title="制作准备"></a>制作准备</h3><h4 id="1、目录结构"><a href="#1、目录结构" class="headerlink" title="1、目录结构"></a>1、目录结构</h4><p>用 Qt Installer Framework (QtIFW) 生成安装包时，必须先按照规范建立目录结构。<br>参考examples中的目录结构，例如examples/tutorial目录中的结构如下：</p><p>规范的目录结构中，包含一个config文件夹和一个packages文件夹。其中config文件夹中只包含一个config.xml文件，用于描述软件以及安装包的一些信息。packages文件夹包含了安装包的信息描述、行为描述以及数据。其中，packages中的每一个子文件夹都表示不同的软件，或者软件的一个模块或者部件，例如com.vendor.product1、com.vendor.product2等等。<br>其结构可能如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-packages</span><br><span class="line">    - com<span class="selector-class">.vendor</span><span class="selector-class">.root</span></span><br><span class="line">        - data</span><br><span class="line">        - meta</span><br><span class="line">    - com<span class="selector-class">.vendor</span><span class="selector-class">.root</span><span class="selector-class">.component1</span></span><br><span class="line">        - data</span><br><span class="line">        - meta</span><br><span class="line">    - com<span class="selector-class">.vendor</span><span class="selector-class">.root</span><span class="selector-class">.component1</span><span class="selector-class">.subcomponent1</span></span><br><span class="line">        - data</span><br><span class="line">        - meta</span><br><span class="line">    - com<span class="selector-class">.vendor</span><span class="selector-class">.root</span><span class="selector-class">.component2</span></span><br><span class="line">        - data</span><br><span class="line">        - meta</span><br></pre></td></tr></table></figure><p>对于简单的软件，可能只有一个模块，对应一个文件夹。<br>每个子文件夹下都有两个文件夹data和meta，前者包含了所有软件的数据，包括可执行文件、链接库文件、配置文件等等，将所有这些文件压缩成.7z压缩包后，放入此文件夹；后者包含了至少3个文件，installscript.qs、license.txt、package.xml，分别用于描述安装行为、许可信息、模块或软件的描述（用于选择模块的页面上），其中license.txt文件名可变，只需要在脚本中做相应修改即可。</p><h4 id="2、config-xml"><a href="#2、config-xml" class="headerlink" title="2、config.xml"></a>2、config.xml</h4><p>config/config.xml定义了安装程序的行为。</p><p>例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Installer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Name</span>&gt;</span>Your App<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Title</span>&gt;</span>Your App Installer<span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Publisher</span>&gt;</span>You<span class="tag">&lt;/<span class="name">Publisher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">StartMenuDir</span>&gt;</span>Your App<span class="tag">&lt;/<span class="name">StartMenuDir</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetDir</span>&gt;</span>@HomeDir@/Your App<span class="tag">&lt;/<span class="name">TargetDir</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ControlScript</span>&gt;</span>controller.qs<span class="tag">&lt;/<span class="name">ControlScript</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Installer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中各个标签的含义如下：</p><ul><li>&lt; Name&gt; 软件名称</li><li>&lt; Version&gt; 版本号</li><li>&lt; Title&gt; 安装程序窗口标题</li><li>&lt; Publisher&gt; 发布者名称</li><li>&lt; StartMenuDir&gt; 要生成的windows开始菜单目录</li><li>&lt; TargetDir&gt; 默认安装路径，您可以使用预定义的变量（嵌入在<a href="http://doc.qt.io/qt-5/qromancalendar.html" target="_blank" rel="noopener">@</a>字符中）作为元素的值，有关更多信息，请参阅<a href="https://doc.qt.io/qtinstallerframework/scripting.html#predefined-variables" target="_blank" rel="noopener">预定义变量</a> 。</li><li>&lt; ControlScript&gt; 自定义安装程序控制脚本的文件名。请参阅<a href="https://doc.qt.io/qtinstallerframework/noninteractive.html" target="_blank" rel="noopener">控制器脚本</a> 。</li></ul><p>config.xml支持的标签很多，不过多数都是可选的，只有上述这些是必须的。请参考官方文档 <a href="https://doc.qt.io/qtinstallerframework/ifw-globalconfig.html" target="_blank" rel="noopener">https://doc.qt.io/qtinstallerframework/ifw-globalconfig.html</a> ，根据需要添加标签。</p><h4 id="3、data"><a href="#3、data" class="headerlink" title="3、data"></a>3、data</h4><p>data文件夹下包含了你要发布的软件的全部数据文件，包括可执行文件、链接库文件、数据库、配置文件等等。将所有文件用.7z格式打包后，放在data文件夹下即可。</p><h4 id="4、meta-installscript-qs"><a href="#4、meta-installscript-qs" class="headerlink" title="4、meta/installscript.qs"></a>4、meta/installscript.qs</h4><p>installscript.qs的语言类似于javascript，用于定义安装软件包的行为（如果软件有多个组件，每个分别配置），例如是否默认选中、是否生成开始菜单快捷方式、是否生成桌面快捷方式、是否有额外的安装步骤需要添加到常规步骤中。具体说明请参考examples中的例子以及官方文档。installscript.qs官方文档链接：<a href="http://doc.qt.io/qtinstallerframework/scripting.html" target="_blank" rel="noopener">http://doc.qt.io/qtinstallerframework/scripting.html</a> 。</p><h4 id="5、meta-license-txt"><a href="#5、meta-license-txt" class="headerlink" title="5、meta/license.txt"></a>5、meta/license.txt</h4><p>将软件有关的许可信息，写在此文件中，会在安装过程中显示并要求用户同意。<br>文件名称可以修改，不过修改过后要修改package.xml中对应的脚本。</p><h4 id="6、meta-package-xml"><a href="#6、meta-package-xml" class="headerlink" title="6、meta/package.xml"></a>6、meta/package.xml</h4><p>meta/package.xml定义了安装包在处理此部件时要显示的信息。<br>例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">DisplayName</span>&gt;</span>The main component<span class="tag">&lt;/<span class="name">DisplayName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Description</span>&gt;</span>the main component of your app<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Version</span>&gt;</span>1.0.0-1<span class="tag">&lt;/<span class="name">Version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ReleaseDate</span>&gt;</span>2016-06-01<span class="tag">&lt;/<span class="name">ReleaseDate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Name</span>&gt;</span>com.vendor.product<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Licenses</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">License</span> <span class="attr">name</span>=<span class="string">"Your App Agreement"</span> <span class="attr">file</span>=<span class="string">"license.txt"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Default</span>&gt;</span>script<span class="tag">&lt;/<span class="name">Default</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Script</span>&gt;</span><span class="undefined">installscript.qs</span><span class="tag">&lt;/<span class="name">Script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">UserInterfaces</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">UserInterface</span>&gt;</span>page.ui<span class="tag">&lt;/<span class="name">UserInterface</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">UserInterfaces</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中各个标签的含义如下：</p><ul><li>&lt; DisplayName&gt; 显示的名称</li><li>&lt; Description&gt; 描述</li><li>&lt; Version&gt; 部件的版本号</li><li>&lt; ReleaseDate&gt; 发行日期</li><li>&lt; Name&gt; 部件名称（与文件夹名一致）</li><li>&lt; Licenses&gt; 许可信息名称以及许可文件名</li><li>&lt; Script&gt; 脚本文件，可选的。有关更多信息，请参阅<a href="https://doc.qt.io/qtinstallerframework/ifw-customizing-installers.html#adding-operations" target="_blank" rel="noopener">添加操作</a>。</li><li>&lt; UserInterfaces&gt; 额外的界面（如果需要的话，而且需要去installscript.qs中配置）</li></ul><p>同样地，支持的标签很多，不过多数都是可选的，上述这些也不一定是必须的。请参考官方文档 <a href="https://doc.qt.io/qtinstallerframework/ifw-component-description.html" target="_blank" rel="noopener">https://doc.qt.io/qtinstallerframework/ifw-component-description.html</a> ，根据需要添加标签。</p><h3 id="制作安装包"><a href="#制作安装包" class="headerlink" title="制作安装包"></a>制作安装包</h3><p>完成上述准备工作后，使用binarycreator.exe工具生成安装包。<br>需要在命令行中操作。在开始菜单中搜索cmd，或按下win+r输入cmd回车，打开命令行。转到刚才准备好的目录中。<br>例如：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\&gt;</span> cd Qt<span class="symbol">\Q</span>tIFW-4.1.1<span class="symbol">\e</span>xamples<span class="symbol">\y</span>ourapp </span><br><span class="line">C:<span class="symbol">\Q</span>t<span class="symbol">\Q</span>tIFW-4.1.1<span class="symbol">\e</span>xamples<span class="symbol">\y</span>ourapp&gt;..<span class="symbol">\.</span>.<span class="symbol">\b</span>in<span class="symbol">\b</span>inarycreator.exe -c config<span class="symbol">\c</span>onfig.xml -p packages YourInstaller.exe</span><br></pre></td></tr></table></figure><p>其中，路径一定要对，YourInstaller.exe是安装包文件名，换成你想要的名称即可</p><h1 id="四-参考"><a href="#四-参考" class="headerlink" title="四. 参考"></a>四. 参考</h1><p><a href="https://doc.qt.io/qtinstallerframework/ifw-reference.html" target="_blank" rel="noopener">https://doc.qt.io/qtinstallerframework/ifw-reference.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用Qt库开发的应用程序，一般有两种发布方式：（1）静态编译发布。这种方式使得程序在编译的时候会将Qt核心库全部编译到一个可执行文件中。其优势是简单单一，所有的依赖库都集中在一起，其缺点也很明显，可执行程序体量较大，光Qt核心库加起来就得十多兆。（2）制作安装包发布。这种方
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="qt" scheme="https://www.ljjyy.com/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>C/C++ 开源算法库</title>
    <link href="https://www.ljjyy.com/archives/2023/06/100670.html"/>
    <id>https://www.ljjyy.com/archives/2023/06/100670.html</id>
    <published>2023-06-19T04:00:00.000Z</published>
    <updated>2023-06-20T01:00:40.654Z</updated>
    
    <content type="html"><![CDATA[<p>本文收集各种 C 和 C++ 优质的科学计算算法开源代码库。数值优化的世界，这些算法库功能强大、快速、高效、优雅，拿去比较普通人编写的算法代码，会发现自己的代码卑贱的如同草芥蝼蚁一般。</p><h1 id="1-GSL"><a href="#1-GSL" class="headerlink" title="1. GSL"></a>1. GSL</h1><p><a href="http://www.gnu.org/software/gsl/" target="_blank" rel="noopener">GNU Scientific Library (GSL)</a> 是一个用于科学计算的C/C ++ 语言类库。有超过1000个函数，算是比较全面。不过在某些方面还有不足，比如优化没有遗传算法，粒子群算法等，积分性能不如cuba。</p><p>函数包括：</p><ul><li>复数</li><li>多项式的根</li><li>特殊功能</li><li>向量和矩阵</li><li>排列</li><li>排序</li><li>BLAS支持</li><li>线性代数</li><li>特征系统</li><li>快速傅立叶变换</li><li>正交</li><li>随机数</li><li>拟随机序列</li><li>随机分布</li><li>统计数据</li><li>直方图</li><li>n元组</li><li>蒙特卡洛积分</li><li>模拟退火</li><li>微分方程</li><li>插补</li><li>数值微分</li><li>切比雪夫逼近</li><li>系列加速</li><li>离散汉克尔变换</li><li>寻根</li><li>最小化</li><li>最小二乘拟合</li><li>物理常数</li><li>IEEE浮点数</li><li>离散小波变换</li><li>基础样条</li><li>运行统计</li><li>稀疏矩阵和线性代数</li></ul><h1 id="2-Cuba"><a href="#2-Cuba" class="headerlink" title="2. Cuba"></a>2. Cuba</h1><p><a href="http://www.feynarts.de/cuba/" target="_blank" rel="noopener">Cuba</a>提供四种积分方法库，包含三种蒙特卡洛积分和一种精确积分。这几个方法的性能要好于GSL中提供的蒙特卡洛积分。</p><h1 id="3-Boost"><a href="#3-Boost" class="headerlink" title="3. Boost"></a>3. Boost</h1><p><a href="https://www.boost.org/" target="_blank" rel="noopener">Boost</a> 是为 C++ 语言标准库提供扩展的一些 C++ 程序库的总称。其中也包含了和科学计算有关的库。</p><p>数学和数字库包括：</p><ul><li><p>Accumulators库：用于增量计算的累加器的框架</p></li><li><p>Integer库：提供一组有关整数处理的类</p></li><li><p>Interval库：处理区间概念的数学问题</p></li><li><p>Math库：数学领域的模板类和算法</p></li><li><p>Math Common Factor库：用于支持最大公约数和最小公倍数</p></li><li><p>Math/Special Functions库：数学上一些常用的函数</p></li><li><p>Math/Statistical Distributions库：用于单变量统计分布操作</p></li><li><p>Multi-Array库：多维容器</p></li><li><p>Numeric Conversion库：用于安全数字转换的一组函数</p></li><li><p>Operators库：允许用户在自己的类里仅定义少量的操作符，就可方便地自动生成其他操作符重载，而且保证正确的语义实现</p></li><li><p>Random库：专注于伪随机数的实现，有多种算法可以产生高质量的伪随机数</p></li><li><p>Rational库：实现了没有精度损失的有理数</p></li><li><p>uBLAS库：用于线性代数领域的数学库</p></li><li><p>Geometry库：用于解决几何问题的概念、原语和算法</p></li><li><p>Ratio库：根据C++ 0x标准N2661号建议，实现编译期的分数操作</p></li><li><p>Multiprecision库：提供比C++内置的整数、分数和浮点数精度更高的多精度数值运算功能</p></li><li><p>Odeint库：用于求解常微分方程的初值问题</p><p>其中分布函数包括：</p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/arcine_dist.html" target="_blank" rel="noopener">Arcsine Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/arcine_dist.html" target="_blank" rel="noopener">反正弦分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/bernoulli_dist.html" target="_blank" rel="noopener">Bernoulli Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/bernoulli_dist.html" target="_blank" rel="noopener">伯努利分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/beta_dist.html" target="_blank" rel="noopener">Beta Distribution</a> <a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/beta_dist.html" target="_blank" rel="noopener">Beta分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/binomial_dist.html" target="_blank" rel="noopener">Binomial Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/binomial_dist.html" target="_blank" rel="noopener">二项分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/cauchy_dist.html" target="_blank" rel="noopener">Cauchy-Lorentz Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/cauchy_dist.html" target="_blank" rel="noopener">柯西洛伦兹分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/chi_squared_dist.html" target="_blank" rel="noopener">Chi Squared Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/chi_squared_dist.html" target="_blank" rel="noopener">卡方分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/empirical_cdf.html" target="_blank" rel="noopener">Empirical Cumulative Distribution Function</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/empirical_cdf.html" target="_blank" rel="noopener">经验累积分布函数</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/exp_dist.html" target="_blank" rel="noopener">Exponential Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/exp_dist.html" target="_blank" rel="noopener">指数分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/extreme_dist.html" target="_blank" rel="noopener">Extreme Value Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/extreme_dist.html" target="_blank" rel="noopener">极值分配</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/f_dist.html" target="_blank" rel="noopener">F Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/f_dist.html" target="_blank" rel="noopener">F分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/gamma_dist.html" target="_blank" rel="noopener">Gamma (and Erlang) Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/gamma_dist.html" target="_blank" rel="noopener">伽玛（和Erlang）分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/geometric_dist.html" target="_blank" rel="noopener">Geometric Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/geometric_dist.html" target="_blank" rel="noopener">几何分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/hyperexponential_dist.html" target="_blank" rel="noopener">Hyperexponential Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/hyperexponential_dist.html" target="_blank" rel="noopener">超指数分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/hypergeometric_dist.html" target="_blank" rel="noopener">Hypergeometric Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/hypergeometric_dist.html" target="_blank" rel="noopener">超几何分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/inverse_chi_squared_dist.html" target="_blank" rel="noopener">Inverse Chi Squared Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/inverse_chi_squared_dist.html" target="_blank" rel="noopener">逆卡平方分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/inverse_gamma_dist.html" target="_blank" rel="noopener">Inverse Gamma Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/inverse_gamma_dist.html" target="_blank" rel="noopener">逆伽马分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/inverse_gaussian_dist.html" target="_blank" rel="noopener">Inverse Gaussian (or Inverse Normal) Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/inverse_gaussian_dist.html" target="_blank" rel="noopener">高斯逆分布（或正态逆分布）</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/kolmogorov_smirnov_dist.html" target="_blank" rel="noopener">Kolmogorov-Smirnov Distribution柯尔莫哥罗夫-斯米诺夫分布系</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/laplace_dist.html" target="_blank" rel="noopener">Laplace Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/laplace_dist.html" target="_blank" rel="noopener">拉普拉斯分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/logistic_dist.html" target="_blank" rel="noopener">Logistic Distribution增长分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/lognormal_dist.html" target="_blank" rel="noopener">Log Normal Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/lognormal_dist.html" target="_blank" rel="noopener">对数正态分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/negative_binomial_dist.html" target="_blank" rel="noopener">Negative Binomial Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/negative_binomial_dist.html" target="_blank" rel="noopener">负二项分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/nc_beta_dist.html" target="_blank" rel="noopener">Noncentral Beta Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/nc_beta_dist.html" target="_blank" rel="noopener">非中央Beta分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/nc_chi_squared_dist.html" target="_blank" rel="noopener">Noncentral Chi-Squared Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/nc_chi_squared_dist.html" target="_blank" rel="noopener">非中心卡方分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/nc_f_dist.html" target="_blank" rel="noopener">Noncentral F Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/nc_f_dist.html" target="_blank" rel="noopener">非中心F分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/nc_t_dist.html" target="_blank" rel="noopener">Noncentral T Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/nc_t_dist.html" target="_blank" rel="noopener">非中心T分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/normal_dist.html" target="_blank" rel="noopener">Normal (Gaussian) Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/normal_dist.html" target="_blank" rel="noopener">正态（高斯）分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/pareto.html" target="_blank" rel="noopener">Pareto Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/pareto.html" target="_blank" rel="noopener">帕累托分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/poisson_dist.html" target="_blank" rel="noopener">Poisson Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/poisson_dist.html" target="_blank" rel="noopener">泊松分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/rayleigh.html" target="_blank" rel="noopener">Rayleigh Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/rayleigh.html" target="_blank" rel="noopener">瑞利分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/skew_normal_dist.html" target="_blank" rel="noopener">Skew Normal Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/skew_normal_dist.html" target="_blank" rel="noopener">偏正态分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/students_t_dist.html" target="_blank" rel="noopener">Students t Distribution学生<em>t</em>-分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/triangular_dist.html" target="_blank" rel="noopener">Triangular Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/triangular_dist.html" target="_blank" rel="noopener">三角分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/uniform_dist.html" target="_blank" rel="noopener">Uniform Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/uniform_dist.html" target="_blank" rel="noopener">均匀分布</a></p><p><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/weibull_dist.html" target="_blank" rel="noopener">Weibull Distribution</a><a href="https://www.boost.org/doc/libs/1_76_0/libs/math/doc/html/math_toolkit/dist_ref/dists/weibull_dist.html" target="_blank" rel="noopener">威布尔分布</a></p></li></ul><h1 id="4-Eigen"><a href="#4-Eigen" class="headerlink" title="4. Eigen"></a>4. Eigen</h1><p><a href="https://eigen.tuxfamily.org/" target="_blank" rel="noopener">Eigen</a> 是一个线性算术的C++模板库，包括：线性代数、矩阵、矢量运算、数值分析以及相关算法。功能强大、快速、优雅以及支持多平台。</p><h1 id="5-MTL"><a href="#5-MTL" class="headerlink" title="5. MTL"></a>5. MTL</h1><p><a href="https://github.com/simunova/mtl4" target="_blank" rel="noopener">Matrix Template Library(MTL)</a>专注于线性代数相关的计算任务，如各种形式矩阵的生成(对角，共轭，稀疏，对称等)，相关的计算，变换，以及与一维向量的运算。</p><h1 id="6-FFTW"><a href="#6-FFTW" class="headerlink" title="6. FFTW"></a>6. FFTW</h1><p><a href="http://www.fftw.org/" target="_blank" rel="noopener">FFTW</a> 是一个C语言的快速傅立叶变换库。它包括复杂的，真实，对称的，多层面的，和并行转换，并且可以处理任意大小的efficiently.It阵列通常比其他免费提供的FFT实现更快，更与供应商的调整库（基准可在网页查阅）竞争。为了实现这一性能，它使用新的代码生成和运行时的自我优化技术（以及许多其他的技巧）。</p><h1 id="7-GAlib"><a href="#7-GAlib" class="headerlink" title="7. GAlib"></a>7. GAlib</h1><p><a href="http://web.mit.edu/galib/www/GAlib.html" target="_blank" rel="noopener">GAlib</a>遗传算法库，包含四种遗传算法，GAListGenome 链表形、GATreeGenome 树形、GAArrayGenome 数组形、GABinaryString 二进制串形。</p><h1 id="8-libGeneiAL"><a href="#8-libGeneiAL" class="headerlink" title="8. libGeneiAL"></a>8. libGeneiAL</h1><p><a href="http://www.geneial.org" target="_blank" rel="noopener">libGeneiAL</a>可扩展遗传算法库。它提供了一个框架，可通过使用自定义适应度函数在生成过程中最大化种群中染色体的适应度值来解决优化问题。该库为用户提供了高度的灵活性和可扩展性，同时还为核心功能提供了良好的可扩展性。</p><h1 id="9-libfgen"><a href="#9-libfgen" class="headerlink" title="9. libfgen"></a>9. libfgen</h1><p><a href="https://sourceforge.net/projects/libfgen/" target="_blank" rel="noopener">libfgen</a>是一个实现高效且可自定义的遗传算法（GA）的库。它还提供了粒子群优化（PSO）功能和用于实值函数最小化或模型拟合的接口。它是用C编写的，但是也可以使用C ++编译器进行编译。</p><p><strong>特征</strong></p><ul><li>人口数量固定，可快速高效地实施通用Analytics（分析）。</li><li>具有多种选择，变异和交叉类型的可定制GA。</li><li>应用程序可以提供自定义的种子，变异和交叉运算符。</li><li>线程安全的，可以将多个线程用于适应度计算或并发遗传算法的群岛。</li><li>具有类似于GA的API的粒子群优化算法。</li><li>使用GA或PSO的高级易用模型拟合和功能最小化界面。</li><li>在真实数据集上进行了测试（系外行星的轨道与恒星径向速度数据的拟合）。</li><li>使用提供的文档清除HTML（html）。</li><li>提供了命令行和图形示例程序。</li><li>例子包括旅行商问题，线性遗传规划和纹理压缩。</li></ul><h1 id="10-C-Wavelet-Libraries"><a href="#10-C-Wavelet-Libraries" class="headerlink" title="10. C++ Wavelet Libraries"></a>10. C++ Wavelet Libraries</h1><p><a href="http://wavelet2d.sourceforge.net/" target="_blank" rel="noopener">C++ Wavelet Libraries</a>是C ++小波变换算法库专注于速度和易用性。</p><p>可用功能包括</p><ul><li>一维DWT和IDWT实现（两种模式）</li><li>2DWT和IDWT的实现（两种模式）</li><li>一维SWT和ISWT实现（固定小波变换）</li><li>2D SWT实施</li><li>使用FFTW3库实现</li></ul><h1 id="11-KFilter"><a href="#11-KFilter" class="headerlink" title="11. KFilter"></a>11. KFilter</h1><p><a href="http://kalman.sourceforge.net/" target="_blank" rel="noopener">KFilter</a>卡尔曼滤波器的开源算法库。提供了可配置的模板类。子类允许为过滤器定义不同的矩阵内容。卡尔曼滤波器在航空，机器人视觉和机器人技术中已经使用了一段时间。估计状态向量并通过使用从传感器获取的度量来校正估计是有用的。它的主要用途是用于跟踪或数据融合。</p><h1 id="12-Dlib"><a href="#12-Dlib" class="headerlink" title="12. Dlib"></a>12. Dlib</h1><p><a href="http://dlib.net/" target="_blank" rel="noopener">Dlib</a>主要为深度学习服务的算法库，包含深度学习相关的优化算法，也包含一些图形图像处理，主要为深度学习的实现服务。被广泛的用在行业和学术领域，包括机器人，嵌入式设备，移动电话和大型高性能计算环境。</p><h1 id="13-MRPT"><a href="#13-MRPT" class="headerlink" title="13. MRPT"></a>13. MRPT</h1><p><a href="https://www.mrpt.org" target="_blank" rel="noopener">Mobile Robot Programming Toolkit （MRPT）</a>机器人编程算法库，主要是机器人相关的定位，计算机视觉图像处理，运动规划相关的算法。</p><h1 id="14-Algorithms-C"><a href="#14-Algorithms-C" class="headerlink" title="14. Algorithms - C++"></a>14. Algorithms - C++</h1><p><a href="https://thealgorithms.github.io/C-Plus-Plus/" target="_blank" rel="noopener">Algorithms - C++</a>算法涵盖了计算机科学，数学和统计学，数据科学，机器学习，工程等多个主题。</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/graph_coloring.cpp" target="_blank" rel="noopener">图形着色</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/knight_tour.cpp" target="_blank" rel="noopener">骑士之旅</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/minimax.cpp" target="_blank" rel="noopener">极小值</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/n_queens.cpp" target="_blank" rel="noopener">N皇后区</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/n_queens_all_solution_optimised.cpp" target="_blank" rel="noopener">N Queens所有解决方案均已优化</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/nqueen_print_all_solutions.cpp" target="_blank" rel="noopener">Nqueen打印所有解决方案</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/rat_maze.cpp" target="_blank" rel="noopener">老鼠迷宫</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/backtracking/sudoku_solve.cpp" target="_blank" rel="noopener">数独解决</a></li></ul><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/bit_manipulation/hamming_distance.cpp" target="_blank" rel="noopener">汉明距离</a></li></ul><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/ciphers/caesar_cipher.cpp" target="_blank" rel="noopener">凯撒密码</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/ciphers/hill_cipher.cpp" target="_blank" rel="noopener">希尔密码</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/ciphers/morse_code.cpp" target="_blank" rel="noopener">摩尔斯电码</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/ciphers/vigenere_cipher.cpp" target="_blank" rel="noopener">Vigenere密码</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/ciphers/xor_cipher.cpp" target="_blank" rel="noopener">Xor密码</a></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/avltree.cpp" target="_blank" rel="noopener">AVL树</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/binary_search_tree.cpp" target="_blank" rel="noopener">二进制搜索树</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/binary_search_tree2.cpp" target="_blank" rel="noopener">二进制搜索树2</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/binaryheap.cpp" target="_blank" rel="noopener">二进制堆</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/circular_queue_using_linked_list.cpp" target="_blank" rel="noopener">使用链表的循环队列</a></li><li>循环链表<ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/cll/cll.cpp" target="_blank" rel="noopener">循环链表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/cll/cll.h" target="_blank" rel="noopener">循环链表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/cll/main_cll.cpp" target="_blank" rel="noopener">main cll</a></li></ul></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/disjoint_set.cpp" target="_blank" rel="noopener">不相交集</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/doubly_linked_list.cpp" target="_blank" rel="noopener">双链表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/linked_list.cpp" target="_blank" rel="noopener">链表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/linkedlist_implentation_usingarray.cpp" target="_blank" rel="noopener">链表实现使用数组</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/list_array.cpp" target="_blank" rel="noopener">列表数组</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/morrisinorder.cpp" target="_blank" rel="noopener">莫里森阶</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/queue.h" target="_blank" rel="noopener">队列</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/queue_using_array.cpp" target="_blank" rel="noopener">使用数组排队</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/queue_using_array2.cpp" target="_blank" rel="noopener">使用Array2进行排队</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/queue_using_linked_list.cpp" target="_blank" rel="noopener">使用链接列表排队</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/queue_using_linkedlist.cpp" target="_blank" rel="noopener">使用链表排队</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/queue_using_two_stacks.cpp" target="_blank" rel="noopener">使用两个堆栈进行排队</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/skip_list.cpp" target="_blank" rel="noopener">跳过清单</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/stack.h" target="_blank" rel="noopener">堆</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/stack_using_array.cpp" target="_blank" rel="noopener">使用数组堆叠</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/stack_using_linked_list.cpp" target="_blank" rel="noopener">使用链表堆叠</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/test_queue.cpp" target="_blank" rel="noopener">测试队列</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/test_stack.cpp" target="_blank" rel="noopener">测试堆栈</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/test_stack_students.cpp" target="_blank" rel="noopener">考试堆栈学生</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/tree.cpp" target="_blank" rel="noopener">树</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/tree_234.cpp" target="_blank" rel="noopener">树234</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/trie_modern.cpp" target="_blank" rel="noopener">特里现代</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/data_structures/trie_tree.cpp" target="_blank" rel="noopener">特里树</a></li></ul><h2 id="动态编程"><a href="#动态编程" class="headerlink" title="动态编程"></a>动态编程</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/0_1_knapsack.cpp" target="_blank" rel="noopener">0 1背包</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/armstrong_number.cpp" target="_blank" rel="noopener">阿姆斯特朗数</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/bellman_ford.cpp" target="_blank" rel="noopener">贝尔曼·福特（Bellman Ford）</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/catalan_numbers.cpp" target="_blank" rel="noopener">加泰罗尼亚语数字</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/coin_change.cpp" target="_blank" rel="noopener">硬币找零</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/coin_change_topdown.cpp" target="_blank" rel="noopener">硬币找零自上而下</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/cut_rod.cpp" target="_blank" rel="noopener">切杆</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/edit_distance.cpp" target="_blank" rel="noopener">编辑距离</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/egg_dropping_puzzle.cpp" target="_blank" rel="noopener">鸡蛋丢拼图</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/fibonacci_bottom_up.cpp" target="_blank" rel="noopener">斐波那契自下而上</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/floyd_warshall.cpp" target="_blank" rel="noopener">弗洛伊德·沃沙尔（Floyd Warshall）</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/kadane.cpp" target="_blank" rel="noopener">kadane</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/kadane2.cpp" target="_blank" rel="noopener">kadane 2</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/longest_common_string.cpp" target="_blank" rel="noopener">最长的普通琴弦</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/longest_common_subsequence.cpp" target="_blank" rel="noopener">最长公共子序列</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/longest_increasing_subsequence.cpp" target="_blank" rel="noopener">最长递增子序列</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/longest_increasing_subsequence_(nlogn" target="_blank" rel="noopener">最长递增子序列（Nlogn）</a>.cpp)</li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/longest_palindromic_subsequence.cpp" target="_blank" rel="noopener">最长回文序列</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/matrix_chain_multiplication.cpp" target="_blank" rel="noopener">矩阵链乘法</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/palindrome_partitioning.cpp" target="_blank" rel="noopener">回文分区</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/searching_of_element_in_dynamic_array.cpp" target="_blank" rel="noopener">动态数组中元素的搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/shortest_common_supersequence.cpp" target="_blank" rel="noopener">最短的通用超序列</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/tree_height.cpp" target="_blank" rel="noopener">树高</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/word_break.cpp" target="_blank" rel="noopener">断字</a></li></ul><h2 id="几何学"><a href="#几何学" class="headerlink" title="几何学"></a>几何学</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/jarvis_algorithm.cpp" target="_blank" rel="noopener">Jarvis算法</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/geometry/line_segment_intersection.cpp" target="_blank" rel="noopener">线段相交</a></li></ul><h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/bidirectional_dijkstra.cpp" target="_blank" rel="noopener">双向最短路径算法</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/breadth_first_search.cpp" target="_blank" rel="noopener">广度优先搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/bridge_finding_with_tarjan_algorithm.cpp" target="_blank" rel="noopener">无向图所有割边的<em>Tarjan</em>算法</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/connected_components.cpp" target="_blank" rel="noopener">连接的组件</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/connected_components_with_dsu.cpp" target="_blank" rel="noopener">使用Dsu连接组件</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/cycle_check_directed_graph.cpp" target="_blank" rel="noopener">循环检查有向图</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/depth_first_search.cpp" target="_blank" rel="noopener">深度优先搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/depth_first_search_with_stack.cpp" target="_blank" rel="noopener">深度优先搜索堆栈</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/dijkstra.cpp" target="_blank" rel="noopener">迪克斯特拉</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/hamiltons_cycle.cpp" target="_blank" rel="noopener">汉密尔顿周期</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/hopcroft_karp.cpp" target="_blank" rel="noopener">霍普克罗夫特·卡普（Hopcroft Karp）</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/is_graph_bipartite.cpp" target="_blank" rel="noopener">图是二分图的吗</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/kosaraju.cpp" target="_blank" rel="noopener">Kosaraju</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/kruskal.cpp" target="_blank" rel="noopener">克鲁斯卡尔</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/lowest_common_ancestor.cpp" target="_blank" rel="noopener">最低共同祖先</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/max_flow_with_ford_fulkerson_and_edmond_karp_algo.cpp" target="_blank" rel="noopener">福特·富尔克森和埃德蒙·卡普·阿尔戈</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/prim.cpp" target="_blank" rel="noopener">原始</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/topological_sort.cpp" target="_blank" rel="noopener">拓扑排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graph/topological_sort_by_kahns_algo.cpp" target="_blank" rel="noopener">拓扑排序按Kahns Algo</a></li></ul><h2 id="图形学"><a href="#图形学" class="headerlink" title="图形学"></a>图形学</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/graphics/spirograph.cpp" target="_blank" rel="noopener">旋描仪</a></li></ul><h2 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/greedy_algorithms/dijkstra.cpp" target="_blank" rel="noopener">迪克斯特拉</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/greedy_algorithms/huffman.cpp" target="_blank" rel="noopener">霍夫曼</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/greedy_algorithms/jumpgame.cpp" target="_blank" rel="noopener">跳跃游戏</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/greedy_algorithms/knapsack.cpp" target="_blank" rel="noopener">背包</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/greedy_algorithms/kruskals_minimum_spanning_tree.cpp" target="_blank" rel="noopener">Kruskals最小生成树</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/greedy_algorithms/prims_minimum_spanning_tree.cpp" target="_blank" rel="noopener">Prims最小生成树</a></li></ul><h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/hashing/chaining.cpp" target="_blank" rel="noopener">链式</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/hashing/double_hash_hash_table.cpp" target="_blank" rel="noopener">双哈希哈希表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/hashing/linear_probing_hash_table.cpp" target="_blank" rel="noopener">线性探测哈希表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/hashing/quadratic_probing_hash_table.cpp" target="_blank" rel="noopener">二次探测哈希表</a></li></ul><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/linear_algebra/gram_schmidt.cpp" target="_blank" rel="noopener">克·施密特（Gram Schmidt）</a></li></ul><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/machine_learning/adaline_learning.cpp" target="_blank" rel="noopener">Adaline学习</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/machine_learning/kohonen_som_topology.cpp" target="_blank" rel="noopener">Kohonen Som拓扑</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/machine_learning/kohonen_som_trace.cpp" target="_blank" rel="noopener">Kohonen Som Trace</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/machine_learning/neural_network.cpp" target="_blank" rel="noopener">神经网络</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/machine_learning/ordinary_least_squares_regressor.cpp" target="_blank" rel="noopener">普通最小二乘回归器</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/machine_learning/vector_ops.hpp" target="_blank" rel="noopener">矢量操作</a></li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/armstrong_number.cpp" target="_blank" rel="noopener">阿姆斯特朗数</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/binary_exponent.cpp" target="_blank" rel="noopener">二元指数</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/binomial_calculate.cpp" target="_blank" rel="noopener">二项式计算</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/check_amicable_pair.cpp" target="_blank" rel="noopener">检查友好对</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/check_factorial.cpp" target="_blank" rel="noopener">检查阶乘</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/check_prime.cpp" target="_blank" rel="noopener">检查Prime</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/complex_numbers.cpp" target="_blank" rel="noopener">复数</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/double_factorial.cpp" target="_blank" rel="noopener">双阶乘</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/eulers_totient_function.cpp" target="_blank" rel="noopener">欧拉Totient功能</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/extended_euclid_algorithm.cpp" target="_blank" rel="noopener">扩展欧几里得算法</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/factorial.cpp" target="_blank" rel="noopener">阶乘</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/fast_power.cpp" target="_blank" rel="noopener">快速电源</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/fibonacci.cpp" target="_blank" rel="noopener">斐波那契</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/fibonacci_fast.cpp" target="_blank" rel="noopener">斐波那契快速</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/fibonacci_large.cpp" target="_blank" rel="noopener">斐波那契大</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/fibonacci_matrix_exponentiation.cpp" target="_blank" rel="noopener">斐波那契矩阵求幂</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/fibonacci_sum.cpp" target="_blank" rel="noopener">斐波那契总和</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/gcd_iterative_euclidean.cpp" target="_blank" rel="noopener">Gcd迭代欧几里得</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/gcd_of_n_numbers.cpp" target="_blank" rel="noopener">N个数字的Gcd</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/gcd_recursive_euclidean.cpp" target="_blank" rel="noopener">Gcd递归欧几里得</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/large_factorial.cpp" target="_blank" rel="noopener">大阶乘</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/large_number.h" target="_blank" rel="noopener">大数字</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/largest_power.cpp" target="_blank" rel="noopener">最大功率</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/lcm_sum.cpp" target="_blank" rel="noopener">Lcm总和</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/least_common_multiple.cpp" target="_blank" rel="noopener">最小公倍数</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/magic_number.cpp" target="_blank" rel="noopener">幻数</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/miller_rabin.cpp" target="_blank" rel="noopener">米勒·拉宾（Miller Rabin）</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_division.cpp" target="_blank" rel="noopener">模块化部门</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_exponentiation.cpp" target="_blank" rel="noopener">模幂</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/modular_inverse_fermat_little_theorem.cpp" target="_blank" rel="noopener">模逆费马小定理</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/n_choose_r.cpp" target="_blank" rel="noopener">N选择R</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/ncr_modulo_p.cpp" target="_blank" rel="noopener">Ncr模数P</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/number_of_positive_divisors.cpp" target="_blank" rel="noopener">正除数的数量</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/power_for_huge_numbers.cpp" target="_blank" rel="noopener">大量数字的力量</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/power_of_two.cpp" target="_blank" rel="noopener">二的力量</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/prime_factorization.cpp" target="_blank" rel="noopener">素因数分解</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/prime_numbers.cpp" target="_blank" rel="noopener">质数</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/primes_up_to_billion.cpp" target="_blank" rel="noopener">灌注至十亿</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/realtime_stats.cpp" target="_blank" rel="noopener">实时统计</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/sieve_of_eratosthenes.cpp" target="_blank" rel="noopener">Eratosthenes筛</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/sqrt_double.cpp" target="_blank" rel="noopener">平方双</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/string_fibonacci.cpp" target="_blank" rel="noopener">弦斐波那契</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/sum_of_binomial_coefficient.cpp" target="_blank" rel="noopener">二项式系数之和</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/sum_of_digits.cpp" target="_blank" rel="noopener">数字总和</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/math/vector_cross_product.cpp" target="_blank" rel="noopener">矢量叉积</a></li></ul><h2 id="数值方法"><a href="#数值方法" class="headerlink" title="数值方法"></a>数值方法</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/bisection_method.cpp" target="_blank" rel="noopener">二等分法</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/brent_method_extrema.cpp" target="_blank" rel="noopener">布伦特方法极值</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/durand_kerner_roots.cpp" target="_blank" rel="noopener">杜兰德·克纳（Durand Kerner Roots）</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/false_position.cpp" target="_blank" rel="noopener">错误的位置</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/gaussian_elimination.cpp" target="_blank" rel="noopener">高斯消除</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/golden_search_extrema.cpp" target="_blank" rel="noopener">黄金搜索极值</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/lu_decompose.cpp" target="_blank" rel="noopener">卢分解</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/lu_decomposition.h" target="_blank" rel="noopener">卢分解</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/newton_raphson_method.cpp" target="_blank" rel="noopener">牛顿拉夫森法</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/ode_forward_euler.cpp" target="_blank" rel="noopener">颂歌前奏欧拉</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/ode_midpoint_euler.cpp" target="_blank" rel="noopener">颂德中点欧拉</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/ode_semi_implicit_euler.cpp" target="_blank" rel="noopener">颂德半隐式欧拉</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/qr_decompose.h" target="_blank" rel="noopener">Qr分解</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/qr_decomposition.cpp" target="_blank" rel="noopener">Qr分解</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/qr_eigen_values.cpp" target="_blank" rel="noopener">Qr本征值</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/rungekutta.cpp" target="_blank" rel="noopener">龙格库塔</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/numerical_methods/successive_approximation.cpp" target="_blank" rel="noopener">逐次逼近</a></li></ul><h2 id="数据结构操作"><a href="#数据结构操作" class="headerlink" title="数据结构操作"></a>数据结构操作</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/array_left_rotation.cpp" target="_blank" rel="noopener">阵列左旋转</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/array_right_rotation.cpp" target="_blank" rel="noopener">阵列向右旋转</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/circular_linked_list.cpp" target="_blank" rel="noopener">通报链表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/circular_queue_using_array.cpp" target="_blank" rel="noopener">使用数组的循环队列</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/get_size_of_linked_list.cpp" target="_blank" rel="noopener">获取链接列表的大小</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/intersection_of_2_arrays.cpp" target="_blank" rel="noopener">2个数组的交集</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/reverse_a_linked_list_using_recusion.cpp" target="_blank" rel="noopener">使用撤消反向链接列表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/selectionsortlinkedlist.cpp" target="_blank" rel="noopener">选择排序链表</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/trie_multiple_search.cpp" target="_blank" rel="noopener">尝试多重搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/operations_on_datastructures/union_of_2_arrays.cpp" target="_blank" rel="noopener">2个数组的并集</a></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/buzz_number.cpp" target="_blank" rel="noopener">蜂鸣号</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/decimal_to_binary.cpp" target="_blank" rel="noopener">十进制到二进制</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/decimal_to_hexadecimal.cpp" target="_blank" rel="noopener">十进制到十六进制</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/decimal_to_roman_numeral.cpp" target="_blank" rel="noopener">十进制到罗马数字</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/fast_integer_input.cpp" target="_blank" rel="noopener">快速整数输入</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/happy_number.cpp" target="_blank" rel="noopener">快乐号码</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/matrix_exponentiation.cpp" target="_blank" rel="noopener">矩阵求幂</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/palindrome_of_number.cpp" target="_blank" rel="noopener">数字回文</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/paranthesis_matching.cpp" target="_blank" rel="noopener">肢体匹配</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/pascal_triangle.cpp" target="_blank" rel="noopener">帕斯卡三角形</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/postfix_evaluation.cpp" target="_blank" rel="noopener">后缀评估</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/primality_test.cpp" target="_blank" rel="noopener">原始性测试</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/smallest_circle.cpp" target="_blank" rel="noopener">最小圆</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/sparse_matrix.cpp" target="_blank" rel="noopener">稀疏矩阵</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/spiral_print.cpp" target="_blank" rel="noopener">螺旋印花</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/stairs_pattern.cpp" target="_blank" rel="noopener">楼梯图案</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/tower_of_hanoi.cpp" target="_blank" rel="noopener">河内塔</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/others/vector_important_functions.cpp" target="_blank" rel="noopener">向量重要功能</a></li></ul><h2 id="可能性"><a href="#可能性" class="headerlink" title="可能性"></a>可能性</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/probability/addition_rule.cpp" target="_blank" rel="noopener">加法规则</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/probability/bayes_theorem.cpp" target="_blank" rel="noopener">贝叶斯定理</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/probability/binomial_dist.cpp" target="_blank" rel="noopener">二项式距离</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/probability/poisson_dist.cpp" target="_blank" rel="noopener">泊松区</a></li></ul><h2 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/range_queries/fenwick_tree.cpp" target="_blank" rel="noopener">芬威克树</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/range_queries/heavy_light_decomposition.cpp" target="_blank" rel="noopener">重光分解</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/range_queries/mo.cpp" target="_blank" rel="noopener">莫</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/range_queries/persistent_seg_tree_lazy_prop.cpp" target="_blank" rel="noopener">持久的Seg树懒惰支柱</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/range_queries/segtree.cpp" target="_blank" rel="noopener">赛格特里</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/range_queries/sparse_table.cpp" target="_blank" rel="noopener">稀疏表</a></li></ul><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/binary_search.cpp" target="_blank" rel="noopener">二元搜寻</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/exponential_search.cpp" target="_blank" rel="noopener">指数搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/fibonacci_search.cpp" target="_blank" rel="noopener">斐波那契搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/hash_search.cpp" target="_blank" rel="noopener">哈希搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/interpolation_search.cpp" target="_blank" rel="noopener">插值搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/interpolation_search2.cpp" target="_blank" rel="noopener">插值搜索2</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/jump_search.cpp" target="_blank" rel="noopener">跳转搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/linear_search.cpp" target="_blank" rel="noopener">线性搜寻</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/median_search.cpp" target="_blank" rel="noopener">中位数搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/saddleback_search.cpp" target="_blank" rel="noopener">鞍背搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/ternary_search.cpp" target="_blank" rel="noopener">三元搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/search/text_search.cpp" target="_blank" rel="noopener">文字搜寻</a></li></ul><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/bead_sort.cpp" target="_blank" rel="noopener">珠子排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/bitonic_sort.cpp" target="_blank" rel="noopener">双音排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/bogo_sort.cpp" target="_blank" rel="noopener">宝高排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/bubble_sort.cpp" target="_blank" rel="noopener">气泡排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/bucket_sort.cpp" target="_blank" rel="noopener">桶分类</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/cocktail_selection_sort.cpp" target="_blank" rel="noopener">鸡尾酒选择排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/comb_sort.cpp" target="_blank" rel="noopener">梳状排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/count_inversions.cpp" target="_blank" rel="noopener">计数反转</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/counting_sort.cpp" target="_blank" rel="noopener">计数排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/counting_sort_string.cpp" target="_blank" rel="noopener">计数排序字符串</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/cycle_sort.cpp" target="_blank" rel="noopener">循环排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/gnome_sort.cpp" target="_blank" rel="noopener">侏儒排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/heap_sort.cpp" target="_blank" rel="noopener">堆排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/insertion_sort.cpp" target="_blank" rel="noopener">插入排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/library_sort.cpp" target="_blank" rel="noopener">图书馆排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/merge_insertion_sort.cpp" target="_blank" rel="noopener">合并插入排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/merge_sort.cpp" target="_blank" rel="noopener">合并排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/non_recursive_merge_sort.cpp" target="_blank" rel="noopener">非递归合并排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/numeric_string_sort.cpp" target="_blank" rel="noopener">数字字符串排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/odd_even_sort.cpp" target="_blank" rel="noopener">奇偶排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/pancake_sort.cpp" target="_blank" rel="noopener">薄煎饼排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/pigeonhole_sort.cpp" target="_blank" rel="noopener">鸽眼排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/quick_sort.cpp" target="_blank" rel="noopener">快速排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/quick_sort_3.cpp" target="_blank" rel="noopener">快速排序3</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/radix_sort.cpp" target="_blank" rel="noopener">基数排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/radix_sort2.cpp" target="_blank" rel="noopener">基数排序2</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/selection_sort.cpp" target="_blank" rel="noopener">选择排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/shell_sort.cpp" target="_blank" rel="noopener">贝壳排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/shell_sort2.cpp" target="_blank" rel="noopener">壳牌Sort2</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/slow_sort.cpp" target="_blank" rel="noopener">慢排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/strand_sort.cpp" target="_blank" rel="noopener">链排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/swap_sort.cpp" target="_blank" rel="noopener">掉期排序</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/tim_sort.cpp" target="_blank" rel="noopener">蒂姆·索特（Tim Sort）</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/sorting/wiggle_sort.cpp" target="_blank" rel="noopener">摆动排序</a></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/strings/brute_force_string_searching.cpp" target="_blank" rel="noopener">蛮力字符串搜索</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/strings/horspool.cpp" target="_blank" rel="noopener">霍斯浦</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/strings/knuth_morris_pratt.cpp" target="_blank" rel="noopener">克努斯·莫里斯·普拉特（Knuth Morris Pratt）</a></li><li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/strings/rabin_karp.cpp" target="_blank" rel="noopener">拉宾·卡普（Rabin Karp）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文收集各种 C 和 C++ 优质的科学计算算法开源代码库。数值优化的世界，这些算法库功能强大、快速、高效、优雅，拿去比较普通人编写的算法代码，会发现自己的代码卑贱的如同草芥蝼蚁一般。&lt;/p&gt;
&lt;h1 id=&quot;1-GSL&quot;&gt;&lt;a href=&quot;#1-GSL&quot; class=&quot;h
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="c++" scheme="https://www.ljjyy.com/tags/c/"/>
    
      <category term="c" scheme="https://www.ljjyy.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Qt项目升级到Qt6移植总结</title>
    <link href="https://www.ljjyy.com/archives/2023/06/100679.html"/>
    <id>https://www.ljjyy.com/archives/2023/06/100679.html</id>
    <published>2023-06-11T06:20:00.000Z</published>
    <updated>2023-06-20T00:59:52.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Qt 6.2 也是 Qt 6 的第一个版本，Qt 公司将为 Qt 商业客户提供长期支持。</p><p>在 Qt 6.2 中，包含了 Qt 5.15 中的所有常用功能以及为 Qt 6 添加的新功能。随着 Qt 6.2 的发布，几乎所有的用户都应该能够将他们的代码从 Qt 5 迁移到 Qt 6。</p><p>目前Qt的支持路线为：Qt5.15.2编译的程序支持WIN7及以上的系统，Qt5.6.3编译的程序支持XP系统。</p><h1 id="二、Qt-6-的架构变化"><a href="#二、Qt-6-的架构变化" class="headerlink" title="二、Qt 6 的架构变化"></a>二、Qt 6 的架构变化</h1><p>我们在 Qt 6 中进行了一些更广泛的架构更改，我们现在正在构建 Qt 6.2 和任何未来版本。</p><ul><li>利用 C++17 在处理 Qt 6 时，我们希望建立在现代 C++ 标准之上。C++17 是最新发布的版本，而 Qt 6 现在依赖于 C++17 兼容编译器。这使得我们可以清理和改进我们的代码库，并为我们的用户提供更现代的 API。</li><li>在处理大型数据集和性能方面改进了我们的低级容器类。</li><li>下一代 QML 我们已经开始更加努力地更新 QML 语言，使其在未来更安全、更易于使用。Qt 6.0 – 6.2 在这里奠定了基础，但这种持续的努力将在整个 Qt 6 系列中继续进行。</li><li>将属性绑定引入 C++ 属性绑定是使 QML 如此成功的概念之一。在 Qt 6 中，我们一直在 C++ 中提供该概念 。</li><li>新的图形架构 Qt 6 在如何处理与底层操作系统 API 的集成方面采用了 全新的架构。得益于新的渲染硬件接口 (RHI)，Qt 6 现在默认使用每个系统上可用的最佳图形 API，显着提高了兼容性——尤其是在桌面和移动操作系统（如 Windows 和 macOS 以及 iOS）上。</li><li>Qt Quick 的统一 2D 和 3D Qt Quick 一直是构建动画和流畅的 2D 用户界面的框架。使用 Qt 6，我们也简化了将 3D 内容集成到基于 QML 的应用程序的过程。深度集成使得在任何级别混合 2D 和 3D 内容变得微不足道，同时从系统中获得最大性能。</li><li>CMake 构建系统 在 Qt 6 中，我们将构建系统从 qmake切换到 cmake，这是当今基于 C++ 的应用程序的标准构建系统。虽然在 Qt 6 的整个生命周期内仍支持 qmake，但初步用户报告表明切换到 cmake 后有显着改进。</li></ul><h1 id="三、添加模块"><a href="#三、添加模块" class="headerlink" title="三、添加模块"></a>三、添加模块</h1><p>开发 Qt 6.2 的主要工作之一是重新添加我们在 Qt 6.0 中遗漏的所有模块和功能。除了极少数例外，Qt 5.15 支持的所有模块现在也支持 Qt 6.2。</p><p>在 Qt 6.2 中，我们添加了对以下附加模块的支持（在 Qt 6.1 中已有的模块之上）：</p><ul><li>Qt Bluetooth</li><li>Qt Multimedia</li><li>Qt NFC</li><li>Qt Positioning</li><li>Qt Quick Dialogs</li><li>Qt RemoteObjects</li><li>Qt Sensors</li><li>Qt SerialBus</li><li>Qt SerialPort</li><li>Qt WebChannel</li><li>Qt WebEngine</li><li>Qt WebSockets</li><li>Qt WebView</li></ul><p>这些模块的 API 主要向后兼容 Qt 5，并且在移植到 Qt 6 时只需要对用户代码进行少量调整。</p><p>Qt 6.2 支持的 <a href="https://doc.qt.io/qt-6/qtmodules.html" target="_blank" rel="noopener">完整模块列表</a> 可以在我们的文档中找到 。</p><h1 id="四、Qt-6-2-中的新功能"><a href="#四、Qt-6-2-中的新功能" class="headerlink" title="四、Qt 6.2 中的新功能"></a>四、Qt 6.2 中的新功能</h1><p>除了我们从 Qt 5 带来的许多模块之外，我们 在 6.2 中还有大量的 <a href="https://wiki.qt.io/New_Features_in_Qt_6.2" target="_blank" rel="noopener">新特性</a>和功能。我们来看一下。</p><h2 id="1、Qt-快速-3D"><a href="#1、Qt-快速-3D" class="headerlink" title="1、Qt 快速 3D"></a>1、Qt 快速 3D</h2><p>Qt Quick 3D 获得了一些很酷的新功能，现在支持 实例化渲染，允许您使用不同的变换渲染大量相同的对象。我们还添加了一个新的 API，用于向 场景添加 3D 粒子效果。</p><p>输入处理已得到改进，我们现在可以为嵌入在 3D 场景中的 2D 项目正确创建 Qt Quick 输入事件。我们还添加了一个新的 API，用于从场景中的任意点进行基于光线的拾取。</p><h2 id="2、QML工具"><a href="#2、QML工具" class="headerlink" title="2、QML工具"></a>2、QML工具</h2><p>Qt 6.2 对 QML 工具进行了较大改进。我们现在有一个公共的 CMake API ，它极大地简化了创建您自己的 QML 模块的过程。</p><p>QML linter (qmlint) 是一种工具，用于检查 QML 源代码的最佳实践、潜在的编码和性能问题，并帮助编写更易于维护的 QML。该工具经历了很大的变化，现在可以完全配置，无论是在命令行级别，还是通过配置文件，甚至是 QML 文件本身中的各个块。此外，它现在可以生成 JSON 输出以简化与其他工具或自动化系统的集成。</p><p>QML 格式化程序 (qmlformat) 现在使用 QML dom 库，大大改进了生成的输出。</p><h2 id="3、Qt多媒体"><a href="#3、Qt多媒体" class="headerlink" title="3、Qt多媒体"></a>3、Qt多媒体</h2><p>Qt 多媒体在 Qt 6 中发生了一些相当大的变化。它是我们在 Qt 5 的生命周期中不满意的 API 之一。因此，我们退后一步，对 Qt 6 进行了一些更广泛的 API 和架构更改。没有过多考虑向后兼容性的模块。</p><p>尽管如此，从 Qt 5 中的 Qt 多媒体移植到 Qt 6 应该相对简单。</p><p>Qt 6 中的 Qt 多媒体确实支持一些我们在 Qt 5 中从未设法正确支持的高度要求的功能。示例包括播放的字幕和语言选择支持以及媒体捕获的可配置设置。</p><p>内部架构已经过清理，不再像 Qt 5 那样通过公共 API 公开。这将使我们能够更快地修复错误，并使将来添加新功能变得更加容易。您可以在有关 Qt 6 中的 Qt 多媒体的单独博客文章中找到更多详细信息。</p><p>然而，由于这些巨大的变化，该模块仍然存在粗糙的边缘，并且可能在实现中存在相当多的错误。但是，我们相信多媒体是一项必不可少的功能，我们将在 Qt 6.2 中完全支持该模块。</p><p>因此，我们将在补丁级别版本的常规提交策略上有所偏离，如果需要修复较大的问题，可能会添加一些较小的 API。</p><p>此外，我们将努力在即将发布的补丁级别版本中尽快修复任何报告的错误。</p><h2 id="4、整个过程中的小改进"><a href="#4、整个过程中的小改进" class="headerlink" title="4、整个过程中的小改进"></a>4、整个过程中的小改进</h2><p>几乎所有其他模块都看到了许多较小的 API 添加和改进。</p><p>我们已经移植了许多 API 以利用新的属性系统，以便您可以使用 C++ 中的属性绑定。这项工作尚未完成，我们将在未来的版本中继续。</p><p>我们还在各个地方修复了许多 API 缺点和缺失的功能。仅举几个例子：</p><ul><li>Qt Charts 获得了一些新的 API，以提高便利性并使事情更加可定制。</li><li>我们为 QImage 添加了浮点图像格式。</li><li>QByteArray::number() 现在可以正确处理 10 以外的基数的负值。</li><li>QLockFile 现在具有采用 std::chrono 的重载</li><li>Qt Network 支持多个可以在运行时共存的 SSL 后端。</li></ul><h2 id="5、Qt-Creator-和-Qt-Design-Studio"><a href="#5、Qt-Creator-和-Qt-Design-Studio" class="headerlink" title="5、Qt Creator 和 Qt Design Studio"></a>5、Qt Creator 和 Qt Design Studio</h2><p>Qt Creator 和 Qt Design Studio 也做了大量工作，以确保它们为 Qt 6.2 提供一流的支持。Qt Creator 5 包含您为 Qt 6.2 开发所需的一切。</p><p>我们今天还发布了全新版本的 Qt Design Studio。Qt Design Studio 2.2 基于 Qt 6.2，极大地支持在一个图形工具中创建基于 Qt Quick 和 Qt Quick 的 3D 用户界面。您可以轻松地在目标硬件上测试这些，无论是台式机、移动设备还是嵌入式设备。有关 更多详细信息，请查看有关Qt Design Studio 2.2的单独博客文章。</p><h1 id="五、新平台"><a href="#五、新平台" class="headerlink" title="五、新平台"></a>五、新平台</h1><p>对于 Qt 6.2，我们做了很多工作来改进我们对当前支持平台的支持，包括桌面和移动端，例如，通过改进我们对 HighDPI 渲染的支持和在 iOS 上添加 NFC 后端。</p><p>最重要的是，Qt 6.2 大大扩展了支持平台的范围：</p><p>Qt 6.2 完全支持 Apple Silicon 上的 macOS。Qt 现在可以轻松创建通用二进制文件并在 Intel 和 Apple Silicon 上为 macOS 进行开发。当然，该版本也在我们的 CI 系统中进行了全面测试。一直可以通过 Rosetta 层在 Apple 芯片上运行 Qt 应用程序，但 Qt 6.2 现在提供了在 Apple 芯片上本地运行的完整支持。</p><p>Qt 6.2 还恢复了对 INTEGRITY 和 QNX 实时操作系统的支持。支持需要 C++17 工具链和最新版本的操作系统。QNX 的最低要求是 7.1 版，在 INTEGRITY 上，我们支持 19.0.13 版。</p><p>针对 Qt 6.2 的 webOS 验证也已完成，以进一步加强 Qt 对 webOS 的承诺。</p><p>有很多工作正在进行以支持 Windows 11，我们希望能够在 6.2 补丁级别版本中为其提供全面支持。Windows on ARM HW 也可作为 Qt 6.2 的技术预览版提供。</p><p>最后，我们做了进一步的工作来改进我们对 WebAssembly 的支持，它在 Qt 6.2 中作为技术预览提供支持。</p><p>Qt for Python 今天也发布了，大家可以试一试。未来几天将发布一篇单独的博客文章，重点介绍最新 Qt 6.2 更改中采用的所有功能。敬请关注！</p><h1 id="六、Qt6-核心的变化"><a href="#六、Qt6-核心的变化" class="headerlink" title="六、Qt6 核心的变化"></a>六、Qt6 核心的变化</h1><p>Qt 6 是有意识地努力使框架更加高效和易于使用的结果。</p><p>我们尝试维护每个版本中所有公共 API 的二进制和源代码兼容性。但是为了使 Qt 成为更好的框架，一些变化是不可避免的。</p><p>在本主题中，我们总结了 Qt Core 中的这些变化，并提供了处理它们的指导。</p><h2 id="1、容器类"><a href="#1、容器类" class="headerlink" title="1、容器类"></a>1、容器类</h2><h3 id="QHash、QMultiHash、QSet"><a href="#QHash、QMultiHash、QSet" class="headerlink" title="QHash、QMultiHash、QSet"></a>QHash、QMultiHash、QSet</h3><h4 id="qHash-签名"><a href="#qHash-签名" class="headerlink" title="qHash() 签名"></a>qHash() 签名</h4><p>对于自定义类型，<a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">QHash</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qmultihash.html" target="_blank" rel="noopener">QMultiHash</a>依赖于您在同一命名空间中提供<a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">自定义 qHash() 函数。</a>在 Qt 4 和 Qt 5 中，函数的返回值和可选的第二个参数的<code>qHash</code>类型是<code>uint</code>. 在 Qt 6 中，它是<code>size_t</code>.</p><p>也就是说，你需要改变</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint</span> <span class="title">qHash</span>(<span class="params">MyType x, <span class="keyword">uint</span> seed</span>)</span>;</span><br></pre></td></tr></table></figure><p>到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> qHash(MyType x, <span class="keyword">size_t</span> seed);</span><br></pre></td></tr></table></figure><p>这允许<a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">QHash</a>、<a href="https://doc-snapshots.qt.io/qt6-dev/qmultihash.html" target="_blank" rel="noopener">QMultiHash</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qset.html" target="_blank" rel="noopener">QSet</a>在 64 位平台上保存超过 2^32 个项目。</p><h4 id="参考文献的稳定性"><a href="#参考文献的稳定性" class="headerlink" title="参考文献的稳定性"></a>参考文献的稳定性</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">Qt 6 中QHash</a>、<a href="https://doc-snapshots.qt.io/qt6-dev/qmultihash.html" target="_blank" rel="noopener">QMultiHash</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qset.html" target="_blank" rel="noopener">QSet</a>的实现从基于节点的方法更改为两阶段查找表。这种设计允许保持哈希实例的内存开销非常小，同时提供良好的性能。</p><p>需要注意的一个行为变化是，当表需要增长或删除条目时，新实现将不会提供对散列中元素的稳定引用。依赖这种稳定性的应用程序现在可能会遇到未定义的行为。</p><h4 id="移除-QHash-insertMulti"><a href="#移除-QHash-insertMulti" class="headerlink" title="移除 QHash::insertMulti"></a>移除 QHash::insertMulti</h4><p>在 Qt 5 中，<a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">QHash</a>可以通过使用 QHash::insertMulti 来创建多值散列，而<a href="https://doc-snapshots.qt.io/qt6-dev/qmultihash.html" target="_blank" rel="noopener">QMultiHash</a>是派生 vom <a href="https://doc-snapshots.qt.io/qt6-dev/qhash.html#qhash" target="_blank" rel="noopener">QHash 的</a>。</p><p>在 Qt 6 中，类型和用例都是不同的，并且 QHash::insertMulti 被删除了。</p><h3 id="QVector，QList"><a href="#QVector，QList" class="headerlink" title="QVector，QList"></a>QVector，QList</h3><p>在 Qt 6 之前，<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>是独立的类。在 Qt 6 中，它们是统一的：Qt 5 <a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>实现消失了，两个类都使用更新<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">的 QVector</a>实现。<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>是具有实际实现的类，<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>是<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>的别名（typedef） 。</p><p><a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>的 fromVector() 和 toVector() 以及<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>的 fromList() 和 toList() 在 Qt 6 中不再涉及数据复制。它们现在返回调用它们的对象。</p><h4 id="API-更改"><a href="#API-更改" class="headerlink" title="API 更改"></a>API 更改</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>的（以及<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>的）大小类型从 更改<code>int</code>为<code>qsizetype</code>。连同大小类型，所有相关方法的签名都更新为使用<code>qsizetype</code>. 这允许<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>在 64 位平台上保存超过 2^31 个项目。</p><p>在将代码库升级到 Qt 6 时，此 API 更改很可能会导致编译器警告关于缩小类型转换。具有以下示例代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myFunction(QList&lt;MyType&gt; &amp;data) &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> pos = getInsertPosition(<span class="built_in">size</span>);</span><br><span class="line">    data.insert(pos, MyType());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您需要更新它以使用其中一个<code>qsizetype</code>或一个 auto 关键字：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> myFunction(QList&lt;MyType&gt; &amp;data) &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">size</span> = data.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> pos = getInsertPosition(<span class="built_in">size</span>);</span><br><span class="line">    data.insert(pos, MyType());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，您可以使用类型转换并将所有内容转换为<code>int</code>或<code>qsizetype</code>。</p><p><strong>注意：</strong>如果您想同时针对 Qt 5 和 Qt 6 进行构建，auto 关键字是一个很好的解决方案，可以覆盖版本之间的签名差异。</p><h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>收到了与 Qt 6 中的内存布局相关的多项更改。</p><p>在 Qt 5 中，<code>sizeof(QList&lt;T&gt;)</code>等于指针的大小。现在，额外的指针间接被删除，<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>数据成员直接存储在对象中。默认情况下，期望<code>sizeof(QList&lt;T&gt;)</code>等于 3 个指针的大小。</p><p>同时，元素的内存布局也更新了。<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>现在总是将其元素直接存储在分配的内存区域中，而不是 Qt 5，在 Qt 5 中，某些对象被单独分配在堆上，而指向对象的指针被放置到<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>中。</p><p>请注意，后者尤其会影响大型对象。要具有 Qt 5 行为，您可以将对象包装成智能指针并将这些智能指针直接存储在<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList中。</a>在这种情况下，您的<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>的类型将与 Qt 5 中的类型<code>QList&lt;MySmartPointer&lt;MyLargeObject&gt;&gt;</code>相反。<code>QList&lt;MyLargeObject&gt;</code></p><h4 id="参考文献的稳定性-1"><a href="#参考文献的稳定性-1" class="headerlink" title="参考文献的稳定性"></a>参考文献的稳定性</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">对QVector</a> / <a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>实现进行了一些更改。QVector相关的一个是：<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">优化</a>了开头的插入（类似于Qt 5中的<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>）。<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>相关的一个是：元素的内存布局被简化。</p><p><strong>重要提示：</strong>这些更改会影响参考的稳定性。在 Qt 6 中，您应该考虑使用任何大小或容量修改方法来使所有引用无效，即使<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList</a>不是<a href="https://doc-snapshots.qt.io/qt6-dev/implicit-sharing.html" target="_blank" rel="noopener">隐式共享</a>的。此规则的例外情况已明确记录。</p><p>依赖某些参考稳定性的应用程序在升级到使用 Qt 6 时可能会遇到未定义的行为。您应该特别注意最初使用具有非 C 兼容数组布局的<a href="https://doc-snapshots.qt.io/qt6-dev/qvector.html" target="_blank" rel="noopener">QVector</a>或<a href="https://doc-snapshots.qt.io/qt6-dev/qlist.html" target="_blank" rel="noopener">QList的情况。</a></p><h2 id="2、在-Qt6-中查看类"><a href="#2、在-Qt6-中查看类" class="headerlink" title="2、在 Qt6 中查看类"></a>2、在 Qt6 中查看类</h2><h3 id="总体概述"><a href="#总体概述" class="headerlink" title="总体概述"></a>总体概述</h3><p><code>View</code>Qt6有几个新的类。已经存在<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>，现在伴随着<a href="https://doc-snapshots.qt.io/qt6-dev/qbytearrayview.html" target="_blank" rel="noopener">QByteArrayView</a>，然后是专门的<a href="https://doc-snapshots.qt.io/qt6-dev/qutf8stringview.html" target="_blank" rel="noopener">QUtf8StringView</a>和更通用的<a href="https://doc-snapshots.qt.io/qt6-dev/qanystringview.html" target="_blank" rel="noopener">QAnyStringView</a>。</p><h3 id="QStringView示例上的视图类介绍"><a href="#QStringView示例上的视图类介绍" class="headerlink" title="QStringView示例上的视图类介绍"></a>QStringView示例上的视图类介绍</h3><p>QStringView类通过<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a> API的只读子集提供统一的 UTF-16 字符串视图<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">。</a>与保留自己的字符串副本（可能是引用计数）的<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString不同， </a><a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>提供了存储在其他地方的字符串的视图。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">char hello[]&#123; <span class="string">"Hello."</span> &#125;;   <span class="regexp">//</span> <span class="regexp">//</span> 窄多字节字符串字面量</span><br><span class="line">QString str&#123;hello&#125;;         <span class="regexp">//</span> 需要复制字符串文字</span><br><span class="line">QString strToStr(str);      <span class="regexp">//</span> 原子增量涉及不再创建 hello 的副本</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 上面的代码可以重写以避免复制和原子增量.</span><br><span class="line"></span><br><span class="line">QStringView view&#123; <span class="string">u"Hello."</span> &#125;;  <span class="regexp">//</span> 查看到 UTF-<span class="number">16</span> 编码的字符串字面量</span><br><span class="line">QStringView viewToView&#123; view &#125;; <span class="regexp">//</span> 查看相同的 UTF-<span class="number">16</span> 编码字符串文字</span><br></pre></td></tr></table></figure><p>字符串<code>&quot;Hello.&quot;</code>存储在二进制文件中，在运行时不分配。<code>view</code>只是对 string 的一个视图<code>&quot;Hello.&quot;</code>，因此不必创建副本。当我们复制<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>时，<code>viewToView</code>观察到的字符串与复制源观察到的字符串相同<code>view</code>。这意味着<code>viewToView</code>不需要创建副本或原子增量。它们是现有字符串的视图<code>&quot;Hello.&quot;</code>。</p><h3 id="作为函数参数的视图"><a href="#作为函数参数的视图" class="headerlink" title="作为函数参数的视图"></a>作为函数参数的视图</h3><p>视图应该按值传递，而不是通过对 const 的引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun1</span><span class="params">(QStringView sv)</span></span>;        <span class="comment">// 首选</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfun2</span><span class="params">(<span class="keyword">const</span> QStringView &amp;sv)</span></span>; <span class="comment">// 编译和工作，但速度较慢</span></span><br></pre></td></tr></table></figure><h3 id="视图操作函数"><a href="#视图操作函数" class="headerlink" title="视图操作函数"></a>视图操作函数</h3><p><a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>支持让我们操作字符串视图的函数。这允许我们在不创建已查看字符串的部分副本的情况下更改视图。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QString pineapple = <span class="string">"Pineapple"</span><span class="comment">;</span></span><br><span class="line">QString pine = pineapple.left(<span class="number">4</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">// 可以重写上面的代码以避免创建部分副本.</span><br><span class="line"></span><br><span class="line">QStringView pineappleView&#123; pineapple &#125;<span class="comment">;</span></span><br><span class="line">QStringView pineView = pineappleView.left(<span class="number">4</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="非空终止的字符串和包含的字符串-39-0-39"><a href="#非空终止的字符串和包含的字符串-39-0-39" class="headerlink" title="非空终止的字符串和包含的字符串 &#39;\0&#39;"></a>非空终止的字符串和包含的字符串 <code>&#39;\0&#39;</code></h3><p><a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>支持空终止和非空终止字符串。不同之处在于您初始化<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>的方式：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">QChar aToE[]&#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> &#125;;</span><br><span class="line"></span><br><span class="line">QStringView nonNull&#123; aToE, std::size(aToE) &#125;; <span class="regexp">//</span> 给定长度QStringView nonNull&#123;aToE&#125;; </span><br><span class="line"><span class="regexp">//</span>  自动确定长度</span><br><span class="line"></span><br><span class="line">QChar fToJ[]&#123; <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'\0'</span>, <span class="string">'j'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 使用给定长度，不搜索 <span class="string">'\0'</span>，所以位置 <span class="number">3</span> 的 <span class="string">'\0'</span></span><br><span class="line"><span class="regexp">//</span> 被认为是字符串的一部分，类似于 <span class="string">'h'</span> 和 <span class="string">'j'</span></span><br><span class="line">QStringView nonNull&#123; fToJ, std::size(fToJ) &#125;;</span><br><span class="line">QStringView part&#123; fToJ &#125;; <span class="regexp">//</span>在第一次遇到<span class="string">'\0'</span>时停止</span><br></pre></td></tr></table></figure><h3 id="视图的所有权模型"><a href="#视图的所有权模型" class="headerlink" title="视图的所有权模型"></a>视图的所有权模型</h3><p>由于<code>views</code>不拥有它们引用的内存，因此必须注意确保引用的数据（例如，由<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>拥有）<code>view</code>在所有代码路径上的寿命都更长。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QStringView <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QString <span class="title">hello</span><span class="params">(<span class="string">"Hello."</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> QStringView&#123; hello &#125;; <span class="comment">// hello 超出范围并被销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QStringView hello&#123; sayHello() &#125;;</span><br><span class="line">    qDebug() &lt;&lt; hello; <span class="comment">// 未定义的行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将-QStringView-转换为-QString"><a href="#将-QStringView-转换为-QString" class="headerlink" title="将 QStringView 转换为 QString"></a>将 QStringView 转换为 QString</h3><p><a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>不会隐式或显式转换为<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>，但可以创建其数据的深层副本：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void print(const QString &amp;s) &#123; qDebug() &lt;&lt; s; &#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    QStringView string&#123; <span class="string">u"string"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="regexp">//</span> print(string); <span class="regexp">//</span> 无效，没有隐式转换</span><br><span class="line">    <span class="regexp">//</span> QString str&#123; string &#125;; <span class="regexp">//</span> 无效，没有显式转换</span><br><span class="line"></span><br><span class="line">    print(string.toString());</span><br><span class="line">    QString str = string.toString(); <span class="regexp">//</span> 从view创建QString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重要笔记"><a href="#重要笔记" class="headerlink" title="重要笔记"></a>重要笔记</h3><p>通过利用新的视图类，可以在许多用例中实现大量性能提升。但是，重要的是要知道可能有一些警告。因此，重要的是要记住：</p><ul><li>视图应该按值传递，而不是通过对 const 的引用。</li><li>构造具有负长度的视图是未定义的行为。</li><li>必须注意确保引用的数据（例如，由<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>拥有）比所有代码路径上的视图都长。</li></ul><h2 id="3、字符串相关类"><a href="#3、字符串相关类" class="headerlink" title="3、字符串相关类"></a>3、字符串相关类</h2><h3 id="QStringView-类"><a href="#QStringView-类" class="headerlink" title="QStringView 类"></a>QStringView 类</h3><p>从 Qt6 开始，通常建议使用<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a> over <code>QStringRef</code>。<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>引用它不拥有的 UTF-16 字符串的连续部分。它充当各种 UTF-16 字符串的接口类型，无需先构造<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>。QStringView类公开了几乎所有<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QString</a>的只读方法<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">和</a>以前存在的<code>QStringRef</code>类。</p><p><strong>注意：</strong>必须注意确保引用的字符串数据（例如，由<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>拥有）在所有代码路径上都超过<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView 。</a></p><p><strong>注意：</strong>如果<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>包装了<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>，则需要小心，因为与<code>QStringRef</code> <a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView不同，一旦</a><a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>数据重定位，将不会更新内部数据指针。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="built_in">string</span> = <span class="params">...</span>;</span><br><span class="line">QStringView view&#123;<span class="built_in">string</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 附加很长的内容可能会导致重定位，并且</span></span><br><span class="line"><span class="comment">// 最终会导致 QStringView 出现乱码.</span></span><br><span class="line"><span class="built_in">string</span> += <span class="params">...</span>;</span><br></pre></td></tr></table></figure><h3 id="QStringRef-类"><a href="#QStringRef-类" class="headerlink" title="QStringRef 类"></a>QStringRef 类</h3><p>在 Qt6中， <a href="https://doc-snapshots.qt.io/qt6-dev/qstringref.html" target="_blank" rel="noopener">QStringRef</a>已从 Qt Core 中删除。为了在不涉及整个代码库的情况下简化现有应用程序的移植，<code>QStringRef</code>该类并没有完全消失，而是被移到了 Qt5Compat 模块中。如果您想<code>QStringRef</code>进一步使用，请参阅<a href="https://doc-snapshots.qt.io/qt6-dev/qtcore-changes-qt6.html#using-the-qt5compat-module" target="_blank" rel="noopener">使用 Qt5Compat 模块</a>。</p><p>不幸的是，<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html" target="_blank" rel="noopener">QString</a>公开的一些方法返回 a <code>QStringRef</code>，无法移动到 Qt5Compat。因此，可能需要一些手动移植。如果您的代码使用以下一个或多个函数，您需要将它们移植到使用<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html" target="_blank" rel="noopener">QStringView</a>或<a href="https://doc-snapshots.qt.io/qt6-dev/qstringtokenizer.html" target="_blank" rel="noopener">QStringTokenizer</a>。对于性能关键代码，还建议使用<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html#tokenize" target="_blank" rel="noopener">QStringView::tokenize</a>而不是<a href="https://doc-snapshots.qt.io/qt6-dev/qstringview.html#split" target="_blank" rel="noopener">QStringView::split 。</a></p><p>使用以下代码更改代码<code>QStringRef</code>：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">QString <span class="keyword">string</span> = ...;</span><br><span class="line">QStringRef left = <span class="keyword">string</span>.leftRef(n);</span><br><span class="line">QStringRef mid = <span class="keyword">string</span>.midRef(n);</span><br><span class="line">QStringRef right = <span class="keyword">string</span>.rightRef(n);</span><br><span class="line"></span><br><span class="line">QString <span class="keyword">value</span> = ...;</span><br><span class="line"><span class="keyword">const</span> QVector&lt;QStringRef&gt; refs = <span class="keyword">string</span>.splitRef(<span class="string">' '</span>);</span><br><span class="line"><span class="keyword">if</span> (refs.contains(<span class="keyword">value</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QString string = ...;</span><br><span class="line">QStringView left = QStringView&#123;string&#125;.left(n);</span><br><span class="line">QStringView mid = QStringView&#123;string&#125;.mid(n);</span><br><span class="line">QStringView right = QStringView&#123;string&#125;.right(n);</span><br><span class="line"></span><br><span class="line">QString value = ...;</span><br><span class="line">const QList&lt;QStringView&gt; refs = QStringView&#123;string&#125;.split(<span class="string">u' '</span>);</span><br><span class="line"><span class="keyword">if</span> (refs.contains(QStringView&#123;value&#125;))</span><br><span class="line">    <span class="keyword">return</span> true;</span><br><span class="line">// 或</span><br><span class="line">const auto refs = QStringView&#123;string&#125;.tokenize(<span class="string">u' '</span>);</span><br><span class="line"><span class="keyword">for</span> (auto ref : refs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ref == value)</span><br><span class="line">        <span class="keyword">return</span> true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、QMutex-和相关类"><a href="#4、QMutex-和相关类" class="headerlink" title="4、QMutex 和相关类"></a>4、QMutex 和相关类</h2><p>在 Qt 6 中，<a href="https://doc-snapshots.qt.io/qt6-dev/qrecursivemutex.html" target="_blank" rel="noopener">QRecursiveMutex</a>不再继承自<a href="https://doc-snapshots.qt.io/qt6-dev/qmutex.html" target="_blank" rel="noopener">QMutex</a>。进行此更改是为了提高<a href="https://doc-snapshots.qt.io/qt6-dev/qmutex.html" target="_blank" rel="noopener">QMutex</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qrecursivemutex.html" target="_blank" rel="noopener">QRecursiveMutex</a>的性能。</p><p>由于这些更改， QMutex::RecursionMode 枚举已被删除，并且<a href="https://doc-snapshots.qt.io/qt6-dev/qmutexlocker.html" target="_blank" rel="noopener">QMutexLocker</a>现在是一个模板类，可以在<a href="https://doc-snapshots.qt.io/qt6-dev/qmutex.html" target="_blank" rel="noopener">QMutex</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qrecursivemutex.html" target="_blank" rel="noopener">QRecursiveMutex</a>上运行。</p><h2 id="5、QFuture-及相关类"><a href="#5、QFuture-及相关类" class="headerlink" title="5、QFuture 及相关类"></a>5、QFuture 及相关类</h2><h3 id="QFuture-类"><a href="#QFuture-类" class="headerlink" title="QFuture 类"></a>QFuture 类</h3><p>为避免意外使用<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture ，Qt 6 中对</a><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a> API进行了一些更改，这可能会导致源代码兼容性中断。</p><h4 id="QFuture-和其他类型之间的隐式转换"><a href="#QFuture-和其他类型之间的隐式转换" class="headerlink" title="QFuture 和其他类型之间的隐式转换"></a>QFuture 和其他类型之间的隐式转换</h4><p><code>QFuture&lt;T&gt;</code>到的转换<code>T</code>已被禁用。转换操作符调用<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html#result" target="_blank" rel="noopener">QFuture::result</a> ()，如果用户在尝试进行转换之前通过<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html#takeResult" target="_blank" rel="noopener">QFuture::takeResult () 从</a><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>移动了结果，这可能会导致未定义的行为。在需要转换<code>QFuture&lt;T&gt;</code>到<code>T</code>。</p><p><code>QFuture&lt;T&gt;</code>从to的隐式转换<code>QFuture&lt;void&gt;</code>也被禁用。如果您真的打算进行转换，请使用显式<code>QFuture&lt;void&gt;(const QFuture&lt;T&gt; &amp;)</code>构造函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QFuture&lt;<span class="keyword">int</span>&gt; future = ...</span><br><span class="line">QFuture&lt;<span class="keyword">void</span>&gt; voidFuture = QFuture&lt;<span class="keyword">void</span>&gt;(future);</span><br></pre></td></tr></table></figure><h4 id="等式运算符"><a href="#等式运算符" class="headerlink" title="等式运算符"></a>等式运算符</h4><p><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>的相等运算符已被删除。他们正在比较底层的 d 指针，而不是比较结果，这可能不是用户所期望的。如果需要比较<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>对象，使用<code>QFuture::result()</code>or<code>QFuture::takeResult()</code>方法。例如：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QFuture&lt;int&gt; future1 = <span class="string">...</span>;</span><br><span class="line">QFuture&lt;int&gt; future2 = <span class="string">...</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(future1.result()</span> == future2.result<span class="params">()</span>)</span><br><span class="line">    <span class="string">//</span> <span class="string">...</span></span><br></pre></td></tr></table></figure><h3 id="QFuture-和-QFutureWatcher-的行为变化"><a href="#QFuture-和-QFutureWatcher-的行为变化" class="headerlink" title="QFuture 和 QFutureWatcher 的行为变化"></a>QFuture 和 QFutureWatcher 的行为变化</h3><p><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">在 Qt 6 中，对QFuture</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a>进行了一些改进，导致以下行为变化：</p><ul><li>在暂停<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>或<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a>（通过调用<code>pause()</code>or <code>setPaused(true)</code>）后，<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a>不会立即停止传递进度和结果就绪信号。在暂停的那一刻，可能仍有计算正在进行且无法停止。此类计算的信号可能在暂停后仍被传递，而不是被推迟并仅在下一次恢复后才报告。要在暂停实际生效时得到通知，可以使用<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html#suspended" target="_blank" rel="noopener">QFutureWatcher::suspended () 信号。</a>此外，还有新的<code>isSuspending()</code>和<code>isSuspended()</code>方法，用于检查<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>是处于挂起过程中还是已经处于挂起状态。请注意，出于一致性原因，对于两者<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html" target="_blank" rel="noopener">QFutureWatcher</a>与暂停相关的 API 已被弃用，取而代之的是名称中带有“suspend”的类似方法。</li><li><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html#waitForFinished" target="_blank" rel="noopener">QFuture::waitForFinished</a> () 现在会等到<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>实际上处于完成状态，而不是在它不处于运行状态时立即退出。如果在调用它的那一刻未来还没有开始，这可以防止<code>waitForFinished()</code>立即退出。这同样适用于<a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html#waitForFinished" target="_blank" rel="noopener">QFutureWatcher::waitForFinished</a> ()。此更改不会影响将<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>与<a href="https://doc-snapshots.qt.io/qt6-dev/qtconcurrent-module.html" target="_blank" rel="noopener">QtConcurrent</a>一起使用的代码的行为。只有在未记录的情况下使用它的代码<code>QFutureInterface</code>可能会受到影响。</li><li><a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html#isFinished" target="_blank" rel="noopener">QFutureWatcher::isFinished</a> () 现在反映 QFuture 的完成状态，<a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">而不是在</a><a href="https://doc-snapshots.qt.io/qt6-dev/qfuturewatcher.html#finished" target="_blank" rel="noopener">QFutureWatcher::finished</a> () 发出之前返回 false 。</li></ul><h3 id="QPromise-类"><a href="#QPromise-类" class="headerlink" title="QPromise 类"></a>QPromise 类</h3><p>在 Qt 6 中，应该使用新的<a href="https://doc-snapshots.qt.io/qt6-dev/qpromise.html" target="_blank" rel="noopener">QPromise类而不是非官方的 QFutureInterface 作为</a><a href="https://doc-snapshots.qt.io/qt6-dev/qfuture.html" target="_blank" rel="noopener">QFuture</a>的“setter”对应物。</p><h2 id="6、IO-类"><a href="#6、IO-类" class="headerlink" title="6、IO 类"></a>6、IO 类</h2><h3 id="QProcess-类"><a href="#QProcess-类" class="headerlink" title="QProcess 类"></a>QProcess 类</h3><p>在 Qt 6 中，通过将单个命令字符串拆分为程序名称和参数来解释单个命令字符串的<a href="https://doc-snapshots.qt.io/qt6-dev/qprocess.html#start" target="_blank" rel="noopener">QProcess::start () 重载重命名为</a><a href="https://doc-snapshots.qt.io/qt6-dev/qprocess.html#startCommand" target="_blank" rel="noopener">QProcess::startCommand</a> ()。但是，存在采用单个字符串的<a href="https://doc-snapshots.qt.io/qt6-dev/qprocess.html#start" target="_blank" rel="noopener">QProcess::start</a> () 重载以及用于参数的<a href="https://doc-snapshots.qt.io/qt6-dev/qstringlist.html" target="_blank" rel="noopener">QStringList 。</a>由于<a href="https://doc-snapshots.qt.io/qt6-dev/qstringlist.html" target="_blank" rel="noopener">QStringList</a>参数默认为空列表，因此仅传递字符串的现有代码仍然可以编译，但如果它是包含参数的完整命令字符串，则将无法执行该过程。</p><p>Qt 5.15 为相应的重载引入了弃用警告，以便于发现和更新现有代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QProcess <span class="built_in">process</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 5.15 中编译时出现警告，在 Qt 6</span></span><br><span class="line"><span class="built_in">process</span>.start(<span class="string">"dir \"My Documents\""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于 Qt 5 和 Qt 6; 另请参阅QProcess::splitCommand()</span></span><br><span class="line"><span class="built_in">process</span>.start(<span class="string">"dir"</span>, QStringList(&#123;<span class="string">"My Documents"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适用于 Qt 6</span></span><br><span class="line"><span class="built_in">process</span>.startCommand(<span class="string">"dir \"My Documents\""</span>);</span><br></pre></td></tr></table></figure><p>QProcess::pid() 和 Q_PID 类型已被移除；使用<a href="https://doc-snapshots.qt.io/qt6-dev/qprocess.html#processId" target="_blank" rel="noopener">QProcess::processId</a> () 来获取本机进程标识符。<code>PROCESS_INFORMATION</code>不再支持使用本机 Win32 API 以 Win32 结构访问 Q_PID 中的数据的代码。</p><h2 id="7、元类型系统"><a href="#7、元类型系统" class="headerlink" title="7、元类型系统"></a>7、元类型系统</h2><h3 id="QVariant-类"><a href="#QVariant-类" class="headerlink" title="QVariant 类"></a>QVariant 类</h3><p><code>QVariant</code>已被重写以<code>QMetaType</code>用于其所有操作。这意味着一些方法的行为改变：</p><ul><li><code>QVariant::isNull()</code>现在仅<code>true</code>在 the<code>QVariant</code>为空或包含 a时返回<code>nullptr</code>。在 Qt 5 中，如果 qtbase 中的类<code>isNull</code>本身有一个方法返回 true，它也会返回 true。依赖于旧行为的代码需要检查包含的值是否返回 isNull ——然而这种代码在实践中不太可能出现，因为<code>isNull()</code>很少有人感兴趣的属性（比较<code>QString::isEmpty()</code>/<code>isNull()</code>和<code>QTime::isValid</code>/ <code>isNull</code>）。</li><li><code>QVariant::operator==</code>在 Qt 6 中使用<code>QMetaType::equals</code>。因此，某些图形类型，如<code>QPixmap</code>,<code>QImage</code>并且<code>QIcon</code>永远不会比较相等。此外，存储在中的浮点数<code>QVariant</code>不再与 进行比较<code>qFuzzyCompare</code>，而是使用精确比较。</li></ul><p>此外，QVariant::operator&lt;、QVariant::operator&lt;=、QVariant::operator&gt; 和 QVariant::operator&gt;= 被删除，因为不同的变体并不总是可订购的。这也意味着<a href="https://doc-snapshots.qt.io/qt6-dev/qvariant.html" target="_blank" rel="noopener">QVariant</a>不能再用作<a href="https://doc-snapshots.qt.io/qt6-dev/qmap.html" target="_blank" rel="noopener">QMap</a>中的键。</p><h3 id="QMetaType-类"><a href="#QMetaType-类" class="headerlink" title="QMetaType 类"></a>QMetaType 类</h3><p>在 Qt 6 中，比较器以及<a href="https://doc-snapshots.qt.io/qt6-dev/qdebug.html" target="_blank" rel="noopener">QDebug</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qdatastream.html" target="_blank" rel="noopener">QDataStream</a>流操作符的注册是自动完成的。因此，、<code>QMetaType::registerEqualsComparator()</code>和不再存在。移植到 Qt 6 时，必须删除对这些方法的调用。<code>QMetaType::registerComparators()`</code>qRegisterMetaTypeStreamOperators()<code></code>QMetaType::registerDebugStreamOperator()`</p><h3 id="类型注册"><a href="#类型注册" class="headerlink" title="类型注册"></a>类型注册</h3><p>中使用的类型<code>Q_PROPERTY</code>将其元类型存储在类’<code>QMetaObject</code>中。这要求当 moc 看到它们时类型是完整的，这可能导致在 Qt 5 中工作的代码中出现编译错误。有三种方法可以解决此问题：</p><ul><li>包括定义类型的标题。</li><li>不要使用包含，而是使用<code>Q_MOC_INCLUDE</code>宏。如果包含标头会导致循环依赖，或者会减慢编译速度，这将很有帮助。</li><li>如果头文件存在于实现类的 cpp 文件中，也可以在其中包含 moc 生成的文件。</li></ul><h2 id="8、正则表达式类"><a href="#8、正则表达式类" class="headerlink" title="8、正则表达式类"></a>8、正则表达式类</h2><h3 id="QRegularExpression-类"><a href="#QRegularExpression-类" class="headerlink" title="QRegularExpression 类"></a>QRegularExpression 类</h3><p>在 Qt6 中，所有采用 的方法都已<code>QRegExp</code>从我们的代码库中删除。因此，您很可能必须将您的应用程序或库移植到<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>。</p><p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>实现了与 Perl 兼容的正则表达式。它完全支持Unicode。<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">有关QRegularExpression</a>支持的正则表达式语法的概述，请参阅前面提到的 pcrepattern(3) 手册页。一个正则表达式由两部分组成：一个模式字符串和一组改变模式字符串含义的模式选项。</p><p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>之间存在一些细微的差异<code>QRegExp</code>，本文档将对此进行解释以简化移植工作。</p><p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>在正则表达式的语法方面更加严格。因此检查表达式的<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#isValid" target="_blank" rel="noopener">有效性</a>总是好的。</p><p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>几乎总是可以声明为 const （模式改变时除外），而<code>QRegExp</code>几乎不可能。</p><p><a href="https://doc-snapshots.qt.io/qt6-dev/qregexp.html#CaretMode-enum" target="_blank" rel="noopener">CaretMode</a>枚举没有替代品。QRegularExpression <a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#MatchOption-enum" target="_blank" rel="noopener">::AnchoredMatchOption</a>匹配选项可用于模拟<a href="https://doc-snapshots.qt.io/qt6-dev/qregexp.html#CaretMode-enum" target="_blank" rel="noopener">QRegExp::CaretAtOffset</a>行为。<a href="https://doc-snapshots.qt.io/qt6-dev/qregexp.html#CaretMode-enum" target="_blank" rel="noopener">其他QRegExp::CaretMode</a>模式没有等价物。</p><p><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>仅支持与 Perl 兼容的正则表达式。尽管如此，它仍然不支持 Perl 兼容的正则表达式中可用的所有功能。最值得注意的是不支持捕获组的重复名称，使用它们可能会导致未定义的行为。这可能会在未来的 Qt 版本中改变。</p><h4 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h4><p>在<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>中没有直接的方法来进行通配符匹配。但是，提供了<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#wildcardToRegularExpression" target="_blank" rel="noopener">QRegularExpression::wildcardToRegularExpression</a>方法来将 glob 模式转换为可用于该目的的 Perl 兼容的正则表达式。</p><p>例如，如果您有类似的代码</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QRegExp</span> <span class="selector-tag">wildcard</span>(<span class="string">"*.txt"</span>);</span><br><span class="line"><span class="selector-tag">wildcard</span><span class="selector-class">.setPatternSyntax</span>(<span class="attribute">QRegExp</span>::Wildcard);</span><br></pre></td></tr></table></figure><p>您可以将其重写为</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto wildcard = QRegularExpression(<span class="name">QRegularExpression</span>:<span class="symbol">:wildcardToRegularExpression</span>(<span class="string">"*.txt"</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>请注意，并非所有类似于通配符模式的 shell 都可能以您期望的方式进行翻译。如果简单地使用上述函数进行转换，以下示例代码将静默中断：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const QString fp1(<span class="string">"C:/Users/dummy/files/content.txt"</span>);</span><br><span class="line">const QString fp2(<span class="string">"/home/dummy/files/content.txt"</span>);</span><br><span class="line"></span><br><span class="line">QRegExp re1(<span class="string">"*/files/*"</span>);</span><br><span class="line">re1.setPatternSyntax(QRegExp<span class="type">::Wildcard</span>);</span><br><span class="line"><span class="params">...</span> = re1.exactMatch(fp1);  <span class="comment">// 返回true</span></span><br><span class="line"><span class="params">...</span> = re1.exactMatch(fp2);  <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是使用 QRegularExpression::wildcardToRegularExpression()</span></span><br><span class="line"></span><br><span class="line">QRegularExpression re2(QRegularExpression<span class="type">::wildcardToRegularExpression</span>(<span class="string">"*/files/*"</span>));</span><br><span class="line"><span class="params">...</span> = re2.<span class="keyword">match</span>(fp1).hasMatch();    <span class="comment">// returns false</span></span><br><span class="line"><span class="params">...</span> = re2.<span class="keyword">match</span>(fp2).hasMatch();    <span class="comment">// returns false</span></span><br></pre></td></tr></table></figure><h4 id="向前搜索"><a href="#向前搜索" class="headerlink" title="向前搜索"></a>向前搜索</h4><p>字符串内的前向搜索通常通过循环使用<code>QRegExp::indexIn</code>和不断增长的偏移量来实现，但现在可以使用<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpressionmatchiterator.html" target="_blank" rel="noopener">QRegularExpressionMatchIterator</a>或<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html#indexOf" target="_blank" rel="noopener">QString::indexOf</a>轻松实现。</p><p>例如，如果您有类似的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">subject</span><span class="params">(<span class="string">"the quick fox"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> offset = <span class="number">0</span>;</span><br><span class="line"><span class="function">QRegExp <span class="title">re</span><span class="params">(<span class="string">"(\\w+)"</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> ((offset = re.indexIn(subject, offset)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    offset += re.matchedLength();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以将其重写为</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QRegularExpression <span class="title">re</span>(<span class="params"><span class="string">"(\\w+)"</span></span>)</span>;</span><br><span class="line"><span class="function">QString <span class="title">subject</span>(<span class="params"><span class="string">"the quick fox"</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">QRegularExpressionMatchIterator i = re.globalMatch(subject);</span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">    QRegularExpressionMatch match = i.next();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 或者使用 QString::indexOf</span></span><br><span class="line"></span><br><span class="line">qsizetype <span class="keyword">from</span> = <span class="number">0</span>;</span><br><span class="line">QRegularExpressionMatch match;</span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">from</span> = subject.indexOf(re, <span class="keyword">from</span>, &amp;match)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">from</span> += match.capturedLength();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向后搜索"><a href="#向后搜索" class="headerlink" title="向后搜索"></a>向后搜索</h4><p>在字符串中向后搜索通常是作为循环实现的<code>QRegExp::lastIndexIn</code>，但现在可以使用<a href="https://doc-snapshots.qt.io/qt6-dev/qstring.html#lastIndexOf" target="_blank" rel="noopener">QString::lastIndexOf</a>和<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpressionmatch.html" target="_blank" rel="noopener">QRegularExpressionMatch</a>轻松实现。</p><p><strong>注意：</strong><a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpressionmatchiterator.html" target="_blank" rel="noopener">QRegularExpressionMatchIterator</a>不能执行向后搜索。</p><p>例如，如果您有类似的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> offset = <span class="number">-1</span>;</span><br><span class="line"><span class="function">QString <span class="title">subject</span><span class="params">(<span class="string">"Lorem ipsum dolor sit amet, consetetur sadipscing."</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">QRegExp <span class="title">re</span><span class="params">(<span class="string">"\\s+([ids]\\w+)"</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> ((offset = re.lastIndexIn(subject, offset)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    --offset;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以将其重写为</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">qsizetype <span class="keyword">from</span> = <span class="number">-1</span>;</span><br><span class="line"><span class="function">QString <span class="title">subject</span>(<span class="params"><span class="string">"Lorem ipsum dolor sit amet, consetetur sadipscing."</span></span>)</span>;</span><br><span class="line"></span><br><span class="line">QRegularExpressionMatch match;</span><br><span class="line"><span class="function">QRegularExpression <span class="title">re</span>(<span class="params"><span class="string">"\\s+([ids]\\w+)"</span></span>)</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="keyword">from</span> = subject.lastIndexOf(re, <span class="keyword">from</span>, &amp;match)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    --<span class="keyword">from</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="exactMatch-与-match-hasMatch"><a href="#exactMatch-与-match-hasMatch" class="headerlink" title="exactMatch 与 match.hasMatch"></a>exactMatch 与 match.hasMatch</h4><p><code>QRegExp::exactMatch</code>有两个目的：将正则表达式与主题字符串完全匹配，并实现部分匹配。精确匹配表示正则表达式是否匹配整个主题字符串。例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QString</span> <span class="selector-tag">source</span>(<span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QRegExp</span>(<span class="string">"\\d+"</span>)<span class="selector-class">.exactMatch</span>(source);         <span class="comment">// 返回false</span></span><br><span class="line"><span class="selector-tag">QRegExp</span>(<span class="string">"[a-z]+\\d+"</span>)<span class="selector-class">.exactMatch</span>(source);   <span class="comment">// 返回true</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">QRegularExpression</span>(<span class="string">"\\d+"</span>)<span class="selector-class">.match</span>(source)<span class="selector-class">.hasMatch</span>();        <span class="comment">// 返回true</span></span><br><span class="line"><span class="selector-tag">QRegularExpression</span>(<span class="string">"[a-z]+\\d+"</span>)<span class="selector-class">.match</span>(source)<span class="selector-class">.hasMatch</span>();  <span class="comment">// 返回true</span></span><br></pre></td></tr></table></figure><p>精确匹配未反映在<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>中。如果要确保主题字符串与正则表达式完全匹配，可以使用<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#anchoredPattern" target="_blank" rel="noopener">QRegularExpression::anchoredPattern</a>函数包装模式：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QString source(<span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line">QString <span class="built_in">pattern</span>(<span class="string">"\\d+"</span>);</span><br><span class="line">QRegularExpression(<span class="built_in">pattern</span>).<span class="keyword">match</span>(source).hasMatch();  // 返回true</span><br><span class="line"></span><br><span class="line"><span class="built_in">pattern</span> = QRegularExpression::anchoredPattern(<span class="built_in">pattern</span>);</span><br><span class="line">QRegularExpression(<span class="built_in">pattern</span>).<span class="keyword">match</span>(source).hasMatch();  // 返回false</span><br></pre></td></tr></table></figure><h4 id="最小匹配"><a href="#最小匹配" class="headerlink" title="最小匹配"></a>最小匹配</h4><p><code>QRegExp::setMinimal()</code>通过简单地反转量词的贪婪来实现最小匹配（<code>QRegExp</code>不支持惰性量词，如*？、+？等）。<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">相反， QRegularExpression</a>确实支持贪婪、懒惰和所有格量词。QRegularExpression <a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#PatternOption-enum" target="_blank" rel="noopener">::InvertedGreedinessOption</a>模式选项可用于模拟<code>QRegExp::setMinimal()</code>: 如果启用，它会反转量词的贪婪（贪婪的变得懒惰，反之亦然）。</p><h4 id="不同的模式语法"><a href="#不同的模式语法" class="headerlink" title="不同的模式语法"></a>不同的模式语法</h4><p>将正则表达式从 QRegularExpression 移植<code>QRegExp</code>可能<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">需要</a>更改模式本身。因此建议检查与<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#isValid" target="_blank" rel="noopener">QRegularExpression::isValid</a>方法一起使用的模式。这对于用户提供的模式或不受开发人员控制的模式尤其重要。</p><p>在其他情况下，从<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a><code>QRegExp</code>移植的模式可能会默默地改变语义。因此，有必要审查所使用的模式。最值得注意的无声不兼容案例是：</p><ul><li><code>\xHHHH</code>为了使用超过 2 位的十六进制转义，需要大括号。<code>\x2022</code>需要将类似的模式移植到<code>\x{2022}</code>，否则它将匹配<code>(0x20)</code>字符串后面的空格<code>&quot;22&quot;</code>。<code>\x</code>通常，无论指定多少位数，强烈建议始终使用带有转义的花括号。</li><li>需要移植类似的<code>0-to-n</code>量化以保留语义。否则，诸如这样的模式实际上会匹配一个数字后跟确切的字符串。<code>{,n}</code> <code>{0,n}</code> <code>\d{,3}</code> <code>&quot;{,3}&quot;</code></li></ul><h4 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h4><p>使用 时<code>QRegExp::exactMatch()</code>，如果没有找到精确匹配，仍然可以通过调用<code>QRegExp::matchedLength()</code>. 如果返回的长度等于主题字符串的长度，则可以断定找到了部分匹配。<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>通过适当的<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#MatchType-enum" target="_blank" rel="noopener">QRegularExpression::MatchType</a>显式支持部分匹配。</p><h4 id="全局匹配"><a href="#全局匹配" class="headerlink" title="全局匹配"></a>全局匹配</h4><p>由于<code>QRegExp</code>API 的限制，不可能正确地实现全局匹配（也就是说，就像 Perl 一样）。特别是，可以匹配零个字符的模式（如“a*”）是有问题的。<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#wildcardToRegularExpression" target="_blank" rel="noopener">QRegularExpression::wildcardToRegularExpression</a>正确实现 Perl 全局匹配，返回的迭代器可用于检查每个结果。</p><h4 id="Unicode-属性支持"><a href="#Unicode-属性支持" class="headerlink" title="Unicode 属性支持"></a>Unicode 属性支持</h4><p>使用 时<code>QRegExp</code>，诸如 、 等字符类<code>\w</code>匹配<code>\d</code>具有相应 Unicode 属性的字符：例如，<code>\d</code>匹配具有 Unicode Nd（十进制数字）属性的任何字符。默认情况下，这些字符类仅匹配 ASCII 字符。使用<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html" target="_blank" rel="noopener">QRegularExpression</a>时：例如，<code>\d</code>精确匹配 0-9 ASCII 范围内的字符。可以通过使用<a href="https://doc-snapshots.qt.io/qt6-dev/qregularexpression.html#PatternOption-enum" target="_blank" rel="noopener">QRegularExpression::UseUnicodePropertiesOption</a>模式选项来更改此行为。</p><h3 id="QRegExp-类"><a href="#QRegExp-类" class="headerlink" title="QRegExp 类"></a>QRegExp 类</h3><p>在 Qt6<a href="https://doc-snapshots.qt.io/qt6-dev/qregexp.html" target="_blank" rel="noopener">中</a>，QRegExp从 Qt Core 中移除。如果您的应用程序现在无法移植<code>QRegExp</code>，Qt5Compat 中仍然存在以保持这些代码库正常工作。如果您想<code>QRegExp</code>进一步使用，请参阅<a href="https://doc-snapshots.qt.io/qt6-dev/qtcore-changes-qt6.html#using-the-qt5compat-module" target="_blank" rel="noopener">使用 Qt5Compat 模块</a>。</p><p><a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html" target="_blank" rel="noopener">QEvent</a>类定义了一个复制构造函数和一个赋值运算符，尽管它是一个多态类。在将不同类中的对象相互分配时，使用虚拟方法复制类可能会导致切片。由于复制和分配经常隐含地发生，这可能会导致难以调试的问题。</p><p>在 Qt 6 中，<a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html" target="_blank" rel="noopener">QEvent</a>子类的复制构造函数和赋值运算符已被保护以防止隐式复制。如果您需要复制事件，请使用<a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html#clone" target="_blank" rel="noopener">clone</a>方法，该方法将返回<a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html" target="_blank" rel="noopener">QEvent</a>对象的堆分配副本。确保删除克隆，可能使用 std::unique_ptr，除非您发布它（在这种情况下，Qt 将在交付后删除它）。</p><p>在您的<a href="https://doc-snapshots.qt.io/qt6-dev/qevent.html" target="_blank" rel="noopener">QEvent</a>子类中，覆盖 clone()，并声明受保护和默认实现的复制构造函数和赋值运算符，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEvent</span> :</span> <span class="keyword">public</span> QEvent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function">MyEvent *<span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> override </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> MyEvent(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    MyEvent(<span class="keyword">const</span> MyEvent &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    MyEvent &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MyEvent &amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    MyEvent(MyEvent &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MyEvent &amp;<span class="keyword">operator</span>=(MyEvent &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">// 成员数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请注意，如果您的 MyEvent 类分配内存（例如，通过指向实现模式的指针），那么您将必须实现自定义复制语义。</p><h2 id="9、序列化类"><a href="#9、序列化类" class="headerlink" title="9、序列化类"></a>9、序列化类</h2><p>在 Qt 6 中，用于将其转换为/从 Qt 的遗留 JSON 二进制格式转换的<a href="https://doc-snapshots.qt.io/qt6-dev/qjsondocument.html" target="_blank" rel="noopener">QJsonDocument</a>方法被删除，以支持标准化的 CBOR 格式。Qt JSON 类型可以转换为 Qt CBOR 类型，后者又可以序列化为 CBOR 二进制格式，反之亦然。例如，参见<a href="https://doc-snapshots.qt.io/qt6-dev/qcborvalue.html#fromJsonValue" target="_blank" rel="noopener">QCborValue::fromJsonValue</a> () 和<a href="https://doc-snapshots.qt.io/qt6-dev/qcborvalue.html#toJsonValue" target="_blank" rel="noopener">QCborValue::toJsonValue</a> ()。</p><p>如果仍然需要使用二进制 JSON 格式，可以使用 Qt5Compat 模块中提供的替换。它们可以在<a href="https://doc-snapshots.qt.io/qt6-dev/qbinaryjson.html" target="_blank" rel="noopener">QBinaryJson</a>命名空间中找到。请参阅<a href="https://doc-snapshots.qt.io/qt6-dev/qtcore-changes-qt6.html#using-the-qt5compat-module" target="_blank" rel="noopener">使用 Qt5Compat 模块</a>以了解如何在您的应用程序中使用该模块。</p><h2 id="10、其他类"><a href="#10、其他类" class="headerlink" title="10、其他类"></a>10、其他类</h2><p>在 Qt 5 中，<a href="https://doc-snapshots.qt.io/qt6-dev/qcoreapplication.html#quit" target="_blank" rel="noopener">QCoreApplication::quit</a> () 等价于调用<a href="https://doc-snapshots.qt.io/qt6-dev/qcoreapplication.html#exit" target="_blank" rel="noopener">QCoreApplication::exit</a> ()。这刚刚退出了主事件循环。</p><p>在 Qt 6 中，该方法将尝试通过发布关闭事件来关闭所有顶级窗口。窗口可以通过忽略该事件来自由取消关闭过程。</p><p>调用<a href="https://doc-snapshots.qt.io/qt6-dev/qcoreapplication.html#exit" target="_blank" rel="noopener">QCoreApplication::exit</a> () 来保持非条件行为。</p><p>由于命名不一致，不推荐使用 QLibraryInfo::location() 和 QLibraryInfo::Location。请改用新的 API <a href="https://doc-snapshots.qt.io/qt6-dev/qlibraryinfo.html#path" target="_blank" rel="noopener">QLibraryInfo::path</a> () 和<a href="https://doc-snapshots.qt.io/qt6-dev/qlibraryinfo.html#LibraryPath-enum" target="_blank" rel="noopener">QLibraryInfo::LibraryPath</a>。</p><h2 id="11、Qt-状态机框架"><a href="#11、Qt-状态机框架" class="headerlink" title="11、Qt 状态机框架"></a>11、Qt 状态机框架</h2><p><a href="https://doc-snapshots.qt.io/qt6-dev/qtstatemachine-index.html" target="_blank" rel="noopener">Qt 状态机</a>被移入 Qt SCXML 模块（即将重命名为 Qt 状态机），因此它不再是 Qt 核心的一部分。Qt Core 内部很少有交叉依赖项，最终导致了这个决定。</p><h2 id="12、使用-Qt5Compat-模块"><a href="#12、使用-Qt5Compat-模块" class="headerlink" title="12、使用 Qt5Compat 模块"></a>12、使用 Qt5Compat 模块</h2><p>要使用<a href="https://doc-snapshots.qt.io/qt6-dev/qtcore5-index.html" target="_blank" rel="noopener">Qt5Compat</a>模块，您需要在包含路径中使用它的头文件进行构建，并链接到它的库。如果您使用的是<a href="https://doc-snapshots.qt.io/qt6-dev/resources.html#qmake" target="_blank" rel="noopener">qmake</a>，请将以下内容添加到您的<code>.pro</code>文件中：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QT += core5compat</span><br></pre></td></tr></table></figure><p><a href="https://doc-snapshots.qt.io/qt6-dev/cmake-manual.html" target="_blank" rel="noopener">如果您使用cmake</a>构建应用程序或库，请将以下内容添加到您的<code>CMakeList.txt</code>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLIC_LIBRARIES</span><br><span class="line">    Qt::Core5Compat</span><br></pre></td></tr></table></figure><h1 id="七、从-Qt-5-移植"><a href="#七、从-Qt-5-移植" class="headerlink" title="七、从 Qt 5 移植"></a>七、从 Qt 5 移植</h1><p>在开发 Qt 6 时，与 Qt 5 的源代码兼容性一直是我们工作的关键部分。有一些地方我们不得不在某种程度上打破这种兼容性，以进行一些必需的架构更改或为我们带来一些巨大的性能优势。</p><p>在大多数情况下，从 Qt 5 移植到 Qt 6 应该很简单。在Qt的6移植指南 列出了所需要的步骤，并具有更多的信息。您还可以从我们的合作伙伴之一或我们的顾问那里获得移植帮助。</p><p>移植到 Qt 6 的典型步骤是：</p><ul><li>检查您是否使用了受支持的编译器和平台版本</li><li>首先在 Qt 6 模式下使用 Qt 5.15 编译（使用 QT_DISABLE_DEPRECATED_BEFORE 宏）</li><li>然后用 Qt 6.x 编译 - 如果需要，在移植阶段利用兼容性模块</li></ul><p>有了这些，您就可以在 Qt 6 上运行应用程序，并可以开始使用它提供的所有新特性和功能。例如，如果您的应用程序使用 QML，请运行 qmlint 工具并修复它给出的警告。</p><h2 id="1、变化总括"><a href="#1、变化总括" class="headerlink" title="1、变化总括"></a>1、变化总括</h2><p>1）. 增加了很多轮子，同时原有模块拆分的也更细致，估计为了方便拓展个管理。</p><p>2）. 把一些过度封装的东西移除了（比如同样的功能有多个函数），保证了只有一个函数执行该功能。<br>3）. 把一些Qt5中兼容Qt4的方法废弃了，必须用Qt5中对应的新的函数。<br>4）. 跟随时代脚步，增加了不少新特性以满足日益增长的客户需求。<br>5）. 对某些模块和类型及处理进行了革命性的重写，运行效率提高不少。<br>6）. 有参数类型的变化，比如 long <em> 到 qintptr </em> 等，更加适应后续的拓展以及同时对32 64位不同系统的兼容。<br>7）. 源码中的double数据类型全部换成了qreal，和Qt内部数据类型高度一致和统一。<br>8）. 我测试的都是QWidget部分，quick部分没有测试，估计quick部分更新可能会更多。<br>9）. 强烈建议暂时不要用Qt6.0到Qt6.2之间的版本，一些模块还缺失，相对来说BUG也比较多，推荐6.2版本开始正式迁移。</p><h2 id="2、移植案例"><a href="#2、移植案例" class="headerlink" title="2、移植案例"></a>2、移植案例</h2><h3 id="新的-Qt-模块状态机"><a href="#新的-Qt-模块状态机" class="headerlink" title="新的 Qt 模块状态机"></a>新的 Qt 模块状态机</h3><p>具有 QStateMachine、QState 和 QFinalState 等类的状态机框架已从模块 Core 移至新模块 StateMachine。我们<code>StateMachine</code>在<em>CMakeLists.txt</em>文件中添加<code>find_package</code>调用和调用。<code>Qt6::StateMachine`</code>target_link_libraries`</p><h3 id="Error-no-match-for-‘operator-lt-’-operand-types-are-‘const-QVariant’-and-‘const-QVariant’"><a href="#Error-no-match-for-‘operator-lt-’-operand-types-are-‘const-QVariant’-and-‘const-QVariant’" class="headerlink" title="Error: no match for ‘operator&lt;’ (operand types are ‘const QVariant’ and ‘const QVariant’)"></a>Error: no match for ‘operator&lt;’ (operand types are ‘const QVariant’ and ‘const QVariant’)</h3><p><em>问题</em>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QMap</span>&lt;<span class="selector-tag">std</span><span class="selector-pseudo">::pair</span>&lt;<span class="selector-tag">QString</span>, <span class="selector-tag">QVariant</span>&gt;, <span class="selector-tag">QObject</span> *&gt; <span class="selector-tag">m_entities</span>;</span><br><span class="line"><span class="selector-tag">m_impl-</span>&gt;<span class="selector-tag">m_entities</span><span class="selector-class">.insert</span>(<span class="selector-tag">it</span><span class="selector-class">.key</span>(), <span class="selector-tag">it</span><span class="selector-class">.value</span>());</span><br></pre></td></tr></table></figure><p>该函数返回一个&gt; 类型的对象，它与 . 的键类型相同。QMap 需要在键类型上定义才能知道在哪里插入新值。<code>it.key()`</code>std::pair&lt;QString, QVariant<code>QMap</code>operator&lt;`</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMap<span class="string">`比较该对`</span>p1<span class="string">`是否小于`</span>p2<span class="string">`，两者都`</span>p1<span class="string">`具有`</span>p2<span class="string">`类型。如果等于，则比较必须计算。G++-9 正确地抱怨没有为s 定义。G++-7 忽略了 s的缺失。`</span>std::pair&lt;QString, QVariant&gt;<span class="string">``</span>p1.first<span class="string">``</span>p2.first<span class="string">``</span>p1.second &lt; p2.second<span class="string">``</span>operator&lt;<span class="string">``</span>QVariant<span class="string">``</span>operator&lt;<span class="string">``</span>QVariant</span><br></pre></td></tr></table></figure><p><em>修复</em>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">QMap</span>&lt;<span class="selector-tag">std</span><span class="selector-pseudo">::pair</span>&lt;<span class="selector-tag">QString</span>, <span class="selector-tag">QString</span>&gt;, <span class="selector-tag">QObject</span> *&gt; <span class="selector-tag">m_entities</span>;</span><br><span class="line"><span class="selector-tag">m_impl-</span>&gt;<span class="selector-tag">m_entities</span><span class="selector-class">.insert</span>(<span class="selector-tag">it</span><span class="selector-class">.key</span>(), <span class="selector-tag">it</span><span class="selector-class">.value</span>());</span><br></pre></td></tr></table></figure><p>将 a<code>QVariant</code>转换为<code>QString</code>with适用于. 由于仅对其键的第二个元素使用支持的类型，我们可以安全地替换键类型中的by 。<code>QVariant::toString()`</code>QVariant<code>m_entities</code>QVariant<code></code>QString`</p><h3 id="Error-QTextCodec-No-such-file-or-directory"><a href="#Error-QTextCodec-No-such-file-or-directory" class="headerlink" title="Error: QTextCodec: No such file or directory"></a>Error: QTextCodec: No such file or directory</h3><p><em>问题</em>：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QTextCodec&gt;</span></span></span><br><span class="line">...</span><br><span class="line">QTextStream is&#123;&amp;csvFile&#125;;</span><br><span class="line">is.setCodec(<span class="symbol">QTextCodec::</span>codecForName(<span class="string">"ISO-8859-1"</span>));</span><br></pre></td></tr></table></figure><p>该类<code>QTextCodec</code>已从 Qt 6 中删除，并被新的类所取代<code>QStringConverter</code>。同样，类<code>QTextEncoder</code>and<code>QTextDecoder</code>被 and 取代<code>QStringEncoder</code>（<code>QStringDecoder</code>参见这篇<a href="https://www.qt.io/blog/porting-from-qt-5-to-qt-6-using-qt5compat-library" target="_blank" rel="noopener">文章</a>）。使用任何旧类的代码都无法编译。</p><p><em>修复</em>：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringConverter&gt;</span></span></span><br><span class="line">...</span><br><span class="line">QTextStream is&#123;&amp;csvFile&#125;;</span><br><span class="line">is.setEncoding(<span class="symbol">QStringConverter::</span>Latin1);</span><br></pre></td></tr></table></figure><p>我们包括替换类的标题<code>QStringConverter</code>。搜索 的功能最<code>QStringConverter</code>有<code>setEncoding</code>可能替代<code>setCodec</code>. 了解 ISO-8859-1 是 Latin1 的正式名称有助于我们<code>setEncoding</code>使用正确的常量调用。<code>QStringConverter::Latin1</code></p><h3 id="Error-QRegExp-No-such-file-or-directory"><a href="#Error-QRegExp-No-such-file-or-directory" class="headerlink" title="Error: QRegExp: No such file or directory"></a>Error: QRegExp: No such file or directory</h3><p>问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QRegExp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In anonymous namespace</span></span><br><span class="line"><span class="function">QRegExp &amp;<span class="title">rxHexFilename</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> QRegExp <span class="title">rx</span><span class="params">(<span class="string">"_(A\\d\\d)_V_(\\d\\d)_(\\d\\d)\\.hex$"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> rx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In constructor</span></span><br><span class="line"><span class="keyword">auto</span> pos = rxHexFilename().indexIn(fileName);</span><br><span class="line"><span class="keyword">auto</span> ecuName = rxHexFilename().cap(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span> || ...) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_version = QString(<span class="string">"v%1.%2"</span>)</span><br><span class="line">    .arg(rxHexFilename().cap(<span class="number">2</span>).toUInt())</span><br><span class="line">    .arg(rxHexFilename().cap(<span class="number">3</span>).toUInt());</span><br><span class="line">m_ecuType = fileName.left(fileName.size() - </span><br><span class="line">    rxHexFilename().matchedLength());</span><br></pre></td></tr></table></figure><p>替换<code>QRegExp</code>——Qt 4 的遗物——<code>QRegularExpression</code>自 Qt 5.0 以来一直在酝酿之中。<code>QRegularExpression</code>是在 Qt 6 中使用正则表达式的唯一方法。界面发生了很大变化。</p><p>修复：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QRegularExpression&gt;</span><br><span class="line"></span><br><span class="line">// In anonymous namespace</span><br><span class="line">const QRegularExpression rxHexFilename(<span class="string">"_(A\\d\\d)_V_(\\d\\d)_(\\d\\d)\\.hex$"</span>);</span><br><span class="line"></span><br><span class="line">// In <span class="built_in">constructor</span></span><br><span class="line"><span class="built_in">auto</span> <span class="keyword">match</span> = rxHexFilename.<span class="keyword">match</span>(fileName);</span><br><span class="line"><span class="built_in">auto</span> ecuName = <span class="keyword">match</span>.captured(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">match</span>.hasMatch() |<span class="type">| ...) &#123;</span></span><br><span class="line"><span class="type">    return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_version = QString(<span class="string">"v%1.%2"</span>)</span><br><span class="line">    .arg(<span class="keyword">match</span>.captured(<span class="number">2</span>).toUInt())</span><br><span class="line">    .arg(<span class="keyword">match</span>.captured(<span class="number">3</span>).toUInt());</span><br><span class="line">m_ecuType = fileName.<span class="built_in">left</span>(fileName.size() - </span><br><span class="line">    <span class="keyword">match</span>.capturedLength(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>将字符串与正则表达式匹配的函数有它的自然名称：（<code>match</code>而不是<code>indexIn</code>）。它返回一个<code>QRegularExpressionMatch</code>对象<code>match</code>而不是索引。我们通过调用来检索<code>nth</code>捕获的子字符串。match.hasMatch() 告诉我们字符串是否匹配正则表达式。<code>match.captured(nth)</code></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QRegExp<span class="type">::matchedLength</span><span class="string">`返回匹配完整正则表达式的子字符串的长度。此子字符串与第 0 个捕获的子字符串相同，其长度为。`</span><span class="keyword">match</span>.captured(<span class="number">0</span>)<span class="string">``</span><span class="keyword">match</span>.capturedLength(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="Error-‘class-QString’-has-no-member-named-‘midRef"><a href="#Error-‘class-QString’-has-no-member-named-‘midRef" class="headerlink" title="Error: ‘class QString’ has no member named ‘midRef"></a>Error: ‘class QString’ has no member named ‘midRef</h3><p><em>问题</em>：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">subDev</span> = m_deviceName.midRef(splitPos + 1).toLatin1();</span><br></pre></td></tr></table></figure><p>该函数在 Qt 6 中已过时。该函数也是如此。<code>QString::midRef`</code>QString::leftRef`</p><p><em>修复</em>：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">subDev</span> = m_deviceName.mid(splitPos + 1).toLatin1();</span><br></pre></td></tr></table></figure><p>我们将和分别替换为和。<code>QString::midRef`</code>QString::leftRef<code>QString::mid</code>QString::left`</p><h3 id="Error-cannot-convert-‘QString’-to-‘const-QFileInfo-amp-’"><a href="#Error-cannot-convert-‘QString’-to-‘const-QFileInfo-amp-’" class="headerlink" title="Error: cannot convert ‘QString’ to ‘const QFileInfo&amp;’"></a>Error: cannot convert ‘QString’ to ‘const QFileInfo&amp;’</h3><p><em>问题</em>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString extractVersion(<span class="name">const</span> QFileInfo <span class="symbol">&amp;info</span>) const<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">QString fileName(...)<span class="comment">;</span></span><br><span class="line">auto version = extractVersion(<span class="name">fileName</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在 Qt 5 中，该函数使用构造函数<code>extractVersion</code>将 隐式转换<code>QString</code> <code>filename</code>为<code>QFileInfo</code>对象。在 Qt 6 中，这个构造函数被标记为，它阻止了隐式转换。<code>QFileInfo(const QString &amp;)`</code>explicit`</p><p><em>修复</em>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString extractVersion(<span class="name">const</span> QFileInfo <span class="symbol">&amp;info</span>) const<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">QString fileName(...)<span class="comment">;</span></span><br><span class="line">auto version = extractVersion(<span class="name">QFileInfo</span>(<span class="name">fileName</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>我们通过显式调用构造函数来消除错误。<code>QFileInfo(const QString &amp;)</code></p><h3 id="Error-invalid-application-of-‘sizeof’-to-incomplete-type-‘IntegerRangeModel’"><a href="#Error-invalid-application-of-‘sizeof’-to-incomplete-type-‘IntegerRangeModel’" class="headerlink" title="Error: invalid application of ‘sizeof’ to incomplete type ‘IntegerRangeModel’"></a>Error: invalid application of ‘sizeof’ to incomplete type ‘IntegerRangeModel’</h3><p><em>问题</em>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">IntegerRangeModel</span>;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">DateTimeModel</span> : public <span class="type">QObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class">    <span class="type">Q_OBJECT</span></span></span><br><span class="line"><span class="class">    <span class="type">Q_PROPERTY</span>(<span class="type">IntegerRangeModel</span>* <span class="title">days</span> <span class="type">READ</span> <span class="title">days</span> <span class="type">CONSTANT</span>)</span></span><br></pre></td></tr></table></figure><p>的前向声明对于Qt 5<code>IntegerRangeModel</code>中的定义来说已经足够好了，因为它被声明为一个指针。Qt 6 添加了一个静态断言。另一条错误消息记录了对静态断言的违反：<code>Q_PROPERTY`</code>days`</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static_assert(<span class="name">sizeof</span>(<span class="name">T</span>), <span class="string">"Type argument of Q_PROPERTY or Q_DECLARE_METATYPE(T*) must be fully defined"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><em>修复</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"IntegerRangeModel.h"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateTimeModel</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    Q_PROPERTY(IntegerRangeModel* days READ days CONSTANT)</span><br></pre></td></tr></table></figure><p>我们通过包含头文件<code>IntegerRangeModel</code>而不是前向声明来消除错误消息<code>IntegerRangeModel</code>。</p><h3 id="Warning-‘Type’-is-deprecated-Use-QMetaType-Type-instead-Wdeprecated-declarations"><a href="#Warning-‘Type’-is-deprecated-Use-QMetaType-Type-instead-Wdeprecated-declarations" class="headerlink" title="Warning: ‘Type’ is deprecated: Use QMetaType::Type instead. [-Wdeprecated-declarations]"></a>Warning: ‘Type’ is deprecated: Use QMetaType::Type instead. [-Wdeprecated-declarations]</h3><p><em>问题</em>：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityColumn(<span class="keyword">const</span> QString &amp;<span class="keyword">name</span>, QVariant::<span class="keyword">Type</span> <span class="keyword">type</span>, ...)</span><br></pre></td></tr></table></figure><p>枚举列出了可以存储在. 它大致是 enumeration 的一个子集，它列出了 Qt 元对象系统已知的类型。建议自己替换。不再包含在 Qt 6 中。<code>QVariant::Type`</code>QVariant<code>QMetaType::Type</code>QVariant::Type<code>QMetaType::Type</code>QVariant::Type`</p><p><em>修复</em>：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityColumn(<span class="keyword">const</span> QString &amp;<span class="keyword">name</span>, QMetaType::<span class="keyword">Type</span> <span class="keyword">type</span>, ...)</span><br></pre></td></tr></table></figure><p>在 Qt 6 中，我们使用而不是. 我们还必须分别替换过时的枚举常量，例如,和,和。<code>QMetaType::Type`</code>QVariant::Type<code>QVariant::Invalid</code>QVariant::UInt<code>QVariant::Bool</code>QMetaType::UnknownType<code>QMetaType::UInt</code>QMetaType::Bool`</p><h3 id="Error-cannot-convert-‘QVariant-Type’-to-‘QMetaType-Type’"><a href="#Error-cannot-convert-‘QVariant-Type’-to-‘QMetaType-Type’" class="headerlink" title="Error: cannot convert ‘QVariant::Type’ to ‘QMetaType::Type’"></a>Error: cannot convert ‘QVariant::Type’ to ‘QMetaType::Type’</h3><p><em>问题</em>：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool typesAreAffine(QMetaType<span class="type">::Type</span> sqlType, <span class="params">...</span>) const;</span><br><span class="line"></span><br><span class="line">QSqlField tableColumn = <span class="params">...</span>;</span><br><span class="line"><span class="keyword">if</span> (!typesAreAffine(tableColumn.<span class="keyword">type</span>(), <span class="params">...</span>)) <span class="params">...</span></span><br></pre></td></tr></table></figure><p>最初， 的第一个参数<code>typesAreAffine</code>具有 type ，它被前面的迁移步骤替换。具有返回类型的函数在 Qt 6 中不存在。<code>QVariant::Type`</code>QMetaType::Type<code>QSqlField::type</code>QVariant::Type`</p><p><em>修复</em>：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool typesAreAffine(QMetaType<span class="type">::Type</span> sqlType, <span class="params">...</span>) const;</span><br><span class="line"></span><br><span class="line">QSqlField tableColumn = <span class="params">...</span>;</span><br><span class="line"><span class="keyword">if</span> (!typesAreAffine(QMetaType<span class="type">::Type</span>(tableColumn.metaType().id()), <span class="params">...</span>)) <span class="params">...</span></span><br></pre></td></tr></table></figure><p>我们用 Qt 6 函数替换现在已过时的 Qt 5 函数。返回一个对象。我们使用 检索对象的类型 ID ，它返回一个而不是 a来为自定义元类型打开。从整数创建一个枚举常量。<code>QSqlField::metaType()`</code>QSqlField::type()<code>QSqlField::metaType()</code>QMetaType<code>QMetaType</code>id()<code>int</code>QMetaType::Type<code>QMetaType::Type(typeID)</code>typeID`</p><h3 id="Error-warning-conversion-from-‘qsizetype’-aka-‘long-long-int’-to-‘int’-may-change-value-Wconversion"><a href="#Error-warning-conversion-from-‘qsizetype’-aka-‘long-long-int’-to-‘int’-may-change-value-Wconversion" class="headerlink" title="Error: warning: conversion from ‘qsizetype’ {aka ‘long long int’} to ‘int’ may change value [-Wconversion]"></a>Error: warning: conversion from ‘qsizetype’ {aka ‘long long int’} to ‘int’ may change value [-Wconversion]</h3><p><em>问题</em>：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QFileInfo&gt; m_dirEntries.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DirectoryModel::rowCount(<span class="keyword">const</span> QModelIndex &amp;<span class="keyword">parent</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(<span class="keyword">parent</span>)</span><br><span class="line">    <span class="keyword">return</span> m_impl-&gt;m_dirEntries.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 Qt 6.0 开始，具有返回类型，相当于. DirectoryModel 类间接派生自，它像这样声明纯虚函数：<code>QList&lt;T&gt;::size()`</code>qsizetype<code>long long int</code>QAbstractItemModel<code></code>rowCount`</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">rowCount</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;parent = QModelIndex())</span> <span class="keyword">const</span> </span>= <span class="number">0</span></span><br></pre></td></tr></table></figure><p>该<code>return</code>语句可以将一个值缩小为一个值，这可能会改变该值。似乎 Qt 开发人员忘记了将from的返回类型更改为.<code>long long int`</code>int<code>rowCount</code>int<code></code>qsizetype`</p><p>类似<code>beginInsertRows</code>,<code>beginRemoveRows</code>和<code>beginMoveRows</code>的函数<code>beginInsertColumns</code>也接受<code>int</code>-type 参数。我们可能还需要注意缩小转化率。</p><p><em>修复</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">QList&lt;QFileInfo&gt; m_dirEntries.</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> DirectoryModel::rowCount(<span class="keyword">const</span> QModelIndex &amp;parent) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Q_UNUSED(parent)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(m_impl-&gt;m_dirEntries.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时没有办法绕过静态演员表。这是其中之一。我们将值强制<code>qsizetype</code>转换为 int<code>value</code>并消除错误。</p><h3 id="Warning-conversion-from-‘size-t’-aka-‘long-unsigned-int’-to-‘uint’-aka-‘unsigned-int’-may-change-value-Wconversion"><a href="#Warning-conversion-from-‘size-t’-aka-‘long-unsigned-int’-to-‘uint’-aka-‘unsigned-int’-may-change-value-Wconversion" class="headerlink" title="Warning: conversion from ‘size_t’ {aka ‘long unsigned int’} to ‘uint’ {aka ‘unsigned int’} may change value [-Wconversion]"></a>Warning: conversion from ‘size_t’ {aka ‘long unsigned int’} to ‘uint’ {aka ‘unsigned int’} may change value [-Wconversion]</h3><p>问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitId</span> :</span> quint16 &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> uint <span class="title">qHash</span><span class="params">(UnitId unit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qHash(<span class="keyword">static_cast</span>&lt;quint16&gt;(unit));</span><br><span class="line">&#125;</span><br><span class="line">qHash``uint`函数在 Qt <span class="number">5</span> 中返回值`uint`，其中. 在 Qt <span class="number">6</span> 中，它们返回值，其中是. 语句中的函数是一个内置的散列函数。它返回一个值，该值可以通过自定义散列函数缩小为一个值。由于这可能会更改值，因此编译器会发出警告。`<span class="keyword">unsigned</span> <span class="keyword">int</span>``<span class="keyword">size_t</span>``<span class="keyword">size_t</span>``<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>``qHash``<span class="keyword">return</span>``<span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>``<span class="keyword">unsigned</span> <span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>修复：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">UnitId</span> :</span> quint16 &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> size_t <span class="title">qHash</span><span class="params">(UnitId unit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qHash(<span class="keyword">static_cast</span>&lt;quint16&gt;(unit));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将自定义散列函数的返回类型从<code>uint</code>更改为<code>size_t</code>。</p><h3 id="Warning-‘static-QQmlFileSelector-QQmlFileSelector-get-QQmlEngine-’-is-deprecated-Wdeprecated-declarations"><a href="#Warning-‘static-QQmlFileSelector-QQmlFileSelector-get-QQmlEngine-’-is-deprecated-Wdeprecated-declarations" class="headerlink" title="Warning: ‘static QQmlFileSelector QQmlFileSelector::get(QQmlEngine)’ is deprecated [-Wdeprecated-declarations]"></a>Warning: ‘static QQmlFileSelector<em> QQmlFileSelector::get(QQmlEngine</em>)’ is deprecated [-Wdeprecated-declarations]</h3><p><em>问题</em>：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> fs = QQmlFileSelector::<span class="built_in">get</span>(engine);</span><br><span class="line">fs-&gt;setExtraSelectors(&#123;<span class="string">"left"</span>&#125;);</span><br></pre></td></tr></table></figure><p>静态函数返回 QML 上当前活动的文件选择器。它在 Qt 6 中已过时，因为它复制了构造函数提供的功能。<code>QQmlFileSelector::get`</code>engine<code></code>QQmlFileSelector`</p><p><em>修复</em>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto fs = new QQmlFileSelector(<span class="name">engine</span>)<span class="comment">;</span></span><br><span class="line">fs-&gt;setExtraSelectors(&#123;<span class="string">"left"</span>&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>在堆上创建<code>QQmlFileSelector</code>对象与调用. 我们必须在堆上创建对象，因为构造函数参数拥有文件选择器的所有权。<code>QQmlFileSelector::get`</code>engine`</p><h3 id="Error-using-typedef-name-‘using-QStringList-class-QList’-after-‘class"><a href="#Error-using-typedef-name-‘using-QStringList-class-QList’-after-‘class" class="headerlink" title="Error: using typedef-name ‘using QStringList = class QList’ after ‘class"></a>Error: using typedef-name ‘using QStringList = class QList<qstring>’ after ‘class</qstring></h3><p><em>问题</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QStringList</span>;</span></span><br></pre></td></tr></table></figure><p>包含的 Qt 头文件介绍了类型定义。有问题的行向前声明了编译器不喜欢的这种类型定义。<code>using QStringList = class QList&lt;QString&gt;</code></p><p><em>修复</em>：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QStringList&gt;</span></span></span><br></pre></td></tr></table></figure><p>我们通过包含头文件来替换前向声明。</p><h3 id="Error-‘QLatin1Literal’-was-not-declared-in-this-scope-did-you-mean-‘QStringLiteral’"><a href="#Error-‘QLatin1Literal’-was-not-declared-in-this-scope-did-you-mean-‘QStringLiteral’" class="headerlink" title="Error: ‘QLatin1Literal’ was not declared in this scope; did you mean ‘QStringLiteral’?"></a>Error: ‘QLatin1Literal’ was not declared in this scope; did you mean ‘QStringLiteral’?</h3><p><em>问题</em>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList errors<span class="comment">;</span></span><br><span class="line">Q_ASSERT_X(<span class="name">false</span>, __PRETTY_FUNCTION__, </span><br><span class="line">    errors.join(<span class="name">QLatin1Literal</span>(<span class="string">"; "</span>)).toUtf8())<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><code>QLatin1Literal</code> Qt 6 中不再存在。</p><p><em>修复</em>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QStringList errors<span class="comment">;</span></span><br><span class="line">Q_ASSERT_X(<span class="name">false</span>, __PRETTY_FUNCTION__, </span><br><span class="line">    errors.join(<span class="name">QLatin1String</span>(<span class="string">"; "</span>)).toUtf8())<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>我们替换<code>QLatin1Literal</code>为<code>QLatin1String</code>。</p><h3 id="Error-No-type-name-‘State’-in-QMediaPlayer"><a href="#Error-No-type-name-‘State’-in-QMediaPlayer" class="headerlink" title="Error: No type name ‘State’ in QMediaPlayer"></a>Error: No type name ‘State’ in QMediaPlayer</h3><p><em>问题：</em></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">on</span>StateChanged(QMediaPlayer::State <span class="keyword">state</span>);</span><br><span class="line"></span><br><span class="line">connect(&amp;m_impl-&gt;m_player, &amp;QMediaPlayer::<span class="keyword">state</span>Changed,</span><br><span class="line">        m_impl, &amp;Impl::<span class="keyword">on</span>StateChanged);</span><br><span class="line"></span><br><span class="line">if (m_player.<span class="keyword">state</span>() != QMediaPlayer::PlayingState) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>我们用信号替换并连接插槽。我们还需要替换对by 的调用。<code>QMediaPlayer::State`</code>QMediaPlayer::PlaybackState<code>onStateChanged</code>QMediaPlayer::playbackStateChanged<code>QMediaPlayer::state()</code>QMediaPlayer::playbackState()`</p><p><em>修复：</em></p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> onStateChanged(QMediaPlayer<span class="type">::PlaybackState</span> state);</span><br><span class="line"></span><br><span class="line">connect(&amp;m_impl-&gt;m_player, &amp;QMediaPlayer<span class="type">::playbackStateChanged</span>,</span><br><span class="line">        m_impl, &amp;Impl<span class="type">::onStateChanged</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m_player.playbackState() != QMediaPlayer<span class="type">::PlayingState</span>) &#123; <span class="params">...</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="Error-‘QMediaPlaylist’-No-such-file-or-directory"><a href="#Error-‘QMediaPlaylist’-No-such-file-or-directory" class="headerlink" title="Error: ‘QMediaPlaylist’: No such file or directory"></a>Error: ‘QMediaPlaylist’: No such file or directory</h3><p><em>问题：</em></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMediaPlaylist&gt;</span></span></span><br></pre></td></tr></table></figure><p><a href="https://doc.qt.io/qt-6/qtmultimedia-changes-qt6.html" target="_blank" rel="noopener">Changes to Qt Multimedia</a>页面通知我们该类<code>QMediaPlaylist</code>已从 Qt 6 中删除。当显示信息、警告或错误对话框时，应用程序会播放不同的 MP3 文件。它将<code>QMediaPlaylist</code>带有正确 MP3 文件的 a 传递给<code>QMediaPlayer</code>. 用户还可以更改播放音量。</p><p><em>修复：</em></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMediaPlaylist<span class="string">`替换为。音量不能直接用 改变，但可以用 间接改变。以下有关 QMediaPlayer 和 QMediaPlaylist 的错误消息告诉我们要修复什么。`</span>QMediaPlayer::setSource<span class="string">``</span>QMediaPlayer::setVolume<span class="string">``</span>QAudioOutput::setVolume</span><br></pre></td></tr></table></figure><h3 id="Error-No-member-named-‘setVolume’-in-‘QMediaPlayer’"><a href="#Error-No-member-named-‘setVolume’-in-‘QMediaPlayer’" class="headerlink" title="Error: No member named ‘setVolume’ in ‘QMediaPlayer’"></a>Error: No member named ‘setVolume’ in ‘QMediaPlayer’</h3><p><em>问题：</em></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_player.setVolume(<span class="number">80</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>Qt 6 将函数<code>setVolume</code>和<code>volume</code>从<code>QMediaPlayer</code>移至<code>QAudioOutput</code>.</p><p><em>修复：</em></p><p>使用的客户端类必须在其构造函数中向该对象<code>QMediaPlayer</code>注册一个<code>QAudioOutput</code>对象。我们必须告诉对象它应该在哪个扬声器上播放 MP3 文件。我们可以使用 访问默认扬声器。这对于只有一个扬声器的终端硬件来说已经足够了。<code>QMediaPlayer`</code>m_player<code>QAudioOutput</code>QMediaDevices::defaultAudioOutput`</p><p>客户端类将音量设置为默认值（例如，0.8）。请注意，新的采用 0.0 到 1.0 之间的浮点值作为参数，而旧的采用 0 到 100 之间的整数。<code>QAudioOutput::setVolume`</code>QMediaPlayer::setVolume`</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto audioOut = new QAudioOutput&#123;&#125;<span class="comment">;</span></span><br><span class="line">audioOut-&gt;setDevice(QMediaDevices::defaultAudioOutput())<span class="comment">;</span></span><br><span class="line">audioOut-&gt;setVolume(<span class="number">0</span>.<span class="number">8</span>f)<span class="comment">;</span></span><br><span class="line">m_player.setAudioOutput(audioOut)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>客户端类的函数改变音量如下：<code>setVolume(int vol)</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_player.audioOutput<span class="function"><span class="params">()</span>-&gt;</span>setVolume(<span class="number">0.8f</span>);</span><br></pre></td></tr></table></figure><h3 id="Error-QMediaPlayer-cannot-play-back-a-QMediaPlaylist-any-more"><a href="#Error-QMediaPlayer-cannot-play-back-a-QMediaPlaylist-any-more" class="headerlink" title="Error: QMediaPlayer cannot play back a QMediaPlaylist any more"></a>Error: QMediaPlayer cannot play back a QMediaPlaylist any more</h3><p><em>问题：</em></p><p>当然，标题错误信息并不是真正的编译器错误。由于 QMediaPlaylist 从 Qt 6 中删除，以下错误类别的播放功能不再编译。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">AudioService</span><span class="selector-pseudo">::Impl</span><span class="selector-pseudo">::playFeedback(int</span> <span class="selector-tag">category</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">m_playlist</span><span class="selector-class">.addMedia</span>(m_audioFiles[category]);</span><br><span class="line">    <span class="selector-tag">m_player</span><span class="selector-class">.play</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">m_audioFiles</span><span class="selector-attr">[category]</span>`返回给定错误的 <span class="selector-tag">MP3</span> 文件的 <span class="selector-tag">QRC</span> <span class="selector-tag">URL</span> `<span class="selector-tag">category</span>`。例如，它返回类别 <span class="selector-tag">2</span>。`<span class="selector-tag">QUrl</span>(<span class="string">"qrc:/Can/Audio/ding.mp3"</span>)</span><br></pre></td></tr></table></figure><p><em>修复：</em></p><p>为给定播放 MP3 文件的修改函数<code>category</code>如下所示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AudioService::Impl::playFeedback(<span class="keyword">int</span> category)</span><br><span class="line">&#123;</span><br><span class="line">    m_player.setSource(m_audioFiles[category]);</span><br><span class="line">    m_player.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QML-警告、错误和改进"><a href="#QML-警告、错误和改进" class="headerlink" title="QML 警告、错误和改进"></a>QML 警告、错误和改进</h3><h4 id="Remove-versions-from-import-statements"><a href="#Remove-versions-from-import-statements" class="headerlink" title="Remove versions from import statements"></a>Remove versions from import statements</h4><p><em>问题：</em></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick 2.15</span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls 2.15</span><br><span class="line"><span class="keyword">import</span> Ag.Models 1.0</span><br></pre></td></tr></table></figure><p>Qt 5 需要导入模块的版本。Qt 6 不会抱怨这些版本，但它不再需要它们。</p><p><em>使固定：</em></p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> QtQuick</span><br><span class="line"><span class="keyword">import</span> QtQuick.Controls</span><br><span class="line"><span class="keyword">import</span> Ag.Models</span><br></pre></td></tr></table></figure><p>在 Qt 6 中只导入一个没有版本的模块就足够了。我们从所有导入语句中删除了版本。</p><h4 id="警告：未声明参数“page”。不推荐将参数注入信号处理程序。"><a href="#警告：未声明参数“page”。不推荐将参数注入信号处理程序。" class="headerlink" title="警告：未声明参数“page”。不推荐将参数注入信号处理程序。"></a>警告：未声明参数“page”。不推荐将参数注入信号处理程序。</h4><p><em>问题：</em></p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// File: RDirectBar.qml</span></span><br><span class="line">Pane </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">signal</span><span class="string"> selectedPage</span>(<span class="built_in">url</span> page, <span class="built_in">bool</span> fullscreen)</span><br><span class="line"></span><br><span class="line"><span class="comment">// File: main.qml</span></span><br><span class="line">RDirectBar</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">onSelectedPage</span>: &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>信号在 的实例化中<code>selectedPage</code>连接到信号处理程序。Qt 6 接受带有警告的旧式信号处理程序。<code>onSelectedPage`</code>RDirectBar`</p><p><em>使固定：</em></p><p>新方法是使用箭头函数或匿名函数（参见Qt 6.2 文档中的<a href="https://doc.qt.io/qt-6/qtqml-syntax-signals.html#signal-parameters" target="_blank" rel="noopener">信号参数</a>）。我们在 C++ 中称它们为 lambda 函数。</p><h2 id="3、移植总结"><a href="#3、移植总结" class="headerlink" title="3、移植总结"></a>3、移植总结</h2><p>1）. 万能方法：安装5.15版本，定位到报错的函数，切换到源码头文件，可以看到对应提示字样 QT_DEPRECATED_X(“Use sizeInBytes”) 和新函数。按照这个提示类修改就没错，一些函数是从Qt5.7 5.9 5.10等版本新增加的，可能你的项目还用的Qt4的方法，但是Qt6以前都兼容这些旧方法，到了Qt6就彻底需要用新方法了。<br>2）. Qt6对core这个核心类进行了拆分，多出来core5compat，因此你需要在pro增加对应的模块已经代码中引入对应的头文件。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pro文件引入模块</span></span><br><span class="line">greaterThan(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line">greaterThan(QT_MAJOR_VERSION, <span class="number">5</span>): QT += core5compat</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码中引入头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtWidgets&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtCore5Compat&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>（1）. 默认Qt6开启了高分屏支持，界面会变得很大，甚至字体发虚，很多人会不习惯，因为这种模式如果程序很多坐标计算没有采用devicePixelRatio进行运算的话，100%会出现奇奇怪怪的问题，因为坐标不准确了。要取消这种效果可以设置高分屏缩放因子。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="symbol">    QGuiApplication:</span>:setHighDpiScaleFactorRoundingPolicy(<span class="symbol">Qt::</span><span class="symbol">HighDpiScaleFactorRoundingPolicy::</span>Floor);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>（1）. 原有的随机数函数提示用QRandomGenerator替代，为了兼容所有qt版本，改动最小的办法是直接用c++中的随机数，比如qsrand函数换成srand，qrand函数换成rand，查看过源代码，其实封装的就是c++中的随机数，很多类似的封装比如qSin封装的sin。<br>（2）. QColor的 light 改成 lighter ，dark 改成 darker，其实 lighter、darker 这两个方法以前一直有。<br>（3）. QFontMetricsF 中的 fm.width 换成 fm.horizontalAdvance ，从5.11开始用新函数。<br>（4）. QPalette调色板枚举值，Foreground = WindowText, Background = Window，其中 Foreground 和 Background 没有了，要用 WindowText 和 Window 替代，以前就有。类似的还有 setTextColor 改成了 setForeground 。<br>（5）. QWheelEvent的 delta() 改成 angleDelta().y()，pos() 改成 position() 。<br>（6）. svg模块拆分出来了svgwidgets，如果用到了该模块则需要在pro增加 QT += svgwidgets 。<br>（7）. qlayout中的 margin() 函数换成 contentsMargins().left()，查看源码得知以前的 margin() 返回的就是 contentsMargins().left()，在四个数值一样的时候，默认四个数值就是一样。类似的还有setMargin移除了，统统用setContentsMargins。<br>（8）. 之前 QChar c = 0xf105 全部要改成强制转换 QChar c = (QChar)0xf105，不再有隐式转换，不然编译报错提示error: conversion from ‘int’ to ‘QChar’ is ambiguous 。<br>（9）. qSort等一些函数用回c++的 std::sort 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="built_in">std</span>::sort(ipv4s.begin(), ipv4s.end());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    qSort(ipv4s);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>（1）. Qt::WA_NoBackground 改成 Qt::WA_OpaquePaintEvent 。<br>（2）. QMatrix 类废弃了没有了，换成 QTransform ，函数功能基本一致，QTransform 类在Qt4就一直有。<br>（3）. QTime 计时去掉了，需要改成 QElapsedTimer ，QElapsedTimer 类在Qt4就一直有。<br>（4）. QApplication::desktop()废弃了， 换成了 QApplication::primaryScreen()。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt; QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"qscreen.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> deskGeometry qApp-&gt;primaryScreen()-&gt;geometry()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> deskGeometry2 qApp-&gt;primaryScreen()-&gt;availableGeometry()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"qdesktopwidget.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> deskGeometry qApp-&gt;desktop()-&gt;geometry()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> deskGeometry2 qApp-&gt;desktop()-&gt;availableGeometry()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>（1）. 获取当前屏幕索引以及尺寸需要分别处理。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取当前屏幕索引</span></span><br><span class="line"><span class="keyword">int</span> QUIHelper::getScreenIndex()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要对多个屏幕进行处理</span></span><br><span class="line">    <span class="keyword">int</span> screenIndex = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">    <span class="keyword">int</span> screenCount = qApp-&gt;screens().count();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">int</span> screenCount = qApp-&gt;desktop()-&gt;screenCount();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">if</span> (screenCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//找到当前鼠标所在屏幕</span></span><br><span class="line">        QPoint pos = QCursor::pos();</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; screenCount; ++i) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">            <span class="built_in">if</span> (qApp-&gt;screens().at(i)-&gt;geometry().contains(pos)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="built_in">if</span> (qApp-&gt;desktop()-&gt;screenGeometry(i).contains(pos)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                screenIndex = i;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> screenIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前屏幕尺寸区域</span></span><br><span class="line">QRect QUIHelper::getScreenRect(<span class="keyword">bool</span> <span class="built_in">available</span>)</span><br><span class="line">&#123;</span><br><span class="line">    QRect <span class="built_in">rect</span>;</span><br><span class="line">    <span class="keyword">int</span> screenIndex = QUIHelper::getScreenIndex();</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">available</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">        <span class="built_in">rect</span> = qApp-&gt;screens().at(screenIndex)-&gt;availableGeometry();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">rect</span> = qApp-&gt;desktop()-&gt;availableGeometry(screenIndex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125; <span class="built_in">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(5,0,0))</span></span><br><span class="line">        <span class="built_in">rect</span> = qApp-&gt;screens().at(screenIndex)-&gt;geometry();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">rect</span> = qApp-&gt;desktop()-&gt;screenGeometry(screenIndex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">rect</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）. QRegExp类移到了core5compat模块，需要主动引入头文件 #include 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//设置限制只能输入数字+小数位</span></span><br><span class="line">    QString pattern = <span class="string">"^-?[0-9]+([.]&#123;1&#125;[0-9]+)&#123;0,1&#125;$"</span>;</span><br><span class="line">    <span class="comment">//设置IP地址校验过滤</span></span><br><span class="line">    QString pattern = <span class="string">"(2[0-5]&#123;2&#125;|2[0-4][0-9]|1?[0-9]&#123;1,2&#125;)"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确切的说 QRegularExpression QRegularExpressionValidator 从5.0 5.1开始就有</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    <span class="function">QRegularExpression <span class="title">regExp</span><span class="params">(pattern)</span></span>;</span><br><span class="line">    QRegularExpressionValidator *validator = <span class="keyword">new</span> QRegularExpressionValidator(regExp, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="function">QRegExp <span class="title">regExp</span><span class="params">(pattern)</span></span>;</span><br><span class="line">    QRegExpValidator *validator = <span class="keyword">new</span> QRegExpValidator(regExp, <span class="keyword">this</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    lineEdit-&gt;setValidator(validator);</span><br></pre></td></tr></table></figure><p>（1）. QWheelEvent构造参数和对应的计算方位函数变了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟鼠标滚轮</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="function">QWheelEvent <span class="title">wheelEvent</span><span class="params">(QPoint(<span class="number">0</span>, <span class="number">0</span>), -scal, Qt::LeftButton, Qt::NoModifier)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function">QWheelEvent <span class="title">wheelEvent</span><span class="params">(QPointF(<span class="number">0</span>, <span class="number">0</span>), QPointF(<span class="number">0</span>, <span class="number">0</span>), QPoint(<span class="number">0</span>, <span class="number">0</span>), QPoint(<span class="number">0</span>, -scal), Qt::LeftButton, Qt::NoModifier, Qt::ScrollBegin, <span class="literal">false</span>)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">QApplication::sendEvent(widget, &amp;wheelEvent);</span><br><span class="line"></span><br><span class="line"><span class="comment">//鼠标滚轮直接修改值</span></span><br><span class="line">QWheelEvent *whellEvent = (QWheelEvent *)event;</span><br><span class="line"><span class="comment">//滚动的角度,*8就是鼠标滚动的距离</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &lt; QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="keyword">int</span> degrees = whellEvent-&gt;delta() / <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">int</span> degrees = whellEvent-&gt;angleDelta().x() / <span class="number">8</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//滚动的步数,*15就是鼠标滚动的角度</span></span><br><span class="line"><span class="keyword">int</span> steps = degrees / <span class="number">15</span>;</span><br></pre></td></tr></table></figure><p>（1）. qVariantValue 改成 qvariant_cast ，qVariantSetValue(v, value) 改成了 v.setValue(val)。相当于退回到最原始的方法，查看qVariantValue源码封装的就是qvariant_cast。<br>（2）. QStyleOption的init改成了initFrom。<br>（3）. QVariant::Type 换成了 QMetaType::Type ，本身以前的 QVariant::Type 封装的就是 QMetaType::Type 。<br>（4）. QStyleOptionViewItemV2 V3 V4 之类的全部没有了，暂时可以用 QStyleOptionViewItem 替代。<br>（5）. QFont的 resolve 的一个重载函数换成了 resolveMask。<br>（6）. QSettings的 setIniCodec 方法移除了，默认就是utf8，不需要设置。<br>（7）. qcombobox 的 activated(QString) 和 currentIndexChanged(QString) 信号删除了，用int索引参数的那个，然后自己通过索引获取值。个人觉得这个没必要删除。<br>（8）. qtscript模块彻底没有了，尽管从Qt5时代的后期版本就提示为废弃模块，一致坚持到Qt6才正式废弃，各种json数据解析全部换成qjson类解析。<br>（9）. QByteArray 的 append indexOf lastIndexOf 等众多方法的QString参数重载函数废弃了，要直接传 QByteArray，就在原来参数基础上加上 .toUtf8() 。查看源码也看得到以前的QString参数也是转成.toUtf8()再去比较。<br>（10）. QDateTime的时间转换函数 toTime_t + setTime_t 名字改了，对应改成了 toSecsSinceEpoch + setSecsSinceEpoch ，这两个方法在Qt5.8时候新增加的。<br>（11）. QLabel的 pixmap 函数之前是指针 *pixmap() 现在换成了引用 pixmap()。<br>（12）. QTableWidget的 sortByColumn 方法移除了默认升序的方法，必须要填入第二个参数表示升序还是降序。<br>（13）. qtnetwork中的错误信号error换成了errorOccurred。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#if (<span class="name">QT_VERSION</span> &gt;= QT_VERSION_CHECK(<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    connect(<span class="name">tcpSocket</span>, SIGNAL(<span class="name">errorOccurred</span>(<span class="name">QAbstractSocket</span>:<span class="symbol">:SocketError</span>)), this, SLOT(<span class="name">error</span>()))<span class="comment">;</span></span><br><span class="line">#else</span><br><span class="line">    connect(<span class="name">tcpSocket</span>, SIGNAL(<span class="name">error</span>(<span class="name">QAbstractSocket</span>:<span class="symbol">:SocketError</span>)), this, SLOT(<span class="name">error</span>()))<span class="comment">;</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>（1）. XmlPatterns模块木有了，全部用xml模块重新解析。<br>（2）. nativeEvent的参数类型变了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nativeEvent</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;eventType, <span class="keyword">void</span> *message, qintptr *result)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nativeEvent</span><span class="params">(<span class="keyword">const</span> QByteArray &amp;eventType, <span class="keyword">void</span> *message, <span class="keyword">long</span> *result)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>（1）. QButtonGroup的buttonClicked信号中int参数的函数全部改名字叫idClicked。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    QButtonGroup *btnGroup = new QButtonGroup(<span class="name">this</span>)<span class="comment">;</span></span><br><span class="line">#if (<span class="name">QT_VERSION</span> &gt;= QT_VERSION_CHECK(<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    connect(<span class="name">btnGroup</span>, SIGNAL(<span class="name">idClicked</span>(<span class="name">int</span>)), ui-&gt;xstackWidget, SLOT(<span class="name">setCurrentIndex</span>(<span class="name">int</span>)))<span class="comment">;</span></span><br><span class="line">#else</span><br><span class="line">    connect(<span class="name">btnGroup</span>, SIGNAL(<span class="name">buttonClicked</span>(<span class="name">int</span>)), ui-&gt;xstackWidget, SLOT(<span class="name">setCurrentIndex</span>(<span class="name">int</span>)))<span class="comment">;</span></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>（1）. QWebEngineSettings之前是QWebEngineSettings::defaultSettings();现在改成了QWebEngineProfile::defaultProfile()-&gt;settings();通过查看之前的源码得知QWebEngineSettings::defaultSettings();封装的就是QWebEngineProfile::defaultProfile()-&gt;settings();因为Qt6去除了N多过度封装的函数。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (QT_VERSION &gt;= QT_VERSION_CHECK(6,0,0))</span></span><br><span class="line">    QWebEngineSettings *webSetting = <span class="symbol">QWebEngineProfile::</span>defaultProfile()-&gt;settings();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    QWebEngineSettings *webSetting = <span class="symbol">QWebEngineSettings::</span>defaultSettings();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;一、前言&lt;/h1&gt;&lt;p&gt;Qt 6.2 也是 Qt 6 的第一个版本，Qt 公司将为 Qt 商业客户提供长期支持。&lt;/p&gt;
&lt;p&gt;在 Qt 6.2 中
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="c++" scheme="https://www.ljjyy.com/tags/c/"/>
    
      <category term="qt" scheme="https://www.ljjyy.com/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>什么情况下需要对数据库进行分库分表分区</title>
    <link href="https://www.ljjyy.com/archives/2023/06/100683.html"/>
    <id>https://www.ljjyy.com/archives/2023/06/100683.html</id>
    <published>2023-06-10T06:20:00.000Z</published>
    <updated>2023-06-20T00:59:34.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是分区、分表、分库"><a href="#一、什么是分区、分表、分库" class="headerlink" title="一、什么是分区、分表、分库"></a>一、什么是分区、分表、分库</h1><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的。</p><h2 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h2><p>就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</p><h2 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h2><p>一旦分表，一个库中的表会越来越多</p><blockquote><p>将整个数据库比作图书馆，一张表就是一本书。当要在一本书中查找某项内容时，如果不<strong>分章节</strong>，查找的效率将会下降。而同理，在数据库中就是<strong>分区</strong>。</p></blockquote><h1 id="二-什么时候分库？"><a href="#二-什么时候分库？" class="headerlink" title="二 . 什么时候分库？"></a>二 . 什么时候分库？</h1><p>其实，<strong>分库主要解决的是并发量大的问题</strong>。因为并发量一旦上来了，那么数据库就可能会成为瓶颈，因为数据库的连接数是有限的，虽然可以调整，但是也不是无限调整的。</p><p>所以，当当你的数据库的读或者写的QPS过高，导致你的数据库连接数不足了的时候，就需要考虑分库了，<strong>通过增加数据库实例的方式来提供更多的可用数据库链接，从而提升系统的并发度。</strong></p><p>比较典型的分库的场景就是我们在做微服务拆分的时候，就会按照业务边界，把各个业务的数据从一个单一的数据库中拆分开，分表把订单、物流、商品、会员等单独放到单独的数据库中。</p><p>还有就是有的时候可能会需要把历史订单挪到历史库里面去。这也是分库的一种具体做法。</p><h1 id="三-什么时候分表？"><a href="#三-什么时候分表？" class="headerlink" title="三 . 什么时候分表？"></a>三 . 什么时候分表？</h1><p>分库主要解决的是并发量大的问题，那<strong>分表其实主要解决的是数据量大的问题。</strong></p><p>假如你的单表数据量非常大，因为并发不高，数据量连接可能还够，但是存储和查询的性能遇到了瓶颈了，你做了很多优化之后还是无法提升效率的时候，就需要考虑做分表了。</p><p><strong>通过将数据拆分到多张表中，来减少单表的数据量，从而提升查询速度。</strong></p><p>一般我们认为，单表行数超过 500 万行或者单表容量超过 2GB之后，才需要考虑做分库分表了，小于这个数据量，遇到性能问题先建议大家通过其他优化来解决。</p><h2 id="oracle"><a href="#oracle" class="headerlink" title="oracle"></a>oracle</h2><p>当oracle单表的数据量大于2000万行时，建议进行水平分拆。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>当mysql单表的数据量大于1000万行时，建议进行水平分拆。</p><h2 id="sqlserver"><a href="#sqlserver" class="headerlink" title="sqlserver"></a>sqlserver</h2><p>一般如下条件就可以选择分区分表操作了</p><p>1)、表的大小超过2GB。<br>2)、表中包含历史数据，新的数据被增加都新的分区中。</p><h1 id="四-什么时候分区？"><a href="#四-什么时候分区？" class="headerlink" title="四 . 什么时候分区？"></a>四 . 什么时候分区？</h1><p>当访问量不大，但单表数据量比较多时，表中的数据是分段的，对数据的操作往往只涉及一部分数据，而不是所有的数据，可以只进行分区。分区和分表的目的都是减少数据库的负担，提高表的增删改查效率，两种方式可以互相配合使用。</p><h1 id="五-什么时候既分库又分表？"><a href="#五-什么时候既分库又分表？" class="headerlink" title="五  . 什么时候既分库又分表？"></a>五  . 什么时候既分库又分表？</h1><p>那么什么时候分库又分表呢，那就是既需要解决并发量大的问题，又需要解决数据量大的问题时候。通常情况下，高并发和数据量大的问题都是同时发生的，所以，我们会经常遇到分库分表需要同时进行的情况。</p><p>所以，当你的数据库链接也不够了，并且单表数据量也很大导致查询比较慢的时候，就需要做既分库又分表了。</p><h1 id="六-怎样分库分表？"><a href="#六-怎样分库分表？" class="headerlink" title="六 . 怎样分库分表？"></a>六 . 怎样分库分表？</h1><h2 id="1-横向拆分和纵向拆分"><a href="#1-横向拆分和纵向拆分" class="headerlink" title="1. 横向拆分和纵向拆分"></a>1. 横向拆分和纵向拆分</h2><p>谈及到分库分表，那就要涉及到该如何做拆分的问题。</p><p><strong>通常在做拆分的时候有两种分法，分别是横向拆分（水平拆分）和纵向拆分(垂直拆分)。</strong>假如我们有一张表，如果把这张表中某一条记录的多个字段，拆分到多张表中，这种就是纵向拆分。那如果把一张表中的不同的记录分别放到不同的表中，这种就是横向拆分。</p><p>横向拆分的结果是数据库表中的数据会分散到多张分表中，使得每一个单表中的数据的条数都有所下降。比如我们可以把不同的用户的订单分表拆分放到不同的表中。</p><p>纵向拆分的结果是数据库表中的数据的字段数会变少，使得每一个单表中的数据的存储有所下降。比如我可以把商品详情信息、价格信息、库存信息等等分别拆分到不同的表中。</p><p>还有我们谈到的针对不同的业务做拆分成多个数据库的这种情况，其实也是纵向拆分的一种。</p><h2 id="2-分表字段的选择"><a href="#2-分表字段的选择" class="headerlink" title="2. 分表字段的选择"></a>2. 分表字段的选择</h2><p>在分库分表的过程中，我们需要有一个字段用来进行分表，比如按照用户分表、按照时间分表、按照地区分表。这里面的用户、时间、地区就是所谓的分表字段。</p><p>那么，<strong>在选择这个分表字段的时候，一定要注意，要根据实际的业务情况来做慎重的选择。</strong></p><p>比如说我们要对交易订单进行分表的时候，我们可以选择的信息有很多，比如买家Id、卖家Id、订单号、时间、地区等等，具体应该如何选择呢？</p><p>通常，如果有特殊的诉求，比如按照月度汇总、地区汇总等以外，我们通常建议大家按照买家Id进行分表。因为这样可以避免一个关键的问题那就是——数据倾斜（热点数据）。</p><h3 id="买家还是卖家？"><a href="#买家还是卖家？" class="headerlink" title="买家还是卖家？"></a>买家还是卖家？</h3><p>首先，我们先说为什么不按照卖家分表？</p><p>因为我们知道，电商网站上面是有很多买家和卖家的，但是，一个大的卖家可能会产生很多订单，比如像苏宁易购、当当等这种店铺，他每天在天猫产生的订单量就非常的大。如果按照卖家Id分表的话，那同一个卖家的很多订单都会分到同一张表。</p><p>那就会使得有一些表的数据量非常的大，但是有些表的数据量又很小，这就是发生了<strong>数据倾斜</strong>。这个卖家的数据就变成了热点数据，随着时间的增长，就会使得这个卖家的所有操作都变得异常缓慢。</p><p>但是，买家ID做分表字段就不会出现这类问题，因为一个不太容易出现一个买家能把数据买倾斜了。</p><p>但是需要注意的是，<strong>我们说按照买家Id做分表，保证的是同一个买家的所有订单都在同一张表 ，并不是要给每个买家都单独分配一张表。</strong></p><p>我们在做分表路由的时候，是可以设定一定的规则的，比如我们想要分1024张表，那么我们可以用买家ID或者买家ID的hashcode对1024取模，结果是0000-1023，那么就存储到对应的编号的分表中就行了。</p><h3 id="卖家查询怎么办？"><a href="#卖家查询怎么办？" class="headerlink" title="卖家查询怎么办？"></a>卖家查询怎么办？</h3><p>如果按照买家Id进行了分表，那卖家的查询怎么办，这不就意味着要跨表查询了吗？</p><p>首先，业务问题我们要建立在业务背景下讨论。电商网站订单查询有几种场景？</p><p>1、买家查自己的订单</p><p>2、卖家查自己的订单</p><p>3、平台的小二查用户的订单。</p><p>首先，我们用买家ID做了分表，那么买家来查询的时候，是一定可以把买家ID带过来的，我们直接去对应的表里面查询就行了。</p><p>那如果是卖家查呢？卖家查询的话，同样可以带卖家id过来，那么，我们可以有一个基于binlog、flink等准实时的同步一张卖家维度的分表，这张表只用来查询，来解决卖家查询的问题。</p><p>本质上就是用空间换时间的做法。</p><p>不知道大家看到这里会不会有这样的疑问：同步一张卖家表，这不又带来了大卖家的热点问题了吗？</p><p>首先，我们说同步一张卖家维度的表来，但是其实所有的写操作还是要写到买家表的，只不过需要准实时同步的方案同步到卖家表中。也就是说，我们的这个卖家表理论上是没有业务的写操作，只有读操作的。</p><p>所以，这个卖家库只需要有高性能的读就行了，那这样的话就可以有很多选择了，比如可以部署到一些配置不用那么高的机器、或者其实可以干脆就不用MYSQL，而是采用HBASE、PolarDB、Lindorm等数据库就可以了。这些数据库都是可以海量数据，并提供高性能查询的。</p><p>还有呢就是，大卖家一般都是可以识别的，提前针对大卖家，把他的订单，再按照一定的规则拆分到多张表中。因为只有读，没有写操作，所以拆分多张表也不用考虑事务的问题。</p><h3 id="按照订单查询怎么办？"><a href="#按照订单查询怎么办？" class="headerlink" title="按照订单查询怎么办？"></a>按照订单查询怎么办？</h3><p>上面说的都是有买卖家ID的情况，那没有买卖家ID呢？用订单号直接查怎么办呢？</p><p>这种问题的解决方案是，在生成订单号的时候，我们一般会把分表解决编码到订单号中去，因为订单生成的时候是一定可以知道买家ID的，那么我们就把买家ID的路由结果比如1023，作为一段固定的值放到订单号中就行了。这就是所谓的”<strong>基因法</strong>“。</p><p>这样按照订单号查询的时候，解析出这段数字，直接去对应分表查询就好了。</p><p>至于还有人问其他的查询，没有买卖家ID，也没订单号的，那其实就属于是低频查询或者非核心功能查询了，那就可以用ES等搜索引擎的方案来解决了。就不赘述了。</p><h2 id="3-分表算法"><a href="#3-分表算法" class="headerlink" title="3. 分表算法"></a>3. 分表算法</h2><p>选定了分表字段之后，如何基于这个分表字段来准确的把数据分表到某一张表中呢？</p><p>这就是分表算法要做的事情了，<strong>但是不管什么算法，我们都需要确保一个前提，那就是同一个分表字段，经过这个算法处理后，得到的结果一定是一致的，不可变的。</strong></p><p>通常情况下，当我们对order表进行分表的时候，比如我们要分成128张表的话，那么得到的128表应该是:order_0000、order_0001、order_0002…..order_0126、order_0127</p><p>通常的分表算法有以下几种：</p><h3 id="直接取模"><a href="#直接取模" class="headerlink" title="直接取模"></a>直接取模</h3><p>在分库分表时，我们是事先可以知道要分成多少个库和多少张表的，所以，比较简单的就是取模的方式。</p><p>比如我们要分成128张表的话，就用一个整数来对128取模就行了，得到的结果如果是0002，那么就把数据放到order_0002这张表中。</p><h3 id="Hash取模"><a href="#Hash取模" class="headerlink" title="Hash取模"></a>Hash取模</h3><p>那如果分表字段不是数字类型，而是字符串类型怎么办呢？有一个办法就是哈希取模，就是先对这个分表字段取Hash，然后在再取模。</p><p>但是需要注意的是，<strong>Java中的hash方法得到的结果有可能是负数</strong>，需要考虑这种负数的情况。</p><h3 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h3><p>前面两种取模方式都比较不错，可以使我们的数据比较均匀的分布到多张分表中。但是还是存在一个缺点。</p><p>那就是如果需要扩容二次分表，表的总数量发生变化时，就需要重新计算hash值，就需要涉及到数据迁移了。</p><p>为了解决扩容的问题，我们可以采用一致性哈希的方式来做分表。</p><p><strong>一致性哈希可以按照常用的hash算法来将对应的key哈希到一个具有2^32次方个节点的空间中，形成成一个顺时针首尾相接的闭合的环形。所以当添加一台新的数据库服务器时，只有增加服务器的位置和逆时针方向第一台服务器之间的键会受影响。</strong></p><h2 id="4-全局ID的生成"><a href="#4-全局ID的生成" class="headerlink" title="4. 全局ID的生成"></a>4. 全局ID的生成</h2><p>涉及到分库分表，就会引申出分布式系统中唯一主键ID的生成问题，因为在单表中我们可以用数据库主键来做唯一ID，但是如果做了分库分表，多张单表中的自增主键就一定会发生冲突。那就不具备全局唯一性了。</p><p>那么，如何生成一个全局唯一的ID呢？有以下几种方式：</p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>很多人对UUID都不陌生，它是可以做到全局唯一的，而且生成方式也简单，但是我们通常不推荐使用他做唯一ID，首先<strong>UUID太长了，其次字符串的查询效率也比较慢，而且没有业务含义，根本看不懂。</strong></p><h3 id="基于某个单表做自增主键"><a href="#基于某个单表做自增主键" class="headerlink" title="基于某个单表做自增主键"></a>基于某个单表做自增主键</h3><p>多张单表生成的自增主键会冲突，但是如果所有的表中的主键都从同一张表生成是不是就可以了。</p><p>所有的表在需要主键的时候，都到这张表中获取一个自增的ID。</p><p>这样做是可以做到唯一，也能实现自增，但是问题是这个单表就变成整个系统的瓶颈，而且也存在单点问题，一旦他挂了，那整个数据库就都无法写入了。</p><h3 id="基于多个单表-步长做自增主键"><a href="#基于多个单表-步长做自增主键" class="headerlink" title="基于多个单表+步长做自增主键"></a>基于多个单表+步长做自增主键</h3><p>为了解决单个数据库做自曾主键的瓶颈及单点故障问题，我们可以引入多个表来一起生成就行了。</p><p>但是如何保证多张表里面生成的Id不重复呢？如果我们能实现以下的生成方式就行了：</p><p>实例1生成的ID从1000开始，到1999结束。</p><p>实例2生成的ID从2000开始，到2999结束。</p><p>实例3生成的ID从3000开始，到3999结束。</p><p>实例4生成的ID从4000开始，到4999结束。</p><p>这样就能避免ID重复了，那如果第一个实例的ID已经用到1999了怎么办？那就生成一个新的起始值：</p><p>实例1生成的ID从5000开始，到5999结束。</p><p>实例2生成的ID从6000开始，到6999结束。</p><p>实例3生成的ID从7000开始，到7999结束。</p><p>实例4生成的ID从8000开始，到8999结束。</p><p>我们把步长设置为1000，确保每一个单表中的主键起始值都不一样，并且比当前的最大值相差1000就行了。</p><h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p><strong>雪花算法也是比较常用的一种分布式ID的生成方式，它具有全局唯一、递增、高可用的特点。</strong></p><p>雪花算法生成的主键主要由 4 部分组成，1bit符号位、41bit时间戳位、10bit工作进程位以及 12bit 序列号位。</p><p>时间戳占用41bit，精确到毫秒，总共可以容纳约69年的时间。</p><p>工作进程位占用10bit，其中高位5bit是数据中心ID，低位5bit是工作节点ID，做多可以容纳1024个节点。</p><p>序列号占用12bit，每个节点每毫秒0开始不断累加，最多可以累加到4095，一共可以产生4096个ID。</p><p>所以，一个雪花算法可以在同一毫秒内最多可以生成1024 X 4096 = 4194304个唯一的ID</p><h2 id="5-分库分表的工具"><a href="#5-分库分表的工具" class="headerlink" title="5. 分库分表的工具"></a>5. 分库分表的工具</h2><p>在选定了分表字段和分表算法之后，那么，如何把这些功能给实现出来，需要怎么做呢？</p><p>我们如何可以做到像处理单表一样处理分库分表的数据呢？这就需要用到一个分库分表的工具了。</p><p>目前市面上比较不错的分库分表的开源框架主要有三个，分别是sharding-jdbc、TDDL和Mycat</p><h3 id="Sharding-JDBC"><a href="#Sharding-JDBC" class="headerlink" title="Sharding-JDBC"></a>Sharding-JDBC</h3><p>现在叫ShardingSphere（Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar这3款相互独立的产品组成）。它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><p>开原地址：<a href="https://shardingsphere.apache.org" target="_blank" rel="noopener">https://shardingsphere.apache.org</a></p><h3 id="TDDL"><a href="#TDDL" class="headerlink" title="TDDL"></a>TDDL</h3><p>TDDL 是淘宝开源的一个用于访问数据库的中间件， 它集成了分库分表， 读写分离，权重调配，动态数据源配置等功能。封装 jdbc 的 DataSource给用户提供统一的基于客户端的使用。</p><p>开源地址：<a href="https://github.com/alibaba/tb_tddl" target="_blank" rel="noopener">https://github.com/alibaba/tb_tddl</a></p><h3 id="Mycat"><a href="#Mycat" class="headerlink" title="Mycat"></a>Mycat</h3><p>Mycat是一款分布式关系型数据库中间件。它支持分布式SQL查询，兼容MySQL通信协议，以Java生态支持多种后端数据库，通过数据分片提高数据查询处理能力。</p><p>开源地址：<a href="https://github.com/MyCATApache/Mycat2" target="_blank" rel="noopener">https://github.com/MyCATApache/Mycat2</a></p><h1 id="七-分库分表带来的问题"><a href="#七-分库分表带来的问题" class="headerlink" title="七. 分库分表带来的问题"></a>七. 分库分表带来的问题</h1><p>分库分表之后，会带来很多问题。</p><p>首先，做了分库分表之后，所有的读和写操作，都需要带着分表字段，这样才能知道具体去哪个库、哪张表中去查询数据。如果不带的话，就得支持全表扫描。</p><p>但是，单表的时候全表扫描比较容易，但是做了分库分表之后，就没办法做扫表的操作了，如果要扫表的话就要把所有的物理表都要扫一遍。</p><p>还有，一旦我们要从多个数据库中查询或者写入数据，就有很多事情都不能做了，比如<strong>跨库事务就是不支持的。</strong></p><p>所以，分库分表之后就会带来因为不支持事务而导致的数据一致性的问题。</p><p>其次，做了分库分表之后，以前单表中很方便的分页查询、排序等等操作就都失效了。因为我们不能跨多表进行分页、排序。</p><p>总之，分库分表虽然能解决一些大数据量、高并发的问题，但是同时也会带来一些新的问题。<strong>所以，在做数据库优化的时候，还是建议大家优先选择其他的优化方式，最后再考虑分库分表。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、什么是分区、分表、分库&quot;&gt;&lt;a href=&quot;#一、什么是分区、分表、分库&quot; class=&quot;headerlink&quot; title=&quot;一、什么是分区、分表、分库&quot;&gt;&lt;/a&gt;一、什么是分区、分表、分库&lt;/h1&gt;&lt;h2 id=&quot;分区&quot;&gt;&lt;a href=&quot;#分区&quot; cla
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="sql" scheme="https://www.ljjyy.com/tags/sql/"/>
    
      <category term="mysql" scheme="https://www.ljjyy.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Wine完全使用指南</title>
    <link href="https://www.ljjyy.com/archives/2023/06/100639.html"/>
    <id>https://www.ljjyy.com/archives/2023/06/100639.html</id>
    <published>2023-06-07T04:00:00.000Z</published>
    <updated>2023-06-20T01:02:49.296Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://winehq.org/" target="_blank" rel="noopener">Wine</a> （“Wine Is Not an Emulator” 的首字母缩写）是一个能够在多种 POSIX-compliant 操作系统（诸如Linux，Mac，FreeBSD和Solaris等）上运行 Windows 应用的兼容层。Wine 不是像虚拟机或者模拟器一样模仿内部的 Windows 逻辑，而是将 Windows API 调用翻译成为动态的 POSIX 调用，免除了性能和其他一些行为的内存占用，让你能够干净地集合 Windows 应用到你的桌面。Wine是不断发展的<a href="http://www.gnu.org/philosophy/free-sw.html" target="_blank" rel="noopener">免费软件</a>。<a href="https://wiki.winehq.org/Compatibility" target="_blank" rel="noopener">其他平台</a>也可能受益。</p><h1 id="一-安装与配置"><a href="#一-安装与配置" class="headerlink" title="一. 安装与配置"></a>一. 安装与配置</h1><p>在Ubuntu上示例安装，安装Ubuntu可以参考<a href="../../2019/10/100590.html">VirtualBox虚拟机安装Ubuntu</a>，记得选择安装图像化界面。</p><p>如果您之前安装过来自其他仓库的 Wine 安装包，请在尝试安装 WineHQ 安装包之前删除它及依赖它的所有安装包（如：wine-mono、wine-gecko、winetricks），否则可能导致依赖冲突。</p><h2 id="1-识别是否64位架构的内核"><a href="#1-识别是否64位架构的内核" class="headerlink" title="1. 识别是否64位架构的内核"></a>1. 识别是否64位架构的内核</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo dpkg --<span class="built_in">print</span>-architecture  </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">看到像这样的内容:amd64,这说明着你已经拥有了64位架构内核。</span></span><br></pre></td></tr></table></figure><h2 id="2-打开多架构支持"><a href="#2-打开多架构支持" class="headerlink" title="2. 打开多架构支持"></a>2. 打开多架构支持</h2><p>如果使用的是 64 位系统，请开启 32 bit 架构支持（如果之前没有开启的话）：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg --<span class="keyword">add</span><span class="bash">-architecture i386 </span></span><br><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure><p><strong>注意：apt只适用于Ubuntu 16.04 之后的版本，apt-get适用于所有版本 </strong></p><p>apt update：只检查，不更新（已安装的软件包是否有可用的更新，给出汇总报告）</p><p>用法：sudo apt update</p><p>apt upgrade：更新已安装的软件包</p><p>用法：sudo apt upgrade 软件包名</p><p>使用sudo apt list –upgradable查看可升级的软件信息</p><p>sudo apt list –upgradable -a查看可升级的软件的全部版本信息</p><h2 id="3-安装wine"><a href="#3-安装wine" class="headerlink" title="3. 安装wine"></a>3. 安装wine</h2><p><strong>安装64位 Wine</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt <span class="keyword">install</span> wine</span><br></pre></td></tr></table></figure><p><strong>安装32位 Wine </strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt <span class="keyword">install</span> wine32</span><br></pre></td></tr></table></figure><p>查看版本<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo wine <span class="comment">--version</span></span><br></pre></td></tr></table></figure></p><p><strong>卸载Wine</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo apt remove wine</span><br><span class="line"><span class="variable">$ </span>sudo apt autoremove</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt <span class="built_in">remove</span> --purge <span class="string">'wine.*'</span></span><br></pre></td></tr></table></figure></p><h2 id="4-配置wine"><a href="#4-配置wine" class="headerlink" title="4. 配置wine"></a>4. 配置wine</h2><h3 id="4-1-创建-Wine-prefix"><a href="#4-1-创建-Wine-prefix" class="headerlink" title="4.1 创建 Wine prefix"></a>4.1 创建 Wine prefix</h3><p><strong>创建64位 Wine prefix</strong><br>默认情况下，当第一次运行Wine软件（在64位Linux操作系统上）时，它将在主目录（~）中的~/.wine中创建标准的64位Wine prefix。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">WINEPREFIX</span>=~/.wine winecfg</span><br></pre></td></tr></table></figure><p><strong>创建32位 Wine prefix</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">WINEARCH</span>=win32 <span class="attribute">WINEPREFIX</span>=~/.wine32 winecfg</span><br><span class="line">$ <span class="builtin-name">export</span> <span class="attribute">WINEPREFIX</span>=~/.wine32</span><br></pre></td></tr></table></figure><p><strong>删除Wine prefix</strong></p><p>首先，按Ctrl+Alt+T或Ctrl+Shift+T打开终端窗口，然后，使用带有“a”选项的ls命令显示主目录中的所有文件和文件夹：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ls -a</span></span><br></pre></td></tr></table></figure></p><p>查看文件列表中的Wine prefix文件夹的名称，然后，使用带有“rf”选项的rm命令删除前缀文件夹：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.<span class="keyword">new</span><span class="type">prefix</span>/</span><br></pre></td></tr></table></figure></p><p>或者：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.<span class="keyword">new</span><span class="type">prefix32</span>/</span><br></pre></td></tr></table></figure></p><p>需要一次删除多个prefix文件夹？在rm命令时使用括号，例如，要删除两个prefix文件夹，需要：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/&#123;.<span class="keyword">new</span><span class="type">prefix</span>,.<span class="keyword">new</span><span class="type">prefix32</span>&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-配置-winecfg"><a href="#4-2-配置-winecfg" class="headerlink" title="4.2 配置 winecfg"></a>4.2 配置 winecfg</h3><p>运行 wine 配置程序 ，不要用 sudo 或者 root 权限<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>winecfg</span><br></pre></td></tr></table></figure></p><p>这样会建立 wine 的运行文件夹 /home/user/.wine .里面有wine的注册表文件和虚拟的C盘；<br>稍等片刻，就会出现一个面板，这就是 wine 的一些基本的配置。</p><h4 id="4-2-1-Drives-标签，配置硬盘和光驱"><a href="#4-2-1-Drives-标签，配置硬盘和光驱" class="headerlink" title="4.2.1 Drives 标签，配置硬盘和光驱"></a>4.2.1 Drives 标签，配置硬盘和光驱</h4><p>Autodect 按钮可以自动检测，也打开 Show Advanced 手动配置，<br>C: /home/用户名/.wine/drive_c Local hard disk<br>D: /home/用户名 Local hard disk<br>E: /media/cdrom0 CDROM<br>其他分区根据需要配置</p><h4 id="4-2-2-Audio-标签，配置声卡"><a href="#4-2-2-Audio-标签，配置声卡" class="headerlink" title="4.2.2 Audio 标签，配置声卡"></a>4.2.2 Audio 标签，配置声卡</h4><p>这个面板会失去反映一段时间，之后出现一个声音驱动程序的选择框，一般情况下选择OSS。如果你是独立的声卡，选择ALSA更好。如果只有 OSS，就选择 OSS。</p><h4 id="4-2-3-Application-Settings-标签，配置-Windows-版本"><a href="#4-2-3-Application-Settings-标签，配置-Windows-版本" class="headerlink" title="4.2.3  Application Settings 标签，配置 Windows 版本"></a>4.2.3  Application Settings 标签，配置 Windows 版本</h4><p>下面的 windows 版本把默认的改成 Windows XP ,实际中可以变更 为 Windows 2000 或 其他版本以使用 wine 的效率更高。</p><h4 id="4-2-3-部分-DLL-设置"><a href="#4-2-3-部分-DLL-设置" class="headerlink" title="4.2.3 部分 DLL 设置"></a>4.2.3 部分 DLL 设置</h4><p>在真实的 windows 系统中从 C:\WINDOWS\systenm32 里复制 mfc42.dll,msvcp60.dll, riched20.dll,riched32.dll 这几个文件到 /home/用户名/.wine/drive_c/windows/system32 文件里，需要覆盖时确定。其他dll文件不要随便覆盖，要做备份。</p><h3 id="4-3-准备字体"><a href="#4-3-准备字体" class="headerlink" title="4.3 准备字体"></a>4.3 准备字体</h3><p>为了让中文界面的Windows 应用程序在Wine里运行时能正确显示中文字，需要中文版Windows操作系统下面的字体：</p><h4 id="4-3-1-从-Windows-复制字体到Linux"><a href="#4-3-1-从-Windows-复制字体到Linux" class="headerlink" title="4.3.1  从 Windows 复制字体到Linux"></a>4.3.1  从 Windows 复制字体到Linux</h4><p>C:\WINDOWS\Fonts\simsun.ttc，复制一份到Linux系统中/root/.wine/drive_c/windows/Fonts里面。</p><h4 id="4-3-2-修改-root-wine-system-reg"><a href="#4-3-2-修改-root-wine-system-reg" class="headerlink" title="4.3.2  修改/root/.wine/system.reg"></a>4.3.2  修改/root/.wine/system.reg</h4><p>装好字体后，还要修改一下 Wine 的注册表设置，指定与字体相关的设置：<br>gedit /root/.wine/system.reg<br>（一定要使用 gedit 、vim或其他支持 gb2312/utf8 编码的编辑器修改这些文件，否则文件中的中文可能变乱码）<br>搜索： LogPixels<br>找到的行应该是：[System\CurrentControlSet\Hardware Profiles\Current\Software\Fonts]<br>将其中的：<br>“LogPixels”=dword:00000060<br>改为：<br>“LogPixels”=dword:00000070<br>搜索： FontSubstitutes<br>找到的行应该是：[Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes]<br>将其中的：<br>“MS Shell Dlg”=”Tahoma”<br>“MS Shell Dlg 2″=”Tahoma”<br>改为：<br>“MS Shell Dlg”=”SimSun”<br>“MS Shell Dlg 2″=”SimSun”</p><h4 id="4-3-3-修改-root-wine-drive-c-windows-win-ini"><a href="#4-3-3-修改-root-wine-drive-c-windows-win-ini" class="headerlink" title="4.3.3 修改 /root/.wine/drive_c/windows/win.ini"></a>4.3.3 修改 /root/.wine/drive_c/windows/win.ini</h4><p>gedit /root/.wine/drive_c/windows/win.ini<br>在文件末尾加入：<br>[Desktop]<br>menufontsize=13<br>messagefontsize=13<br>statusfontsize=13<br>IconTitleSize=13</p><h4 id="4-3-4-最关键的一步，把下面的代码保存为kashu-reg，然后直接在linux终端上执行regedit-kashu-reg即可。"><a href="#4-3-4-最关键的一步，把下面的代码保存为kashu-reg，然后直接在linux终端上执行regedit-kashu-reg即可。" class="headerlink" title="4.3.4  最关键的一步，把下面的代码保存为kashu.reg，然后直接在linux终端上执行regedit kashu.reg即可。"></a>4.3.4  最关键的一步，把下面的代码保存为kashu.reg，然后直接在linux终端上执行regedit kashu.reg即可。</h4><p>代码:<br>REGEDIT4<br>LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes]<br>   “Arial”=”simsun”<br>   “Arial CE,238”=”simsun”<br>   “Arial CYR,204”=”simsun”<br>   “Arial Greek,161”=”simsun”<br>   “Arial TUR,162”=”simsun”<br>   “Courier New”=”simsun”<br>   “Courier New CE,238”=”simsun”<br>   “Courier New CYR,204”=”simsun”<br>   “Courier New Greek,161”=”simsun”<br>   “Courier New TUR,162”=”simsun”<br>   “FixedSys”=”simsun”<br>   “Helv”=”simsun”<br>   “Helvetica”=”simsun”<br>   “MS Sans Serif”=”simsun”<br>   “MS Shell Dlg”=”simsun”<br>   “MS Shell Dlg 2”=”simsun”<br>   “System”=”simsun”<br>   “Tahoma”=”simsun”<br>   “Times”=”simsun”<br>   “Times New Roman CE,238”=”simsun”<br>   “Times New Roman CYR,204”=”simsun”<br>   “Times New Roman Greek,161”=”simsun”<br>   “Times New Roman TUR,162”=”simsun”<br>   “Tms Rmn”=”simsun”</p><h2 id="5-安装winetricks"><a href="#5-安装winetricks" class="headerlink" title="5. 安装winetricks"></a>5. 安装winetricks</h2><p>使用Winetricks只是为了更的轻松安装Wine应用程序，因为使用Wine在Linux系统上运行某些Windows应用程序有时会很棘手。 Winetricks会帮助到这一点，并使它更容易下载和安装必要的组件，如一结DLL文件。默认的WINE环境缺少很多WIN平台的库，而且最可恨的是，system32目录下竟然没有regedit程序。当然你也可以通过手动搜索，下载和安装它们应该是的东西来完成所有必要的事情。</p><h3 id="5-1-安装"><a href="#5-1-安装" class="headerlink" title="5.1 安装"></a>5.1 安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt <span class="keyword">install</span> winetricks</span><br></pre></td></tr></table></figure><h3 id="5-2-使用winetricks安装win支持库。"><a href="#5-2-使用winetricks安装win支持库。" class="headerlink" title="5.2 使用winetricks安装win支持库。"></a>5.2 使用winetricks安装win支持库。</h3><p>命令行中输入：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>winetricks</span><br></pre></td></tr></table></figure></p><p>然后勾选你软件需要的如：colorprofile、corefonts、d3dx9、fontfix、fontsmooth-gray、fontsmooth-rgb、fontsmooth-bgr、gdiplus、mfc40、mfc42、</p><p>msxml3、msxml4、msxml6、riched20、riched30、tahoma、urlmon、vb6run、vcrun6、vcrun2003、vcrun2005、vcrun2008、ie6、allfonts</p><p>也可在命令行中直接安装：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>winetricks corefonts</span><br></pre></td></tr></table></figure><h3 id="5-2-使用winetricks安装win应用。"><a href="#5-2-使用winetricks安装win应用。" class="headerlink" title="5.2 使用winetricks安装win应用。"></a>5.2 使用winetricks安装win应用。</h3><p>命令行中输入：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>winetricks</span><br></pre></td></tr></table></figure></p><p>然后选择你的win应用安装文件进行安装。</p><h3 id="5-3-删除-winetricks"><a href="#5-3-删除-winetricks" class="headerlink" title="5.3 删除 winetricks"></a>5.3 删除 winetricks</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf〜/ <span class="selector-class">.cache</span> / winetricks /</span><br></pre></td></tr></table></figure><h1 id="二-安装案例"><a href="#二-安装案例" class="headerlink" title="二. 安装案例"></a>二. 安装案例</h1><h2 id="1-安装-Visual-Basic-6"><a href="#1-安装-Visual-Basic-6" class="headerlink" title="1. 安装 Visual Basic 6"></a>1. 安装 Visual Basic 6</h2><p>准备Visual Basic 6安装文件。</p><p>windows 2003上可以直接安装上</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wine <span class="built_in">setup</span>.exe</span><br></pre></td></tr></table></figure><p>或用winetricks可视化安装</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>winetricks</span><br></pre></td></tr></table></figure><p>通用安装办法如下：</p><h3 id="1-1-复制OS-SYSTEM-的内容"><a href="#1-1-复制OS-SYSTEM-的内容" class="headerlink" title="1.1 复制OS / SYSTEM /的内容"></a>1.1 复制OS / SYSTEM /的内容</h3><p>从CD根目录将OS / SYSTEM /的内容复制到wine系统32目录中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r <span class="regexp">/media/</span>cdrom<span class="regexp">/OS/</span>SYSTEM<span class="regexp">/* 〜/</span>.wine<span class="regexp">/drive_c/</span>windows<span class="regexp">/system32/</span></span><br></pre></td></tr></table></figure><h3 id="1-2-复制VB98"><a href="#1-2-复制VB98" class="headerlink" title="1.2   复制VB98"></a>1.2   复制VB98</h3><p>由于我们只关心Visual Basic 6，因此将CD根目录下的文件夹VB98复制到程序文件中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cp -r <span class="regexp">/media/</span>cdrom<span class="regexp">/VB98/</span> 〜<span class="regexp">/.wine/</span>drive_c<span class="regexp">/Program Files/</span></span><br><span class="line">$ mv ~<span class="regexp">/.wine/</span>drive_c<span class="regexp">/Program Files/</span>VB98<span class="regexp">/ 〜/</span>.wine<span class="regexp">/drive_c/</span>Program Files<span class="regexp">/Visual Basic 6/</span></span><br></pre></td></tr></table></figure><h3 id="1-3-注册动态链接库"><a href="#1-3-注册动态链接库" class="headerlink" title="1.3 注册动态链接库"></a>1.3 注册动态链接库</h3><p>注册两个动态链接库，这对于顺利运行Visual Basic 6是必不可少的</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cd ~<span class="regexp">/.wine/drive</span>_c/windows/system32/</span><br><span class="line"><span class="variable">$ </span>wine regsvr32 comcat.dll</span><br><span class="line"><span class="variable">$ </span>wine regsvr32 MSSTDFMT.DLL</span><br></pre></td></tr></table></figure><h3 id="1-4-创建启动命令"><a href="#1-4-创建启动命令" class="headerlink" title="1.4 创建启动命令"></a>1.4 创建启动命令</h3><p>完成所有操作，让我们创建一个包含以下内容<strong>文件</strong>的可选启动命令</p><p>打开文本编辑器<code>$ gedit</code>，复制粘贴文件内容，将文件另存为vb6在您的主目录中，退出编辑器并打开终端。<br>文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> ~/.wine/drive_c/<span class="string">"Program Files"</span>/<span class="string">"Visual Basic 6"</span>/</span><br><span class="line">wine VB6.EXE</span><br></pre></td></tr></table></figure><p><strong>使我们的启动器可执行，并将其放置在正确的位置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo chmod + x vb6</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mv vbasic /usr/<span class="built_in">local</span>/bin/</span></span><br></pre></td></tr></table></figure><p><strong>现在，只需发出命令<code>vb6</code>启动 Visual Basic 6。</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>vb6</span><br></pre></td></tr></table></figure><h2 id="2-安装Visual-Studio-2019"><a href="#2-安装Visual-Studio-2019" class="headerlink" title="2. 安装Visual Studio 2019"></a>2. 安装Visual Studio 2019</h2><p>要运行vs安装程序，您需要使用“ winetricks dotnet45”安装dotnet v4.5，并使用<strong>32位 Wine prefix</strong>前缀。</p><h3 id="2-1-确保在干净的WINEPREFIX（〜-wine）上运行！"><a href="#2-1-确保在干净的WINEPREFIX（〜-wine）上运行！" class="headerlink" title="2.1 确保在干净的WINEPREFIX（〜/ .wine）上运行！"></a>2.1 确保在<strong>干净的WINEPREFIX（〜/ .wine）上运行！</strong></h3><p>删除<strong>WINEPREFIX</strong>和其他可能的东西。如果您以root用户身份运行Wine，则需要：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>sudo rm -rf〜/ .wine</span><br></pre></td></tr></table></figure></p><p>然后运行<strong>winecfg</strong>来设置Wine文件夹结构。如果您使用<a href="http://wiki.winehq.org/winetricks" target="_blank" rel="noopener"><strong>winetricks</strong></a>脚本作为root用户，则可能还需要：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm -rf〜/ <span class="selector-class">.cache</span> / winetricks /</span><br></pre></td></tr></table></figure></p><h3 id="2-2-Winetricks将解决所有必需的安装先决条件，并解决一些问题。"><a href="#2-2-Winetricks将解决所有必需的安装先决条件，并解决一些问题。" class="headerlink" title="2.2 Winetricks将解决所有必需的安装先决条件，并解决一些问题。"></a>2.2 <a href="http://wiki.winehq.org/winetricks" target="_blank" rel="noopener">Winetricks</a>将解决所有必需的安装先决条件，并解决一些问题。</h3><p><strong>再说一遍：只需以普通用户身份运行wine，一切就可以了。</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>wget <span class="symbol">https:</span>/<span class="regexp">/raw.githubusercontent.com/</span>Winetricks/winetricks/master/src/winetricks</span><br><span class="line"><span class="variable">$ </span>winetricks -q dotnet462</span><br></pre></td></tr></table></figure><p>要解决一些错误，您还需要：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ winetricks -<span class="selector-tag">q</span> corefonts</span><br></pre></td></tr></table></figure><h3 id="2-3-安装-Visual-Studio-2019"><a href="#2-3-安装-Visual-Studio-2019" class="headerlink" title="2.3 安装 Visual Studio 2019"></a>2.3 安装 Visual Studio 2019</h3><p>下载 Visual Studio 2019 </p><h1 id="三-释疑"><a href="#三-释疑" class="headerlink" title="三. 释疑"></a>三. 释疑</h1><h2 id="1-使用最新的Wine"><a href="#1-使用最新的Wine" class="headerlink" title="1. 使用最新的Wine"></a>1. 使用最新的Wine</h2><p>记住最新版的Wine会包含一些旧版本里没有的bug。个人还是推荐使用最新版，使用新版本会有更好的运行速度，而且基本上每个bug都会在未来的2~3个版本中被修复</p><h2 id="2-不要从源码编译安装Wine"><a href="#2-不要从源码编译安装Wine" class="headerlink" title="2. 不要从源码编译安装Wine"></a>2. 不要从源码编译安装Wine</h2><p>因为编译要解决的依赖性问题太多了。</p><p>我个人还是推荐编译安装，这样安装完后问题少一点，性能好一点。</p><h2 id="3-使用终端"><a href="#3-使用终端" class="headerlink" title="3.  使用终端"></a>3.  使用终端</h2><p>如果正确安装的话，wine会把它自己关联到exe文件，所以你只要双击exe文件就可以运行。无论怎样，这都不是我们所推荐的使用wine的方法（译者：我也不推荐）。使用终端会比较好，因为这样可以正确地设定程序的路径，否则程序就会找不到所需要的文件。另外，使用终端还可以显示出错误信息，这对于解决问题是非常有用的。</p><h2 id="4-“winecfg”的使用资料"><a href="#4-“winecfg”的使用资料" class="headerlink" title="4. “winecfg”的使用资料"></a>4. “winecfg”的使用资料</h2><h3 id="4-1-运行“winecfg”"><a href="#4-1-运行“winecfg”" class="headerlink" title="4.1 运行“winecfg”"></a>4.1 运行“winecfg”</h3><p>你至少需要运行一次winecfg来设置wine的目录和硬件。</p><h3 id="4-2-虚拟桌面"><a href="#4-2-虚拟桌面" class="headerlink" title="4.2 虚拟桌面"></a>4.2 虚拟桌面</h3><p>使用这个选项可以使软件的安装更加流畅。我发现在不使用这个选项的时候，使用某些程序会导致已经激活的对话框、CDKEY输入窗口或更换光盘的确认窗口不能出现在前端。让我以为程序卡死了，就kill掉了进程。选择这个选项还能够避免程序锁死你的桌面或者把你的屏幕分辨率改成难看的模式。</p><h3 id="4-3-使用Application-Settings"><a href="#4-3-使用Application-Settings" class="headerlink" title="4.3 使用Application Settings"></a>4.3 使用Application Settings</h3><p>你可以在winecfg的Application标签里的Application Settings对话框对个别的程序进行自定义设置。那里只允许你进行windows兼容运行模式设置（译者：像windows下的exe属性里的兼容性标签）、某些显示设置和DLL的设置。</p><p>当你只需要设置某个程序使用某些特定的windows自带的DLL，不希望其它程序（包括wine）使用这些native的DLL的时候（而其它程序使用这些DLL会导致问题），（译者：wine自带的DLL叫做builtin，windows下原生的DLL叫做native）这个选项就会变得十分有用。在进行DLL设置时我都用这个方法，就是为了防止某些对wine的运行存在潜在威胁的nativeDLL被wine调用（译者：在一般情况下， wine只调用自带的builtinDLL，而不会使用native的DLL，版权问题，除非经过设置，如上所述）。这样我就只是修改了那些可执行的配置文件，当我不需要时，可以改回来而不会损坏整个Wine。（译者：设置这些东西之前，保证已经将一个程序的exe文件添加到Application标签的白框中，并且反色选中。不是default的那个，是你所需要设置的那个exe文件。）</p><h3 id="4-4-Windows版本"><a href="#4-4-Windows版本" class="headerlink" title="4.4 Windows版本"></a>4.4 Windows版本</h3><p>对不同的程序尝试不同的Windows版本。这就是说一个为了XP而设计的游戏可能会在wine的98模式的支持下能更好地运行。在做这个之前确认你已经把程序添加到Application的白框中，并且选中，反色显示。</p><h3 id="4-5-使用ALSA驱动"><a href="#4-5-使用ALSA驱动" class="headerlink" title="4.5 使用ALSA驱动"></a>4.5 使用ALSA驱动</h3><p>有些游戏是需要OSS才能运行，但是OSS已经不会再继续开发了。</p><p>（推荐只是独立声卡使用ALSA，集成的还是使用OSS最好）</p><h3 id="4-6-不要总是选择allow-the-window-manager-to-control-the-windows（winecfg里的）"><a href="#4-6-不要总是选择allow-the-window-manager-to-control-the-windows（winecfg里的）" class="headerlink" title="4.6 不要总是选择allow the window manager to control the windows（winecfg里的）"></a>4.6 不要总是选择allow the window manager to control the windows（winecfg里的）</h3><p>使用这个选项有时候会使游戏在全屏幕运行时出现问题。当前的wine版本0.9.39+已经修正了多数游戏的全屏问题，但是引入了一个新的问题：当不使用这个选项时，会使键盘不能游戏中输入。在使用一个单独的X server来运行游戏时，这个问题可以得到解决。（见“高级设置资料”）</p><h3 id="4-7-谨慎对待DLL"><a href="#4-7-谨慎对待DLL" class="headerlink" title="4.7 谨慎对待DLL"></a>4.7 谨慎对待DLL</h3><p>winecfg可以让你用native的DLL替换builtin的DLL。下面的这些DLL是绝对不能被替换的。kernel32.dll， gdi32.dll，user32.dll，和ntdll.dll。有些nativeDLL也可能使一些程序不能运行。记得永远不要覆盖wine自带的 dll，如果native的用不了就用builtin的换回来。有些MS的DLL要得到许可才能用，如果你没有许可，就不要用。</p><h2 id="5-特殊配置资料"><a href="#5-特殊配置资料" class="headerlink" title="5. 特殊配置资料"></a>5. 特殊配置资料</h2><h3 id="5-1建立一个到CD的链接"><a href="#5-1建立一个到CD的链接" class="headerlink" title="5.1建立一个到CD的链接"></a>5.1建立一个到CD的链接</h3><p>Wine会建立一个到你挂载CD的文件夹的链接，但是建立一个到真正的/dev里的设备的链接会更好。我发现如果不这样做，Wine会自己建立到 /dev的链接，把CD认成E：盘，而我的挂载目录却链接为D：盘。我认为这个可能会导致某些使用CD安装的程序出现问题。修改/dev/hdc以适应你的系统（译者：7.04一般都是/dev/scd0）。</p><p>代码:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="regexp">/dev/</span>hdc ~<span class="regexp">/.wine/</span>dosdevices<span class="regexp">/d\:\:</span></span><br></pre></td></tr></table></figure></p><h3 id="5-2-实用注册表键值"><a href="#5-2-实用注册表键值" class="headerlink" title="5.2 实用注册表键值"></a>5.2 实用注册表键值</h3><p>有些设置是不能通过winecfg来进行设置的，但是可以在注册表中进行设置。有两个键值是非常有用的，一个是Alsa Driver的UseDirectHW，可以解决一些声音跳顿的问题；还有Direct3D的VideoMemorySize，你应该设置成你的显卡的准确显存，默认wine会设置成64MB。</p><h3 id="5-3-安装Wine-Gecko-IE-engine"><a href="#5-3-安装Wine-Gecko-IE-engine" class="headerlink" title="5.3 安装Wine Gecko IE engine"></a>5.3 安装Wine Gecko IE engine</h3><p>有些程序的运行依赖于IE，但是，安装IE会严重地破环Wine。所以可以安装Wine Gecko IE engine作为替代品。</p><p>1、在终端下运行下面的命令：</p><p>代码:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine iexplore <span class="string">http:</span><span class="comment">//www.winehq.org</span></span><br></pre></td></tr></table></figure></p><p>2、当出现安装提示时回答yes</p><p>3、打开<a href="http://wiki.winehq.org/UsefulRegistryKeys，找到HKEY_LOCAL_MACHINE板块" target="_blank" rel="noopener">http://wiki.winehq.org/UsefulRegistryKeys，找到HKEY_LOCAL_MACHINE板块</a></p><p>4、把所有有关Internet Explorer的键值加到注册表中</p><p>安装完成后，运行</p><p>代码:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine iexplore <span class="string">http:</span><span class="comment">//www.winehq.org</span></span><br></pre></td></tr></table></figure></p><p>成功的话就会出现winehq的主页。</p><h3 id="5-4-中文支持设置"><a href="#5-4-中文支持设置" class="headerlink" title="5.4 中文支持设置"></a>5.4 中文支持设置</h3><p>把下面的代码保存为zh.reg，然后终端执行regedit zh.reg。从Windows目录下的Fonts里的simsun.ttc复制到/home/user/.wine/drive_c/windows/fonts里面。</p><p>代码:</p><p>REGEDIT4</p><p>[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes]</p><p>“Arial”=”simsun”</p><p>“Arial CE,238”=”simsun”</p><p>“Arial CYR,204”=”simsun”</p><p>“Arial Greek,161”=”simsun”</p><p>“Arial TUR,162”=”simsun”</p><p>“Courier New”=”simsun”</p><p>“Courier New CE,238”=”simsun”</p><p>“Courier New CYR,204”=”simsun”</p><p>“Courier New Greek,161”=”simsun”</p><p>“Courier New TUR,162”=”simsun”</p><p>“FixedSys”=”simsun”</p><p>“Helv”=”simsun”</p><p>“Helvetica”=”simsun”</p><p>“MS Sans Serif”=”simsun”</p><p>“MS Shell Dlg”=”simsun”</p><p>“MS Shell Dlg 2”=”simsun”</p><p>“System”=”simsun”</p><p>“Tahoma”=”simsun”</p><p>“Times”=”simsun”</p><p>“Times New Roman CE,238”=”simsun”</p><p>“Times New Roman CYR,204”=”simsun”</p><p>“Times New Roman Greek,161”=”simsun”</p><p>“Times New Roman TUR,162”=”simsun”</p><p>“Tms Rmn”=”simsun”</p><h2 id="6-安装资料"><a href="#6-安装资料" class="headerlink" title="6. 安装资料"></a>6. 安装资料</h2><h3 id="6-1不要在CD的目录下安装程序"><a href="#6-1不要在CD的目录下安装程序" class="headerlink" title="6. 1不要在CD的目录下安装程序"></a>6. 1不要在CD的目录下安装程序</h3><p>（就是不要cd到CD的挂载目录运行安装程序）</p><p>如果这样做的话，就会在换CD时出现CD不能推出的问题，用下面的命令来安装CD：</p><p>代码:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine /media/cdrom0/<span class="built_in">setup</span>.exe</span><br></pre></td></tr></table></figure></p><h3 id="6-2-需要用到“wine-eject”"><a href="#6-2-需要用到“wine-eject”" class="headerlink" title="6. 2 需要用到“wine eject”"></a>6. 2 需要用到“wine eject”</h3><p>如果安装程序需要你换CD，而系统却说不能推出CD，那就打开一个新终端，输入：</p><p>代码:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">wine</span> eject d：</span><br></pre></td></tr></table></figure></p><h3 id="6-3-安装InstallShield的bug补丁"><a href="#6-3-安装InstallShield的bug补丁" class="headerlink" title="6. 3 安装InstallShield的bug补丁"></a>6. 3 安装InstallShield的bug补丁</h3><p>安装<a href="http://support.installshield.com/kb/files/Q108322/IkernelUpdate.exe" target="_blank" rel="noopener">http://support.installshield.com/kb/files/Q108322/IkernelUpdate.exe</a></p><p>这个补丁可以解决一些CD安装问题。</p><h3 id="6-4-使用uninstaller"><a href="#6-4-使用uninstaller" class="headerlink" title="6. 4 使用uninstaller"></a>6. 4 使用uninstaller</h3><p>使用命令“uninstaller”来卸载安装的程序，不要使用程序在菜单里面创建的卸载快捷方式，他们有时候不能正常工作，而uninstaller可以。</p><h3 id="6-5-安装-msi文件"><a href="#6-5-安装-msi文件" class="headerlink" title="6. 5 安装.msi文件"></a>6. 5 安装.msi文件</h3><p>有些windows的安装程序是使用msi来安装的，那就用下面的命令来安装：</p><p>代码:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine msiexec /<span class="selector-tag">i</span> install.msi</span><br></pre></td></tr></table></figure></p><p>或者</p><p>代码:<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine start <span class="keyword">install</span>.msi</span><br></pre></td></tr></table></figure></p><h3 id="6-6-不要安装DirectX"><a href="#6-6-不要安装DirectX" class="headerlink" title="6. 6 不要安装DirectX"></a>6. 6 不要安装DirectX</h3><p>Wine有它自己的DirectX库，安装微软的DirectX会破坏wine的DirectX库和Wine。</p><p>但是，d3dx9_##.dll和d3dx10_33.dll可以从Windows复制过来使用，可能会在启动某些游戏时有所帮助。使用这些dll你需要微软的授权证书。</p><h2 id="7-一般使用资料"><a href="#7-一般使用资料" class="headerlink" title="7.  一般使用资料"></a>7.  一般使用资料</h2><h3 id="7-1-如何用wine来运行程序"><a href="#7-1-如何用wine来运行程序" class="headerlink" title="7.1 如何用wine来运行程序"></a>7.1 如何用wine来运行程序</h3><p>代码:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine <span class="built_in">application</span>.exe</span><br></pre></td></tr></table></figure></p><h3 id="7-2-运行程序前cd到程序的安装目录"><a href="#7-2-运行程序前cd到程序的安装目录" class="headerlink" title="7.2 运行程序前cd到程序的安装目录"></a>7.2 运行程序前cd到程序的安装目录</h3><p>cd到程序的安装目录再运行程序。</p><h3 id="7-3-关掉WINEDEBUG"><a href="#7-3-关掉WINEDEBUG" class="headerlink" title="7.3 关掉WINEDEBUG"></a>7.3 关掉WINEDEBUG</h3><p>一般情况下，wine会不断地产生一些debug信息（那些“fixme”的东西）。那些信息在很多情况下是没有用的，尤其你已经可以正常地运行一个程序。你可以使用下面的命令来避免debug信息，节省资源：</p><p>代码:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">WINEDEBUG</span>=-all game.exe</span><br></pre></td></tr></table></figure></p><h3 id="7-4-不要使用root或者sudo来运行wine"><a href="#7-4-不要使用root或者sudo来运行wine" class="headerlink" title="7.4 不要使用root或者sudo来运行wine"></a>7.4 不要使用root或者sudo来运行wine</h3><p>可能会损坏系统文件。</p><h3 id="7-5-其他wine的命令"><a href="#7-5-其他wine的命令" class="headerlink" title="7.5 其他wine的命令"></a>7.5 其他wine的命令</h3><p>wineboot 模拟windows的重新启动</p><p>wine control 运行控制面板</p><p>wineserver wineserver会随着wine的命令自动启动，但也能通过终端启动来达到不同的目的。</p><p>wineserver的一些参数</p><p>1、-d# 设置终端中debug的显示级别。</p><p>2、-h 显示wineserver帮助文件</p><p>3、-k kill掉当前的wineserver，当程序失去响应而你要结束它时使用。</p><p>4、-p 让wineserver一直运行，也就是说即使程序退出了，wineserver还继续运行。当你需要运行连续的程序时可以使用，这样可以缩短程序的启动时间。</p><p>5、-w 让wineserver一直运行直到当前已激活的wineserver退出。</p><h3 id="7-6-让Wine运行更流畅"><a href="#7-6-让Wine运行更流畅" class="headerlink" title="7.6 让Wine运行更流畅"></a>7.6 让Wine运行更流畅</h3><p>当出现程序运行缓慢或性能起伏不定的问题时，可以通过提高进程的优先级来解决。启动游戏后，可以使用“renice”命令来改变进程的优先级。 “renice”命令可以改变当前进程的优先级，“nice”的值是优先级级别的标志，（高优先级=低nice值，低优先级=高nice值）。这个命令把程序优先级的值设置为从-20（最高优先级）到19（最低优先级）之间的任何一个整数值，而默认的值是0。在启动游戏以后，你需要打开另外一个终端输入下面的命令来改变程序的优先级：</p><p>代码:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">renice</span> <span class="selector-tag">-10</span> <span class="selector-tag">-n</span> <span class="selector-tag">game</span><span class="selector-class">.exe</span></span><br></pre></td></tr></table></figure></p><p>在用Wine运行游戏时，我不推荐直接把程序的优先级设置到-20，最好是从-10开始，如果效果提升不明显，可以一步步尝试小幅度的提高（- 11，-12，……）。你会发现绝大多数的游戏不需要比-10更高的优先级就已经可以达到最好的性能了。不用多说（我认为），在游戏中你可以用ALT- TAB组合键回到桌面使用“renice”命令。</p><p><strong>第二种方法</strong></p><p>使用图形界面来设置优先级。</p><p>1、 用终端运行游戏，按ALT-TAB回到桌面</p><p>2、 系统——&gt;系统管理——&gt;系统监视程序，切换到进程标签</p><p>3、 在进程上点右键——更改优先权</p><p>4、 要求密码时输入</p><p>5、 关闭系统监视程序，用ALT-TAB回到游戏</p><h2 id="8-第三方软件资料"><a href="#8-第三方软件资料" class="headerlink" title="8. 第三方软件资料"></a>8. 第三方软件资料</h2><h3 id="8-1-WineTools"><a href="#8-1-WineTools" class="headerlink" title="8.1 WineTools"></a>8.1 WineTools</h3><p>WineTools是一个菜单式的可以安装90多个常见Windows程序的软件。它也可以帮助你设置Wine的基本目录。已经不再有人维护 WineTools，它已经两年没有升级了，但很多用户都发现它依然有用。而WineTools所作的一切事情都可以自己通过winecfg或终端完成。</p><h3 id="8-2-Wine-Doors"><a href="#8-2-Wine-Doors" class="headerlink" title="8.2 Wine-Doors"></a>8.2 Wine-Doors</h3><p>Wine-Doors是一个帮助你安装很多的Windows程序，包括游戏的一个图形界面的软件。它现在还处在开发阶段，但已经发布了一个可以下载的最初版本。就这个软件看来，是非常有前途的。</p><h3 id="8-3-Cedega"><a href="#8-3-Cedega" class="headerlink" title="8..3 Cedega"></a>8..3 Cedega</h3><p>Cedega就技术上来说是Wine的一个分支，它明确地针对于游戏。cedega包含了一个安装和运行游戏的图形界面，还加上了对受防拷贝保护的软件的支持（不需要使用破解来免CD）（译者：wine的对防拷贝的支持不是很好）。cedega不适免费的，最低消费是购买3个月，每月3美元，如果预付一年的费用的话，可以享受一点折扣。cedega从前叫做WineX，在Wine还是MIT软件，而不是现在的GPL的时候，WineX就从wine的一个分支分离出来，就因为cedega不属于GPL，cedega不再对wine的代码发展作贡献了。再加上cedega缺少支持，很多人便不再用cedega 在linux下玩游戏。</p><h3 id="8-4-CrossOver"><a href="#8-4-CrossOver" class="headerlink" title="8.4 CrossOver"></a>8.4 CrossOver</h3><p>CrossOver从技术上来说，CrossOver不是wine的一个第三方产品，而是wine的主要财力支持者。CrossOver一开始是以在linux下运行Microsoft Office软件为目标的，但最近它开始添加对游戏的支持。CrossOver基于一个更老，更稳定的Wine版本，但 CrossOver也随着Wine一起升级。CrossOver标准版的售价是39.95美元。</p><h3 id="8-5-ReactOS"><a href="#8-5-ReactOS" class="headerlink" title="8.5 ReactOS"></a>8.5 ReactOS</h3><p>正如CrossOver一样，ReactOS也是Wine的一个支持者，基于许多Wine已经完成的成果，它致力于建立一个能与Windows完全兼容的操作系统。完成后，ReactOS能够使用Windows的驱动程序和软件，完全兼容。这项计划还处于开发阶段，但已经可以提供安装CD、 LiveCD、QEMU和VMware镜像的下载。</p><h2 id="9-高级设置资料"><a href="#9-高级设置资料" class="headerlink" title="9. 高级设置资料"></a>9. 高级设置资料</h2><h3 id="9-1-使用启动脚本（使用之前确保游戏能够正常运行）"><a href="#9-1-使用启动脚本（使用之前确保游戏能够正常运行）" class="headerlink" title="9.1 使用启动脚本（使用之前确保游戏能够正常运行）"></a>9.1 使用启动脚本（使用之前确保游戏能够正常运行）</h3><p>再使用单独得X server时，很多游戏一般都可以发挥出他们最佳性能。wine不需要窗口管理器（GNOME或KDE）就可以正常地运行，所以如果你在一个单独的X server下运行游戏，你会得到明显的性能提升。在运行游戏之前，关闭GDM或KDM，还会得到更大的性能提升（只能通过控制（console）台来实现）。</p><p>1、首先，在终端下建立一个脚本</p><p>代码:<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano launcher.<span class="keyword">sh</span>（可以用<span class="keyword">vim</span>替换nano）</span><br></pre></td></tr></table></figure></p><p>2、复制下面的文字到终端里。如果你没有nVidia的显卡，就删除nvidia settings的那部分，然后用你的游戏的正确路径替换里面的路径</p><p>代码:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#uncomment if launching from console session</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sudo /etc/init.d/gdm stop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#KDE use this instead</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sudo /etc/init.d/kdm stop</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Launches a new X session on display 3. If you don’t have an Nvidia card</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># take out the “&amp; nvidia-settings –load-config-only” part</span></span><br><span class="line"></span><br><span class="line">X :3 -ac &amp; nvidia-settings –load-config-only</span><br><span class="line"></span><br><span class="line"><span class="comment"># Goto game dir (modify as needed)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> “<span class="variable">$HOME</span>/.wine/drive_c/Program Files/Game/Directory/”</span><br><span class="line"></span><br><span class="line"><span class="comment"># Forces the system to have a break for 2 seconds, X doesn’t launch instantly</span></span><br><span class="line"></span><br><span class="line">sleep 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Launches game (modify as needed)</span></span><br><span class="line"></span><br><span class="line">DISPLAY=:3 WINEDEBUG=-all wine “C:/Program Files/Game/Directory/game.exe”</span><br></pre></td></tr></table></figure></p><p>3、把文件保存到你的主文件夹（保存Ctrl+O，退出Ctrl+X。Vim的话先Esc，再Shift+：，保存w，退出q）</p><p>4、然后，给你的脚本加上可执行属性</p><p>代码:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ~<span class="string">/launcher.sh</span></span><br></pre></td></tr></table></figure></p><p>5、运行脚本</p><p>代码:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> launcher.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p><p>或</p><p>代码:<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">./launcher.sh</span></span><br></pre></td></tr></table></figure></p><p>6、结束游戏后，用CTRL-ALT-BACKSPACE回到桌面</p><p><strong>第二种方法</strong></p><p>如果你的游戏不能运行或者只是单纯想压榨出更好的游戏性能，跟着下面的步骤尝试在关闭X session的情况下运行游戏。</p><p>1、取消注销“sudo /etc/init.d/gdm stop”语句（删除#）后保存，如果你是使用KDE，就取消注销“sudo /etc/init.d/kdm stop”。</p><p>2、关闭所有程序，按CTRL-ALT-F1打开控制台</p><p>3、在控制台登陆并运行这个脚本。你会被要求输入密码，然后游戏会在它自己的X session里运行，而没有GDM或KDM的妨碍。</p><p>4、如果脚本显示你没有启动X session的权限，就修改那个脚本</p><p>按照这样修改X server的启动语句</p><p>代码:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo X :<span class="number">3</span> -ac &amp; nvidia-settings –<span class="built_in">load</span>-<span class="built_in">config</span>-only</span><br></pre></td></tr></table></figure></p><p>注意：为了避免修改脚本，你可以修改Xwrapper.config给与一般用户启动X的权限。用sudo vim打开/etc/X11/Xwrapper.config，把allowed_users=console修改为allowed_users=anybody。</p><p>5、结束游戏后，可以重启或CTRL-ALT-BACKSPACE回到控制台，重新启动X和桌面：</p><p>代码:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/gdm start</span></span><br></pre></td></tr></table></figure></p><p>如果是KDE</p><p>代码:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="regexp">/etc/i</span>nit.d<span class="regexp">/kdm start</span></span><br></pre></td></tr></table></figure></p><p>桌面会很快出现，还不行的话就输入</p><p>代码:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">startx</span></span><br></pre></td></tr></table></figure></p><p>注意：</p><p>1、如果让游戏使用它自己的X session，确认禁止winecfg里的virtual desktop。</p><p>2、让游戏使用它自己的X session可以解决在游戏时键盘无法输入的问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://winehq.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Wine&lt;/a&gt; （“Wine Is Not an Emulator” 的首字母缩写）是一个能够在多种 POSIX-compliant 操作系统（诸如Li
      
    
    </summary>
    
      <category term="运维" scheme="https://www.ljjyy.com/categories/devops/"/>
    
    
      <category term="wine" scheme="https://www.ljjyy.com/tags/wine/"/>
    
  </entry>
  
  <entry>
    <title>高效解析器 Lex&amp;YACC(Flex&amp;Bison) 使用教程</title>
    <link href="https://www.ljjyy.com/archives/2023/05/100671.html"/>
    <id>https://www.ljjyy.com/archives/2023/05/100671.html</id>
    <published>2023-05-27T04:00:00.000Z</published>
    <updated>2023-06-20T01:01:17.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>只要在Unix环境中写程序，必定会邂逅神秘的Lex&amp;YACC，就如GNU/Linux用户所熟知的Flex&amp;Bison，这里的Flex就是由Vern Paxon实现的一个Lex，Bison则是GNU版本的YACC。在此我们将统一称呼这些程序为Lex和YACC。新版本的程序是向上兼容的(译注：即兼容老版本)，所以你可以用Flex和Bison来尝试下我们的实例。</p><p>这些程序实用性极广，但如同你的C编译器一样，在其主页上并没有描述它们，也没有关于怎样使用的信息。当和Lex结合使用时，YACC实在是棒极了，但是Bison的主页上并没有描述Bison如何跟Lex结合使用以生成代码的相应说明。</p><h1 id="二、Lex-amp-YACC能为你做什么？"><a href="#二、Lex-amp-YACC能为你做什么？" class="headerlink" title="二、Lex &amp; YACC能为你做什么？"></a>二、Lex &amp; YACC能为你做什么？</h1><p>如果使用得当，这些程序(指LEX&amp;YACC)可以让你轻易的解析复杂的语言，当你需要读取一个配置文件时，或者你需要编写一个你自己使用的语言的编译器时，这对于你来说是莫大的裨益。<br>本文档能提供给你一些帮助，你将发现你再也不用手工写解析器了，Lex &amp; YACC就是为你量身打造的利器。</p><p>先来看一个示例，简单计算器：</p><h2 id="2-1-简单计算器"><a href="#2-1-简单计算器" class="headerlink" title="2.1 简单计算器"></a>2.1 简单计算器</h2><p>计算器实现整数的 +、-、*、/、% 五种简单运算。</p><h3 id="1-词法分析程序-cal-l"><a href="#1-词法分析程序-cal-l" class="headerlink" title="1. 词法分析程序 cal.l"></a>1. 词法分析程序 cal.l</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cal.tab.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> yylval;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+  &#123; yylval = atoi(yytext); <span class="keyword">return</span> NUMBER; &#125;</span><br><span class="line">[ \t]   ;       <span class="comment">/* ignore white space */</span></span><br><span class="line">\n  <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">/* logical EOF */</span></span><br><span class="line">.   <span class="keyword">return</span> yytext[<span class="number">0</span>];</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>代码中定义了四条规则，前面的部分就是模式，处于一行的开始位置，后面部分是动作，也就是，输入中匹配到了这个模式的时候，对应进行什么动作（就像机器人接受到了什么样的指令，然后会执行相应的动作一样）</p><ul><li>第一个模式，匹配连续一个或者多个数字，匹配到之后就返回标签NUMBER。</li><li>第二个模式，匹配空格，没有任何操作，忽略所有空格。</li><li>第三个模式，匹配一个换行符，匹配到之后结束匹配。</li><li>第四个模式，匹配出了\n之外的字符，返回该字符。</li></ul><p>总体来说，匹配到连续数字，则返回NUMBER；忽略空格；换行结束；匹配到任何其他字符返回字符。</p><h3 id="2-语法分析程序-cal-y"><a href="#2-语法分析程序-cal-y" class="headerlink" title="2. 语法分析程序 cal.y"></a>2. 语法分析程序 cal.y</h3><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"><span class="keyword">int</span> yylex(void);</span><br><span class="line">%&#125;</span><br><span class="line">%token NAME NUMBER</span><br><span class="line">%%</span><br><span class="line">statement:  NAME <span class="string">'='</span> <span class="keyword">expression</span></span><br><span class="line">    |   <span class="keyword">expression</span>      &#123; printf(<span class="string">"= %d\n"</span>, $1); &#125;</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">expression</span>: <span class="keyword">expression</span> <span class="string">'+'</span> NUMBER   &#123; $$ = $1 + $3; &#125;</span><br><span class="line">    |   <span class="keyword">expression</span> <span class="string">'-'</span> NUMBER   &#123; $$ = $1 - $3; &#125;</span><br><span class="line">    |   <span class="keyword">expression</span> <span class="string">'*'</span> NUMBER   &#123; $$ = $1 * $3; &#125;</span><br><span class="line">    |   <span class="keyword">expression</span> <span class="string">'/'</span> NUMBER   &#123; $$ = $1 / $3; &#125;</span><br><span class="line">    |   <span class="keyword">expression</span> <span class="string">'%'</span> NUMBER   &#123; $$ = $1 % $3; &#125;</span><br><span class="line">    |   NUMBER          &#123; $$ = $1; &#125;</span><br><span class="line">    ;</span><br><span class="line">%%</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    yyparse();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> yyerror(char *s)</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"%s/n"</span>,s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> yywrap() </span><br><span class="line">&#123; </span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-编译运行过程"><a href="#3-编译运行过程" class="headerlink" title="3. 编译运行过程"></a>3. 编译运行过程</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* <span class="number">1</span>.  编译<span class="keyword">lex</span>文件，生成<span class="keyword">lex</span>.yy.<span class="keyword">c</span>文件 */</span><br><span class="line">C:\flex&gt;flex <span class="keyword">cal</span>.<span class="keyword">l</span></span><br><span class="line"></span><br><span class="line">/* <span class="number">2</span>. 编译yacc文件，生成<span class="keyword">cal</span>.<span class="keyword">tab</span>.h 与<span class="keyword">cal</span>.<span class="keyword">tab</span>.<span class="keyword">c</span>文件 */</span><br><span class="line">C:\flex&gt;bison -d <span class="keyword">cal</span>.<span class="keyword">y</span></span><br><span class="line"></span><br><span class="line">/* <span class="number">3</span>. 链接生成的.<span class="keyword">c</span> 文件，并生成相应的可执行文件 <span class="keyword">cal</span> */</span><br><span class="line">C:\flex&gt;gcc -<span class="keyword">o</span> <span class="keyword">cal</span> <span class="keyword">cal</span>.<span class="keyword">tab</span>.<span class="keyword">c</span> <span class="keyword">lex</span>.yy.<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line">/* <span class="number">4</span>. 运行可执行文件<span class="keyword">cal</span>，计算简单表达式  */</span><br><span class="line">C:\flex&gt;<span class="keyword">cal</span></span><br><span class="line"><span class="number">32</span>*<span class="number">10</span>-<span class="number">20</span>+<span class="number">150</span>/<span class="number">3</span></span><br><span class="line">= <span class="number">150</span></span><br></pre></td></tr></table></figure><h1 id="三、Lex"><a href="#三、Lex" class="headerlink" title="三、Lex"></a>三、Lex</h1><p>Lex会生成一个叫做『词法分析器』的程序。这是一个函数，它带有一个字符流传入参数，词法分析器函数看到一组字符就会去匹配一个关键字(key)，采取相应措施。</p><h2 id="3-1-Lex-的结构规范"><a href="#3-1-Lex-的结构规范" class="headerlink" title="3.1 Lex 的结构规范"></a>3.1 Lex 的结构规范</h2><p> lex源文件扩展名.l，分为三个段：定义段、规则段、用户子程序段</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义段 */</span></span><br><span class="line"><span class="comment">%&#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">%&#125;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">    <span class="comment">/* 规则段 */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line">    <span class="comment">/* 用户子程序段 */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>三个段用 <strong>%%</strong> 进行分隔。</p><h3 id="1-定义段"><a href="#1-定义段" class="headerlink" title="1. 定义段"></a>1. 定义段</h3><p>定义段包括文字块、定义、内部表声明、起始条件和转换。<br> C语言的注释、头文件包含等一般就放在<code>%{</code>&nbsp;   <code>%}</code>之间，这一部分的内容会被直接复制到输出文件的开头部分。<br> 例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cal.tab.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> yylval;</span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure><h3 id="2-规则段"><a href="#2-规则段" class="headerlink" title="2. 规则段"></a>2. 规则段</h3><p>规则段为一系列匹配模式和动作，模式一般使用正则表达式书写，动作部分为C代码：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">模式<span class="number">1</span> &#123;动作<span class="number">1</span> （C代码）&#125;</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+  &#123; yylval = atoi(yytext); return NUMBER; &#125;</span><br></pre></td></tr></table></figure><p>在输入和模式1匹配的时候，执行动作部分的代码。<br>   <strong>C代码被逐字拷贝到生成的C文件中。</strong></p><p>当lex扫描程序运行时，它把输入与规则段的模式进行匹配。<br> ➢ 每次发现一个匹配（被匹配的输入称为标记（token））时就执行与那种模式相关的C代码。<br> ➢ 如果模式后面跟着 <strong>|</strong> 符号，则该模式将使用与文件中下一个模式相同的C代码。<br> ➢ 当输入字符不匹配模式时，词法分析程序的动作就好像它匹配上了代码ECHO的模式，ECHO将标记的拷贝写到输出。</p><h3 id="3-用户子程序段"><a href="#3-用户子程序段" class="headerlink" title="3. 用户子程序段"></a>3. 用户子程序段</h3><p>这里为C代码，会被原样复制到c文件中，一般这里定义一些辅助函数等，如动作代码中使用到的辅助函数。<br> 如果重新定义input()、unput()、output()、或者yywrap()，新的版本或者支持子程序，都可以放在这里。</p><p>词法分析器所做的，就是在输入中寻找字符的模式（pattern）。<br> 在词法分析器中，我们要给定我们需要识别的模式，因此需要使用一种方式来描述模式，这就是常用的正则表达式。</p><h2 id="3-2-Lex的常规表达式"><a href="#3-2-Lex的常规表达式" class="headerlink" title="3.2 Lex的常规表达式"></a>3.2 Lex的常规表达式</h2><p>lex模式是由编辑程序和实用程序使用的正则表达式的扩展版本。正则表达式由常规字符（代表它们本身）和元字符（在一种模式中具有特殊含义）组成。</p><h3 id="1-用-Lex-定义常规表达式"><a href="#1-用-Lex-定义常规表达式" class="headerlink" title="1. 用 Lex 定义常规表达式"></a>1. 用 Lex 定义常规表达式</h3><table><thead><tr><th style="text-align:left">字符</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left">A-Z, 0-9, a-z</td><td>构成了部分模式的字符和数字。</td></tr><tr><td style="text-align:left">.</td><td>匹配任意字符，除了 \n。</td></tr><tr><td style="text-align:left">-</td><td>用来指定范围。例如：A-Z 指从 A 到 Z 之间的所有字符。</td></tr><tr><td style="text-align:left">[ ]</td><td>一个字符集合。匹配括号内的 任意 字符。如果第一个字符是 ^ 那么它表示否定模式。例如: [abC] 匹配 a, b, 和 C中的任何一个。</td></tr><tr><td style="text-align:left">*</td><td>匹配 0个或者多个上述的模式。</td></tr><tr><td style="text-align:left">+</td><td>匹配 1个或者多个上述模式。</td></tr><tr><td style="text-align:left">?</td><td>匹配 0个或1个上述模式。</td></tr><tr><td style="text-align:left">$</td><td>作为模式的最后一个字符匹配一行的结尾。</td></tr><tr><td style="text-align:left">{ }</td><td>指出一个模式可能出现的次数。 例如: A{1,3} 表示 A 可能出现1次或3次。</td></tr><tr><td style="text-align:left">\</td><td>用来转义元字符。同样用来覆盖字符在此表中定义的特殊意义，只取字符的本意。</td></tr><tr><td style="text-align:left">^</td><td>否定。</td></tr><tr><td style="text-align:left">&#124;</td><td>表达式间的逻辑或。</td></tr><tr><td style="text-align:left">“&lt;一些符号&gt;”</td><td>字符的字面含义。元字符具有。</td></tr><tr><td style="text-align:left">/</td><td>向前匹配。如果在匹配的模版中的“/”后跟有后续表达式，只匹配模版中“/”前 面的部分。如：如果输入 A01，那么在模版 A0/1 中的 A0 是匹配的。</td></tr><tr><td style="text-align:left">( )</td><td>将一系列常规表达式分组。</td></tr></tbody></table><p>下面将逐一详细讲解;</p><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><p>➢  <strong>.</strong><br> . 匹配除了换行符 <strong>\n</strong> 之外的任意单个字符<br> 例如</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.   <span class="keyword">return</span> yytext[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>➢  <strong>[]</strong><br> [] 匹配括号中字符的任意一个。<br> 用“-”（短划线）指示字符的范围，例如[0-9]指10个数字中的任意一个。<br> 如果开括号之后的第一个字符是短划线或者闭括号，那么它就不能被解释为元字符。<br> 如果第一个字符是抑扬字符“ ^ ”，那么它的含义就变为匹配括号内字符以外的任意字符。<br> <strong><em>除了以“ \ ”开始的C转义序列被识别以外，其他的元字符在方括号中没有特殊含义。\</em></strong></p><p>例如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>+  &#123;<span class="selector-tag">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125; <span class="comment">// 匹配大写字母，出现1次以上</span></span><br><span class="line"><span class="selector-attr">[^A-Z]</span>+  &#123;<span class="selector-tag">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125; <span class="comment">// 匹配除了大写字母外的其他字符，出现1次以上</span></span><br></pre></td></tr></table></figure><p>➢  <strong>*</strong><br> <strong>*</strong> 匹配前面正则表达式的零次或者多次出现。</p><p>例如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>*  &#123;<span class="selector-tag">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125; <span class="comment">// 匹配大写字母，出现0次或者多次</span></span><br></pre></td></tr></table></figure><p>➢  <strong>+</strong><br> <strong>+</strong> 匹配前面正则表达式的一次或者多次出现。</p><p>例如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>+  &#123;<span class="selector-tag">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125;<span class="comment">// 匹配大写字母，出现1次以上</span></span><br></pre></td></tr></table></figure><p>➢  <strong>?</strong><br> ? 匹配前面正则表达式的零次或者一次出现。例如： -?[0-9]+  指具有可选的前导或者一元减号的数字</p><p>例如</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[A-Z]</span>?  &#123;<span class="selector-tag">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125; <span class="comment">// 匹配大写字母，出现零次或者一次</span></span><br></pre></td></tr></table></figure><p>➢  <strong>{}</strong><br> {} 意味着根据括号内部的不同而不同。单个数字{n}意味着前面的模式重复n次。例如： [A-Z]{3} 表示任意3个大写字母。</p><p>如果大括号包含的由逗号分开的两个数字{n,m}，那么它们是前面模式重复的最小数和最大数。例如：A{1,3}表示字母A出现1次到3次。</p><p>如果第二个数字丢失就意味着无穷大，所以{1，}意味着 +    ；  {0，}意味着 *  。</p><p>如果大括号包含一个名字，它指示用那个名字来替换。</p><p>例如</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[A-Z]&#123;<span class="number">3</span>&#125;  &#123;printf(<span class="string">"get word:%s<span class="subst">\n</span>"</span>, yytext);&#125; <span class="comment">// 匹配大写字母，出现3次</span></span><br><span class="line">[A-Z]&#123;<span class="number">3</span>,&#125;  &#123;printf(<span class="string">"get word:%s<span class="subst">\n</span>"</span>, yytext);&#125; <span class="comment">// 匹配大写字母，出现3次以上</span></span><br><span class="line">[A-Z]&#123;<span class="number">3</span>,<span class="number">6</span>&#125;  &#123;printf(<span class="string">"get word:%s<span class="subst">\n</span>"</span>, yytext);&#125; <span class="comment">// 匹配大写字母，出现3~6次</span></span><br></pre></td></tr></table></figure><p>➢  <strong>\</strong><br> \ 转义符号，如果后面的字符是小写字母，那么它就是C转义序列。 例如制表位：\t</p><p>一些实现允许采用如“\123” 和 “\x3f” 这种形式的八进制和十六进制字符。</p><p>否则，“\” 引用后面的字符，所以 * 匹配一个 * 号。</p><p><strong><em>转义字符表\</em></strong></p><table><thead><tr><th>转义字符</th><th>意义</th><th style="text-align:center">ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>响铃(BEL)</td><td style="text-align:center">007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td style="text-align:center">008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td style="text-align:center">012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td style="text-align:center">010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td style="text-align:center">013</td></tr><tr><td>\t</td><td>水平制表(HT) （跳到下一个TAB位置）</td><td style="text-align:center">009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td style="text-align:center">011</td></tr><tr><td>\</td><td>代表一个反斜线字符’\’</td><td style="text-align:center">092</td></tr><tr><td>\’</td><td>代表一个单引号（撇号）字符</td><td style="text-align:center">039</td></tr><tr><td>\”</td><td>代表一个双引号字符</td><td style="text-align:center">034</td></tr><tr><td>\?</td><td>代表一个问号</td><td style="text-align:center">063</td></tr><tr><td>\0</td><td>空字符(NULL)</td><td style="text-align:center">000</td></tr><tr><td>\ddd</td><td>1到3位八进制数所代表的任意字符</td><td style="text-align:center">三位八进制</td></tr><tr><td>\xhh</td><td>1到2位十六进制所代表的任意字符</td><td style="text-align:center">二位十六进制</td></tr></tbody></table><p>➢  <strong>()</strong><br> ()  将一系列正则表达式归组。 *   +   {}   中的每一个都直接作用于它左侧的表达式，而且 |  通常同时影响左侧和右侧的内容。圆括号可以改变这种情况，</p><p>例如：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">abc</span>)&#123;<span class="number">3</span>&#125;  &#123;printf(<span class="string">"get word:%s\n"</span>, yytext)<span class="comment">;&#125; // 连续出现3次 abc</span></span><br><span class="line">(<span class="name">ab</span>|cd)&#123;<span class="number">3</span>&#125;  &#123;printf(<span class="string">"get word:%s\n"</span>, yytext)<span class="comment">;&#125; // 出现3次："ab" 或 "cd"</span></span><br></pre></td></tr></table></figure><p>➢  <strong>|</strong><br> | 匹配前面的或者随后的表达式。<br> 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ab|<span class="built_in">cd</span>)&#123;1&#125;  &#123;<span class="built_in">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125; // 出现1次：<span class="string">"ab"</span>或 <span class="string">"cd"</span></span><br></pre></td></tr></table></figure><p>➢  <strong>“…”</strong><br> “…”  逐字匹配引号内的每个字符。不同于“\”的元字符会失去它的含义。<br> 和 () 不同的是，引号内的都是普通字符，没有特殊含义。</p><p>例如：“/<em>” 匹配两个字符 /</em></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(\\)&#123;<span class="number">1</span>&#125;  &#123;printf(<span class="string">"get word:%s<span class="subst">\n</span>"</span>, yytext);&#125; <span class="comment">// 出现1次："\"</span></span><br><span class="line"><span class="string">"<span class="subst">\\</span>"</span>&#123;<span class="number">1</span>&#125;  &#123;printf(<span class="string">"get word:%s<span class="subst">\n</span>"</span>, yytext);&#125; <span class="comment">// 出现1次："\\"</span></span><br></pre></td></tr></table></figure><p>➢  <strong>/</strong><br> / 只有当有后面的表达式跟随时才匹配前面的表达式。</p><p>例如： 0/1 匹配字符串01中的0 但是不匹配字符串0或者02中的任何字符。</p><p>每个模式只允许有一个/ ，并且模式不能同时包含 / 和 $</p><p>➢  <strong>^</strong><br> ^作为正则表达式的第一个字符，它匹配行的开始；<br> ^在方括号[] 中用于否定。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^<span class="selector-attr">[A-Z]</span>* &#123;<span class="selector-tag">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125; <span class="comment">// 行开始的所有大写字母串</span></span><br><span class="line"><span class="selector-attr">[^A-Z]</span>*  &#123;<span class="selector-tag">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125; <span class="comment">// 匹配非大写字母的字符串</span></span><br></pre></td></tr></table></figure><p>➢  <strong>$</strong><br> $作为正则表达式的最后一个字符，它匹配行的结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A-Z]*$ &#123;<span class="built_in">printf</span>(<span class="string">"get word:%s\n"</span>, yytext);&#125; <span class="comment">// 行末尾的大写字母串</span></span><br></pre></td></tr></table></figure><p>➢  <strong>&lt;&gt;</strong><br> &lt;&gt; 位于模式开头的尖括号内的一个或者一列名字，使那个模式只应用于指定的起始状态。<br> 匹配词（word）的开始（&lt;）和结束（&gt;）。例如正则表达式<code>&lt;the&gt;</code>能够匹配字符串”for the wise”中的”the”，但是不能匹配字符串”otherwise”中的”the”。</p><p>➢  <strong><code>&lt;&lt;EOF&gt;&gt;</code></strong><br> <code>&lt;&lt;EOF&gt;&gt;</code> 只用于flex中，这个特殊模式匹配文件的结尾。</p><h3 id="2-常规表达式举例"><a href="#2-常规表达式举例" class="headerlink" title="2. 常规表达式举例"></a>2. 常规表达式举例</h3><table><thead><tr><th style="text-align:left">常规表达式</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">joke[rs]</td><td style="text-align:left">匹配 jokes 或 joker。</td></tr><tr><td style="text-align:left">A{1,2}shis+</td><td style="text-align:left">匹配 AAshis, Ashis, AAshi, Ashi。</td></tr><tr><td style="text-align:left">(A[b-e])+</td><td style="text-align:left">匹配在 A 出现位置后跟随的从 b 到 e 的所有字符中的 0 个或 1个。</td></tr></tbody></table><h3 id="3-标记声明举例"><a href="#3-标记声明举例" class="headerlink" title="3. 标记声明举例"></a>3. 标记声明举例</h3><table><thead><tr><th>标记</th><th>相关表达式</th><th>含义</th></tr></thead><tbody><tr><td>数字(number)</td><td>([0-9])+</td><td>1个或多个数字</td></tr><tr><td>字符(chars)</td><td>[A-Za-z]</td><td>任意字符</td></tr><tr><td>空格(blank)</td><td>“ “</td><td>一个空格</td></tr><tr><td>字(word)</td><td>(chars)+</td><td>1个或多个 <em>chars</em></td></tr><tr><td>变量(variable)</td><td>(字符)+(数字)<em>(字符)</em>(数字)*</td><td>&nbsp;</td></tr></tbody></table><h2 id="3-3-简单示例"><a href="#3-3-简单示例" class="headerlink" title="3.3 简单示例"></a>3.3 简单示例</h2><p>一个非常简单的例子(example1)如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line"><span class="function">stop <span class="title">printf</span><span class="params">(<span class="string">"Stop command received\n"</span>)</span></span>;</span><br><span class="line"><span class="function">start <span class="title">printf</span><span class="params">(<span class="string">"Start command received\n"</span>)</span></span>;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>第一部分，位于%{和%}对之间直接包含了输出程序(stdio.h)。我们需要这个程序，因为使用了printf函数，它在stdio.h中定义。</p><p>第二部分用’%%’分割开来，所以第二行起始于’stop’，一旦在输入参数中遇到了’stop’，接下来的那一行(printf()调用)将被执行。</p><p>除此之外，还有’start’，其跟stop的行为差不多。</p><p>我们再次用’%%’结束代码段。</p><p>为了编译上面的例子，只需要执行以下命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lex example1.l</span><br><span class="line">cc lex<span class="selector-class">.yy</span><span class="selector-class">.c</span> -o example -ll</span><br></pre></td></tr></table></figure><p>flex，执行以下命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">C:</span>\flex&gt;flex example1.l</span><br><span class="line"></span><br><span class="line"><span class="symbol">C:</span>\flex&gt;gcc lex.yy.c -o example -L <span class="symbol">C:</span>\Qt\GnuWin32\<span class="class"><span class="keyword">lib</span> -<span class="title">lfl</span></span></span><br><span class="line"></span><br><span class="line"><span class="symbol">C:</span>\flex&gt;example</span><br><span class="line">aa</span><br><span class="line">aa</span><br><span class="line">stop</span><br><span class="line">Stop command received</span><br><span class="line"></span><br><span class="line">start</span><br><span class="line">Start command received</span><br><span class="line"></span><br><span class="line">^Z</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果你用flex，则就将lex命令用flex代替，还需要将’-ll’选项改成’-lfl’。在RedHat 6.x以及SuSe中需要这样做。</p><p>这样，Lex将生成’example1’这个文件。运行该文件，它将等待你输入一些数据。每次你输入一些不匹配的命令(非’stop’和’start’)，它会将你输入的字符再次输出。你若输入’stop’，它将输出’Stop command received’。</p><p>用一个EOF(^D)来结束程序。</p><p>也许你想知道，它是怎么运行的，因为我们并没有定义main()函数。这个函数(指main())已经在lib1(liblex)中定义好了，在此我们选用了编译选项’-ll’</p><h2 id="3-4-匹配中的正则表达式示例"><a href="#3-4-匹配中的正则表达式示例" class="headerlink" title="3.4 匹配中的正则表达式示例"></a>3.4 匹配中的正则表达式示例</h2><p>这个实例(example2)本身并没什么用处，下一个实例也不会提及正则表达式。但这里它展示了如何在Lex中使用正则表达式，这在后面将非常有用。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="section">#include &lt;stdio.h&gt;</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[0123456789]+ printf("NUMBER\n");</span><br><span class="line">[<span class="string">a-zA-Z</span>][<span class="symbol">a-zA-Z0-9</span>]* printf("WORD\n");</span><br></pre></td></tr></table></figure><p>该Lex文件描述了两种token匹配：WORDs和NUMBERs。正则表达式非常恐怖，但是只需要稍花力气便可以加以理解。</p><p>其中NUMBER匹配“[0123456789]+”可以写成“[0-9]+”。</p><p>WORD匹配就有点复杂：[a-zA-Z][a-zA-Z0-9]*</p><p>第一部分仅仅匹配一个’a’到’z’或’A’到’Z’之间的字符，也即一个字母。接着该字母后面需要连上0个或多个字符，这些字符可以是字母，也可以是数字。这里为何用’<em>’? ’+’表示至少1次的匹配。一个WORD只有一个字符也可以很好的匹配，在第一部分我们已经匹配到了一个字符，所以第二部分可以是0个匹配，所以用’</em>’。</p><p>用这种方式，我们就模仿了很多编程语言中对于一个变量名的要求，即要求变量名『必须』以字母开头，但是可以在后续字符中用数字。也就是说’temperature1’是一个正确的命名，但是’1temperature’就不是。</p><p>像example1一样编译example2，并输入一些文本，如下：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ./example2</span><br><span class="line">foo</span><br><span class="line"><span class="built_in">WORD</span></span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line"><span class="built_in">WORD</span></span><br><span class="line"></span><br><span class="line">123</span><br><span class="line">NUMBER</span><br><span class="line"></span><br><span class="line">bar123</span><br><span class="line"><span class="built_in">WORD</span></span><br><span class="line"></span><br><span class="line">123bar</span><br><span class="line">NUMBER</span><br><span class="line"><span class="built_in">WORD</span></span><br></pre></td></tr></table></figure><p>你也许会疑惑，所有的输出中的空格是从哪来的？理由很简单：从输入而来，我们不在空格上匹配任何内容，所以它们又输出来了。</p><p>Flex主页上有正则表达式的详细文档。很多人觉得perl正则表达式主页的说明非常有用，但是Flex并不实现perl所实现的所有东西。</p><p>你只需要确保不写一些形如’[0-9]*’的空匹配即可，你的词法分析器(由Flex生成)将不明就里的开始不断的匹配空字符。</p><h2 id="3-5-复杂一点的类C语法示例"><a href="#3-5-复杂一点的类C语法示例" class="headerlink" title="3.5 复杂一点的类C语法示例"></a>3.5 复杂一点的类C语法示例</h2><p>假定我们需要解析一个形如下面的文件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">logging&#123;</span><br><span class="line">category lame-servers &#123; <span class="literal">null</span>; &#125;;</span><br><span class="line">category cname &#123; <span class="literal">null</span>; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zone <span class="string">"."</span> &#123;</span><br><span class="line">type hint;</span><br><span class="line">file <span class="string">"/etc/bind/db.root"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在此见到了很多token：</p><ul><li>WORD: 如’zone’和’type’</li><li>FILENAME：如“/etc/bind/db.root”</li><li>QUOTE: 如包含文件名的引号</li><li>OBRACE：{</li><li>EBRACE: }</li><li>SEMICOLON: ;</li></ul><p>example3相应的Lex文件如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[a-zA-Z][a-zA-Z0-<span class="number">9</span>]* printf(<span class="string">"WORD "</span>);</span><br><span class="line">[a-zA-Z0-<span class="number">9</span><span class="string">\/.-]+</span> printf(<span class="string">"FILENAME "</span>);</span><br><span class="line"><span class="string">\"</span> printf(<span class="string">"QUOTE "</span>);</span><br><span class="line"><span class="string">\&#123;</span> printf(<span class="string">"OBRACE "</span>);</span><br><span class="line"><span class="string">\&#125;</span> printf(<span class="string">"EBRACE "</span>);</span><br><span class="line">; printf(<span class="string">"SEMICOLON "</span>);</span><br><span class="line"><span class="string">\n</span> printf(<span class="string">"\n"</span>);</span><br><span class="line">[ <span class="string">\t]+</span> <span class="comment">/* ignore whitespace */</span>;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>当输入我们的文件到Lex生成的example3中，我们得到：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">WORD</span> OBRACE</span><br><span class="line"><span class="built_in">WORD</span> FILENAME OBRACE <span class="built_in">WORD</span> SEMICOLON EBRACE SEMICOLON</span><br><span class="line"><span class="built_in">WORD</span> <span class="built_in">WORD</span> OBRACE <span class="built_in">WORD</span> SEMICOLON EBRACE SEMICOLON</span><br><span class="line">EBRACE SEMICOLON</span><br><span class="line"><span class="built_in">WORD</span> QUOTE FILENAME QUOTE OBRACE</span><br><span class="line"><span class="built_in">WORD</span> <span class="built_in">WORD</span> SEMICOLON</span><br><span class="line"><span class="built_in">WORD</span> QUOTE FILENAME QUOTE SEMICOLON</span><br><span class="line">EBRACE SEMICOLON</span><br></pre></td></tr></table></figure><h2 id="3-6-Lex深入学习"><a href="#3-6-Lex深入学习" class="headerlink" title="3. 6 Lex深入学习"></a>3. 6 Lex深入学习</h2><p>.l文件 的结构</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="keyword">section</span>(定义段)</span><br><span class="line">%%</span><br><span class="line">Rules <span class="keyword">section</span>（规则段）</span><br><span class="line">%%</span><br><span class="line">C code <span class="keyword">section</span> （用户子程序段）</span><br></pre></td></tr></table></figure><p>下面以一个单词统计程序详细说明。</p><h3 id="1-Definition-Section-定义段"><a href="#1-Definition-Section-定义段" class="headerlink" title="1. Definition Section(定义段)"></a>1. Definition Section(定义段)</h3><p>这块可以放C语言的各种各种include，define等声明语句，但是要用%{ %}括起来。<br> 可以放预定义的正则表达式：minus “-” 还要放token的定义，方法是：代号 正则表达式。然后到了<strong>规则段</strong>就可以通过{代号} 来引用正则表达式</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">%&#123;</span></span><br><span class="line"><span class="variable">#include &lt;stdio.h&gt; // include</span></span><br><span class="line"><span class="variable">int wordCount = 0;  // 定义全局变量 单词计数器</span></span><br><span class="line"><span class="variable">%</span>&#125;</span><br><span class="line">// 预定义代号表</span><br><span class="line">chars [A-za-z<span class="symbol">\_</span><span class="symbol">\'</span><span class="symbol">\.</span><span class="symbol">\"</span>]</span><br><span class="line">numbers ([0-9])+</span><br><span class="line">delim [" "<span class="symbol">\n</span><span class="symbol">\t</span>]</span><br><span class="line">whitespace &#123;delim&#125;+  // 使用前面的代号 来 定义代号</span><br><span class="line">words &#123;chars&#125;+  // 使用前面的代号 来 定义代号</span><br><span class="line"><span class="variable">%%</span></span><br></pre></td></tr></table></figure><h3 id="2-Rules-section（规则段）"><a href="#2-Rules-section（规则段）" class="headerlink" title="2. Rules section（规则段）"></a>2. Rules section（规则段）</h3><p>在这里放置的rules就是每个正则表达式要对应的动作，一般是返回一个token<br> 这里的动作都是用{}扩起来的，用C语言来描述，这些代码可以做你任何想要做的事情</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;words&#125; &#123; wordCount++; /* wordCount 加1 */ &#125;</span><br><span class="line">&#123;whitespace&#125; &#123; /* 空白，什么也不做*/ &#125;</span><br><span class="line">&#123;numbers&#125; &#123; /* 这里可以加入如果遇到数字的处理逻辑*/ &#125;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><h3 id="3-C-code-section-（用户子程序段）"><a href="#3-C-code-section-（用户子程序段）" class="headerlink" title="3. C code section （用户子程序段）"></a>3. C code section （用户子程序段）</h3><p>Lex 编程的第三段，也就是最后一段覆盖了 C 的函数声明（有时是主函数）。注意这一段必须包括 yywrap() 函数。 Lex 有一套可供使用的函数和变量。 其中之一就是 yywrap。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* main函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    yylex(); <span class="comment">//这一函数开始分析。 它由 Lex 自动生成。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" No of words: %d\n"</span>, wordCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这一函数在文件（或输入）的末尾调用。 如果函数的返回值是1，就停止解析。</span></span><br><span class="line"><span class="comment"> 因此它可以用来解析多个文件。 代码可以写在第三段，这就能够解析多个文件。</span></span><br><span class="line"><span class="comment"> 方法是使用 yyin 文件指针指向不同的文件，直到所有的文件都被解析。 </span></span><br><span class="line"><span class="comment"> 最后，yywrap() 可以返回 1 来表示解析的结束。*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-编译运行"><a href="#4-编译运行" class="headerlink" title="4.编译运行"></a>4.编译运行</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">c:</span><span class="string">\&gt;flex</span> <span class="string">wordcount.l</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">c:</span><span class="string">\&gt;gcc</span> <span class="bullet">-o</span> <span class="string">wordcount</span> <span class="string">lex.yy.c</span></span><br><span class="line"></span><br><span class="line"><span class="attr">c:</span><span class="string">\&gt;wordcount</span></span><br><span class="line"><span class="literal">yes</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="string">but</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">--99</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">^Z</span></span><br><span class="line"> <span class="literal">No</span> <span class="string">of</span> <span class="attr">words:</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">c:</span><span class="string">\&gt;wordcount</span> <span class="string">&lt;</span> <span class="string">text.txt</span>  <span class="comment">#运行程序，将输入流重定向为要分析的文件</span></span><br><span class="line"><span class="bullet">-</span><span class="bullet">-----</span> <span class="literal">No</span> <span class="string">of</span> <span class="attr">words:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="5-常用的全局变量和宏"><a href="#5-常用的全局变量和宏" class="headerlink" title="5. 常用的全局变量和宏"></a>5. 常用的全局变量和宏</h3><p>lex.yy.c中，有很多全局变量、函数、宏。这里之处部分最常用的</p><blockquote><blockquote><p><strong>FILE *yyin:</strong><br> <strong>FILE *yyout：</strong> 这是Lex中本身已定义的输入和输出文件指针。这两个变量指明了lex生成的词法分析器从哪里获得输入和输出到哪里。默认：键盘输入，屏幕输出。</p></blockquote><blockquote><p><strong>char *yytext：</strong>指向当前识别的词法单元（词文）的指针</p></blockquote><blockquote><p><strong>int yyleng：</strong>当前词法单元的长度。</p></blockquote><blockquote><p><strong>yylineno</strong> 提供当前的行数信息。（lexer不一定支持。）</p></blockquote><blockquote><p><strong>ECHO：</strong>Lex中预定义的宏，可以出现在动作中，相当于fprintf(yyout, “%s”,yytext)，即输出当前匹配的词法单元。</p></blockquote><blockquote><p><strong>REJECT：</strong> 指示简析器对当前规则不做处理，而是采用第二匹配规则。<br> 因为解析器在通常情况下，每个被匹配的对象只会对一个动作生效。REJECT指示解析器，会寻找下一个最配的规则来做处理。下面的规则会把输入的”abcd”处理后输出”abcd|abc|ab|a|abcd”。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> a |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ab |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> abc |</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> abcd &#123;ECHO;<span class="built_in">printf</span>(<span class="string">"|"</span>);REJECT;&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> %%</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p><strong>BEGIN</strong> 开始一个条件处理块</p></blockquote><blockquote><p><strong>int yylex()：</strong>词法分析器驱动程序，用Lex翻译器生成的lex.yy.c内必然含有这个函数。它自动移动文件指针<br> yyin 和 yyout 。<br> <strong>在定义模式动作时，可以用 return 语句来结束 yylex分析函数。return 需要返回一个整数。</strong><br> 由于 yylex() 函数的运行环境都是以全局变量的方式来保存，因此在下一次调用 yylex() 时，yylex()可以从上次扫描的断点处继续扫描。若用户未定义相应的return语句，则yylex()继续分析被扫描的文件，直到碰到文件结束标识符EOF。<br> 在读取到EOF时，yylex() 函数调用 int yywrap() 函数，若yywrap()返回非0值，则yylex() 函数结束返回0；否则，yylex()继续对yyin指向的文件扫描。</p></blockquote><blockquote><p><strong>int yywrap()：</strong>词法分析器遇到文件结尾时会调用yywrap()来决定下一步怎么做：<br> 若yywrap()返回0，则继续扫描<br> 若返回1，则返回报告文件结尾的0标记。<br> 由于词法分析器总会调用yywrap，因此辅助函数中最好提供yywrap，如果不提供，则在用C编译器编译lex.yy.c时，需要链接相应的库，库中会给出标准的yywrap函数（标准函数返回1）。</p></blockquote><blockquote><p><strong>yymore()</strong>这一函数告诉 Lexer 将下一个标记附加到当前标记后。<br> `yymore()’ 告诉解析器下一次匹配的规则，满足的部分将会添加到当前yytext值得后面而不是替换它。 例如，指定的输入”mega-kludge”经过下面的程序处理后将会输出”mega-mega-kludge”。</p></blockquote><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">%</span><span class="meta">%</span></span><br><span class="line">&gt; mega- ECHO; yymore<span class="comment">()</span>;</span><br><span class="line">&gt; kludge ECHO;<span class="comment">/* 这时，yytext的值为mega-kludge */</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p><strong>yyless(int n)</strong> 返回当前匹配项除了开始的n个字符内的所有的内容到输入缓存区，解析器处理下一个匹配时，它们将会被重新解析。yyless将会导致yytext与yyleng的调整。（yyleng将会等于=n） 如输入”createtable”被下面的程序处理后，将会输出”createtableatetable”. 因为前n=3个字符foo外的字符atetable被重新返回到输入缓存区，再次解析。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">createtable ECHO; yyless(3);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> [a-zA-Z]+ ECHO;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">\n <span class="built_in">return</span> 0;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> %%</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p><strong>unput(c)</strong> 将字符c放回到输入流中，该字符可以重新被解析。下面的动作将当前的匹配值附上括号后重新进行匹配。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> int i;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">/* Copy yytext because unput() trashes yytext */</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> char *yycopy = strdup( yytext );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">unput( <span class="string">')'</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">for</span> ( i = yyleng - 1; i &gt;= 0; --i )</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> unput( yycopy[i] );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> unput( <span class="string">'('</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> free( yycopy );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p>注意: 由于每次unput()将指定的字符添加到输入源的开头，所以将字符串添加到输入源开头必须从后道前处理。一个比较重要的潜在问题是使用unput()的时候，如果采用了%pointer指针模式保存yytext,unput会破坏yytext的内容，从最右边的字符开始将会破坏左边的一个字符。如果在unput()后要用到yytext,你首先必须复制一份yytext,或者用%array模式来保存yytext. 最后不能尝试放一个EOF标志输入流的结束。</p></blockquote><blockquote><p><strong>input()</strong> 从输入源中读取下一个字符。<br> 下面例子将会吃掉C语言注释</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> %%</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"><span class="string">"/*"</span> &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  register int c;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  <span class="keyword">for</span> ( ; ; ) &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   <span class="keyword">while</span> ( (c = input()) != <span class="string">'*'</span> &amp;&amp;&gt;c != EOF ); /* eat up text of comment */</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    <span class="keyword">if</span> ( c == <span class="string">'*'</span> ) &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="keyword">while</span> ( (c = input()) == <span class="string">'*'</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">      <span class="keyword">if</span> ( c == <span class="string">'/'</span> ) <span class="built_in">break</span>; /* found the end */</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    <span class="keyword">if</span> ( c == EOF ) &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">      error( <span class="string">"EOF in comment"</span> );</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">      <span class="built_in">break</span>;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">   &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><blockquote><blockquote><p><strong>yyterminate()</strong> 可以在动作内部返回描述区域中使用，它将终止解析器并返回0给解析器调用者，表示操作完成。缺省情况下，到达文件结束位置也会被调用，它是一个宏，并且可能重定义。</p></blockquote></blockquote><h3 id="6-条件模式"><a href="#6-条件模式" class="headerlink" title="6. 条件模式"></a>6. 条件模式</h3><p>LEX提供控制模式在一定状态下使用的功能，称为条件模式。LEX首先在定义部份通过 “%start/x/s 条件名” 来定义条件句。在规则部份可通过宏 “BEGIN(条件名)” 来激活条件。”BEGIN(INITIAL)” 或 “BEGIN(0)” 将休眠所有的条件模式，使分析器回到开始状态。</p><p>下面是postgresql里面的一段LEX代码，解析SQL里面的comments</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">op_chars        [\~\!\@\<span class="comment">#\^\&amp;\|\`\?\+\-\*\/\%\&lt;\&gt;\=]</span></span><br><span class="line">... ...</span><br><span class="line"><span class="comment">/* C-style comments</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The "extended comment" syntax closely resembles allowable operator syntax.</span></span><br><span class="line"><span class="comment"> * The tricky part here is to get lex to recognize a string starting with</span></span><br><span class="line"><span class="comment"> * slash-star as a comment, when interpreting it as an operator would produce</span></span><br><span class="line"><span class="comment"> * a longer match --- remember lex will prefer a longer match!  Also, if we</span></span><br><span class="line"><span class="comment"> * have something like plus-slash-star, lex will think this is a 3-character</span></span><br><span class="line"><span class="comment"> * operator whereas we want to see it as a + operator and a comment start.</span></span><br><span class="line"><span class="comment"> * The solution is two-fold:</span></span><br><span class="line"><span class="comment"> * 1. append &#123;op_chars&#125;* to xcstart so that it matches as much text as</span></span><br><span class="line"><span class="comment"> *    &#123;operator&#125; would. Then the tie-breaker (first matching rule of same</span></span><br><span class="line"><span class="comment"> *    length) ensures xcstart wins.  We put back the extra stuff with yyless()</span></span><br><span class="line"><span class="comment"> *    in case it contains a star-slash that should terminate the comment.</span></span><br><span class="line"><span class="comment"> * 2. In the operator rule, check for slash-star within the operator, and</span></span><br><span class="line"><span class="comment"> *    if found throw it back with yyless().  This handles the plus-slash-star</span></span><br><span class="line"><span class="comment"> *    problem.</span></span><br><span class="line"><span class="comment"> * Dash-dash comments have similar interactions with the operator rule.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">xcstart         \/\*&#123;op_chars&#125;*</span><br><span class="line">xcstop          \*+\/</span><br><span class="line">xcinside        [^*/]+</span><br><span class="line">... ...</span><br><span class="line">%%</span><br><span class="line">... ...</span><br><span class="line">&#123;xcstart&#125;       &#123;</span><br><span class="line">                    <span class="comment">/* Set location in case of syntax error in comment */</span></span><br><span class="line">                    SET_YYLLOC();</span><br><span class="line">                    yyextra-&gt;xcdepth = <span class="number">0</span>;</span><br><span class="line">                    BEGIN(xc);</span><br><span class="line">                    <span class="comment">/* Put back any characters past slash-star; see above */</span></span><br><span class="line">                    yyless(<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&#123;xcstart&#125;   &#123;</span><br><span class="line">                    (yyextra-&gt;xcdepth)++;</span><br><span class="line">                    <span class="comment">/* Put back any characters past slash-star; see above */</span></span><br><span class="line">                    yyless(<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&#123;xcstop&#125;    &#123;</span><br><span class="line">                    <span class="keyword">if</span> (yyextra-&gt;xcdepth &lt;= <span class="number">0</span>)</span><br><span class="line">                        BEGIN(INITIAL);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        (yyextra-&gt;xcdepth)--;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&#123;xcinside&#125;  &#123;</span><br><span class="line">                    <span class="comment">/* ignore */</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&#123;op_chars&#125;  &#123;</span><br><span class="line">                    <span class="comment">/* ignore */</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;\*+         &#123;</span><br><span class="line">                    <span class="comment">/* ignore */</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">&lt;xc&gt;&lt;&lt;EOF&gt;&gt;     &#123; yyerror(<span class="string">"unterminated /* comment"</span>); &#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p><strong>&lt;INITIAL,STRING,QUOTE&gt;</strong> 将会在 “INITIAL”, “STRING”, “QUOTE”三者之一的条件下被激活。</p><p>开始条件在定义段被申明，在’%s’ 或 ‘%x’后跟随着名字列表。 %s申明了包含的开始条件，%x申明了排他的开始条件。开始条件被BEGIN动作激活。直到下一个BEGIN动作，满足开始条件名称的规则将会被规则，不满足启动条件的规则将不会被执行。<br> <strong>如果是包含条件，没有开始条件的规则也会被激活执行，如果时排他条件，只有满足开始条件的规则才会被执行。</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">%s</span> example</span><br><span class="line">%%</span><br><span class="line">&lt;example&gt;foo   do_something()<span class="comment">;</span></span><br><span class="line">bar            something_else()<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">x</span></span> example</span><br><span class="line"><span class="tag">%</span>%</span><br><span class="line">&lt;example&gt;foo   do_something();</span><br><span class="line">&lt;INITIAL,example&gt;bar    something_else();</span><br></pre></td></tr></table></figure><p>上面的程序中如果没有&lt;INITIAL,example&gt;，在example条件下bar规则将永远不会被激活。如果使用<example>，将会导致只能在exmaple开始条件下激活，而INITIAL条件下不会被激活。而第一个程序中在任何条件下bar都被会激活。因为第一个程序用example时%s，时包含条件。<strong><em>也可以通过特殊开始条件&lt;\</em>&gt;来配置任何开始条件，上面的程序还可以写为：*</strong></example></p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">x</span></span> example</span><br><span class="line"><span class="tag">%</span>%</span><br><span class="line">&lt;example&gt;foo   do_something();</span><br><span class="line">&lt;*&gt;bar    something_else();</span><br></pre></td></tr></table></figure><p><strong>YY_START</strong> 开始条件的名字实际上时一个整形值并且能够被保存，可以使用 <strong>YY_START</strong> 宏来访问当前的开始条件。<strong>YYSTATE</strong> 是 YY_START 的别名（AT&amp;T lex使用了YYSTATE）。</p><p>下面的代码能够是被C语言注释并且统计行数。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">%x <span class="built_in">comment</span> foo</span><br><span class="line">%%</span><br><span class="line">        int line_num = <span class="number">1</span>;</span><br><span class="line">        int comment_caller;</span><br><span class="line"></span><br><span class="line"><span class="string">"/*"</span>         &#123;</span><br><span class="line">             comment_caller = INITIAL;</span><br><span class="line">             BEGIN(<span class="built_in">comment</span>);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&lt;foo&gt;<span class="string">"/*"</span>    &#123;</span><br><span class="line">             comment_caller = foo; <span class="comment">/* comment_caller = foo ==》comment_caller = YY_START */</span></span><br><span class="line">             BEGIN(<span class="built_in">comment</span>);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="built_in">comment</span>&gt;[^*\n]*        <span class="comment">/* eat anything that's not a '*' */</span></span><br><span class="line">&lt;<span class="built_in">comment</span>&gt;<span class="string">"*"</span>+[^*/]*   <span class="comment">/* eat up '*'s not followed by '/'s */</span></span><br><span class="line">&lt;<span class="built_in">comment</span>&gt;\n             ++line_num;</span><br><span class="line">&lt;<span class="built_in">comment</span>&gt;<span class="string">"*"</span>+<span class="string">"/"</span>        BEGIN(comment_caller);</span><br></pre></td></tr></table></figure><h4 id="开始条件范围"><a href="#开始条件范围" class="headerlink" title="开始条件范围"></a>开始条件范围</h4><p>前面条件模式的代码中，会有许多相同开始条件的处理。使用开始条件范围可以简化重复操作。</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">SCs</span>&gt;</span></span><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>SCs 是一个或开始条件的列表。在这个开始条件范围内，每个规则将会自动具有前缀 ‘<scs>‘ 直到 ‘}’ 与开始的 ‘{‘ 匹配. 例如</scs></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;comment&gt;  &#123;</span><br><span class="line">  [^*]*        <span class="comment">/* eat anything that's not a '*' */</span></span><br><span class="line">  <span class="string">"*"</span>+[^*<span class="regexp">/]*   /</span>* eat up <span class="string">'*'</span>s <span class="keyword">not</span> followed <span class="keyword">by</span> <span class="string">'/'</span>s */</span><br><span class="line">  <span class="string">\n</span>             ++line_num;</span><br><span class="line">  <span class="string">"*"</span>+<span class="string">"/"</span>        BEGIN(comment_caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;comment&gt;[^*]*        <span class="comment">/* eat anything that's not a '*' */</span></span><br><span class="line">&lt;comment&gt;<span class="string">"*"</span>+[^*<span class="regexp">/]*   /</span>* eat up <span class="string">'*'</span>s <span class="keyword">not</span> followed <span class="keyword">by</span> <span class="string">'/'</span>s */</span><br><span class="line">&lt;comment&gt;<span class="string">\n</span>             ++line_num;</span><br><span class="line">&lt;comment&gt;<span class="string">"*"</span>+<span class="string">"/"</span>        BEGIN(comment_caller);</span><br></pre></td></tr></table></figure><h4 id="条件嵌套"><a href="#条件嵌套" class="headerlink" title="条件嵌套"></a>条件嵌套</h4><p>开始条件也可以嵌套，下面时三个管理开始条件堆栈的参数。</p><blockquote><p><strong>void yy_push_state(int new_state)</strong> 将当前的开始条件压栈，切换到 new_state 与使用 ‘BEGIN new_state’类似。<br> <strong>void yy_pop_state()</strong> 从栈顶弹出，类似于 BEGIN.<br> <strong>int yy_top_state()</strong> 返回栈顶值，不改变栈内容。</p></blockquote><p>开始条件栈动态增长，没有固定限制，如果内存用尽，程序自会终止。</p><h3 id="7-多输入缓存区"><a href="#7-多输入缓存区" class="headerlink" title="7. 多输入缓存区"></a>7. 多输入缓存区</h3><p>YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )<br> void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )<br> void yy_delete_buffer( YY_BUFFER_STATE buffer )<br> void yy_flush_buffer( YY_BUFFER_STATE buffer )</p><h1 id="四、YACC"><a href="#四、YACC" class="headerlink" title="四、YACC"></a>四、YACC</h1><p>yacc是开发编译器的一个有用的工具,采用LR（1）（实际上是LALR(1)）语法分析方法。<br> LR(k)分析方法，括号中的k（k &gt;=0）表示向右查看输入串符号的个数。LR分析法正视给出一种能根据当前分析栈中的符号串和向右顺序查看输入串的k个符号就可唯一确定分析器的动作是移进还是规约和用哪个产生式规约。<br> 这种方法具有分析速度快，能准确，即使地指出出错的位置，它的主要缺点是对于一个使用语言文法的分析器的构造工作量相当大，k愈大构造愈复杂，实现比较困难。</p><p>一个LR分析器有3个部分组成：</p><ul><li><strong>总控程序，也可以称为驱动程序。</strong><br> 对所有的LR分析器总控程序都是相同的。</li><li><strong>分析表或分析函数。</strong><br> 不同的文法分析表将不同，同一个文法采用的LR分析器不同时，分析表也不同，分析表又可分为动作(ACTION)表和状态转换(GOTO)表两个部分，它们都可用二维数组表示。</li><li><strong>分析栈，包括文法符号栈和相应的状态栈。</strong><br> 它们均是先进后出栈。 分析器的动作由栈顶状态和当前输入符号所决定(LR(0)分析器不需要向前查看输入符号)。<br> LR分析器工作过程如下 :<br> 其中SP为栈指针，S[i]为状态栈，X[i]为文法符号栈。状态转换表内容按关系GOTO[Si，X] = Sj确定，该关系式是指当栈顶状态为Si遇到当前文法符号为X时应转向状态Sj。X为终结符或非终结符。 ACTION[Si，a]规定了栈顶状态为Si是遇到输入符号a应执行的动作。</li></ul><p>YACC可以解析输入流中的标识符(token)，这就清楚的描述了YACC和LEX的关系，YACC并不知道『输入流』为何物，它需要事先就将输入流预加工成标识符，虽然你可以自己手工写一个Tokenizer，但我们将这些工作留给LEX来做。</p><p>YACC用来为编译器解析输入数据，即程序代码。这些用编程语言写成的程序代码一点也不模棱两可——它们只有一个意思。正因为如此，YACC才不会去对付那些有歧义的语法，并且会抱怨shift/reduce或者reduce/reduce冲突。更多的关于模糊性和YACC『问题』可以在『冲突』一章中找到。</p><h2 id="4-1-yacc语法结构"><a href="#4-1-yacc语法结构" class="headerlink" title="4.1 yacc语法结构"></a>4.1 yacc语法结构</h2><p>yacc语法包括三部分：定义段、规则段和用户子例程段</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">..</span>.定义段<span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="built_in">..</span>.规则段<span class="built_in">..</span>.</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line"><span class="built_in">..</span>.用户子例程段<span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>各部分由以两个百分号开头的行分开，尽管某一个部分可以为空，但是前两部分是必须的，第三部分和前面的百分号可以省略。</p><h3 id="1-符号"><a href="#1-符号" class="headerlink" title="1. 符号"></a>1. 符号</h3><p>yacc 语法由符号组成，即语法的“词”。符号是一串不以数字开头的字母、数字、句点和下划线。符号error专用于错误恢复，另外，yacc对任何符号都不会附加“先验”的意义。</p><p>由词法分析程序产生的符号叫做终结符号或者标记。定义在规则左侧的叫做非终结符号或者非终结。标记也可能是字面上引用的字符，<strong>通常遵循约定：标记大写，非终结符号小写</strong>。</p><h3 id="2-定义段"><a href="#2-定义段" class="headerlink" title="2. 定义段"></a>2. 定义段</h3><p>定义段包括文字块，逐字拷贝到生成的C文件开头部分的C代码，通常包括声明和#include行。可能有%union  %start   %token   %type   %left  %right  和 %nonassoc声明。</p><p>也可以包含普通的C语言风格的注释，所有这些都是可选的，在简单的语法分析程序中，定义段可能完全是空的。</p><p>如在定义部分定义标志：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">token</span></span> INTEGER</span><br></pre></td></tr></table></figure><p>当运行yacc后，会产生头文件，里面包含该标志的预定义，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> YYSTYPE </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYSTYPE int </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTEGER 258 </span></span><br><span class="line"><span class="keyword">extern</span> YYSTYPE yylval;</span><br></pre></td></tr></table></figure><p>lex使用该头文件中的标志定义。Yacc调用lex的yylex()来获得标志（token），与标志对应的值由lex放在变量yylval中。yylval的类型由YYSTYPE决定，YYSTYPE缺省类型是int。如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">0-9</span>]+ &#123; </span><br><span class="line">yylval = atoi(yytext); </span><br><span class="line"><span class="keyword">return</span> INTEGER; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标志0-255被保留作为字符值，一般产生的token标志从258开始。如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">-+</span>] <span class="keyword">return</span> *yytext; <span class="comment">/* return operator */</span></span><br></pre></td></tr></table></figure><p>返回加号或减号。注意要把减号放在前面，避免被认作是范围符号。<br> 对于操作符，可以定义%left和%right：%left表示左相关（left-associative），%right表示右相关（right-associative）。<strong>可以定义多组%left或%right，在后面定义的组有更高的优先级</strong>。如：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">left</span></span> ‘+’ ‘-‘</span><br><span class="line"><span class="tag">%<span class="selector-tag">left</span></span> ‘*’ ‘/’</span><br></pre></td></tr></table></figure><p>上面定义的乘法和除法比加法和减法有更高的优先级。<br> 改变YYSTYPE的类型。如这样定义TTSTYPE：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%<span class="class"><span class="keyword">union</span></span></span><br><span class="line">&#123; </span><br><span class="line">     int iValue; <span class="regexp">/* integer value */</span> </span><br><span class="line">     char sIndex; <span class="regexp">/* symbol table index */</span> </span><br><span class="line">     nodeType *nPtr; <span class="regexp">/* node pointer */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>则生成的头文件中的内容是：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">union</span></span></span><br><span class="line">&#123; </span><br><span class="line">     int iValue;      <span class="regexp">/* integer value */</span> </span><br><span class="line">     char sIndex;    <span class="regexp">/* symbol table index */</span> </span><br><span class="line">     nodeType *nPtr; <span class="regexp">/* node pointer */</span> </span><br><span class="line">&#125; YYSTYPE; </span><br><span class="line">extern YYSTYPE yylval;</span><br></pre></td></tr></table></figure><p>可以把标志（token）绑定到YYSTYPE的某个域。如：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">token</span></span> &lt;iValue&gt; INTEGER </span><br><span class="line"><span class="tag">%<span class="selector-tag">type</span></span> &lt;nPtr&gt; expr</span><br></pre></td></tr></table></figure><p>把expr绑定到nPtr，把INTEGER绑定到iValue。yacc处理时会做转换。如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr: <span class="keyword">INTEGER</span> &#123; <span class="symbol">$</span><span class="symbol">$</span> = con(<span class="symbol">$</span><span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><p>转换结果为：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yylval.nPtr</span> = con(yyvsp[<span class="number">0</span>].iValue);</span><br></pre></td></tr></table></figure><p>其中yyvsp[0]是值栈（value stack）当前的头部。</p><p>定义一元减号符有更高的优先级的方法：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%left <span class="keyword">GE</span> <span class="keyword">LE</span> <span class="keyword">EQ</span> <span class="keyword">NE</span> <span class="string">'&gt;'</span> <span class="string">'&lt;'</span> </span><br><span class="line">%left <span class="string">'+'</span> <span class="string">'-'</span> </span><br><span class="line">%left <span class="string">'*'</span> </span><br><span class="line">%nonassoc UMINUS</span><br></pre></td></tr></table></figure><p>%nonassoc的含义是没有结合性。它一般与%prec结合使用表示该操作有同样的优先级。如：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr: '-' expr %prec UMINUS &#123; $$ = <span class="keyword">node</span><span class="title">(UMINUS</span>, <span class="number">1</span>, $<span class="number">2</span>); &#125;</span><br></pre></td></tr></table></figure><p>表示该操作的优先级与UMINUS相同，在上面的定义中，UMINUS的优先级高于其他操作符，所以该操作的优先级也高于其他操作符计算。</p><h3 id="3-规则段"><a href="#3-规则段" class="headerlink" title="3. 规则段"></a>3. 规则段</h3><p>规则段由语法规则和包括C代码的动作组成。</p><p>规则中目标或非终端符放在左边，后跟一个冒号（：），然后是产生式的右边，之后是对应的动作（用{}包含）。如：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">%token <span class="keyword">INTEGER</span></span><br><span class="line">%%</span><br><span class="line">program: program expr <span class="string">'\n'</span> &#123; printf(<span class="string">"%d\n"</span>, <span class="symbol">$</span><span class="number">2</span>); &#125; </span><br><span class="line">              ;</span><br><span class="line">expr: <span class="keyword">INTEGER</span> &#123; <span class="symbol">$</span><span class="symbol">$</span> = <span class="symbol">$</span><span class="number">1</span>; &#125;  </span><br><span class="line">         | expr <span class="string">'+'</span> expr &#123; <span class="symbol">$</span><span class="symbol">$</span> = <span class="symbol">$</span><span class="number">1</span> + <span class="symbol">$</span><span class="number">3</span>; &#125; </span><br><span class="line">         | expr <span class="string">'-'</span> expr &#123; <span class="symbol">$</span><span class="symbol">$</span> = <span class="symbol">$</span><span class="number">1</span> - <span class="symbol">$</span><span class="number">3</span>; &#125; </span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">int yyerror(char *s) </span><br><span class="line">&#123; </span><br><span class="line">     fprintf(stderr, <span class="string">"%s\n"</span>, s); </span><br><span class="line">     return <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，1表示右边的第一个标记的值，2表示右边的第二个标记的值，依次类推。$$表示归约后的值。</p><h3 id="4-用户子例程段"><a href="#4-用户子例程段" class="headerlink" title="4. 用户子例程段"></a>4. 用户子例程段</h3><p>yacc 将用户子例程段的内容完全拷贝到C文件中，通常这部分包括从动作调用的例程。<br> 该部分是函数部分。当yacc解析出错时，会调用函数yyerror()，用户可自定义函数的实现。<br> main函数是调用yacc解析入口函数yyparse()。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">     yyparse(); </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-动作"><a href="#5-动作" class="headerlink" title="5. 动作"></a>5. 动作</h3><p>动作 是yacc与在语法中规则相符时执行的C代码，动作一定是C复合语句。</p><p>动作有4种可能：</p><ul><li>移进：<br> 当Sj = GOTO[Si，a]成立，则把Sj移入到状态栈，把a移入到文法符号栈。其中i，j表示状态号。</li><li>规约：<br> 当在栈顶形成句柄为β时，则用β归约为相应的非终结符A，即当文法中有 A–&gt;β的产生式，而β的长度为r（即|β| = r）,则从状态栈和文法符号栈中自栈顶向下去掉r个符号，即栈指针SP减去r。并把A移入文法符号栈内，再把满足Sj = GOTO[Si，A]的状态移进状态栈，其中Si为修改指针后的栈顶状态。</li><li>接受acc:<br> 当规约到文法符号栈只剩文法的开始符号S时，并且输入符号串已结束即当前输入符是‘#’，则为分析成功。</li><li>报错：<br> 当遇到状态栈顶为某一状态下出现不该遇到的文法符号时，则报错，说明输入串不是该文法能接受的句子。</li></ul><p>通过使用后面跟有数字的美元符号，动作可以查阅在规则中与符号有关的值,冒号后面跟的第一个符号是数字1，例如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date：month  <span class="string">'/'</span>  day   <span class="string">'/'</span>  year  </span><br><span class="line">           &#123; <span class="keyword">printf</span> (<span class="string">"date %d-%d-%d  found"</span>,$1,$3,$5);&#125;</span><br></pre></td></tr></table></figure><p><strong>而名字，$$是指冒号左边符号的值，符号值可以有不同的C类型。</strong></p><h2 id="4-2-递归处理"><a href="#4-2-递归处理" class="headerlink" title="4.2 递归处理"></a>4.2 递归处理</h2><p>递归处理有左递归和右递归。<br> 左递归形式：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>: <span class="built_in">item</span> </span><br><span class="line">    | <span class="built_in">list</span> ',' <span class="built_in">item</span>;</span><br></pre></td></tr></table></figure><p>右递归形式：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>: <span class="built_in">item</span> </span><br><span class="line">     | <span class="built_in">item</span> ',' <span class="built_in">list</span></span><br></pre></td></tr></table></figure><p>使用右递归时，所有的项都压入堆栈里，才开始规约；而使用左递归的话，同一时刻不会有超过三个项在堆栈里。</p><h3 id="1-歧义和冲突"><a href="#1-歧义和冲突" class="headerlink" title="1. 歧义和冲突"></a>1. 歧义和冲突</h3><p>由于语法有歧义或者包含冲突，yacc对于语法规范的翻译可能会失败。一些情况下，语法确实有歧义，也就是说对于一个单独的输入字符串有两种可能的分析而且yacc处理不了。</p><p>另外一些情况，语法并无歧义，但yacc使用的语法分析技术不足以分析这个语法。</p><ul><li><strong>移进/归约冲突</strong><br> 当一个输入字符串有两种可能的分析时，而且其中一个分析完成一个规则（归约选项），而另一个却没有（移进选项）时，移进/归约冲突便发生了。<br> 例如：</li></ul><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="meta">%</span>  </span><br><span class="line">e: ‘X’  </span><br><span class="line">     |e  <span class="string">'+'</span>   e  </span><br><span class="line">         ;</span><br></pre></td></tr></table></figure><p>对于输入字符串“X+X+X” ，有两种可能的分析： “（X+X）+X”或者“X+(X+X)”，采用归约选项使得语法分析程序使用第一个分析，而采用移进选项则使用另一个。</p><ul><li><strong>归约/归约冲突</strong><br> 当同样的标记可以完成两个不同的规则时，就会发生归约/归约冲突。<br> 例如：</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%%  </span><br><span class="line"><span class="symbol">prog:</span>    proga | progb  </span><br><span class="line"><span class="symbol">proga:</span>       <span class="string">'X'</span> <span class="comment">;  </span></span><br><span class="line"><span class="symbol">progb:</span>       <span class="string">'Y'</span> <span class="comment">;</span></span><br></pre></td></tr></table></figure><p>一个“X”可能是proga，也可能是progb。</p><p>大多数归约/归约冲突没这么明显，但是几乎在任何情况下它们在语法中都表现为错误。</p><ul><li><strong>If-Else 的冲突</strong><br> 当有两个IF一个ELSE时，该ELSE和哪个IF匹配是一个问题。有两种匹配方法：与第一个匹配和与第二匹配。<strong>现代程序语言都让ELSE与最近的IF匹配，这也是yacc的缺省行为。</strong><br> 虽然yacc行为正确，但为避免警告，可以给IF-ELSE语句比IF语句更高的优先级：</li></ul><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">%nonassoc</span> IFX </span><br><span class="line"><span class="built_in">%nonassoc</span> <span class="keyword">ELSE</span></span><br><span class="line">stmt: <span class="keyword">IF</span> expr stmt <span class="built_in">%prec</span> IFX </span><br><span class="line">       | <span class="keyword">IF</span> expr stmt <span class="keyword">ELSE</span> stmt</span><br></pre></td></tr></table></figure><h2 id="4-3-特殊字符"><a href="#4-3-特殊字符" class="headerlink" title="4.3 特殊字符"></a>4.3 特殊字符</h2><p>由于yacc处理符号标记而不是文本，它的输入字符集比起lex来说就简单的多，下面列出了yacc所使用的特殊符号的列表：</p><blockquote><p><strong>%</strong><br> 具有两个%标记的行将yacc语法分成了几部分；<br> 定义段的所有声明都是以%开始，包括%{ %}    %union  %start   %token   %type   %left  %right  和 %nonassoc声明。</p><p><strong>\</strong><br> 反斜线符号是废弃的百分号同义词，在动作中，C语言字符串中有其通常作用。</p><p><strong>$</strong><br> 在动作中，美元符号引入一个值引用，举例来说，$3表示规则右端第3个符号的值。</p><p><strong>‘</strong><br> 文字标记由一个单引号结束，例如 ‘z’ 。</p><p><strong>&lt;&gt;</strong><br> 在一个动作的值引用中，可以不考虑尖括号包围起来的默认类型。</p><p><strong>“</strong><br> 有些yacc版本在文字标记中将单引号和双引号同等对待，这样使用根本不方便。</p><p><strong>{}</strong><br> 动作中C代码在大括号中。</p><p><strong>;</strong><br> 除了后面紧接着是以竖线开头的规则外，规则部分每个都是以分号结束。</p><p><strong>|</strong><br> 当连续两个规则具有相同的左端，第二个规则可用一个 | 代替符号和冒号。</p><p><strong>:</strong><br> 在每一条规则里，左端的每个符号后面都跟着一个冒号。</p><p><strong>_</strong><br> 符号可以包括和字母、数字以及句点在一起的下划线。</p><p><strong>.</strong><br> 符号可以包括与字母、数字、下划线一起的句点。</p><p><strong>=</strong><br> 早期版本使用，现已不推荐。</p></blockquote><h2 id="4-3-Yacc-源程序的风格"><a href="#4-3-Yacc-源程序的风格" class="headerlink" title="4.3 Yacc 源程序的风格"></a>4.3 Yacc 源程序的风格</h2><p>建议按照如下风格来写：</p><ol><li>终端符名全部用大写字母，非终端符全部用小写字母；</li><li>把语法规则和语义动作放在不同的行；</li><li>把左部相同的规则写在一起，左部只写一次，而后面所有规则都写在竖线“|”之后；</li><li>把分号“；”放在规则最后，独占一行；</li><li>用制表符来对齐规则和动作。</li></ol><h2 id="4-4-一个简单的温度控制器"><a href="#4-4-一个简单的温度控制器" class="headerlink" title="4.4 一个简单的温度控制器"></a>4.4 一个简单的温度控制器</h2><p>假定我们有一个温度计，我们要用一种简单的语言来控制它。关于此的一个会话、如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">heat <span class="keyword">on</span></span><br><span class="line">Heater <span class="keyword">on</span>!</span><br><span class="line">heat <span class="keyword">off</span></span><br><span class="line">Header <span class="keyword">off</span>!</span><br><span class="line"><span class="keyword">target</span> temperature <span class="keyword">set</span>!</span><br></pre></td></tr></table></figure><p>我们需要识别的标识符为heat, on/off(STATE), target, temperature, NUMBER。</p><p>LEX的tokenizer(example4)为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"y.tab.h"</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+ <span class="keyword">return</span> NUMBER;</span><br><span class="line">heat <span class="keyword">return</span> TOKHEAT;</span><br><span class="line">on|off <span class="keyword">return</span> STATE;</span><br><span class="line">target <span class="keyword">return</span> TOKTARGET;</span><br><span class="line">temperature <span class="keyword">return</span> TOKTEMPERATURE;</span><br><span class="line">\n <span class="comment">/* ignore end of line */</span>;</span><br><span class="line">[ \t]+ <span class="comment">/* ignore whitespace */</span></span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>有两个重点需要注意：<br>第一，我们包含了『y.tab.h』；<br>第二，我们不再打印输出了，我们返回标识符的名字。之所这样做是因为我们将这些返回传送给了YACC，而它对于我们屏幕上的输出并不感冒。 『y.tab.h』中定义了这些标识符。</p><p>但是y.tab.h从哪里来？它由YACC从我们编写的语法文件中生成，语法文件非常简单，如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">commands:</span> <span class="comment">/* empty */</span></span><br><span class="line">| commands command</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="symbol">command:</span> heat_switch | target_set ;</span><br><span class="line"></span><br><span class="line"><span class="symbol">heat_switch:</span></span><br><span class="line">TOKHEAT STATE</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"\tHeat turned on or off\n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="symbol">target_set:</span></span><br><span class="line">TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"\tTemperature set\n"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一部分，我们称之为根(root)。它告诉我们有一个『commands』，并且这些『commands』由单个的『command』组成。正如你所见到的那样，这是一个标准的递归结构，因为它又再次包含了『commands』。这意味着该程序可以一个个的递减一系列的命令。参见『LEX和YACC内部工作原理』一章，阅读更多的递归细节。</p><p>第二个规则定义了『command』的内容。我们只假定两种命令。</p><p>一个heat_switch由HEAT标识符组成，它后面跟着一个状态，该状态在LEX中定义，为『on』或『off』。</p><p>target_set稍微有点复杂，它由TARGET标识符、TEMPERATURE以及一个数字组成。</p><p>前面的那个例子只有YACC文件的语法部分，起始在YACC文件中还有其它内容，完整的YACC文件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在lex.yy.c里定义，会被yyparse()调用。在此声明消除编译和链接错误。</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">yylex</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此声明，消除yacc生成代码时的告警</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">yyparse</span><span class="params">(<span class="keyword">void</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该函数在y.tab.c里会被调用，需要在此定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yyerror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[error] %s\n"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">yyparse();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token NUMBER TOKHEAT STATE TOKTARGET TOKTEMPERATURE</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">commands: <span class="comment">/* empty */</span></span><br><span class="line">| commands command</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">command: heat_switch | target_set ;</span><br><span class="line"></span><br><span class="line">heat_switch:</span><br><span class="line">TOKHEAT STATE</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tHeat turned on or off\n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">target_set:</span><br><span class="line">TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\tTemperature set\n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>函数yyerror()在YACC发现一个错误的时候被调用，我们只是简单的输出错误信息，但其实还可以做一些更漂亮的事情，参见文档尾的『进阶阅读』部分。</p><p>yywrap()函数用于不断的从一个文件中读取数据，当遇到EOF时，你可以再输入一个文件，然后返回0，你也可以使得其返回1，暗示着输入结束。更多细节，参见『YACC和LEX内部如何工作的？』一章。</p><p>接着，这里有一个main()函数，它基本什么也不做，只是调用一些函数。</p><p>最后一行简单的定义了我将使用的标识符，如果调用YACC时，使用『-d』选项，那么它们会输出到y.tab.h中。</p><p>编译并运行恒温控制器：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lex example4.l</span><br><span class="line">yacc –d example4.y</span><br><span class="line">cc lex<span class="selector-class">.yy</span><span class="selector-class">.c</span> y<span class="selector-class">.tab</span><span class="selector-class">.c</span> –o example4</span><br></pre></td></tr></table></figure><p>在此，情况有所改变，我们现在调用YACC来编译我们的程序，它创建了y.tab.c和y.tab.h. 我接着再调用LEX。 编译时，我们去除了『-ll』编译选项，因为此时我们有了自己的main()函数，并不需要libl来提供。</p><p>注意：如果在编译过程中报错说找不到『yylval』，那么在example4.l的#include &lt;y.tab.h&gt;下面加上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> YYSTYPE yylval；</span><br></pre></td></tr></table></figure><p>具体细节在『LEX和YACC内部工作原理』中解说。</p><p>一个简单的会话：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ./example4</span><br><span class="line">heat <span class="keyword">on</span></span><br><span class="line">Heat turned <span class="keyword">on</span> <span class="keyword">or</span> off</span><br><span class="line">heat off</span><br><span class="line">Heat turned <span class="keyword">on</span> <span class="keyword">or</span> off</span><br><span class="line">target temperature <span class="number">10</span></span><br><span class="line">Temperature <span class="keyword">set</span></span><br><span class="line">target humidity <span class="number">20</span></span><br><span class="line"><span class="keyword">error</span>: parse <span class="keyword">error</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="4-5-扩展恒温器，使得其可以接受参数"><a href="#4-5-扩展恒温器，使得其可以接受参数" class="headerlink" title="4.5 扩展恒温器，使得其可以接受参数"></a>4.5 扩展恒温器，使得其可以接受参数</h2><p>我们已经可以正确的解析温度计命令了，并且能对一些错误做标记。但也许一些狡猾的人会猜疑说，该解析器并不知道你应该做什么，也没有处理一些你输入的数值。</p><p>让我们来添加能读取新的温度参数的功能。为达到此目的，我们得知道LEX中的NUMBER匹配要转化成一个数值，然后才能为YACC所接收.</p><p>每当LEX匹配到了一个目标字串，它就将该匹配文本赋值给『yytext』，YACC则依次在『yylval』中来查找一个值，在example5中，我们可以得到一个明晰的方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"y.tab.h"</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+ yylval = atoi(yytext); <span class="keyword">return</span> NUMBER;</span><br><span class="line">heat <span class="keyword">return</span> TOKHEAT;</span><br><span class="line">on|off yylval = !<span class="built_in">strcmp</span>(yytext, <span class="string">"on"</span>); <span class="keyword">return</span> STATE;</span><br><span class="line">target <span class="keyword">return</span> TOKTARGET;</span><br><span class="line">temperature <span class="keyword">return</span> TOKTEMPERATURE;</span><br><span class="line">\n <span class="comment">/* ignore end of line */</span></span><br><span class="line">[ \t]+ <span class="comment">/* ignore whitespace */</span></span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>如你所见，我们在yytext中用了atoi()，并将结果存储在yylval中，使得YACC可以『看见』它。 同理，我们再处理STATE匹配，将其与『on』比较，若想等，则将yylval设置为1。</p><p>接下来，我们就得考察YACC如何来应对。我们来看看新的temperature target规则设置：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_set:</span><br><span class="line">TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"\tTemperature set to %d\n"</span>, $3);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为得到规则中第三部分的值(NUMBER)，我们用『$3』来表示，每次yylex()返回时，yylval的值便依附到了终结符上，其值可以通过『$-常数』来获取。</p><p>为更进一步加深理解，我们来看『heat_switch』规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">heat_switch:</span><br><span class="line">TOKHEAT STATE</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$2</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tHeat turned on\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\tHeat turned off\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果现在运行example5，它将输出你所输入的数据。</p><h2 id="4-6-解析一个配置文件"><a href="#4-6-解析一个配置文件" class="headerlink" title="4.6 解析一个配置文件"></a>4.6 解析一个配置文件</h2><p>让我们再次回顾先前提到的那个配置文件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zone <span class="string">"./www"</span> &#123;</span><br><span class="line"><span class="built_in">type </span>hint;</span><br><span class="line">name foo;</span><br><span class="line">hello <span class="string">"/hello/world"</span>;</span><br><span class="line">file <span class="string">"/etc/bind/db.root"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之前我们已经将LEX文件写好了，接下来只需要编写YACC语法文件，并且对词法分析器做一些修改，使得其可以返回一些值给YACC。<br>example6中的词法分析器如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="section">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="section">#define YYSTYPE char *</span></span><br><span class="line">extern YYSTYPE yylval; // 必须放在#include "y.tab.h"前面</span><br><span class="line"><span class="section">#include "y.tab.h"</span></span><br><span class="line">%&#125;</span><br><span class="line">%%</span><br><span class="line">zone return ZONETOK;</span><br><span class="line">file return FILETOK;</span><br><span class="line">[<span class="string">a-zA-Z</span>][<span class="symbol">a-zA-Z0-9</span>]* yylval = strdup(yytext); return WORD;</span><br><span class="line">[a-zA-Z0-9\/.-]+ yylval = strdup(yytext); return FILENAME;</span><br><span class="line">\" return QUOTE;</span><br><span class="line">\&#123; return OBRACE;</span><br><span class="line">\&#125; return EBRACE;</span><br><span class="line">; return SEMICOLON;</span><br><span class="line">[ \t]+ /<span class="bullet">* ignore whitespace *</span>/;</span><br><span class="line">\n /<span class="bullet">* ignore EOL *</span>/;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>细心的话，你会发现yylval已经改变了！我们不再认为它是一个整数，而是假定为一个char*类型数据。为保持简单性，我们调用strdup并因此耗费了很多内存。但这并不影响你解析这个文件。</p><p>我们需要保存字符串的值，在此我们处理的都是一些命名，文件名以及区域命。在下一章，我们将解说如何对付一些复杂类型的数据。</p><p>为通知YACC关于yylval的新类型，我们在YACC的语法文件中添加一行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYSTYPE char *</span></span><br></pre></td></tr></table></figure><p>下面是完整的YACC文件，语法比较复杂，建议结合代码画AST树来帮助理解（原文这里的代码有不少问题，下面是修正后的代码，对语法也简化了一点点）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYSTYPE char *</span></span><br><span class="line"><span class="keyword">extern</span> YYSTYPE yylval;</span><br><span class="line"><span class="comment">//int yydebug = 1; // debug</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">yylex</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">yyparse</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yyerror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[error] %s\n"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">yyparse();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%token SEMICOLON ZONETOK OBRACE EBRACE QUOTE FILENAME WORD FILETOK</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">commands:</span><br><span class="line">| commands command SEMICOLON</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">command:</span><br><span class="line">zone_set</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">zone_set:</span><br><span class="line">ZONETOK quotedname zonecontent</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Complete zone for '%s' found\n"</span>, $<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zonecontent:</span><br><span class="line">OBRACE zonestatements EBRACE</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">quotedname:</span><br><span class="line">QUOTE FILENAME QUOTE</span><br><span class="line">&#123;</span><br><span class="line">$$ = $<span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">zonestatements:</span><br><span class="line">| zonestatements zonestatement SEMICOLON</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">zonestatement:</span><br><span class="line">statements | FILETOK quotedname</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"A zonefile name '%s' was encountered\n"</span>, $<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">statements:</span><br><span class="line">| WORD statement</span><br><span class="line">&#123;</span><br><span class="line">$$ = $<span class="number">2</span>; <span class="comment">// seems unnecessary</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"statements, key: %s, value: %s\n"</span>, $<span class="number">1</span>, $<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">statement:</span><br><span class="line">WORD | quotedname</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>我们执行example6的输出文件：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将配置文件的内容保存到<span class="keyword">sample</span>.<span class="keyword">conf</span>文件中，方便测试</span><br><span class="line">$ <span class="keyword">cat</span> <span class="keyword">sample</span>.<span class="keyword">conf</span> | ./example6</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   statements, <span class="string">key:</span> type, <span class="string">value:</span> hint</span><br><span class="line">statements, <span class="string">key:</span> name, <span class="string">value:</span> foo</span><br><span class="line">statements, <span class="string">key:</span> hello, <span class="string">value:</span> <span class="regexp">/hello/</span>world</span><br><span class="line"> A zonefile name <span class="string">'/etc/bind/db.root'</span> was encountered</span><br><span class="line">Complete zone <span class="keyword">for</span> <span class="string">'./www'</span> found</span><br></pre></td></tr></table></figure><h1 id="五、生成C-代码的解析器"><a href="#五、生成C-代码的解析器" class="headerlink" title="五、生成C++代码的解析器"></a>五、生成C++代码的解析器</h1><p>虽然LEX和YACC的历史要早于C++，但是还是可以用它们来生成一个C++解析器。但我们用LEX来生成C++的词法分析器，YACC并不知道如何直接来处理这些，所以我们不打算这么做。</p><p>我认为比较好的做法是，要做一个C++解析器，就需要LEX生成一个C文件，并且让YACC来生成C++代码。但当你这么做的时候，在这个过程中你将会遇到问题，因为C++代码默认情况下并不能找到C的函数，除非你将那些函数定义为extern “C”。</p><p>为达此目的，我们在YACC代码中编写一个C开头：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> “C”</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">yyparse</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">yylex</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">yywrap</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想声明并改变yydebug函数，你得这样做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> yydebug;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    yydebug = <span class="number">1</span>;</span><br><span class="line">    yyparse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是因为C++中的一个关于定义的规则，即不允许yydebug的多处定义。</p><p>你还可能发现，你需要在你的LEX文件中重复#define YYSTYPE，这是由于C++中严格的类型检查(机制)造成的。</p><p>按照如下方式来编译：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Makefile</span><br><span class="line">example_cpp:</span><br><span class="line">lex -o $<span class="title">@.yy.c</span> $<span class="title">@.lex</span></span><br><span class="line"><span class="keyword">cc</span> -<span class="keyword">c</span> $<span class="title">@.yy.c</span> -o $<span class="title">@.yy.o</span></span><br><span class="line">yacc -dtv $<span class="title">@.yy</span> -o $<span class="title">@.cpp</span></span><br><span class="line">g++ $<span class="title">@.yy.o</span> $<span class="title">@.cpp</span> -o $<span class="title">@.out</span></span><br></pre></td></tr></table></figure><p>由于-o选项的存在，y.tab.h现在变成example_cpp.hpp，记住这点。</p><p>总结： 不要自寻烦恼的在C++中编译你的词法分析器，让它呆在C的领地里。在C++中编写解析器时，(也得)确保向编译器解释清楚，即你的C函数都有一个extern “C”声明。</p><h1 id="六、Lex和YACC内部工作原理"><a href="#六、Lex和YACC内部工作原理" class="headerlink" title="六、Lex和YACC内部工作原理"></a>六、Lex和YACC内部工作原理</h1><p>在YACC文件中，你定义了你自己的main()函数，它在某个点上调用了yyparse()。YACC会创建你的yyparse()函数，并在y.tab.c中结束该函数。</p><p>yyparse()函数读取一个『标识符/值对』(token/value pairs)流，这些流需要事先就提供，这些流可以是你自己手写的代码提供的，也可以是LEX生成的。在我们的示例中，我们把这个工作丢给了LEX。</p><p>LEX生成的yylex()函数从文件参数FILE *file中读取字符(文件名为yyin)。如果不设置成yyin，则默认为标准输入，它会输出到yyout中，如果不加设置，就是stdout。你可以在yywrap()函数中修改位于文件尾的yyin.yywrap()函数。这些修改使得你可以打开另一些文件，并继续解析。</p><p>如果是这种情况，那么就让yywrap()返回0，如果你想在该文件上结束解析，就让它返回1。</p><p>每次yylex()调用都会返回一个整数值，该值代表了一个标识符类型(token type)。它告诉YACC，已经读取了这种标识符。该标识符可以有一个值，它应该存放在yylval变量中。</p><p>yylval的默认类型为int，但是你可以修改其类型，通过在YACC文件中#define YYSTYPE。</p><p>词法分析器需要能够访问yylval，为达到此效果，(yylval)必须在词法分析器(lexer)中被声明为一个外部变量(extern variable)。原来的YACC忽略了这点，并没有为你干这项工作，所以，你必须添加以下代码到你的词法分析器中，就在#include &lt;y.tab.h&gt;下面：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern </span>YYSTYPE yylval<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>当今多数人使用的Bison已经为你把这事自动做好了。</p><h2 id="6-1-标识符的值-token-values"><a href="#6-1-标识符的值-token-values" class="headerlink" title="6.1 标识符的值(token values)"></a>6.1 标识符的值(token values)</h2><p>在前面我已经说过，yylex()需要返回它遇到了一个什么标识符类型，并将其值存储在yylval中。当这些标识符在%token命令中定义时，它们就被赋予了一些数字ID，从256开始。</p><p>由于这个事实，(我们)可以将所有的ascii字符当作标识符。假定你要写一个计算器，到现在为止，我们可能已经这样写了其词法分析器：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span>-<span class="number">9</span>]+ yylval = atoi(yytext); <span class="keyword">return</span> NUMBER;</span><br><span class="line">[ \n]+ <span class="comment">/* eat whitespace */</span></span><br><span class="line">- <span class="keyword">return</span> MINUS;</span><br><span class="line">\* <span class="keyword">return</span> MULT;</span><br><span class="line">\+ <span class="keyword">return</span> PLUS;</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>YACC文件可能是这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span> : <span class="built_in">NUMBER</span></span><br><span class="line">| <span class="built_in">exp</span> PLUS <span class="built_in">exp</span></span><br><span class="line">| <span class="built_in">exp</span> MINUS <span class="built_in">exp</span></span><br><span class="line">| <span class="built_in">exp</span> MULT <span class="built_in">exp</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure><p>没有必要弄这么复杂。用字符作为速记法来作为标识符的数字ID，我们可以这样来重写我们的词法分析器：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">0-9</span>]+ yylval = atoi(yytext); <span class="keyword">return</span> NUMBER;</span><br><span class="line">[<span class="meta"> \n</span>]+ <span class="comment">/* eat whitespace */</span></span><br><span class="line">. <span class="keyword">return</span> (<span class="keyword">int</span>) yytext[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>最后一行匹配任何的单个字符，否则就是不匹配字符。</p><p>而YACC的语法文件则是这样:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exp</span> : <span class="built_in">NUMBER</span></span><br><span class="line">| <span class="built_in">exp</span> <span class="string">'+'</span> <span class="built_in">exp</span></span><br><span class="line">| <span class="built_in">exp</span> <span class="string">'-'</span> <span class="built_in">exp</span></span><br><span class="line">| <span class="built_in">exp</span> <span class="string">'*'</span> <span class="built_in">exp</span></span><br></pre></td></tr></table></figure><p>这样更加简短而直观，你就不必在文件头用%token来定义那些ascii字符了。<br>另一方面，这样构造还有一些好处，它可以匹配所有丢给它的东西，而避免了将那些不匹配的输入输出到标准输出的默认行为。如果用户在当前计算器上输入一个’^’字符，将会导致一个解析错误，而不是将其输出到标准输出中。</p><h2 id="6-2-递归：’right-is-wrong’"><a href="#6-2-递归：’right-is-wrong’" class="headerlink" title="6.2 递归：’right is wrong’"></a>6.2 递归：’right is wrong’</h2><p>递归是YACC一个极其重要的特性。没有递归的话，你就确定一个文件是由一系列独立的命令组成还是由语句组成。由于YACC自身的特性，它只对第一个规则或那个你将其设计为『起始规则』的规则感兴趣。起始规则用’%start’符号标记。</p><p>YACC中的递归以两种形式出现，左递归和右递归。左递归是你应该经常使用的，它们看起来如下：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands ： <span class="comment">/* empty */</span></span><br><span class="line">| commands <span class="keyword">command</span></span><br></pre></td></tr></table></figure><p>这是在说，一个command要么为空，要么它包含了更多的commands，后面再跟一个command。YACC的这种工作方式意味着它现在可以轻易的剔除单个的command群并一步步简化(处理)。<br>拿上面的例子和下面的右递归做比较：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands : <span class="comment">/* empty */</span></span><br><span class="line">| <span class="keyword">command</span> <span class="title">commands</span></span><br></pre></td></tr></table></figure><p>但是这样做开销有点大，如果(commands)是%start规则(即起始规则)，那么YACC会将所有的commands保存在你的栈数据中(file on the stack)，这将耗费大量内存。所以，在解析长的语句时，务必使用左递归，例如整个文件。但有时难以避免右递归，不过，如果你的语句并不太长，你就没有必要越轨使用左递归。</p><p>如果你有一些东西来终结(因此而分割)你的commands，右递归就非常适合了，但开销还是有点大:</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands : <span class="comment">/* empty */</span></span><br><span class="line">| <span class="keyword">command</span> <span class="title">SEMICOLON</span> <span class="title">commands</span></span><br></pre></td></tr></table></figure><p>正确的做法是使用左递归(这也不是我发明的)：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commands : <span class="comment">/* empty */</span></span><br><span class="line">| commands <span class="keyword">command</span> <span class="title">SEMICOLON</span></span><br></pre></td></tr></table></figure><p>本文档的早期版本错误的使用了右递归。Markus Triska友好的提示我们这点(错误)。</p><h2 id="6-3-高级yylval-union"><a href="#6-3-高级yylval-union" class="headerlink" title="6.3 高级yylval: %union"></a>6.3 高级yylval: %union</h2><p>现在，我们需要定义yylval的类型。但是这并不一直恰如其当。我们可能会多次这样做，因为需要处理多种数据类型。回到我们假定的那个恒温器，可能你想选择控制一个加热器，例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">heater mainbuilding</span><br><span class="line">Selected ‘mainbuilding’ heater</span><br><span class="line"><span class="keyword">Target</span> temperature <span class="number">23</span></span><br><span class="line">‘mainbuilding’ heater <span class="keyword">target</span> temperature now <span class="number">23</span></span><br></pre></td></tr></table></figure><p>这样的话，就要求yylval是一个union，它可以存储字符串，也可以存储整数，但并不是同时存储。<br>回忆之前我们讲过，我们提前通知YACC哪种yylval类型会要处理是通过定义YYSTYPE来实现。同样，我们可以定义YYSTYPE为一个union，YACC中有一种简便的方法来实现，即%union语句。</p><p>在example4基础上，我编写example7的YACC语法：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%token TOKHEATER TOKHEAT TOKTARGET TOKTEMERATURE</span><br><span class="line">%<span class="class"><span class="keyword">union</span></span></span><br><span class="line">&#123;</span><br><span class="line">int number;</span><br><span class="line">char *string;</span><br><span class="line">&#125;</span><br><span class="line">%token &lt;number&gt; STATE</span><br><span class="line">%token &lt;number&gt; NUMBER</span><br><span class="line">%token &lt;string&gt; WORD</span><br></pre></td></tr></table></figure><p>我们定义了union，它只包含一个整数和一个字符串。接着使用了一个扩展的%token语法，我们向YACC解释了应该获取union哪个部分的标识符。<br>在本例中，我们让STATE标识符用一个整数(来表示)，这跟之前一样。NUMBER同理，我们之前用来读取温度。<br>但是WORD有所改变，它声明为需要一个字符串。<br>词法解析器文件有所改变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"y.tab.h"</span></span></span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span><span class="number">-9</span>]+ yylval.number=atoi(yytext); <span class="keyword">return</span> NUMBER;</span><br><span class="line">heater <span class="keyword">return</span> TOKHEATER;</span><br><span class="line">heat <span class="keyword">return</span> TOKHEAT;</span><br><span class="line">on|off yylval.number =! <span class="built_in">strcmp</span>(yytext,<span class="string">"on"</span>); returnSTATE;</span><br><span class="line">target <span class="keyword">return</span> TOKTARGET;</span><br><span class="line">temperature <span class="keyword">return</span> TOKTEMPERATURE;</span><br><span class="line">[a-z0<span class="number">-9</span>]+ yylval.<span class="built_in">string</span> = strdup(yytext); <span class="keyword">return</span> WORD;</span><br><span class="line">\n <span class="comment">/* ignore end of line */</span></span><br><span class="line">[ \t]+ <span class="comment">/* ignore whitespace */</span></span><br><span class="line"></span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>正如你所见，我们不再直接访问yylval，我们添加了一个后缀来说明我们要访问那个部分。我们不再需要在YACC语法文件中来干这个工作，YACC在这里耍了下魔法：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heater_select:</span><br><span class="line">TOKHEATER WORD</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"\tSelected heater '%s'\n"</span>, $2);</span><br><span class="line">    heater = $2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于上面的%token声明，YACC自动选择了union中的’string’成员。注意这里$2中存储的一份拷贝，在后面它会告诉用户发送命令到哪个heater（需要在C文件头定义char *heater）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target_set:</span><br><span class="line">TOKTARGET TOKTEMPERATURE NUMBER</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\tHeater '%s' temperature set to %d\n"</span>, </span><br><span class="line">            heater, $<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-4-自定义YY-INPUT指向字符串而非标准输入"><a href="#6-4-自定义YY-INPUT指向字符串而非标准输入" class="headerlink" title="6.4 自定义YY_INPUT指向字符串而非标准输入"></a>6.4 自定义YY_INPUT指向字符串而非标准输入</h2><p>很多情况下，我们不希望从标准输入解析，而希望解析给定的字符串。实现方法是自定义实现YY_INPUT，具体做法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LEX 文件 */</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">lex_custom_input</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">unsigned</span> <span class="keyword">long</span> *num_read,<span class="keyword">int</span> max_read)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(b,r,s) lex_custom_input(b,&amp;r,s)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* C 文件 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> g_read_offset;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TEXT_LEN 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> s_text_buf[MAX_TEXT_LEN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lex_custom_input</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">unsigned</span> <span class="keyword">long</span> *num_read,<span class="keyword">int</span> max_read)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num_to_read = max_read;</span><br><span class="line">    <span class="keyword">int</span> remain = <span class="built_in">strlen</span>(s_text_buf) - g_read_offset;</span><br><span class="line"></span><br><span class="line">    num_to_read = num_to_read&gt;remain ? reamin:num_to_read;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, s_text_buf + g_read_offset, num_to_read);</span><br><span class="line"></span><br><span class="line">    *num_read = num_to_read;</span><br><span class="line">    g_read_offset += num_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、调试"><a href="#七、调试" class="headerlink" title="七、调试"></a>七、调试</h1><p>YACC中有许多调试反馈信息。这些调试信息的代价有点高，所以你需要提供一些开关来打开它。</p><p>当调试你的语法时，在YACC命令行中添加—debug和—verbose选项，在你的C文件头中添加以下语句：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">int yydebug</span> = 1;</span><br></pre></td></tr></table></figure><p>这将生成一个y.output文件，其中说明了所创建的那个状态机。<br>当你运行那个生成的二进制文件，它将输出很多运行时信息。里面包含当前所运行的状态机以及读取到的一些标识符。</p><p>Peter Jinks写了一篇关于调试的文章，他在其中讲述了一些常见得错误以及如何修正这些错误。</p><h2 id="7-1-状态机"><a href="#7-1-状态机" class="headerlink" title="7.1 状态机"></a>7.1 状态机</h2><p>YACC解析器在内部运行的是一个『状态机』，该状态机可以有多种转台。接着有多个规则来管制状态间的相互转化。任何内容都是从『root』规则开始。</p><p>在example7的y.output文件中：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">state</span> <span class="number">0</span></span><br><span class="line">ZPONETOK , and go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">1</span></span><br><span class="line"><span class="variable">$default</span> reduce using <span class="keyword">rule</span> <span class="number">1</span> (commands)</span><br><span class="line">commands go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">29</span></span><br><span class="line">command go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">2</span></span><br><span class="line">zone_set go <span class="keyword">to</span> satte <span class="number">3</span></span><br></pre></td></tr></table></figure><p>默认情形下，这个状态机从『commands』规则开始递减演化，这也是我们之前的那个递归规则，它定义了『commands』并从单个的『command』进行构造，后面跟着一个分号，然后可能再跟着更多的『commands』。</p><p>这个状态机不断递减演化，直到它遇到某些它能理解的东西，在本例中，为一个ZONETOK，也即单词『zone』。然后转化到状态1，在此，进一步处理一个zone command:</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">state</span> <span class="number">1</span></span><br><span class="line">zone_set -&gt; ZONETOK .quotedname zonecontent (<span class="keyword">rule</span> <span class="number">4</span>)</span><br><span class="line">QUOTE , and go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">4</span></span><br><span class="line">Quotedname go <span class="keyword">to</span> <span class="keyword">state</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>第一行中有一个『.』，它用来说明我们所处的位置：即刚刚识别到了一个ZONETOK，目前正在寻找一个『quotedname』。显然，一个『quotedname』会以QUOTE开始，它将我们转化到状态4。<br>为进一步跟踪，用在『调试』章节中提到的标志来编译example7。</p><h2 id="7-2-冲突：『shift-reduce』以及『reduce-reduce』"><a href="#7-2-冲突：『shift-reduce』以及『reduce-reduce』" class="headerlink" title="7.2 冲突：『shift/reduce』以及『reduce/reduce』"></a>7.2 冲突：『shift/reduce』以及『reduce/reduce』</h2><p>一旦YACC警告你出现了冲突，那么你的麻烦来了。要解决这些问题显得是一种技巧形式，它会教会很多关于你的语言的东西。比你想知道的要多的多的内容。</p><p>问题萦绕于如何来翻译一系列标识符。假定我们定义了一种语言，它需要接受一下两种命令：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> heater <span class="keyword">all</span></span><br><span class="line"><span class="keyword">delete</span> heater number1</span><br></pre></td></tr></table></figure><p>为达到此目的，我们的语法为：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">delete_heaters :</span><br><span class="line">TOKDELETE TOKHEATER mode</span><br><span class="line">&#123;</span><br><span class="line">    Deleteheaters(<span class="variable">$3</span>);</span><br><span class="line">&#125;</span><br><span class="line">mode : <span class="built_in">WORD</span></span><br><span class="line">delete_a_heater:</span><br><span class="line">TOKDELETE TOKHEATER <span class="built_in">WORD</span></span><br><span class="line">&#123;</span><br><span class="line">    delete(<span class="variable">$3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你已经嗅到了麻烦的味道。状态机从读取单词『word』开始，接着它根据下一个标识符觉得转换到何种状态。接下来的标识符可以是『mode』，它指定了如何来删除heater，或者是将要删除的heater。<br>然而这里的麻烦是，对于这两个命令，下一个标识符都将是一个WORD。YACC因此也无法决定下一步该干嘛。这回导致一个『reduce/reduce』警告，而下一个警告就是『delete_a_heater』节点在状态转化图中永远也不能达到。<br>这种情况的冲突容易解决(例如，重命名第一个命令为『delete all heater』，或者将『all』作为一个分开的标识符)，但有时，(要解决冲突)却非常困难。 通过『–verbose』参数生成的y.output文件可以提供给你极大的帮助。</p><h1 id="八、参考资料"><a href="#八、参考资料" class="headerlink" title="八、参考资料"></a>八、参考资料</h1><p>GNU YACC(Bison)有一个非常棒的.info文件，在其中很好的记录了YACC的语法。其中只提到了一次LEX，然而它还是很棒的。你可以用Emacs中那个非常好的『pinfo』工具阅读.info文件。同时，在Bison的主页上可以获得它：<a href="http://www.gnu.org/software/bison/manual/bison.html" target="_blank" rel="noopener">Bison手册</a>。<br>FLEX有一个不错的主页。如果你粗略了解了FLEX所作所为，那将是非常有益的。<a href="http://www.gnu.org/manual/flex/" target="_blank" rel="noopener">FLEX的手册</a>也可以联机获取。<br>在这些关于YACC和LEX的介绍之后，你可能觉得你想需要更多的信息。下面的书籍也相当不错：</p><ul><li>《Bison—The Yacc-Compitible Parser Generator》——Charles Donnelly &amp;&amp; Richard Stallman.</li><li>《Lex &amp; Yacc》——John R. Levine, Tony Mason ,Doug Brown.</li><li>《Compilers: Principles, Techniques, and Tools》——By Alfred V.Aho,Ravi</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h1&gt;&lt;p&gt;只要在Unix环境中写程序，必定会邂逅神秘的Lex&amp;amp;YACC，就如GNU/Linux用户所熟知的Flex&amp;amp;B
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="c++" scheme="https://www.ljjyy.com/tags/c/"/>
    
      <category term="c" scheme="https://www.ljjyy.com/tags/c/"/>
    
      <category term="lex" scheme="https://www.ljjyy.com/tags/lex/"/>
    
      <category term="yacc" scheme="https://www.ljjyy.com/tags/yacc/"/>
    
  </entry>
  
  <entry>
    <title>C/C++宏 详解</title>
    <link href="https://www.ljjyy.com/archives/2023/05/100648.html"/>
    <id>https://www.ljjyy.com/archives/2023/05/100648.html</id>
    <published>2023-05-24T04:00:00.000Z</published>
    <updated>2023-06-20T01:01:38.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="宏-替换-发生的时机"><a href="#宏-替换-发生的时机" class="headerlink" title="宏 替换 发生的时机"></a><strong>宏 替换 发生的时机</strong></h1><p>   为了能够真正理解#define的作用，需要了解下C语言源程序的处理过程。当在一个集成的开发环境如Turbo C中将编写好的源程序进行编译时，实际经过了<strong>预处理、编译、汇编</strong>和<strong>连接</strong>几个过程。其中预处理器产生编译器的输出，它实现以下的功能：</p><ol><li><strong>文件包含。</strong><br>可以把源程序中的#include 扩展为文件正文，即把包含的.h文件找到并展开到#include 所在处。</li><li><strong>条件编译。</strong><br>预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。</li><li><strong>宏展开。</strong><br>预处理器将源程序文件中出现的对宏的引用展开成相应的宏 定义，即本文所说的#define的功能，由预处理器来完成。经过预处理器处理的源程序与之前的源程序有所有不同，<strong>在这个阶段所进行的工作只是纯粹的替换与展开，没有任何计算功能，所以在学习#define命令时只要能真正理解这一点，这样才不会对此命令引起误解并误用。</strong></li></ol><h1 id="1-define的基本用法"><a href="#1-define的基本用法" class="headerlink" title="1. #define的基本用法"></a><strong>1. #define的基本用法</strong></h1><p>  #define 是 C语言中提供的宏定义命令，其主要目的是为程序员在编程时提供一定的方便，并能在一定程度上提高程序的运行效率，但学生在学习时往往不能 理解该命令的本质，总是在此处产生一些困惑，在编程时误用该命令，使得程序的运行与预期的目的不一致，或者在读别人写的程序时，把运行结果理解错误，这对 C语言的学习很不利。</p><h2 id="1-1-define命令剖析"><a href="#1-1-define命令剖析" class="headerlink" title="1.1 #define命令剖析"></a><strong>1.1 #define命令剖析</strong></h2><p>​     #define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。<strong>该命令有两种格式：**</strong>一种是简单的宏定义，另一种是带参数的宏定义**。</p><p>  一个标识符被宏定义后，该标识符便是一个宏名。这时，在程序中出现的是宏名，在该程序被编译前，先将宏名用被定义的字符串替换，这称为宏替换，替换后才进行编译，宏替换只是简单的替换，即 简单的纯文本替换，C预处理器不对宏体做任何语法检查，像缺个括号、少个分号什么的预处理器是不管的。</p><p> 宏体换行需要在行末加反斜杠 \</p><ul><li><p>宏名之后带括号的宏 被认为是 宏函数。用法和普通函数一样，只不过在预处理阶段，宏函数会被展开。优点是没有普通函数保存寄存器和参数传递的开销，展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。<br>#define min(X, Y) ((X) &lt; (Y) ? (X) : (Y))<br>y = min(1, 2);会被扩展成y = ((1) &lt; (2) ? (1) : (2));</p></li><li><p>分号吞噬 问题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) \</span></span><br><span class="line">&#123; \</span><br><span class="line">    <span class="keyword">return</span> (x) &gt; (y) ? (x):(y); \</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">    MAX(<span class="number">20</span>, <span class="number">10</span>); <span class="comment">//这个分号导致这一部分代码块结束，致使else找不到对应的if分支而报错</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ;;</span><br><span class="line"> </span><br><span class="line">上面 宏 展开后 <span class="keyword">if</span> <span class="keyword">else</span> 代码如下</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)</span><br><span class="line">    &#123; <span class="keyword">return</span> (<span class="number">20</span>) &gt; (<span class="number">10</span>) ? (<span class="number">20</span>):(<span class="number">10</span>); &#125;;<span class="comment">//后面多了一个分号，导致 if 代码块结束，致使else找不到对应的if分支而报错</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ;;</span><br></pre></td></tr></table></figure></li></ul><p>示例代码（test.c）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(x,y) \  </span></span><br><span class="line">&#123; \  </span><br><span class="line">    <span class="keyword">return</span> (x) &gt; (y) ? (x):(y); \  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>)  </span><br><span class="line">        MAX(<span class="number">20</span>, <span class="number">10</span>); <span class="comment">//这个分号导致这一部分代码块结束，致使else找不到对应的if分支而报错  </span></span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        ;;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc -E test.c -o test.e 会生成 test.e 的预处理文件</p><p>gcc -E test.c 会直接把预处理后内容输出到屏幕上。</p><p>可以看到后面多了一个分号。现在执行编译</p><p>可以看到 else 分支缺少 对应的 if 。</p><p>预处理并不分析整个源代码文件, 它只是将源代码分割成一些标记(token), 识别语句中哪些是C语句, 哪些是预处理语句. 预处理器能够识别C标记, 文件名, 空白符, 文件结尾标志.</p><p>预处理语句格式:  <strong>#command name(…) token(s)</strong></p><p>1, command预处理命令的名称, 它之前以#开头, #之后紧随预处理命令, 标准C允许#两边可以有空白符, 但比较老的编译器可能不允许这样. 若某行中只包含#(以及空白符), 那么在标准C中该行被理解为空白. 整个预处理语句之后只能有空白符或者注释, 不能有其它内容.<br>2, name代表宏名称, 它可带参数. 参数可以是可变参数列表(C99).<br>3, 语句中可以利用”\”来换行.</p><p><strong>e.g.</strong><br># define ONE 1 /<em> ONE == 1 </em>/<br>等价于: #define ONE　１</p><p>#define err(flag, msg) if(flag) \<br>  printf(msg)<br>等价于: #define err(flag, msg) if(flag) printf(msg)</p><h3 id="简单的宏定义"><a href="#简单的宏定义" class="headerlink" title="简单的宏定义"></a><strong>简单的宏定义</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> <span class="meta-string">&lt;宏名&gt; &lt;字符串&gt;</span></span></span><br><span class="line">例： <span class="meta">#<span class="meta-keyword">define</span> PI      3.1415926</span></span><br><span class="line">     <span class="meta">#<span class="meta-keyword">define</span> FALSE   0</span></span><br></pre></td></tr></table></figure><h3 id="带参数的宏定义"><a href="#带参数的宏定义" class="headerlink" title="带参数的宏定义"></a><strong>带参数的宏定义</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define &lt;宏名&gt;(&lt;形式参数表&gt;) &lt;宏体&gt;</span></span><br><span class="line">例： <span class="comment">#define A(x) x</span></span><br><span class="line">     <span class="comment">#define MAX(a,b) ( (a) &gt; (b) ) ? (a) : (b)</span></span><br></pre></td></tr></table></figure><h3 id="取消宏定义：-undef-宏名"><a href="#取消宏定义：-undef-宏名" class="headerlink" title="取消宏定义：#undef 宏名"></a><strong>取消宏定义：</strong>#undef 宏名</h3><h3 id="可变参数-的-宏"><a href="#可变参数-的-宏" class="headerlink" title="可变参数 的 宏"></a><strong>可变参数 的 宏</strong></h3><p>C/C++宏定义的可变参数详细解析_C 语言：<a href="https://yq.aliyun.com/ziliao/134584" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/134584</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG( format, ... ) printf( format, __VA_ARGS__ )</span></span><br><span class="line">LOG( <span class="string">"%s %d"</span>, str, count );</span><br></pre></td></tr></table></figure><p><strong>VA_ARGS</strong>是系统预定义宏，被自动替换为参数列表。</p><p>#define debug(format, args…) fprintf (stderr, format, args)<br>#define debug(format, …) fprintf (stderr, format, <strong>VA_ARGS</strong>)<br>或者</p><p>#define debug(format, …) fprintf (stderr, format, <strong>## <strong>VA_ARGS</strong></strong>)<br>前两者存在多余逗号问题，第三个宏使用##去掉可能多余的逗号。</p><p>即可变参数被忽略或为空，’##’操作将使预处理器(preprocessor)去除掉它前面的那个逗号</p><p> <strong>当一个宏自己调用自己时，会发生什么？</strong></p><p>例如：#define TEST( x ) ( x + TEST( x ) )<br>TEST( 1 ); 会发生什么？为了防止无限制递归展开，语法规定，当一个宏遇到自己时，就停止展开，也就是说，当对TEST( 1 )进行展开时，展开过程中又发现了一个TEST，那么就将这个TEST当作一般的符号。TEST(1) 最终被展开为：1 + TEST( 1) 。</p><h3 id="宏参数的prescan-预扫描"><a href="#宏参数的prescan-预扫描" class="headerlink" title="宏参数的prescan(预扫描)"></a><strong>宏参数的prescan(预扫描)</strong></h3><p>当一个宏参数被放进宏体时，这个宏参数会首先被全部展开(有例外，见下文)。当展开后的宏参数被放进宏体时，预处理器对新展开的宏体进行第二次扫描，并继续展开。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARAM( x ) x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDPARAM( x ) INT_##x</span></span><br><span class="line">PARAM( ADDPARAM( <span class="number">1</span> ) );</span><br></pre></td></tr></table></figure><p>因为ADDPARAM( 1 ) 是作为PARAM的宏参数，所以先将ADDPARAM( 1 )展开为INT_1，然后再将INT_1放进PARAM。<br>例外情况：如果PARAM宏里对宏参数使用了#或##，那么宏参数不会被展开：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARAM( x ) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDPARAM( x ) INT_##x</span></span><br><span class="line">PARAM( ADDPARAM( <span class="number">1</span> ) );        <span class="comment">//将被展开为"ADDPARAM( 1 )"。</span></span><br></pre></td></tr></table></figure><p>使用这么一个规则，可以创建一个很有趣的技术：打印出一个宏被展开后的样子，这样可以方便你分析代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_STRING( x ) TO_STRING1( x )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TO_STRING1( x ) #x</span></span><br></pre></td></tr></table></figure><p>TO_STRING首先会将x全部展开(如果x也是一个宏的话)，然后再传给TO_STRING1转换为字符串。</p><p>现在你可以这样：</p><p>​    const char *str = TO_STRING( PARAM( ADDPARAM( 1 ) ) );</p><p>去一探PARAM展开后的样子。</p><h3 id="一个很重要的补充："><a href="#一个很重要的补充：" class="headerlink" title="一个很重要的补充："></a><strong>一个很重要的补充：</strong></h3><p>  如果一个像函数的宏在使用时没有出现括号，那么预处理器只是将这个宏作为一般的符号处理(即 就是不处理)。</p><p>  函数宏对参数类型是不敏感的, 你不必考虑将何种数据类型传递给宏. 那么, 如何构建对参数类型敏感的宏呢? 参考关于”##”的介绍.</p><h3 id="对象宏"><a href="#对象宏" class="headerlink" title="对象宏"></a><strong>对象宏</strong></h3><p>不带参数的宏被称为”对象宏(objectlike macro)”<br>#define 经常用来定义常量, 此时的宏名称一般为大写的字符串. 这样利于修改这些常量.<br><strong>e.g.</strong><br>#define MAX 100<br>int a[MAX];</p><p>#ifndef <strong>FILE_H</strong><br>#define <strong>FILE_H</strong><br>#include “file.h”<br>#endif<br>#define <strong>FILE_H</strong> 中的宏就不带任何参数, 也不扩展为任何标记. 这经常用于包含头文件.</p><p>要调用该宏, 只需在代码中指定宏名称, 该宏将被替代为它被定义的内容.</p><h3 id="函数宏"><a href="#函数宏" class="headerlink" title="函数宏"></a><strong>函数宏</strong></h3><p>带参数的宏也被称为”函数宏”. 利用宏可以提高代码的运行效率: 子程序的调用需要压栈出栈, 这一过程如果过于频繁会耗费掉大量的CPU运算资源. 所以一些代码量小但运行频繁的代码如果采用带参数宏来实现会提高代码的运行效率.</p><p>函数宏的参数是固定的情况</p><p>函数宏的定义采用这样的方式: #define name( args ) tokens<br>其中的args和tokens都是可选的. 它和对象宏定义上的区别在于宏名称之后不带括号.</p><p>注意, name之后的左括号(必须紧跟name, 之间不能有空格, 否则这就定义了一个对象宏, 它将被替换为 以(开始的字符串. 但在调用函数宏时, name与(之间可以有空格.</p><p><strong>e.g.</strong><br>#define mul(x,y) ((x)*(y))</p><p>注意, 函数宏之后的参数要用括号括起来, 看看这个例子:<br>e.g.<br>#define mul(x,y) x<em>y<br>“mul(1, 2+2);” 将被扩展为: 1</em>2 + 2<br>同样, 整个标记串也应该用括号引用起来:<br><strong>e.g.</strong><br>#define mul(x,y) (x)<em>(y)<br>sizeof mul(1,2.0) 将被扩展为 sizeof 1 </em> 2.0</p><p>调用函数宏时候, 传递给它的参数可以是函数的返回值, 也可以是任何有意义的语句:<br>e.g.<br>mul (f(a,b), g(c,d));</p><p>e.g.<br>#define insert(stmt) stmt<br>insert ( a=1; b=2;) 相当于在代码中加入 a=1; b=2 .<br>insert ( a=1, b=2;) 就有问题了: 预处理器会提示出错: 函数宏的参数个数不匹配. 预处理器把”,”视为参数间的分隔符.<br>insert ((a=1, b=2;)) 可解决上述问题.</p><p>在定义和调用函数宏时候, 要注意一些问题:<br>1, 我们经常用{}来引用函数宏被定义的内容, 这就要注意调用这个函数宏时的”;”问题.<br>example_3.7:<br>#define swap(x,y) { unsigned long _temp=x; x=y; y=_tmp}<br>如果这样调用它: “swap(1,2);” 将被扩展为: { unsigned long _temp=1; 1=2; 2=_tmp};<br>明显后面的;是多余的, 我们应该这样调用: swap(1,2)<br>虽然这样的调用是正确的, 但它和C语法相悖, 可采用下面的方法来处理被{}括起来的内容:</p><p>#define swap(x,y) \<br>  do { unsigned long _temp=x; x=y; y=_tmp} while (0)<br>swap(1,2); 将被替换为:<br>do { unsigned long _temp=1; 1=2; 2=_tmp} while (0);<br>在Linux内核源代码中对这种do-while(0)语句有这广泛的应用.</p><p>2, 有的函数宏是无法用do-while(0)来实现的, 所以在调用时不能带上”;”, 最好在调用后添加注释说明.<br>eg_3.8:<br>#define incr(v, low, high) \<br>  for ((v) = (low),; (v) &lt;= (high); (v)++)<br>只能以这样的形式被调用: incr(a, 1, 10) /<em> increase a form 1 to 10 </em>/</p><p>函数宏中的参数包括可变参数列表的情况<br>C99标准中新增了可变参数列表的内容. 不光是函数, 函数宏中也可以使用可变参数列表.</p><p><strong>#define name(args, …) tokens</strong><br><strong>#define name(…) tokens</strong><br>“…”代表可变参数列表, 如果它不是仅有的参数, 那么它只能出现在参数列表的最后. 调用这样的函数宏时, 传递给它的参数个数要不少于参数列表中参数的个数(多余的参数被丢弃).<br>通过<strong>VA_ARGS</strong>来替换函数宏中的可变参数列表. 注意<strong>VA_ARGS</strong>只能用于函数宏中参数中包含有”…”的情况.</p><p>e.g.<br>#ifdef DEBUG<br>#define my_printf(…) fprintf(stderr, <strong>VA_ARGS</strong>)<br>#else<br>#define my_printf(…) printf(<strong>VA_ARGS</strong>)<br>#endif</p><p>tokens中的<strong>VA_ARGS</strong>被替换为函数宏定义中的”…”可变参数列表. </p><p>注意在使用#define时候的一些常见错误:<br>#define MAX = 100<br>#define MAX 100;<br>=, ; 的使用要值得注意. 再就是调用函数宏是要注意, 不要多给出”;”.</p><h2 id="1-2-关于定义宏的另外一些问题"><a href="#1-2-关于定义宏的另外一些问题" class="headerlink" title="1.2 关于定义宏的另外一些问题"></a><strong>1.2 关于定义宏的另外一些问题</strong></h2><h3 id="1-宏可以被多次定义-前提是这些定义必须是相同的。"><a href="#1-宏可以被多次定义-前提是这些定义必须是相同的。" class="headerlink" title="(1)宏可以被多次定义, 前提是这些定义必须是相同的。"></a><strong>(1)</strong>宏可以被多次定义, 前提是这些定义必须是相同的。</h3><p>这里的”相同”要求先后定义中空白符出现的位置相同, 但具体的空白符类型或数量可不同, 比如原先的空格可替换为多个其他类型的空白符: 可为tab, 注释…<br><strong>e.g.</strong><br>#define NULL 0<br>#define NULL　/<em> null pointer </em>/   0<br>上面的重定义是相同的, 但下面的重定义不同:<br>#define fun(x) x+1<br>#define fun(x) x + 1 或: #define fun(y) y+1<br>如果多次定义时, 再次定义的宏内容是不同的, gcc会给出”NAME redefined”警告信息.</p><p>应该避免重新定义函数宏, 不管是在预处理命令中还是C语句中, 最好对某个对象只有单一的定义. 在gcc中, 若宏出现了重定义, gcc会给出警告.</p><h3 id="2-在gcc中-可在命令行中指定对象宏的定义"><a href="#2-在gcc中-可在命令行中指定对象宏的定义" class="headerlink" title="(2) 在gcc中, 可在命令行中指定对象宏的定义:"></a>(2) 在gcc中, 可在命令行中指定对象宏的定义:</h3><p><strong>e.g.</strong><br>$ gcc -Wall -DMAX=100 -o tmp tmp.c<br>相当于在tmp.c中添加” #define MAX 100”.</p><p>那么, 如果原先tmp.c中含有MAX宏的定义, 那么再在gcc调用命令中使用-DMAX, 会出现什么情况呢?<br>—若-DMAX=1, 则正确编译.<br>—若-DMAX的值被指定为不为1的值, 那么gcc会给出MAX宏被重定义的警告, MAX的值仍为1.</p><p>注意: 若在调用gcc的命令行中不显示地给出对象宏的值, 那么gcc赋予该宏默认值(1), 如: -DVAL == -DVAL=1</p><h3 id="3-define所定义的宏的作用域"><a href="#3-define所定义的宏的作用域" class="headerlink" title="(3) #define所定义的宏的作用域"></a>(3) #define所定义的宏的作用域</h3><p>宏在定义之后才生效, 若宏定义被#undef取消, 则#undef之后该宏无效. 并且字符串中的宏不会被识别<br><strong>e.g.</strong><br>#define ONE 1<br>sum = ONE + TWO  /<em> sum = 1 + TWO </em>/<br>#define TWO 2<br>sum = ONE + TWO  /<em> sum = 1 + 2  </em>/<br>#undef ONE<br>sum = ONE + TWO  /<em> sum = ONE + 2 </em>/<br>char c[] = “TWO”  /<em> c[] = “TWO”, NOT “2”! </em>/</p><h3 id="4-宏的替换可以是递归的-所以可以嵌套定义宏"><a href="#4-宏的替换可以是递归的-所以可以嵌套定义宏" class="headerlink" title="(4) 宏的替换可以是递归的, 所以可以嵌套定义宏."></a>(4) 宏的替换可以是递归的, 所以可以嵌套定义宏.</h3><p><strong>e.g.</strong><br># define ONE NUMBER_1<br># define NUMBER_1 1<br>int a = ONE /<em> a = 1 </em>/</p><h2 id="1-3-undef"><a href="#1-3-undef" class="headerlink" title="1.3 #undef"></a>1.3 #undef</h2><p>#undef用来取消宏定义, 它与#define对立:<br><strong>#undef name</strong><br>如够被取消的宏实际上没有被#define所定义, 针对它的#undef并不会产生错误.<br>当一个宏定义被取消后, 可以再度定义它. </p><h2 id="1-4-if-elif-else-endif"><a href="#1-4-if-elif-else-endif" class="headerlink" title="1.4 #if, #elif, #else, #endif"></a>1.4 #if, #elif, #else, #endif</h2><p>#if, #elif, #else, #endif用于条件编译:<br><strong>#if 常量表达式1</strong><br>  <strong>语句…</strong><br><strong>#elif 常量表达式2</strong><br>  <strong>语句…</strong><br><strong>#elif 常量表达式3</strong><br>  <strong>语句…</strong><br><strong>…</strong><br><strong>#else</strong><br>  <strong>语句…</strong><br><strong>#endif</strong></p><p>#if和#else分别相当于C语句中的if, else. 它们根据常量表达式的值来判别是否执行后面的语句. #elif相当于C中的else-if. 使用这些条件编译命令可以方便地实现对源代码内容的控制.<br>else之后不带常量表达式, 但若包含了常量表达式, gcc只是给出警告信息.</p><p>使用它们可以提升代码的可移植性—针对不同的平台使用执行不同的语句. 也经常用于大段代码注释.<br><strong>e.g.</strong><br>#if 0<br>{<br>  一大段代码;<br>}<br>#endif</p><p>常量表达式可以是包含宏, 算术运算, 逻辑运算等等的合法C常量表达式, 如果常量表达式为一个未定义的宏, 那么它的值被视为0.<br>#if MACRO_NON_DEFINED == #if 0<br>在判断某个宏是否被定义时, 应当避免使用#if, 因为该宏的值可能就是被定义为0. 而应当使用下面介绍的#ifdef或#ifndef.</p><p>注意: #if, #elif, #else之后的宏只能是对象宏. 如果name为名的宏未定义, 或者该宏是函数宏. 那么在gcc中使用”-Wundef”选项会显示宏未定义的警告信息.</p><h2 id="1-5-ifdef-ifndef-defined"><a href="#1-5-ifdef-ifndef-defined" class="headerlink" title="1.5 #ifdef, #ifndef, defined."></a>1.5 #ifdef, #ifndef, defined.</h2><p>#ifdef, #ifndef, defined用来测试某个宏是否被定义<br>#ifdef name 或 #ifndef name</p><p>它们经常用于避免头文件的重复引用:<br>#ifndef <strong>FILE_H</strong><br>#define <strong>FILE_H</strong><br>#include “file.h”<br>#endif</p><p>defined(name): 若宏被定义,则返回1, 否则返回0.<br>它与#if, #elif, #else结合使用来判断宏是否被定义, 乍一看好像它显得多余, 因为已经有了#ifdef和#ifndef. defined用于在一条判断语句中声明多个判别条件:</p><p>#if defined(VAX) &amp;&amp; defined(UNIX) &amp;&amp; !defined(DEBUG) </p><p>和#if, #elif, #else不同, #indef, #ifndef, defined测试的宏可以是对象宏, 也可以是函数宏. 在gcc中使用”-Wundef”选项不会显示宏未定义的警告信息.</p><h2 id="1-6-include-include-next"><a href="#1-6-include-include-next" class="headerlink" title="1.6 #include , #include_next"></a>1.6 #include , #include_next</h2><p>#include用于文件包含. 在#include 命令所在的行不能含有除注释和空白符之外的其他任何内容.<br><strong>#include “headfile”</strong><br><strong>#include <headfile></headfile></strong><br><strong>#include 预处理标记</strong><br>前面两种形式大家都很熟悉, “#include 预处理标记”中, 预处理标记会被预处理器进行替换, 替换的结果必须符合前两种形式中的某一种.</p><p>实际上, 真正被添加的头文件并不一定就是#include中所指定的文件. #include”headfile”包含的头文件当然是同一个文件, 但#include <headfile>包包含的”系统头文件”可能是另外的文件. 但这不值得被注意. 感兴趣的话可以查看宏扩展后到底引入了哪些系统头文件.</headfile></p><p>关于#include “headfile”和#include <headfile>的区别以及如何在gcc中包含头文件的详细信息, 参考本blog的GCC笔记.</headfile></p><p>相对于#include, 我们对#include_next不太熟悉. #include_next仅用于特殊的场合. 它被用于头文件中(#include既可用于头文件中, 又可用于.c文件中)来包含其他的头文件. 而且包含头文件的路径比较特殊: 从当前头文件所在目录之后的目录来搜索头文件.<br>比如: 头文件的搜索路径一次为A,B,C,D,E. #include_next所在的当前头文件位于B目录, 那么#include_next使得预处理器从C,D,E目录来搜索#include_next所指定的头文件.</p><p>可参考<a href="http://gcc.gnu.org/onlinedocs/" target="_blank" rel="noopener">cpp手册</a>进一步了解#include_next</p><h2 id="1-7-预定义-的-宏"><a href="#1-7-预定义-的-宏" class="headerlink" title="1.7 预定义 的 宏**"></a>1.7 预定义 的 宏**</h2><p>标准C中定义了一些对象宏, 这些宏的名称以”__”开头和结尾, 并且都是大写字符. 这些预定义宏可以被#undef, 也可以被重定义.</p><p>下面列出一些标准C中常见的预定义对象宏(其中也包含gcc自己定义的一些预定义宏:</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__LINE__           当前语句所在的行号, 以<span class="number">10</span>进制整数标注.</span><br><span class="line">__FILE__           当前源文件的文件名, 以字符串常量标注.</span><br><span class="line">__DATE__           程序被编译的日期, 以<span class="string">"Mmm dd yyyy"</span>格式的字符串标注.</span><br><span class="line">__TIME__           程序被编译的时间, 以<span class="string">"hh:mm:ss"</span>格式的字符串标注, 该时间由asctime返回.</span><br><span class="line"></span><br><span class="line">__STDC__           如果当前编译器符合ISO标准, 那么该宏的值为<span class="number">1</span></span><br><span class="line">__STDC_VERSION__   如果当前编译器符合C89, 那么它被定义为<span class="number">199409</span>L, 如果符合C99, 那么被定义为<span class="number">199901</span>L. </span><br><span class="line">                   我用gcc, 如果不指定-std=c99, 其他情况都给出__STDC_VERSION__未定义的错误信息, 咋回事呢?</span><br><span class="line">__STDC_HOSTED__    如果当前系统是<span class="string">"本地系统(hosted)"</span>, 那么它被定义为<span class="number">1</span>. 本地系统表示当前系统拥有完整的标准C库.</span><br></pre></td></tr></table></figure><p>ANSI标准说明了五个预定义的宏名。它们是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_LINE_             <span class="comment">/* (两个下划线)，对应%d*/</span></span><br><span class="line">_FILE_             <span class="comment">/* 对应%s */</span></span><br><span class="line">__FUNCTION__       <span class="comment">/* 对应%s */</span></span><br><span class="line">_DATE_             <span class="comment">/* 对应%s */</span></span><br><span class="line">_TIME_             <span class="comment">/* 对应%s */</span></span><br></pre></td></tr></table></figure><p>gcc定义的预定义宏:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__OPTMIZE__         如果编译过程中使用了优化, 那么该宏被定义为1.</span><br><span class="line">__OPTMIZE_SIZE__    同上, 但仅在优化是针对代码大小而非速度时才被定义为1.</span><br><span class="line">__VERSION__         显示所用gcc的版本号.</span><br></pre></td></tr></table></figure><p>可参考”GCC the complete reference”.<br>要想看到gcc所定义的所有预定义宏, 可以运行: $ cpp -dM /dev/null</p><h2 id="1-7-line"><a href="#1-7-line" class="headerlink" title="1.7 #line"></a>1.7 #line</h2><p>#line用来修改<strong>LINE</strong>和<strong>FILE</strong>.<br><strong>e.g.</strong><br>printf(“line: %d, file: %s\n”, <strong>LINE</strong>, <strong>FILE</strong>);<br>#line 100 “haha”<br>printf(“line: %d, file: %s\n”, <strong>LINE</strong>, <strong>FILE</strong>);<br>printf(“line: %d, file: %s\n”, <strong>LINE</strong>, <strong>FILE</strong>);</p><p>显示:<br>line: 34, file: 1.c<br>line: 100, file: haha<br>line: 101, file: haha </p><h2 id="1-8-pragma-和-Pragma"><a href="#1-8-pragma-和-Pragma" class="headerlink" title="1.8 #pragma 和 _Pragma"></a>1.8 #pragma 和 _Pragma</h2><p>#pragma用编译器用来添加新的预处理功能或者显示一些编译信息. #pragma的格式是各编译器特定的, gcc的如下:<br><strong>#pragma GCC name token(s)</strong></p><p>#pragma之后有两个部分: GCC和特定的pragma name. 下面分别介绍gcc中常用的.</p><p><strong>(1) #pragma GCC dependency</strong><br>dependency测试当前文件(既该语句所在的程序代码)与指定文件(既#pragma语句最后列出的文件)的时间戳. 如果指定文件比当前文件新, 则给出警告信息.<br><strong>e.g.</strong><br>在demo.c中给出这样一句:<br>#pragma GCC dependency “temp-file”<br>然后在demo.c所在的目录新建一个更新的文件: $ touch temp-file, 编译: $ gcc demo.c 会给出这样的警告信息: warning: current file is older than temp-file<br>如果当前文件比指定的文件新, 则不给出任何警告信息.</p><p>还可以在在#pragma中给添加自定义的警告信息.<br><strong>e.g.</strong><br>#pragma GCC dependency “temp-file” “demo.c needs to be updated!”<br>1.c:27:38: warning: extra tokens at end of #pragma directive<br>1.c:27:38: warning: current file is older than temp-file<br>注意: 后面新增的警告信息要用””引用起来, 否则gcc将给出警告信息.</p><p><strong>(2) #pragma GCC poison token(s)</strong><br>若源代码中出现了#pragma中给出的token(s), 则编译时显示警告信息. 它一般用于在调用你不想使用的函数时候给出<strong>出错信息</strong>.<br>e.g.<br>#pragma GCC poison scanf<br>scanf(“%d”, &amp;a);<br>warning: extra tokens at end of #pragma directive<br>error: attempt to use poisoned “scanf”<br>注意, 如果调用了poison中给出的标记, 那么编译器会给出的是出错信息. 关于第一条警告, 我还不知道怎么避免, 用””将token(s)引用起来也不行.</p><p><strong>(3) #pragma GCC system_header</strong><br>从#pragma GCC system_header直到文件结束之间的代码会被编译器视为系统头文件之中的代码. 系统头文件中的代码往往不能完全遵循C标准, 所以头文件之中的警告信息往往不显示. (除非用 #warning显式指明).<br>(这条#pragma语句还没发现用什么大的用处<img src="http://www.cublog.cn/images/face/033.gif" alt="img">)</p><p>由于#pragma不能用于宏扩展, 所以gcc还提供了<strong>_Pragma</strong>:<br>e.g.<br>#define PRAGMA_DEP #pragma GCC dependency “temp-file”<br>由于预处理之进行一次宏扩展, 采用上面的方法会在编译时引发错误, 要将#pragma语句定义成一个宏扩展, 应该使用下面的_Pragma语句:<br>#define PRAGMA_DEP _Pragma(“GCC dependency \”temp-file\””)<br>注意, ()中包含的””引用之前引该加上\转义字符. </p><h2 id="1-9-warning-error"><a href="#1-9-warning-error" class="headerlink" title="1.9 #warning, #error"></a>1.9 #warning, #error</h2><p>#warning, #error分别用于在编译时显示警告和错误信息, 格式如下:<br><strong>#warning tokens</strong><br><strong>#error tokens</strong><br><strong>e.g.</strong><br>#warning “some warning”<br>注意, #error 和 #warning 后的 token 要用””引用起来!<br>(在gcc中, 如果给出了warning, 编译继续进行, 但若给出了error, 则编译停止. 若在命令行中指定了 -Werror, 即使只有警告信息, 也不编译.</p><h2 id="1-10-常用的预处理命令"><a href="#1-10-常用的预处理命令" class="headerlink" title="1.10 常用的预处理命令"></a><strong>1.10 常用的预处理命令</strong></h2><p>预处理命令由#(hash字符)开头, 它独占一行, #之前只能是空白符. 以#开头的语句就是预处理命令，不以#开头的语句为C中的代码行。</p><p>常用的预处理命令如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>              定义一个预处理宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span>               取消宏的定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>             包含文件命令</span></span><br><span class="line">#include_next        与<span class="meta">#<span class="meta-keyword">include</span>相似, 但它有着特殊的用途</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>                  编译预处理中的条件命令, 相当于C语法中的<span class="meta-keyword">if</span>语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>               判断某个宏是否被定义, 若已定义, 执行随后的语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span>              与#<span class="meta-keyword">ifdef</span>相反, 判断某个宏是否未被定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span>                若#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>或前面的#<span class="meta-keyword">elif</span>条件不满足, 则执行#<span class="meta-keyword">elif</span>之后的语句, 相当于C语法中的<span class="meta-keyword">else</span>-<span class="meta-keyword">if</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>                与#<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>对应, 若这些条件不满足, 则执行#<span class="meta-keyword">else</span>之后的语句, 相当于C语法中的<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>               #<span class="meta-keyword">if</span>, #<span class="meta-keyword">ifdef</span>, #<span class="meta-keyword">ifndef</span>这些条件命令的结束标志.</span></span><br><span class="line">defined              与<span class="meta">#<span class="meta-keyword">if</span>, #<span class="meta-keyword">elif</span>配合使用, 判断某个宏是否被定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">line</span>                标志该语句所在的行号</span></span><br><span class="line">#                    将宏参数替代为以参数值为内容的字符窜常量</span><br><span class="line">##                   将两个相邻的标记(token)连接为一个单独的标记</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span>              说明编译器信息</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span>             显示编译警告信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span>               显示编译错误信息</span></span><br></pre></td></tr></table></figure><h1 id="2-define使用中的常见问题解析"><a href="#2-define使用中的常见问题解析" class="headerlink" title="2. #define使用中的常见问题解析"></a><strong>2. #define使用中的常见问题解析</strong></h1><h2 id="2-1-简单宏定义使用中出现的问题"><a href="#2-1-简单宏定义使用中出现的问题" class="headerlink" title="2.1 简单宏定义使用中出现的问题"></a>2.1 简单宏定义使用中出现的问题</h2><p> 在简单宏定义的使用中，当替换文本所表示的字符串为一个表达式时，容易引起误解和误用。如下例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2+2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=N*N;</span><br><span class="line">    <span class="built_in">printf</span>(“%d”,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出现问题：</strong></p><p>  在此程序中存在着宏定义命令，宏N代表的字符串是2+2，在程序中有对宏N的使用，一般同学在读该程序时，容易产生的问题是先求解N为2＋2＝4，然后在程序中计算a时使用乘法，即N<em>N=4</em>4=16，<strong>其实该题的结果为8，为什么结果有这么大的偏差?</strong></p><p><strong>问题解析：</strong></p><p>宏展开是在预处理阶段完成的，这个阶段把替换文本只是看作一个字符串，并不会有任何的计算发生，在展开时是在宏N出现的地方 只是简单地使用串2＋2来代替N，并不会增添任何的符号，所以对该程序展开后的结果是a=2+2*2+2，计算后=8，这就是宏替换的实质，如何写程序才能完成结果为16的运算呢？</p><p><strong>解决办法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*将宏定义写成如下形式*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N (2+2)</span></span><br><span class="line"><span class="comment">/*这样就可替换成(2+2)*(2+2)=16*/</span></span><br></pre></td></tr></table></figure><p><strong>总结：把 宏体 和 所有的宏变量 都用 括号括起来</strong></p><h2 id="2-2-带参数的宏定义出现的问题"><a href="#2-2-带参数的宏定义出现的问题" class="headerlink" title="2.2 带参数的宏定义出现的问题"></a><strong>2.2 带参数的宏定义出现的问题</strong></h2><p>  在带参数的宏定义的使用中，极易引起误解。例如我们需要做个宏替换能求任何数的平方，这就需要使用参数，以便在程序中用实际参数来替换宏定义中的参数。一般容易写成如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> area(x) x*x</span></span><br><span class="line"><span class="comment">/*这在使用中是很容易出现问题的，看如下的程序*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = area(<span class="number">2</span>+<span class="number">2</span>);  </span><br><span class="line">    <span class="built_in">printf</span>(“%d”,y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  按理说给的参数是2+2，所得的结果应该为4<em>4=16，但是错了，因为该程序的实际结果为8，仍然是没能遵循纯粹的简单替换的规则，又是先计算再替换 了，在这道程序里，2+2即为area宏中的参数，应该由它来替换宏定义中的x，即替换成2+2</em>2+2=8了。那如果遵循(1)中的解决办法，把2+2 括起来，即把宏体中的x括起来，是否可以呢？#define area(x) (x)<em>(x)，对于area(2+2)，替换为(2+2)</em>(2+2)=16，可以解决，但是对于area(2+2)/area(2+2)又会怎么样呢，有的学生一看到这道题马上给出结果，因为分子分母一样，又错了，还是忘了遵循先替换再计算的规则了，这道题替换后会变为 (2+2)<em>(2+2)/(2+2)</em>(2+2)即4<em>4/4</em>4按照乘除运算规则，结果为16/4<em>4=4</em>4=16，那应该怎么呢？解决方法是在整个宏体上再加一个括号，即#define  area(x) ((x)*(x))，不要觉得这没必要，没有它，是不行的。<br>  要想能够真正使用好宏定义，那么在读别人的程序时，一定要记住先将程序中对宏的使用全部替换成它所代表的字符串，不要自作主张地添加任何其他符号，完全展开后再进行相应的计算，就不会写错运行结果。</p><p>  如果是自己编程使用宏替换，则在使用简单宏定义时，当字符串中不只一个符号时，加上括号表现出优先级，如果是带参数的宏定义，则要给宏体中的每个参数加上括号，并在整个宏体上再加一个括号。看到这里，不禁要问，用宏定义这么麻烦，这么容易出错，可不可以摒弃它， 那让我们来看一下在C语言中用宏定义的好处吧。</p><p>如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> product(x)    x*x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> j,k;</span><br><span class="line">    j = product(i++);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"j="</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    k = product(++i);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"k="</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"i="</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次输出结果：</p><p>j=9;i=5;k=49;i=7</p><h1 id="3-宏定义的优点"><a href="#3-宏定义的优点" class="headerlink" title="3. 宏定义的优点"></a><strong>3. 宏定义的优点</strong></h1><p><strong>(1)  方便程序的修改</strong></p><p>  使用简单宏定义可用宏代替一个在程序中经常使用的常量，这样在将该常量改变时，不用对整个程序进行修改，只修改宏定义的字符串即可，而且当常量比较长时， 我们可以用较短的有意义的标识符来写程序，这样更方便一些。我们所说的常量改变不是在程序运行期间改变，而是在编程期间的修改，举一个大家比较熟悉的例子，圆周率π是在数学上常用的一个值，有时我们会用3.14来表示，有时也会用3.1415926等，这要看计算所需要的精度，如果我们编制的一个程序中 要多次使用它，那么需要确定一个数值，在本次运行中不改变，但也许后来发现程序所表现的精度有变化，需要改变它的值， 这就需要修改程序中所有的相关数值，这会给我们带来一定的不便，但如果使用宏定义，使用一个标识符来代替，则在修改时只修改宏定义即可，还可以减少输入 3.1415926这样长的数值多次的情况，我们可以如此定义 #define  pi  3.1415926，既减少了输入又便于修改，何乐而不为呢？</p><p><strong>(2) 提高程序的运行效率</strong></p><p>  使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。正如C语言中所讲，函数的使用可以使程序更加模块化，便于组织，而且可重复利用，但在发生函数调用时，需要保留调用函数的现场，以便子 函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间，如果子函数执行的操作比较多，这种转换时间开销可以忽 略，但如果子函数完成的功能比较少，甚至于只完成一点操作，如一个乘法语句的操作，则这部分转换开销就相对较大了，但使用带参数的宏定义就不会出现这个问 题，因为它是在预处理阶段即进行了宏展开，在执行时不需要转换，即在当地执行。宏定义可完成简单的操作，但复杂的操作还是要由函数调用来完成，而且宏定义所占用的目标代码空间相对较大。所以在使用时要依据具体情况来决定是否使用宏定义。</p><h1 id="4-define中的三个特殊符号：-，-，-和-do-while"><a href="#4-define中的三个特殊符号：-，-，-和-do-while" class="headerlink" title="4. define中的三个特殊符号：#，##，#@ 和 do while"></a><strong>4. define中的三个特殊符号：#，##，#@ 和 do while</strong></h1><ol><li>#define Conn(x,y) x##y</li><li>#define ToChar(x) #@x</li><li>#define ToString(x) #x</li></ol><h2 id="1-x-y-表示什么？表示x连接y。"><a href="#1-x-y-表示什么？表示x连接y。" class="headerlink" title="(1) \x##y** 表示什么？表示x连接y。**"></a><strong>(1) \</strong>x##y** 表示什么？表示x连接y。**</h2><p>  <strong>##符号会连接两个符号，从而产生新的符号(词法层次)**</strong>，即 “##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。 例如：**<br>  #define SIGN( x ) INT_##x<br>  int SIGN( 1 ); 宏被展开后将成为：int INT_1;</p><p>  <strong>举例说：</strong></p><p>​    int n = Conn(123,456);        /<em> 结果就是n=123456;    </em>/<br>​    char<em> str = Conn(“asdf”, “adf”);  /</em> 结果就是 str = “asdfadf”; */<br>​    #define TYPE1(type,name) type name_##type##<em>type<br>​    #define TYPE2(type,name) type name##</em>##type##_type<br>​    TYPE1(int, c); 转换为：int 　name_int_type ; (因为##号将后面分为 name_ 、type 、 _type三组，替换后强制连接)<br>​    TYPE2(int, d);转换为： int 　d_int_type ; (因为##号将后面分为 name、_、type 、_type四组，替换后强制连接)</p><h2 id="（2）再来看-x-，其实就是给x加上单引号，结果返回是一个const-char。-举例说："><a href="#（2）再来看-x-，其实就是给x加上单引号，结果返回是一个const-char。-举例说：" class="headerlink" title="（2）再来看****#@x**，其实就是给x加上单引号，结果返回是一个const char。**举例说："></a><strong>（2）再来看***</strong>*#@x*<strong>*</strong>，其实就是给x加上单引号，结果返回是一个const char。<strong>**举例说：</strong></h2><p>​    char a = ToChar(1);结果就是a=’1’;<br>​    做个越界试验char a = ToChar(123);结果就错了;<br>​    但是如果你的参数超过四个字符，编译器就给给你报错了！</p><p>​    error C2015: too many characters in constant  ：P</p><h2 id="3）最后看看-x，估计你也明白了，他是给x加双引号。即-符号把一个符号直接转换为字符串。"><a href="#3）最后看看-x，估计你也明白了，他是给x加双引号。即-符号把一个符号直接转换为字符串。" class="headerlink" title="(3）最后看看#x，估计你也明白了，他是给x加双引号。即** **#符号把一个符号直接转换为字符串。"></a>(3）最后看看#x，估计你也明白了，他是给x加双引号。即** **#符号把一个符号直接转换为字符串。</h2><p>​    也就是** #是“字符串化”的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串**</p><p>​    char* str = ToString(123132);就成了str=”123132”;</p><p>​    #define ERROR_LOG(module) fprintf(stderr,”error: “#module”\n”)</p><p>​    ERROR_LOG(“add”); 转换为 fprintf(stderr,”error: “add”\n”);<br>​    ERROR_LOG(devied =0); 转换为 fprintf(stderr,”error: devied=0\n”);</p><h2 id="4-宏定义用-do-while-0"><a href="#4-宏定义用-do-while-0" class="headerlink" title="(4) 宏定义用 do{ }while(0)"></a><strong>(4) 宏定义用 do{ }while(0)</strong></h2><p>复杂宏定义及do{}while(0)的使用</p><p>#define foo() do{}while(0)</p><p>采用这种方式是为了防范在使用宏过程中出现错误，主要有如下几点：</p><p>　　（1）空的宏定义避免warning:<br>　　#define foo() do{}while(0)<br>　　（2）存在一个独立的block，可以用来进行变量定义，进行比较复杂的实现。<br>　　（3）如果出现在判断语句过后的宏，这样可以保证作为一个整体来是实现：<br>　　　　  #define foo(x) \<br>　　　　　　　 action1(); \<br>　　　　　　 action2();<br>　　　　在以下情况下：<br>　　　　if(NULL == pPointer)<br> 　　　　　  foo();<br>　　　　就会出现action1和action2不会同时被执行的情况，而这显然不是程序设计的目的。<br>　　（4）以上的第3种情况用单独的{}也可以实现，但是为什么一定要一个do{}while(0)呢，看以下代码：<br>　　　　　　#define switch(x,y) {int tmp; tmp=”x”;x=y;y=tmp;}<br>　　　　　　if(x&gt;y)<br>　　　　　　　　switch(x,y);<br>　　　　　　else    //error, parse error before else<br>　　　　　　otheraction();</p><p>在把宏引入代码中，会多出一个分号，从而会报错。使用do{….}while(0) 把它包裹起来，成为一个独立的语法单元，从而不会与上下文发生混淆。同时因为绝大多数的编译器都能够识别do{…}while(0)这种无用的循环并进行优化，所以使用这种方法也不会导致程序的性能降低。</p><p>为了看起来更清晰，这里用一个简单点的宏来演示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_DELETE(p) do&#123; delete p; p = NULL&#125; while(0)</span></span><br></pre></td></tr></table></figure><p>假设这里去掉do…while(0),</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_DELETE(p) delete p; p = NULL;</span></span><br></pre></td></tr></table></figure><p>那么以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != p) SAFE_DELETE(p)</span><br><span class="line"><span class="keyword">else</span> ...<span class="keyword">do</span> sth...</span><br></pre></td></tr></table></figure><p>就有两个问题：</p><ul><li>1) 因为if分支后有两个语句，else分支没有对应的if，编译失败</li><li>2) 假设没有else, SAFE_DELETE中的第二个语句无论if测试是否通过，会永远执行。</li></ul><p>你可能发现，为了避免这两个问题，我不一定要用这个令人费解的do…while, 我直接用{}括起来就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_DELETE(p) &#123; delete p; p = NULL;&#125;</span></span><br></pre></td></tr></table></figure><p>的确，这样的话上面的问题是不存在了，但是我想对于C++程序员来讲，在每个语句后面加分号是一种约定俗成的习惯，这样的话，以下代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">NULL</span> != p) SAFE_DELETE(p);</span><br><span class="line"><span class="keyword">else</span> ...<span class="keyword">do</span> sth...</span><br></pre></td></tr></table></figure><p>其else分支就无法通过编译了（原因同上），所以采用do…while(0)是做好的选择了。也许你会说，我们代码的习惯是在每个判断后面加上{}, 就不会有这种问题了，也就不需要do…while了，如：<br>if(…)<br>{<br>}<br>else<br>{<br>}</p><p>现有一个例子：#define PROJECT_LOG(level,arg) \ dosomething();\ if (level &lt;= PROJECT_LOG_get_level()) \ PROJECT_LOG_wrapper_##level(arg);</p><p>现在假设有以下应用，现有一个例子：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_LOG(level,arg) \</span></span><br><span class="line">    dosomething();\</span><br><span class="line">    <span class="keyword">if</span> (level &lt;= PROJECT_LOG_get_level()) \</span><br><span class="line">        PROJECT_LOG_wrapper_<span class="meta">##level(arg);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">现在假设有以下应用：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（L==<span class="number">1</span>）</span><br><span class="line">    PROJECT_LOG(L,<span class="string">"AAA"</span>);</span><br><span class="line"></span><br><span class="line">宏转开为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>（L==<span class="number">1</span>）</span><br><span class="line">    dosomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> &lt;= PROJECT_LOG_get_level())</span><br><span class="line">        PROJECT_LOG_wrapper_1(<span class="string">"AAA"</span>); ;</span><br><span class="line"></span><br><span class="line">显然<span class="keyword">if</span>（L==<span class="number">1</span>）只管到dosomething();而后面的</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &lt;= PROJECT_LOG_get_level())</span><br><span class="line">    PROJECT_LOG_wrapper_1(<span class="string">"AAA"</span>); ;</span><br><span class="line"></span><br><span class="line">则成了独立的语句。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">假如使用<span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>（<span class="number">0</span>）语句块，进行宏定义：</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJECT_LOG(level,arg)do&#123; \</span></span><br><span class="line">    dosomething();\</span><br><span class="line">    <span class="keyword">if</span> (level &lt;= PROJECT_LOG_get_level()) \</span><br><span class="line">        PROJECT_LOG_wrapper_<span class="meta">##level(arg); \</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">上述应用转开后为：</span><br><span class="line"><span class="keyword">if</span>（L==<span class="number">1</span>）</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    dosomething();</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span>&lt;= PROJECT_LOG_get_level())</span><br><span class="line">        PROJECT_LOG_wrapper_1(<span class="string">"AAA"</span>);</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">这样避免了意外的麻烦。OK现在明白了很多C程序中奇怪的<span class="keyword">do</span>&#123;&#125;<span class="keyword">while</span>（<span class="number">0</span>）宏定义了吧</span><br></pre></td></tr></table></figure><p>使用示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT1(a,b)        \</span></span><br><span class="line">    &#123;                  \</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print a\n"</span>); \</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print b\n"</span>); \</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>      PRINT2(a, b)      \</span></span><br><span class="line">  <span class="keyword">do</span>&#123;               \</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print a\n"</span>); \</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"print b\n"</span>); \</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>)  </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT(a) \</span></span><br><span class="line">    <span class="keyword">do</span>&#123;\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s: %d\n"</span>,#a,a);\</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d: %d\n"</span>,a,a);\</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE1(type,name)   type name_##type##_type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE2(type,name)   type name##_##type##_type</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR_LOG(module)   fprintf(stderr,<span class="meta-string">"error: "</span>#module<span class="meta-string">"\n"</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">19</span>;</span><br><span class="line">    TYPE1(<span class="keyword">int</span>, c);</span><br><span class="line">    ERROR_LOG(<span class="string">"add"</span>);</span><br><span class="line">    name_int_type = a;</span><br><span class="line">    TYPE2(<span class="keyword">int</span>, d);</span><br><span class="line">    d_int_type = a;</span><br><span class="line"> </span><br><span class="line">    PRINT(a);</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)</span><br><span class="line">    &#123;</span><br><span class="line">        PRINT1(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PRINT2(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-常用的一些宏定义"><a href="#5-常用的一些宏定义" class="headerlink" title="5. 常用的一些宏定义"></a><strong>5. 常用的一些宏定义</strong></h1><h2 id="1-防止一个头文件被重复包含"><a href="#1-防止一个头文件被重复包含" class="headerlink" title="1. 防止一个头文件被重复包含"></a>1. 防止一个头文件被重复包含</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BODYDEF_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BODYDEF_H </span></span><br><span class="line"> <span class="comment">//头文件内容 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="2-得到指定地址上的一个字节或字"><a href="#2-得到指定地址上的一个字节或字" class="headerlink" title="2. 得到指定地址上的一个字节或字"></a>2. 得到指定地址上的一个字节或字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_B( x ) ( *( (byte *) (x) ) ) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_W( x ) ( *( (word *) (x) ) )</span></span><br></pre></td></tr></table></figure><p>用法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_B(x) (*((byte*)(x)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM_W(x) (*((WORD*)(x)))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bTest = <span class="number">0x123456</span>;</span><br><span class="line">    byte m = MEM_B((&amp;bTest));<span class="comment">/*m=0x56*/</span></span><br><span class="line">    <span class="keyword">int</span> n = MEM_W((&amp;bTest));<span class="comment">/*n=0x3456*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-得到一个field在结构体-struct-中的偏移量"><a href="#3-得到一个field在结构体-struct-中的偏移量" class="headerlink" title="3. 得到一个field在结构体(struct)中的偏移量"></a>3. 得到一个field在结构体(struct)中的偏移量</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OFFSETOF( type, field ) ( (size_t) &amp;(( type *) 0)-&gt; field )</span></span><br></pre></td></tr></table></figure><p> <strong>请参考文章：详解**</strong>写宏定义：得到一个field在结构体（struct type）中的偏移量**。</p><h2 id="4-得到一个结构体中field所占用的字节数"><a href="#4-得到一个结构体中field所占用的字节数" class="headerlink" title="4. 得到一个结构体中field所占用的字节数"></a>4. 得到一个结构体中field所占用的字节数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FSIZ( type, field ) sizeof( ((type *) 0)-&gt;field )</span></span><br></pre></td></tr></table></figure><h2 id="5-得到一个变量的地址（word宽度）"><a href="#5-得到一个变量的地址（word宽度）" class="headerlink" title="5. 得到一个变量的地址（word宽度）"></a>5. 得到一个变量的地址（word宽度）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B_PTR( var ) ( (byte *) (void *) &amp;(var) ) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> W_PTR( var ) ( (word *) (void *) &amp;(var) )</span></span><br></pre></td></tr></table></figure><h2 id="6-将一个字母转换为大写"><a href="#6-将一个字母转换为大写" class="headerlink" title="6. 将一个字母转换为大写"></a>6. 将一个字母转换为大写</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define UPCASE( c ) ( ((c) &gt;= ''a'' &amp;&amp; (c) &lt;= ''z'') ? ((c) - 0x20) : (c) )</span><br></pre></td></tr></table></figure><h2 id="7-判断字符是不是10进值的数字"><a href="#7-判断字符是不是10进值的数字" class="headerlink" title="7. 判断字符是不是10进值的数字"></a>7. 判断字符是不是10进值的数字</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define DECCHK( c ) ((c) &gt;= ''0'' &amp;&amp; (c) &lt;= ''9'')</span><br></pre></td></tr></table></figure><h2 id="8-判断字符是不是16进值的数字"><a href="#8-判断字符是不是16进值的数字" class="headerlink" title="8. 判断字符是不是16进值的数字"></a>8. 判断字符是不是16进值的数字</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define HEXCHK( c ) ( ((c) &gt;= ''0'' &amp;&amp; (c) &lt;= ''9'') ||((c) &gt;= ''A'' &amp;&amp; (c) &lt;= ''F'') ||((c) &gt;= ''a'' &amp;&amp; (c) &lt;= ''f'') )</span><br></pre></td></tr></table></figure><h2 id="9-防止溢出的一个方法"><a href="#9-防止溢出的一个方法" class="headerlink" title="9. 防止溢出的一个方法"></a>9. 防止溢出的一个方法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INC_SAT( val ) (val = ((val)+1 &gt; (val)) ? (val)+1 : (val))</span></span><br></pre></td></tr></table></figure><h2 id="10-返回数组元素的个数"><a href="#10-返回数组元素的个数" class="headerlink" title="10. 返回数组元素的个数"></a>10. 返回数组元素的个数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARR_SIZE( a ) ( sizeof( (a) ) / sizeof( (a[0]) ) )</span></span><br></pre></td></tr></table></figure><h1 id="6-宏的使用场景"><a href="#6-宏的使用场景" class="headerlink" title="6. 宏的使用场景"></a>6. 宏的使用场景</h1><h2 id="1-打印错误信息"><a href="#1-打印错误信息" class="headerlink" title="1. 打印错误信息"></a>1. 打印错误信息</h2><p>如果程序的执行必须要求某个宏被定义，在检查到宏没有被定义是可以使用#error，#warning打印错误（警告）信息，如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __unix__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"This section will only work on UNIX systems"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>只有<strong>unix</strong>宏被定义，程序才能被正常编译。</p><h2 id="2-方便调试"><a href="#2-方便调试" class="headerlink" title="2. 方便调试"></a>2. 方便调试</h2><p><strong>FILE, </strong>LINE, __FUNCTION是由编译器预定义的宏，其分别代表当前代码所在的文件名，行号，以及函数名。可以在代码中加入如下语句来跟踪代码的执行情况：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(err) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"%s(%d)-%s\n"</span>,__FILE_<span class="number">_</span>,__LINE_<span class="number">_</span>,__FUNCTION_<span class="number">_</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-C-C-的混合编程"><a href="#3-C-C-的混合编程" class="headerlink" title="3. C/C++的混合编程"></a>3. C/C++的混合编程</h2><p>​    函数int foo(int a, int b);<br>​    在C语言的该函数在编译器编译后在库中的名字为_foo，而C++中该函数被编译后在库中的名字为_foo_int_int（为实现函数重载所做的改变）。如果C++中需要使用C编译后的库函数，则会提示找不到函数，因为符号名不匹配。C++中使用extern “C”解决该问题，说明要引用的函数是由C编译的，应该按照C的命名方式去查找符号。<br>​    如果foo是C编译的库，如果要在C++中使用foo，需要加如下声明，其中__cplusplus是c++编译器预定义的宏，说明该文件是被C++编译器编译，此时引用C的库函数，就需要加extern “C”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> “C” &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">   <span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="4-使用宏打印-Log-使用示例"><a href="#4-使用宏打印-Log-使用示例" class="headerlink" title="4. 使用宏打印 Log 使用示例"></a>4. 使用宏打印 Log 使用示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    ERROR_ONE,    <span class="comment">// 0</span></span><br><span class="line">    ERROR_TWO,</span><br><span class="line">    ERROR_THREE,</span><br><span class="line">    ERROR_END</span><br><span class="line">&#125;E_ERROR_CODE;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> g_error_statistics[ERROR_END] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* LOG 打印， # 直接常亮字符串替换 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PRINT(ERROR_CODE)                                             \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                                      \</span><br><span class="line">    g_error_statistics[ERROR_CODE]++;                                     \</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s : %d], error is %s\n"</span>, __FILE__, __LINE__, #ERROR_CODE);  \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* ERROR 公共前缀，传参时省略的写法, ## 直接展开拼接 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PRINT_2(CODE)                                                        \</span></span><br><span class="line"><span class="keyword">do</span> &#123;                                                                             \</span><br><span class="line">    g_error_statistics[ERROR_ ## CODE]++;                                        \</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s : %d], error is %s\n"</span>, __FILE__, __LINE__, <span class="string">"ERROR_"</span> #CODE);      \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LOG_PRINT(ERROR_TWO);</span><br><span class="line">    LOG_PRINT_2(ONE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ERROR_END; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error %u statistics is %lu \n"</span>, i, g_error_statistics[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写文件记录log</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">write_log</span> <span class="params">(FILE* pFile, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;  </span><br><span class="line">    va_list arg;  </span><br><span class="line">    <span class="keyword">int</span> done;  </span><br><span class="line">  </span><br><span class="line">    va_start (arg, format);  </span><br><span class="line">    <span class="comment">//done = vfprintf (stdout, format, arg);  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">time_t</span> time_log = time(<span class="literal">NULL</span>);  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span>* <span class="title">tm_log</span> = <span class="title">localtime</span>(&amp;<span class="title">time_log</span>);</span>  </span><br><span class="line">    <span class="built_in">fprintf</span>(pFile, <span class="string">"%04d-%02d-%02d %02d:%02d:%02d "</span>, tm_log-&gt;tm_year + <span class="number">1900</span>, tm_log-&gt;tm_mon + <span class="number">1</span>, tm_log-&gt;tm_mday, tm_log-&gt;tm_hour, tm_log-&gt;tm_min, tm_log-&gt;tm_sec);  </span><br><span class="line">  </span><br><span class="line">    done = <span class="built_in">vfprintf</span> (pFile, format, arg);  </span><br><span class="line">    va_end (arg);  </span><br><span class="line">  </span><br><span class="line">    fflush(pFile);  </span><br><span class="line">    <span class="keyword">return</span> done;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    FILE* pFile = fopen(<span class="string">"123.txt"</span>, <span class="string">"a"</span>);  </span><br><span class="line">    write_log(pFile, <span class="string">"%s %d %f\n"</span>, <span class="string">"is running"</span>, <span class="number">10</span>, <span class="number">55.55</span>);  </span><br><span class="line">    fclose(pFile);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译运行：</span></span><br><span class="line"><span class="comment">gcc log.c -o log</span></span><br><span class="line"><span class="comment">./log</span></span><br><span class="line"><span class="comment">返回结果：cat 123.txt</span></span><br><span class="line"><span class="comment">2016-12-13 13:10:02 is running 10 55.550000</span></span><br><span class="line"><span class="comment">2016-12-13 13:10:04 is running 10 55.550000</span></span><br><span class="line"><span class="comment">2016-12-13 13:10:04 is running 10 55.550000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG_WRITE(fmt,args)  DBG_Write_Log(strrchr(__FILE__, <span class="meta-string">'\\'</span>)+1, __LINE__, fmt,##args);</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DBG_Write_Log</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">int</span> line, <span class="keyword">char</span>* fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    FILE* fp;</span><br><span class="line">    va_list argp;</span><br><span class="line">    <span class="keyword">char</span>* para;</span><br><span class="line">    <span class="keyword">char</span> logbuf[<span class="number">512</span>];</span><br><span class="line">    <span class="keyword">char</span> timeStr[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">time_t</span> tt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">local</span>;</span></span><br><span class="line">    tt = time(<span class="literal">NULL</span>);</span><br><span class="line">    local = localtime(&amp;tt);</span><br><span class="line">    strftime(timeStr, <span class="number">20</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>, local);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">sprintf</span>(logbuf, <span class="string">"[%s] %s[%d]"</span>, timeStr, filename, line);</span><br><span class="line"> </span><br><span class="line">    va_start(argp, fmt);</span><br><span class="line">    <span class="built_in">vsprintf</span>(logbuf+<span class="built_in">strlen</span>(logbuf), fmt, argp);</span><br><span class="line">    va_end(argp);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">fprintf</span>(fp, logbuf);</span><br><span class="line">    fclose(fp);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(logbuf);   </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DBG_WRITE(<span class="string">"test log [%d]system[%s][%d]\n"</span>, <span class="number">1234</span>,<span class="string">"add by test"</span>, <span class="number">5</span>);</span><br><span class="line">    DBG_Write_Log(<span class="built_in">strrchr</span>(__FILE__,<span class="string">'\\'</span>)+<span class="number">1</span>,  __LINE__, <span class="string">"%s %d\n"</span>,  <span class="string">"add by test"</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几种 log 打印 printf 函数 的 宏定义 示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lU_DEBUG_PREFIX <span class="meta-string">"##########"</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_DEBUG_CMD 0x01</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_DEBUG_DATA 0x02</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_DEBUG_ERROR 0x04</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_PRINTF_cmd(msg...) do&#123;<span class="meta-keyword">if</span>(g_lu_debugs_level &amp; LU_DEBUG_CMD)printf(lU_DEBUG_PREFIX msg);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_PRINTF_data(msg...) do&#123;<span class="meta-keyword">if</span>(g_lu_debugs_level &amp; LU_DEBUG_DATA)printf(lU_DEBUG_PREFIX msg);&#125;while(0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LU_PRINTF_error(msg...) do&#123;<span class="meta-keyword">if</span>(g_lu_debugs_level &amp; LU_DEBUG_ERROR)printf(lU_DEBUG_PREFIX msg);&#125;while(0)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lu_printf(level, msg...) LU_PRINTF_##level(msg)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lu_printf2(...) printf(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lu_printf3(...) lu_printf(__VA_ARGS__)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lu_printf4_format</span><span class="params">(<span class="keyword">int</span> prio, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lu_printf4(prio, fmt...) lu_printf4_format(prio, fmt)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_lu_debugs_level; <span class="comment">//控制打印等级的全局开关</span></span><br><span class="line"><span class="comment">//lu_printf 类似内核的分等级打印宏，根据g_lu_debugs_level和输入的第一个标号名来决定该句打印是否输出。</span></span><br><span class="line"><span class="comment">//lu_printf3 等同于 lu_printf</span></span><br><span class="line"><span class="comment">//lu_printf2 等同于 printf</span></span><br><span class="line"><span class="comment">//lu_printf4 等同于 lu_printf4_format，作用是把输入的第一个整型参数用&lt;val&gt;的格式打印出来</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_lu_debugs_level |= LU_DEBUG_CMD | LU_DEBUG_DATA | LU_DEBUG_ERROR;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_lu_debugs_level = %p\n"</span>, g_lu_debugs_level);</span><br><span class="line">    lu_printf(cmd,<span class="string">"this is cmd\n"</span>);</span><br><span class="line">    lu_printf(data,<span class="string">"this is data\n"</span>);</span><br><span class="line">    lu_printf(error,<span class="string">"this is error\n"</span>);</span><br><span class="line">    g_lu_debugs_level &amp;= ~(LU_DEBUG_CMD | LU_DEBUG_DATA);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_lu_debugs_level = %p\n"</span>, g_lu_debugs_level);</span><br><span class="line">    lu_printf(cmd,<span class="string">"this is cmd\n"</span>);</span><br><span class="line">    lu_printf(data,<span class="string">"this is data\n"</span>);</span><br><span class="line">    lu_printf(error,<span class="string">"this is error\n"</span>);</span><br><span class="line">    lu_printf2(<span class="string">"aa%d,%s,%dbbbbb\n"</span>, <span class="number">20</span>, <span class="string">"eeeeeee"</span>, <span class="number">100</span>);</span><br><span class="line">    g_lu_debugs_level |= LU_DEBUG_CMD | LU_DEBUG_DATA | LU_DEBUG_ERROR;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"g_lu_debugs_level = %p\n"</span>, g_lu_debugs_level);</span><br><span class="line">    lu_printf3(cmd,<span class="string">"this is cmd \n"</span>);</span><br><span class="line">    lu_printf3(data,<span class="string">"this is data\n"</span>);</span><br><span class="line">    lu_printf3(error,<span class="string">"this is error\n"</span>);</span><br><span class="line">    lu_printf4(<span class="number">0</span>,<span class="string">"luther %s ,%d ,%d\n"</span>, <span class="string">"gliethttp"</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lu_printf4_format</span><span class="params">(<span class="keyword">int</span> prio, <span class="keyword">const</span> <span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_BUF_SIZE (4096)</span></span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="keyword">char</span> buf[LOG_BUF_SIZE];</span><br><span class="line"> </span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    vsnprintf(buf, LOG_BUF_SIZE, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&lt;%d&gt;: %s"</span>, prio, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------------------\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENTER() LOGD(<span class="meta-string">"enter into %s"</span>, __FUNCTION__)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...) ((void)LOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__))</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(priority, tag, ...) \</span></span><br><span class="line">    LOG_PRI(ANDROID_##priority, tag, __VA_ARGS__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PRI(priority, tag, ...) \</span></span><br><span class="line">    android_printLog(priority, tag, __VA_ARGS__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> android_printLog(prio, tag, fmt...) \</span></span><br><span class="line">    __android_log_print(prio, tag, fmt)</span><br></pre></td></tr></table></figure><p>使用示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Define Log print macro */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyLog(DebugLevel, format, ...)   \</span></span><br><span class="line">        <span class="keyword">do</span>&#123;  \</span><br><span class="line">            <span class="keyword">switch</span> (DebugLevel)  \</span><br><span class="line">            &#123;  \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:  \</span><br><span class="line">                <span class="built_in">printf</span>(format, ##__VA_ARGS__);  \</span><br><span class="line">                <span class="keyword">break</span>;  \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: \</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Function: "</span>__FUNCTION__<span class="string">", Line: %d, ---&gt; "</span>format<span class="string">""</span>, __LINE__, ##__VA_ARGS__); \</span><br><span class="line">                <span class="keyword">break</span>;  \</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:  \</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"File: "</span>__FILE__<span class="string">", Function: "</span>__FUNCTION__<span class="string">", Line: %d, ---&gt; "</span>format<span class="string">""</span>, __LINE__, ##__VA_ARGS__); \</span><br><span class="line">                <span class="keyword">break</span>; \</span><br><span class="line">            <span class="keyword">default</span>:   \</span><br><span class="line">                <span class="keyword">break</span>;  \</span><br><span class="line">            &#125;   \</span><br><span class="line">        &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyLog(<span class="number">1</span>, <span class="string">"Simple Log print!\r\n"</span>);</span><br><span class="line">    MyLog(<span class="number">2</span>, <span class="string">"Satndard Log display!\r\n"</span>);</span><br><span class="line">    MyLog(<span class="number">3</span>, <span class="string">"Detail Log view!\r\n"</span>);</span><br><span class="line"> </span><br><span class="line">    MyLog(<span class="number">1</span>, <span class="string">"If debug level is not equal 1,2 or 3 that log is invisible, such as next line :\r\n"</span>);</span><br><span class="line">    MyLog(<span class="number">6</span>, <span class="string">"I am invisible log!\r\n"</span>);</span><br><span class="line">    MyLog(<span class="number">1</span>, <span class="string">"Now, I think you have understood how to use MyLog macro.\r\n"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG <span class="meta-string">"DEBUG"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TRACE <span class="meta-string">"TRACE"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERROR <span class="meta-string">"ERROR"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO  <span class="meta-string">"INFOR"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_CRIT  <span class="meta-string">"CRTCL"</span>  </span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(level, format, ...) \  </span></span><br><span class="line">    <span class="keyword">do</span> &#123; \  </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[%s|%s@%s,%d] "</span> format <span class="string">"\n"</span>, \  </span><br><span class="line">            level, __func__, __FILE__, __LINE__, ##__VA_ARGS__ ); \  </span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    LOG(LOG_DEBUG, <span class="string">"a=%d"</span>, <span class="number">10</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define DBG(format, ...) fprintf(stderr, "[%s|%s@%s,%d] " format "\n", APP_NAME, __FUNCTION__, __FILE__, __LINE__, ##__VA_ARGS__ );  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(level, format, ...) \</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[%s|%s@%s,%d] "</span> format <span class="string">"/n"</span>, \</span><br><span class="line">        level, __func__, __FILE__, __LINE__, ##__VA_ARGS__ ); \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>使用示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(fmt, ...) do \</span></span><br><span class="line">&#123;                        \</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%s][%s][%s:%d] %s:"</span>fmt<span class="string">"\n"</span>, __DATE__, __TIME__, __FILE__, __LINE__, __FUNCTION__, ##__VA_ARGS__); \</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* str = <span class="string">"this is test string"</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"> </span><br><span class="line">    LOG(<span class="string">"test string : %s . test num: %d"</span>, str, num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关宏定义的经验与技巧-简化代码-增强Log：<a href="http://blog.csdn.net/zh_2608/article/details/46646385" target="_blank" rel="noopener">http://blog.csdn.net/zh_2608/article/details/46646385</a></p><p>C语言日志处理：<a href="https://www.cnblogs.com/274914765qq/p/4589929.html" target="_blank" rel="noopener">https://www.cnblogs.com/274914765qq/p/4589929.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;宏-替换-发生的时机&quot;&gt;&lt;a href=&quot;#宏-替换-发生的时机&quot; class=&quot;headerlink&quot; title=&quot;宏 替换 发生的时机&quot;&gt;&lt;/a&gt;&lt;strong&gt;宏 替换 发生的时机&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;   为了能够真正理解#define的作用
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="c++" scheme="https://www.ljjyy.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>QxOrm使用教程(ORM for C++ 对象关系映射)</title>
    <link href="https://www.ljjyy.com/archives/2023/05/100647.html"/>
    <id>https://www.ljjyy.com/archives/2023/05/100647.html</id>
    <published>2023-05-16T04:00:00.000Z</published>
    <updated>2023-06-20T01:03:11.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1><p>ORM 全称是 Object Relational Mapping（对象关系映射），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。</p><p>面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。</p><p>简单理解，ORM 就是在数据库和对象之间作了一个映射：</p><ul><li><p>数据库的表（table） –&gt; 类（class）</p></li><li><p>记录（record，行数据）–&gt; 对象（object）</p></li><li><p>字段（field）–&gt; 对象的属性（attribute）</p></li></ul><h2 id="ORM-的优缺点"><a href="#ORM-的优缺点" class="headerlink" title="ORM 的优缺点"></a>ORM 的优缺点</h2><p><strong>优点：</strong></p><ul><li>ORM 提供了一种面向对象的查询语言，这使得开发者可以专注于对象模型，而不必关心数据库结构或 SQL 语义。</li><li>ORM 提供了大量的服务，开发者只需要关注业务逻辑，而不是重复的 CRUD（Create、Read、Update、Delete）操作，这可以减少大量的代码。</li><li>ORM 将迫使你使用 MVC 风格，这通常会使代码更加简洁、更容易理解。</li><li>ORM 有现成的工具，很多功能可以自动完成，比如预处理、事务等。</li><li>ORM 对数据库进行了抽象，因此从一种数据库切换到另一种（例如：从 MySQL  到 PostgreSQL）会很容易。</li></ul><p><strong>缺点：</strong></p><ul><li>无论是什么 ORM 框架，都需要花费相当大的精力去学习和理解。</li><li>ORM 抽象掉了数据库层，开发者无法了解底层数据库（和 SQL）的相关操作。</li><li>对于复杂的查询，ORM 要么难以实现，要么性能不如原生的 SQL。</li></ul><h1 id="主流的-ORM-框架"><a href="#主流的-ORM-框架" class="headerlink" title="主流的 ORM 框架"></a>主流的 ORM 框架</h1><p>目前为止，C++ 中主流的 ORM 框架有以下几个：</p><ul><li>LiteSQL：<a href="https://litesql.org/" target="_blank" rel="noopener">https://litesql.org/</a></li><li>ODB：<a href="https://www.codesynthesis.com/products/odb/" target="_blank" rel="noopener">https://www.codesynthesis.com/products/odb/</a></li><li>QxOrm：<a href="https://www.qxorm.com/qxorm_en/home.html" target="_blank" rel="noopener">https://www.qxorm.com/qxorm_en/home.html</a></li><li>Wt::Dbo：<a href="https://www.webtoolkit.eu/wt/doc/tutorial/dbo.html" target="_blank" rel="noopener">https://www.webtoolkit.eu/wt/doc/tutorial/dbo.html</a></li></ul><p>其中，LiteSQL 和 ODB 不依赖于特定的框架，而 QxOrm 依赖于 Qt，Wt::Dbo 依赖于 Wt。</p><p>综合考虑，如果是纯 C++ 开发，可以选择使用 ODB。它拥有大量的用户群体，（相比 LiteSQL）技术支持好，（相比 QxOrm）编译时间短，（相比 Wt::Dbo）提供了更多的特性，更重要的是它易于使用，并且提供了很全面的文档。</p><p>当然，如果是 Qt 开发，也可以选择使用 QxOrm。它几乎支持所有的数据库，并且也有良好的文档。除此之外，它还提供了一个图形编辑器 - QxEntityEditor，可以很方便地以图形方式来管理数据模型。</p><h1 id="关于-QxOrm"><a href="#关于-QxOrm" class="headerlink" title="关于 QxOrm"></a>关于 QxOrm</h1><p>QxOrm 是一个 C++ 库，旨在为 C++/Qt 开发人员提供对象关系映射（ORM）功能（类似于 Java 中的 Hibernate，.Net 中的 NHibernate）。</p><ul><li><strong>主页：</strong><a href="http://www.qxorm.com/qxorm_en/home.html" target="_blank" rel="noopener">http://www.qxorm.com/qxorm_en/home.html</a></li><li><strong>下载：</strong><a href="http://www.qxorm.com/qxorm_en/download.html" target="_blank" rel="noopener">http://www.qxorm.com/qxorm_en/download.html</a></li><li><strong>手册：</strong><a href="http://www.qxorm.com/qxorm_en/manual.html" target="_blank" rel="noopener">http://www.qxorm.com/qxorm_en/manual.html</a></li><li><strong>在线类文档：</strong><a href="http://www.qxorm.com/doxygen/html/index.html" target="_blank" rel="noopener">http://www.qxorm.com/doxygen/html/index.html</a></li><li><strong>GitHub：</strong><a href="https://github.com/QxOrm/QxOrm" target="_blank" rel="noopener">https://github.com/QxOrm/QxOrm</a></li></ul><p>其主要特性包括：</p><ul><li>持久性：支持最常见的数据库，如 SQLite、MySQL、PostgreSQL、Oracle、MS SQL Server、MongoDB（具有 1-1、1-n、n-1 和 n-n 关系）。</li><li>序列化：JSON、二进制和 XML 格式。</li><li>反射（或内省）：动态访问类定义、检索属性和调用类方法。</li><li>HTTP Web Server：独立的多线程 HTTP 1.1 web 服务器（支持 SSL/TLS、持久连接、cookie、会话、分块响应、URL 分发器/路由）。</li><li>JSON API：与 C++/Qt 以外的其他技术的互操作性（REST web 服务、QML 应用程序、脚本语言）。</li></ul><p>默认情况下，QxOrm 库只依赖 QtCore 和 QtSql 模块。如果启用 QxOrm HTTP web server 特性，那么还将依赖于 QtNetwork 模块。除此之外，有些特性还需要依赖 boost（默认禁用）。</p><h1 id="编译-QxOrm"><a href="#编译-QxOrm" class="headerlink" title="编译 QxOrm"></a>编译 QxOrm</h1><p>进入 QxOrm <a href="https://github.com/QxOrm/QxOrm/releases" target="_blank" rel="noopener">下载页面</a> ，选择最新版本进行下载，目前最新为 <a href="https://github.com/QxOrm/QxOrm/archive/1.4.8.zip" target="_blank" rel="noopener">QxOrm 1.4.8</a> 。下载完成之后，将 QxOrm 的 zip 包解压缩。</p><p>对一些重点目录的介绍一下：</p><ul><li><strong>doc：</strong>介绍 QxOrm 的相关文档。</li><li><strong>include：</strong>包含了 QxOrm 的所有头文件（.h）。</li><li><strong>lib：</strong>库目录，用于存放编译后的 .lib 和 .dll 文件。</li><li><strong>src：</strong>包含了 QxOrm 的所有源文件（.cpp）。</li><li><strong>test：</strong>包含了 QxOrm 相关的示例程序。</li></ul><p>有关 QxOrm 的各个历史版本以及各版本的一些特性，都记录在 changes.txt 文件中，感兴趣的话可以大概看一看。</p><p>由于源码包中提供了 CMakeLists.txt、QxOrm.pro 和 QxOrm.sln，所以无论你使用 CMake 还是 Qt Creator，亦或者是 Visual Studio，都能够快速编译 QxOrm。</p><p>以 Qt Creator 为例，打开 QxOrm.pro 并进行编译。成功之后，对应的库会生成到 QxOrm/lib 目录下。</p><p>默认情况下，这会生成共享库（动态链接库）；倘若要生成静态链接库，需要启用 QxOrm.pri 中的 _QX_STATIC_BUILD 编译选项。</p><h1 id="QxOrm-使用"><a href="#QxOrm-使用" class="headerlink" title="QxOrm 使用"></a>QxOrm 使用</h1><p>QxOrm 几乎支持所有的主流数据库，比如 SQLite、MySQL、PostgreSQL、Oracle、MS SQL Server、MongoDB 等。为了快速了解它的用法，我们以 SQLite 为例，来介绍一些常见的数据库操作（例如：增删改查）。</p><p>先来创建一个名为 User 的项目，项目所在目录与 QxOrm 解压目录同级，可以根据自己的需要调整。项目完整源代码<a href="https://github.com/myhhub/QxOrm-project" target="_blank" rel="noopener">下载地址</a>。</p><h2 id="项目文件"><a href="#项目文件" class="headerlink" title="项目文件"></a><strong>项目文件</strong></h2><p>项目文件由 User.pro 表示，它包含了项目中所有的文件列表（头文件、源文件），以及所有依赖项（QxOrm.pri 文件包含了与 Qt 和 boost 库的所有依赖项）：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># QxOrm 的通用配置，包含了 Qt 和 boost 库依赖</span></span><br><span class="line">include($<span class="variable">$PWD</span>/<span class="built_in">..</span>/<span class="built_in">..</span>/QxOrm/QxOrm.pri)</span><br><span class="line"></span><br><span class="line">CONFIG += console</span><br><span class="line">DEFINES += _BUILDING_USER</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预编译头文件</span></span><br><span class="line">!contains(DEFINES, _QX_NO_PRECOMPILED_HEADER) &#123;</span><br><span class="line">    PRECOMPILED_HEADER = precompiled.h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># QxOrm 库相关配置</span></span><br><span class="line">INCLUDEPATH += $<span class="variable">$PWD</span>/<span class="built_in">..</span>/<span class="built_in">..</span>/QxOrm/include</span><br><span class="line">LIBS += -L$<span class="variable">$PWD</span>/<span class="built_in">..</span>/<span class="built_in">..</span>/QxOrm/lib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置生成的目标名称、添加依赖库</span></span><br><span class="line">CONFIG(debug, debug|release) &#123;</span><br><span class="line">    TARGET = Userd</span><br><span class="line">    LIBS += -lQxOrmd</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TARGET = User</span><br><span class="line">    LIBS += -lQxOrm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件列表</span></span><br><span class="line">HEADERS += \</span><br><span class="line">    precompiled.h \</span><br><span class="line">    export.h \</span><br><span class="line">    user.h</span><br><span class="line"></span><br><span class="line">SOURCES += \</span><br><span class="line">    main.cpp \</span><br><span class="line">    user.cpp</span><br></pre></td></tr></table></figure><p>这里有一个重要的常量 - _BUILDING_USER，通过它可以知道项目是否正在编译（参见 export.h 和 Windows 下的 DLL 机制 - 导入或导出函数、类…）。</p><h2 id="export-h-文件"><a href="#export-h-文件" class="headerlink" title="export.h 文件"></a>export.h 文件</h2><p>如果使用过 DLL，相信对此文件并不陌生，它可以管理类、函数 … 的导出/导入。</p><p>QxOrm 使用了相同的机制来提供某些功能：因此对于使用 QxOrm 库的所有项目，export.h 文件是必需的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXPORT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _BUILDING_USER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_DLL_EXPORT  QX_DLL_EXPORT_HELPER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_DLL_EXPORT  QX_DLL_IMPORT_HELPER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _BUILDING_USER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QX_REGISTER_HPP_USER  QX_REGISTER_HPP_EXPORT_DLL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QX_REGISTER_CPP_USER  QX_REGISTER_CPP_EXPORT_DLL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QX_REGISTER_HPP_USER  QX_REGISTER_HPP_IMPORT_DLL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QX_REGISTER_CPP_USER  QX_REGISTER_CPP_IMPORT_DLL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// EXPORT_H</span></span></span><br></pre></td></tr></table></figure><h2 id="预编译头文件"><a href="#预编译头文件" class="headerlink" title="预编译头文件"></a>预编译头文件</h2><p>预编译头文件的作用在于：提高编译速度。换句话说，使用它能够减少项目的编译时间。</p><p>QxOrm 使用元编程的概念来提供许多功能，元编程在编译时成本很高，因此使用 precompiled.h 文件可以更快地编译项目：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRECOMPILED_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRECOMPILED_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QxOrm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"export.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// PRECOMPILED_H</span></span></span><br></pre></td></tr></table></figure><p>此外，还有一个优点：文件 QxOrm.h 包含了 Qt 和 boost 库的基本功能，因此，不需要再编写像 #include &lt;QtCore/QString.h&gt; 这样的语句来使用 Qt 的 QString 类；同样地，也不需要编写像 #include &lt;boost/shared_ptr.hpp&gt; 这样的语句来使用 boost 库的智能指针。</p><h2 id="定义-User-类"><a href="#定义-User-类" class="headerlink" title="定义 User 类"></a>定义 User 类</h2><p>在 C++ 代码中，User 类对应的是数据库中的 User 表，而类的属性对应的是表中的一个字段（列）。因此，C++ 源代码中的一个 User 类实例对应 User 表中的一条记录（行），这种机制使得 C++ 源代码更易于开发和维护。</p><p>为 User 类定义三个属性，id、name 和 age：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> USER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USER_DLL_EXPORT</span> <span class="title">User</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    User() : id(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~User() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> id;</span><br><span class="line">    QString name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">QX_REGISTER_HPP_USER(User, qx::trait::no_base_class_defined, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// USER_H</span></span></span><br></pre></td></tr></table></figure><p>QX_REGISTER_HPP_USER 宏是必须的，用于将 User 类注册到 QxOrm 的上下文中：</p><ul><li><strong>参数一：</strong>表示要注册的当前类 - User。</li><li><strong>参数二：</strong>基类，如果没有基类，则使用 qx::trait::no_base_class_defined。</li><li><strong>参数三：</strong>用于序列化的类版本。</li></ul><p>在 user.cpp 文件中，需要实现 qx::register_class()，它是一个设置函数：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"precompiled.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="string">"user.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QxOrm_Impl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">QX_REGISTER_CPP_USER(User)</span><br><span class="line"></span><br><span class="line">namespace <span class="class">qx </span>&#123;</span><br><span class="line">    template <span class="params">&lt;&gt;</span> void register_class(QxClass<span class="params">&lt;User&gt;</span> &amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册 User::id &lt;=&gt; 数据库中的主键</span></span><br><span class="line">        t.id(&amp;<span class="symbol">User::</span>id, <span class="string">"id"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册 User::name 属性，使用的 key 是 name，version 是 1。</span></span><br><span class="line">        t.data(&amp;<span class="symbol">User::</span>name, <span class="string">"name"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册 User::age 属性，使用的 key 是 age。</span></span><br><span class="line">        t.data(&amp;<span class="symbol">User::</span>age, <span class="string">"age"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 QX_REGISTER_HPP_USER  相同，QX_REGISTER_CPP_USER 宏也是必需的，用于将 User 类注册到 QxOrm 的上下文中。</p><h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><p>现在，是时候一展身手了。通过 User 类，来了解 QxOrm 中的一些基本操作：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include "precompiled.h"</span></span><br><span class="line"><span class="comment">#include "user.h"</span></span><br><span class="line"><span class="comment">#include &lt;QxOrm_Impl.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QCoreApplication a(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化参数，用于和数据库交互</span></span><br><span class="line">    qx::QxSqlDatabase::getSingleton()-&gt;setDriverName(<span class="string">"QSQLITE"</span>);</span><br><span class="line">    qx::QxSqlDatabase::getSingleton()-&gt;setDatabaseName(<span class="string">"./Users.db"</span>);</span><br><span class="line">    qx::QxSqlDatabase::getSingleton()-&gt;setHostName(<span class="string">"localhost"</span>);</span><br><span class="line">    qx::QxSqlDatabase::getSingleton()-&gt;setUserName(<span class="string">"root"</span>);</span><br><span class="line">    qx::QxSqlDatabase::getSingleton()-&gt;setPassword(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在数据库中创建 User 表</span></span><br><span class="line">    QSqlError daoError = qx::dao::create_table&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 3 个用户</span></span><br><span class="line">    <span class="comment">// 可以使用 std 和 Qt 智能指针：std::shared_ptr、QSharedPointer 等...</span></span><br><span class="line">    typedef  QSharedPointer&lt;User&gt; UserPtr;</span><br><span class="line">    UserPtr u1;</span><br><span class="line">    u1.reset(<span class="keyword">new</span> User());</span><br><span class="line">    u1-&gt;name = <span class="string">"Jack Ma"</span>;</span><br><span class="line">    u1-&gt;age = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    UserPtr u2;</span><br><span class="line">    u2.reset(<span class="keyword">new</span> User());</span><br><span class="line">    u2-&gt;name = <span class="string">"Pony"</span>;</span><br><span class="line">    u2-&gt;age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">    UserPtr u3;</span><br><span class="line">    u3.reset(<span class="keyword">new</span> User());</span><br><span class="line">    u3-&gt;name = <span class="string">"Waleon"</span>;</span><br><span class="line">    u3-&gt;age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有用户插入容器中</span></span><br><span class="line">    <span class="comment">// 可以使用 std、boost、Qt 和 qx::QxCollection&lt;Key，Value&gt; 中的许多容器</span></span><br><span class="line">    typedef QVector&lt;UserPtr&gt; VectorUser;</span><br><span class="line">    VectorUser users;</span><br><span class="line">    users.push_back(u1);</span><br><span class="line">    users.push_back(u2);</span><br><span class="line">    users.push_back(u3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将容器中的所有用户插入到数据库中</span></span><br><span class="line">    <span class="comment">// p1、p2、p3 的 id 属性会自动更新</span></span><br><span class="line">    daoError = qx::dao::insert(users);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改第二个用户的信息，并更新到数据库中</span></span><br><span class="line">    u2-&gt;name = <span class="string">"Pony modified"</span>;</span><br><span class="line">    u2-&gt;age = <span class="number">38</span>;</span><br><span class="line">    daoError = qx::dao::update(u2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中删除第一个用户</span></span><br><span class="line">    daoError = qx::dao::delete_by_id(u1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算用户的数量</span></span><br><span class="line">    <span class="keyword">long</span> userCount = qx::dao::count&lt;User&gt;();</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"User Count: "</span> &lt;&lt; userCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 id 为 3 的用户取出，并传给一个新变量</span></span><br><span class="line">    UserPtr userTmp;</span><br><span class="line">    userTmp.reset(<span class="keyword">new</span> User());</span><br><span class="line">    userTmp-&gt;id = <span class="number">3</span>;</span><br><span class="line">    daoError = qx::dao::fetch_by_id(userTmp);</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"User Tmp: "</span> &lt;&lt; userTmp-&gt;id &lt;&lt; userTmp-&gt;name &lt;&lt; userTmp-&gt;age;</span><br><span class="line"></span><br><span class="line"><span class="comment">#if _QX_SERIALIZE_XML</span></span><br><span class="line">    <span class="comment">// 将容器中的用户导出到 XML 文件中（序列化）</span></span><br><span class="line">    qx::serialization::xml::to_file(users, <span class="string">"./export_users.xml"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 XML 中的用户导入至新容器</span></span><br><span class="line">    VectorUser usersXmlTmp;</span><br><span class="line">    qx::serialization::xml::from_file(usersXmlTmp, <span class="string">"./export_users.xml"</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ifndef _QX_NO_JSON</span></span><br><span class="line">    <span class="comment">// 将容器中的用户导出到 Json 文件中（序列化）</span></span><br><span class="line">    qx::serialization::json::to_file(users, <span class="string">"./export_users.json"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Json 文件中的用户导入至新容器</span></span><br><span class="line">    VectorUser usersJsonTmp;</span><br><span class="line">    qx::serialization::json::from_file(usersJsonTmp, <span class="string">"./export_users.json"</span>);</span><br><span class="line"><span class="comment">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆一个用户</span></span><br><span class="line">    UserPtr uClone = qx::clone_to_qt_shared_ptr(*u1);</span><br><span class="line">    qDebug() &lt;&lt; <span class="string">"Clone from u1: "</span> &lt;&lt; uClone-&gt;id &lt;&lt; uClone-&gt;name &lt;&lt; uClone-&gt;age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按类名（factory）创建新用户</span></span><br><span class="line">    qx::any uAny = qx::create(<span class="string">"User"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将用户插入到 qx::cache</span></span><br><span class="line">    qx::cache::set(<span class="string">"users"</span>, users);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 qx::cache 中删除所有元素</span></span><br><span class="line">    qx::cache::clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存泄漏</span></span><br><span class="line">    User *user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里重点介绍一下 QxOrm_Impl.h，它的作用是检测内存泄露。如果使用 QxMemLeak 模块或 boost::serialization 引擎，应该在所有的 *.cpp 中包含它；否则，它便是可选的（非必须）。</p><h2 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h2><p>运行程序，除了会打印一系列的输出信息之外，还会生成相应的数据库文件和 JSON 文件。</p><p>QxOrm 不会隐藏 SQL 查询（默认情况下，所有的语句都会显示），所以在控制台中可以看到执行过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[QxOrm] qx::QxSqlDatabase : <span class="keyword">create</span> <span class="keyword">new</span> <span class="keyword">database</span> <span class="keyword">connection</span> <span class="keyword">in</span> <span class="keyword">thread</span> <span class="string">'0x2554'</span> <span class="keyword">with</span> <span class="keyword">key</span> <span class="string">'&#123;652e45d3-7186-4bd6-81d1-9ff32fcff744&#125;'</span></span><br><span class="line">[QxOrm] <span class="keyword">sql</span> <span class="keyword">query</span> (total: <span class="number">31.8</span> ms, db_exec: <span class="number">0</span> ms) : <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">User</span> (<span class="keyword">id</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT, <span class="keyword">name</span> <span class="built_in">TEXT</span>, age <span class="built_in">INTEGER</span>)</span><br><span class="line">[QxOrm] <span class="keyword">sql</span> <span class="keyword">query</span> (total: <span class="number">12</span> ms, db_exec: <span class="number">1.91</span> ms) : <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">User</span> (<span class="keyword">name</span>, age) <span class="keyword">VALUES</span> (:<span class="keyword">name</span>, :age)</span><br><span class="line">[QxOrm] <span class="keyword">sql</span> <span class="keyword">query</span> (total: <span class="number">9.35</span> ms, db_exec: <span class="number">0.511</span> ms) : <span class="keyword">UPDATE</span> <span class="keyword">User</span> <span class="keyword">SET</span> <span class="keyword">id</span> = :<span class="keyword">id</span>, <span class="keyword">name</span> = :<span class="keyword">name</span>, age = :age <span class="keyword">WHERE</span> <span class="keyword">id</span> = :id_bis</span><br><span class="line">[QxOrm] <span class="keyword">sql</span> <span class="keyword">query</span> (total: <span class="number">8.49</span> ms, db_exec: <span class="number">8.43</span> ms) : <span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">User</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = :<span class="keyword">id</span></span><br><span class="line">[QxOrm] <span class="keyword">sql</span> <span class="keyword">query</span> (total: <span class="number">0.125</span> ms, db_exec: <span class="number">0.0994</span> ms) : <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> <span class="keyword">User</span></span><br><span class="line"><span class="keyword">User</span> <span class="keyword">Count</span>:  <span class="number">2</span></span><br><span class="line">[QxOrm] <span class="keyword">sql</span> <span class="keyword">query</span> (total: <span class="number">0.153</span> ms, db_exec: <span class="number">0.068</span> ms) : <span class="keyword">SELECT</span> User.id <span class="keyword">AS</span> User_id_0, User.name <span class="keyword">AS</span> User_name_0, User.age <span class="keyword">AS</span> User_age_0 <span class="keyword">FROM</span> <span class="keyword">User</span> <span class="keyword">WHERE</span> User.id = :<span class="keyword">id</span></span><br><span class="line"><span class="keyword">User</span> Tmp:  <span class="number">3</span> <span class="string">"Rose"</span> <span class="number">18</span></span><br><span class="line"><span class="keyword">Clone</span> <span class="keyword">from</span> u1:  <span class="number">1</span> <span class="string">"Jack Ma"</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>如果要查看数据库 Users.db 的信息，可以使用数据库可视化工具（例如：Navicat Premium）。</p><p>JSON 文件是通过序列化生成的，打开 export_users.json，将会看到相应的数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">30</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Jack Ma"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">38</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Pony modified"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Rose"</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h1 id="文献资料"><a href="#文献资料" class="headerlink" title="文献资料"></a>文献资料</h1><p>QxOrm网站提供了一个<a href="https://www.qxorm.com/qxorm_en/manual.html" target="_blank" rel="noopener">用户手册</a>。</p><p>本文档的目的是提供用户指南，以学习如何使用QxOrm库功能。本手册适用于正在寻找一种解决方案来管理C ++ / Qt中的持久数据层的开发人员和软件架构师。要理解本文档，需要具备C ++和数据库的技术技能。</p><p><strong>注意：</strong>可以使用<strong>QxEntityEditor应用程序</strong>（用于QxOrm库的图形编辑器，数据模型设计器和源代码生成器）快速轻松地定义本手册/用户指南中描述的所有功能。QxOrm网站上提供了另一个<a href="https://www.qxorm.com/qxorm_en/manual_qxee.html" target="_blank" rel="noopener">专门针对QxEntityEditor应用程序的文档</a>。</p><h1 id="数据模型管理工具"><a href="#数据模型管理工具" class="headerlink" title="数据模型管理工具"></a>数据模型管理工具</h1><p>QxEntityEditor是QxOrm库的图形编辑器：<strong>QxEntityEditor提供了一种图形方法来管理数据模型</strong>。QxEntityEditor是多平台的（适用于Windows，Linux和Mac OS X），并为所有环境生成本机代码：台式机（Windows，Linux，Mac OS X），嵌入式和移动（Android，iOS，Windows Phone，Raspberry Pi等） ）。 QxOrm网站上提供<a href="https://www.qxorm.com/qxorm_en/manual_qxee.html" target="_blank" rel="noopener">了QxEntityEditor应用程序的用户手册（文档）</a>。</p><p>QxEntityEditor基于插件，并提供了多种导入/导出数据模型的方式：</p><ul><li>自动生成C ++持久类（在QxOrm上下文中注册）；</li><li>自动为SQLite，MySQL，PostgreSQL，Oracle和MS SQL Server生成DDL SQL脚本（数据库架构）；</li><li>管理每个项目版本（ALTER TABLE，ADD COLUMN，DROP INDEX等）的模式演变；</li><li>使用 QxService模块通过网络传输数据模型并快速创建客户/服务器应用程序;</li><li>导入用于SQLite，MySQL，PostgreSQL，Oracle和MS SQL Server数据库的现有数据库结构（使用ODBC连接或本机驱动程序）；</li><li>因为每个项目都是不同的，所以QxEntityEditor提供了几种自定义生成文件的方法（尤其是javascript引擎和集成的调试器）。</li></ul><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>由于 QxOrm 可以自动对 Entity 对象与数据库中的 Table 进行属性与字段的映射，所以在实际项目中几乎不需要编写数据访问层的代码，这在很大程度上提高了我们的开发效率。</p><p>但 QxOrm 不能解决 SQL 和数据库的所有问题（没有一种工具是万能的），所以有时也需要使用 Qt 的 QtSql 引擎来编写自己的 SQL 查询或存储过程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ORM&quot;&gt;&lt;a href=&quot;#ORM&quot; class=&quot;headerlink&quot; title=&quot;ORM&quot;&gt;&lt;/a&gt;ORM&lt;/h1&gt;&lt;p&gt;ORM 全称是 Object Relational Mapping（对象关系映射），是一种程序设计技术，用于实现面向对象编程语言里不
      
    
    </summary>
    
      <category term="后端" scheme="https://www.ljjyy.com/categories/back/"/>
    
    
      <category term="qt" scheme="https://www.ljjyy.com/tags/qt/"/>
    
      <category term="qxorm" scheme="https://www.ljjyy.com/tags/qxorm/"/>
    
      <category term="orm" scheme="https://www.ljjyy.com/tags/orm/"/>
    
  </entry>
  
  <entry>
    <title>随机相对强弱指标StochRSI</title>
    <link href="https://www.ljjyy.com/archives/2023/04/100719.html"/>
    <id>https://www.ljjyy.com/archives/2023/04/100719.html</id>
    <published>2023-04-13T04:51:00.000Z</published>
    <updated>2023-09-20T01:51:36.911Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Stochastic-RSI指标"><a href="#什么是Stochastic-RSI指标" class="headerlink" title="什么是Stochastic RSI指标?"></a>什么是Stochastic RSI指标?</h3><p>随机相对强弱指标即Stochastic Relative Strength Index(Stoch RSI)，是最著名的动量技术指标之一，由Tushar S. Chande及Stanley Kroll发明，该技术指标得到了广泛的运用，并从传统的交易领域进入到了加密货币的世界。人们常说Stoch RSI指标是一个指标的指标，因为它是RSI(标准相对强度指标)的一种衍生指标。该指标可用于识别加密货币市场的趋势，并确定资产是处于超买还是超卖的状态。</p><h3 id="Stoch-RSI指标的工作原理？"><a href="#Stoch-RSI指标的工作原理？" class="headerlink" title="Stoch RSI指标的工作原理？"></a>Stoch RSI指标的工作原理？</h3><p>该指标计算出一个值，介于0到1(或者0-100)之间，可用一条线来表示。</p><p> 公式: Stoch RSI(K) = 100 – (RSI值 - 最低的RSI值) / (最高的高RSI值 - 最低的低RSI值)</p><p>Stoch RSI D:MA( Stoch RSI(K),P2); p2=3</p><p>RSI的计算通常运用14个周期内的数据，这也是Welles Wilder所倡导的周期长度。</p><p>通常来说，一种资产的Stoch RSI计算值低于0.20可认为其已超卖，高于0.80则认为已超买(在100框架内时则低于20则认为超卖，高于80则认为超买)。</p><h3 id="如何使用Stoch-RSI指标"><a href="#如何使用Stoch-RSI指标" class="headerlink" title="如何使用Stoch RSI指标?"></a>如何使用Stoch RSI指标?</h3><p>Stoch RSI指标主要用于识别市场中潜在的进入点、退出点以及市场反转点，但该指标的图形线运行到20(或0.2)下方时，则代表该资产处于超卖状态，相反地，如果指标指数高于80(或0.8)，则代表着资产可能处于超买状态。</p><p>当Stoch RSI的图形线跨过中间点50(或0.5)并指向80(或0.8)时，则很可能意味着该资产处于牛市或具有较强的上涨趋势。而如果处于熊市时，则图形线很可能持续走低，下探到50(或0.5)并走向20(0.2)。</p><p>更重要的是，与相对强弱指数相比，Stoch RSI指标从超买到超卖的转化速度非常快，反之是然，它对市场变化的响应更快、更敏感，对交易者来说是一个非常实用的工具。</p><p>与此同时，Stoch RSI指标产生的市场超买或超卖的信号也可能变化多端，因为该指标可能也会产生大量的错误信号。因此，建议将其与其他技术指标一起使用，以确认信号是否正确。</p><p>参考：<a href="https://www.investopedia.com/terms/s/stochrsi.asp" target="_blank" rel="noopener">https://www.investopedia.com/terms/s/stochrsi.asp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是Stochastic-RSI指标&quot;&gt;&lt;a href=&quot;#什么是Stochastic-RSI指标&quot; class=&quot;headerlink&quot; title=&quot;什么是Stochastic RSI指标?&quot;&gt;&lt;/a&gt;什么是Stochastic RSI指标?&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="其他" scheme="https://www.ljjyy.com/categories/other/"/>
    
    
      <category term="stock" scheme="https://www.ljjyy.com/tags/stock/"/>
    
  </entry>
  
  <entry>
    <title>K线形态识别</title>
    <link href="https://www.ljjyy.com/archives/2023/04/100718.html"/>
    <id>https://www.ljjyy.com/archives/2023/04/100718.html</id>
    <published>2023-04-07T04:51:00.000Z</published>
    <updated>2023-09-20T01:50:29.510Z</updated>
    
    <content type="html"><![CDATA[<p>基本知识<br>“千里之行 始于足下”</p><p>日本蜡烛线图表分析名副其实，其图线与蜡烛相像。它出自远东，经受了世世代代的千锤百炼。日本人创造了一套活色生香的命名体系，而这些名目所描述的，正是当对应的蜡烛图形态出现时，市场在情绪上的健康状态。如果您听到了“乌云盖顶”这样的表达方式，您还会觉得此时的市场情绪处于健康状态吗？——当然不能！后面我们将看到，这是一个看跌的形态，其名称已经清楚地向我们昭示此时的市场状态是不健康的。</p><p><strong>精准识别61种K线形态，支持用户自选形态识别。</strong></p><p><strong>K线形态识别返回的结果有三种：</strong> <strong>负：出现卖出信号</strong> <strong>0：没有出现该形态</strong> <strong>正：出现买入信号</strong></p><h3 id="1、两只乌鸦"><a href="#1、两只乌鸦" class="headerlink" title="1、两只乌鸦"></a>1、两只乌鸦</h3><blockquote><p>函数名：CDL2CROWS<br>名称：Two Crows 两只乌鸦<br>简介：三日K线模式，第一天长阳，第二天高开收阴，第三天再次高开继续收阴， 收盘比前一日收盘价低，预示股价下跌。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDL2CROWS(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="2、三只乌鸦"><a href="#2、三只乌鸦" class="headerlink" title="2、三只乌鸦"></a>2、三只乌鸦</h3><blockquote><p>函数名：CDL3BLACKCROWS<br>名称：Three Black Crows 三只乌鸦<br>简介：三日K线模式，连续三根阴线，每日收盘价都下跌且接近最低价， 每日开盘价都在上根K线实体内，预示股价下跌。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDL3BLACKCROWS(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="3、三内部上涨和下跌"><a href="#3、三内部上涨和下跌" class="headerlink" title="3、三内部上涨和下跌"></a>3、三内部上涨和下跌</h3><blockquote><p>函数名：CDL3INSIDE<br>名称： Three Inside Up/Down 三内部上涨和下跌<br>简介：三日K线模式，母子信号+长K线，以三内部上涨为例，K线为阴阳阳， 第三天收盘价高于第一天开盘价，第二天K线在第一天K线内部，预示着股价上涨。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDL3INSIDE(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="4、三线打击"><a href="#4、三线打击" class="headerlink" title="4、三线打击"></a>4、三线打击</h3><blockquote><p>函数名：CDL3LINESTRIKE<br>名称： Three-Line Strike 三线打击<br>简介：四日K线模式，前三根阳线，每日收盘价都比前一日高， 开盘价在前一日实体内，第四日市场高开，收盘价低于第一日开盘价，预示股价下跌。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDL3LINESTRIKE(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="5、三外部上涨和下跌"><a href="#5、三外部上涨和下跌" class="headerlink" title="5、三外部上涨和下跌"></a>5、三外部上涨和下跌</h3><blockquote><p>函数名：CDL3OUTSIDE<br>名称：Three Outside Up/Down 三外部上涨和下跌<br>简介：三日K线模式，与三内部上涨和下跌类似，K线为阴阳阳，但第一日与第二日的K线形态相反， 以三外部上涨为例，第一日K线在第二日K线内部，预示着股价上涨。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDL3OUTSIDE(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="6、南方三星"><a href="#6、南方三星" class="headerlink" title="6、南方三星"></a>6、南方三星</h3><blockquote><p>函数名：CDL3STARSINSOUTH<br>名称：Three Stars In The South 南方三星<br>简介：三日K线模式，与大敌当前相反，三日K线皆阴，第一日有长下影线， 第二日与第一日类似，K线整体小于第一日，第三日无下影线实体信号， 成交价格都在第一日振幅之内，预示下跌趋势反转，股价上升。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDL3STARSINSOUTH(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="7、三个白兵"><a href="#7、三个白兵" class="headerlink" title="7、三个白兵"></a>7、三个白兵</h3><blockquote><p>函数名：CDL3WHITESOLDIERS<br>名称：Three Advancing White Soldiers 三个白兵<br>简介：三日K线模式，三日K线皆阳， 每日收盘价变高且接近最高价，开盘价在前一日实体上半部，预示股价上升。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDL3WHITESOLDIERS(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="8、弃婴"><a href="#8、弃婴" class="headerlink" title="8、弃婴"></a>8、弃婴</h3><blockquote><p>函数名：CDLABANDONEDBABY<br>名称：Abandoned Baby 弃婴<br>简介：三日K线模式，第二日价格跳空且收十字星（开盘价与收盘价接近， 最高价最低价相差不大），预示趋势反转，发生在顶部下跌，底部上涨。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLABANDONEDBABY(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>, penetration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="9、大敌当前"><a href="#9、大敌当前" class="headerlink" title="9、大敌当前"></a>9、大敌当前</h3><blockquote><p>函数名：CDLADVANCEBLOCK<br>名称：Advance Block 大敌当前<br>简介：三日K线模式，三日都收阳，每日收盘价都比前一日高， 开盘价都在前一日实体以内，实体变短，上影线变长。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLADVANCEBLOCK(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="10、捉腰带线"><a href="#10、捉腰带线" class="headerlink" title="10、捉腰带线"></a>10、捉腰带线</h3><blockquote><p>函数名：CDLBELTHOLD<br>名称：Belt-hold 捉腰带线<br>简介：两日K线模式，下跌趋势中，第一日阴线， 第二日开盘价为最低价，阳线，收盘价接近最高价，预示价格上涨。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLBELTHOLD(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="11、脱离"><a href="#11、脱离" class="headerlink" title="11、脱离"></a>11、脱离</h3><blockquote><p>函数名：CDLBREAKAWAY<br>名称：Breakaway 脱离<br>简介：五日K线模式，以看涨脱离为例，下跌趋势中，第一日长阴线，第二日跳空阴线，延续趋势开始震荡， 第五日长阳线，收盘价在第一天收盘价与第二天开盘价之间，预示价格上涨。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLBREAKAWAY(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="12、收盘缺影线"><a href="#12、收盘缺影线" class="headerlink" title="12、收盘缺影线"></a>12、收盘缺影线</h3><blockquote><p>函数名：CDLCLOSINGMARUBOZU<br>名称：Closing Marubozu 收盘缺影线<br>简介：一日K线模式，以阳线为例，最低价低于开盘价，收盘价等于最高价， 预示着趋势持续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLCLOSINGMARUBOZU(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="13、藏婴吞没"><a href="#13、藏婴吞没" class="headerlink" title="13、藏婴吞没"></a>13、藏婴吞没</h3><blockquote><p>函数名：CDLCONCEALBABYSWALL<br>名称： Concealing Baby Swallow 藏婴吞没<br>简介：四日K线模式，下跌趋势中，前两日阴线无影线 ，第二日开盘、收盘价皆低于第二日，第三日倒锤头， 第四日开盘价高于前一日最高价，收盘价低于前一日最低价，预示着底部反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLCONCEALBABYSWALL(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="14、反击线"><a href="#14、反击线" class="headerlink" title="14、反击线"></a>14、反击线</h3><blockquote><p>函数名：CDLCOUNTERATTACK<br>名称：Counterattack 反击线<br>简介：二日K线模式，与分离线类似。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLCOUNTERATTACK(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="15、乌云压顶"><a href="#15、乌云压顶" class="headerlink" title="15、乌云压顶"></a>15、乌云压顶</h3><blockquote><p>函数名：CDLDARKCLOUDCOVER<br>名称：Dark Cloud Cover 乌云压顶<br>简介：二日K线模式，第一日长阳，第二日开盘价高于前一日最高价， 收盘价处于前一日实体中部以下，预示着股价下跌。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLDARKCLOUDCOVER(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>, penetration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="16、十字"><a href="#16、十字" class="headerlink" title="16、十字"></a>16、十字</h3><blockquote><p>函数名：CDLDOJI<br>名称：Doji 十字<br>简介：一日K线模式，开盘价与收盘价基本相同。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLDOJI(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="17、十字星"><a href="#17、十字星" class="headerlink" title="17、十字星"></a>17、十字星</h3><blockquote><p>函数名：CDLDOJISTAR<br>名称：Doji Star 十字星<br>简介：一日K线模式，开盘价与收盘价基本相同，上下影线不会很长，预示着当前趋势反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLDOJISTAR(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="18、蜻蜓十字-T形十字"><a href="#18、蜻蜓十字-T形十字" class="headerlink" title="18、蜻蜓十字/T形十字"></a>18、蜻蜓十字/T形十字</h3><blockquote><p>函数名：CDLDRAGONFLYDOJI<br>名称：Dragonfly Doji 蜻蜓十字/T形十字<br>简介：一日K线模式，开盘后价格一路走低， 之后收复，收盘价与开盘价相同，预示趋势反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLDRAGONFLYDOJI(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="19、吞噬模式"><a href="#19、吞噬模式" class="headerlink" title="19、吞噬模式"></a>19、吞噬模式</h3><blockquote><p>函数名：CDLENGULFING<br>名称：Engulfing Pattern 吞噬模式<br>简介：两日K线模式，分多头吞噬和空头吞噬，以多头吞噬为例，第一日为阴线， 第二日阳线，第一日的开盘价和收盘价在第二日开盘价收盘价之内，但不能完全相同。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLENGULFING(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="20、十字暮星"><a href="#20、十字暮星" class="headerlink" title="20、十字暮星"></a>20、十字暮星</h3><blockquote><p>函数名：CDLEVENINGDOJISTAR<br>名称：Evening Doji Star 十字暮星<br>简介：三日K线模式，基本模式为暮星，第二日收盘价和开盘价相同，预示顶部反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLEVENINGDOJISTAR(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>, penetration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="21、暮星"><a href="#21、暮星" class="headerlink" title="21、暮星"></a>21、暮星</h3><blockquote><p>函数名：CDLEVENINGSTAR<br>名称：Evening Star 暮星<br>简介：三日K线模式，与晨星相反，上升趋势中, 第一日阳线，第二日价格振幅较小，第三日阴线，预示顶部反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLEVENINGSTAR(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>, penetration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="22、向上-下跳空并列阳线"><a href="#22、向上-下跳空并列阳线" class="headerlink" title="22、向上/下跳空并列阳线"></a>22、向上/下跳空并列阳线</h3><blockquote><p>函数名：CDLGAPSIDESIDEWHITE<br>名称：Up/Down-gap side-by-side white lines 向上/下跳空并列阳线<br>简介：二日K线模式，上升趋势向上跳空，下跌趋势向下跳空, 第一日与第二日有相同开盘价，实体长度差不多，则趋势持续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLGAPSIDESIDEWHITE(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="23、墓碑十字-倒T十字"><a href="#23、墓碑十字-倒T十字" class="headerlink" title="23、墓碑十字/倒T十字"></a>23、墓碑十字/倒T十字</h3><blockquote><p>函数名：CDLGRAVESTONEDOJI<br>名称：Gravestone Doji 墓碑十字/倒T十字<br>简介：一日K线模式，开盘价与收盘价相同，上影线长，无下影线，预示底部反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLGRAVESTONEDOJI(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="24、锤头"><a href="#24、锤头" class="headerlink" title="24、锤头"></a>24、锤头</h3><blockquote><p>函数名：CDLHAMMER<br>名称：Hammer 锤头<br>简介：一日K线模式，实体较短，无上影线， 下影线大于实体长度两倍，处于下跌趋势底部，预示反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLHAMMER(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="25、上吊线"><a href="#25、上吊线" class="headerlink" title="25、上吊线"></a>25、上吊线</h3><blockquote><p>函数名：CDLHANGINGMAN<br>名称：Hanging Man 上吊线<br>简介：一日K线模式，形状与锤子类似，处于上升趋势的顶部，预示着趋势反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLHANGINGMAN(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="26、母子线"><a href="#26、母子线" class="headerlink" title="26、母子线"></a>26、母子线</h3><blockquote><p>函数名：CDLHARAMI<br>名称：Harami Pattern 母子线<br>简介：二日K线模式，分多头母子与空头母子，两者相反，以多头母子为例，在下跌趋势中，第一日K线长阴， 第二日开盘价收盘价在第一日价格振幅之内，为阳线，预示趋势反转，股价上升。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLHARAMI(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="27、十字孕线"><a href="#27、十字孕线" class="headerlink" title="27、十字孕线"></a>27、十字孕线</h3><blockquote><p>函数名：CDLHARAMICROSS<br>名称：Harami Cross Pattern 十字孕线<br>简介：二日K线模式，与母子县类似，若第二日K线是十字线， 便称为十字孕线，预示着趋势反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLHARAMICROSS(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="28、风高浪大线"><a href="#28、风高浪大线" class="headerlink" title="28、风高浪大线"></a>28、风高浪大线</h3><blockquote><p>函数名：CDLHIGHWAVE<br>名称：High-Wave Candle 风高浪大线<br>简介：三日K线模式，具有极长的上/下影线与短的实体，预示着趋势反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLHIGHWAVE(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="29、陷阱"><a href="#29、陷阱" class="headerlink" title="29、陷阱"></a>29、陷阱</h3><blockquote><p>函数名：CDLHIKKAKE<br>名称：Hikkake Pattern 陷阱<br>简介：三日K线模式，与母子类似，第二日价格在前一日实体范围内, 第三日收盘价高于前两日，反转失败，趋势继续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLHIKKAKE(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="30、修正陷阱"><a href="#30、修正陷阱" class="headerlink" title="30、修正陷阱"></a>30、修正陷阱</h3><blockquote><p>函数名：CDLHIKKAKEMOD<br>名称：Modified Hikkake Pattern 修正陷阱<br>简介：三日K线模式，与陷阱类似，上升趋势中，第三日跳空高开； 下跌趋势中，第三日跳空低开，反转失败，趋势继续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLHIKKAKEMOD(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="31、家鸽"><a href="#31、家鸽" class="headerlink" title="31、家鸽"></a>31、家鸽</h3><blockquote><p>函数名：CDLHOMINGPIGEON<br>名称：Homing Pigeon 家鸽<br>简介：二日K线模式，与母子线类似，不同的的是二日K线颜色相同， 第二日最高价、最低价都在第一日实体之内，预示着趋势反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLHOMINGPIGEON(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="32、三胞胎乌鸦"><a href="#32、三胞胎乌鸦" class="headerlink" title="32、三胞胎乌鸦"></a>32、三胞胎乌鸦</h3><blockquote><p>函数名：CDLIDENTICAL3CROWS<br>名称：Identical Three Crows 三胞胎乌鸦<br>简介：三日K线模式，上涨趋势中，三日都为阴线，长度大致相等， 每日开盘价等于前一日收盘价，收盘价接近当日最低价，预示价格下跌。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLIDENTICAL3CROWS(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="33、颈内线"><a href="#33、颈内线" class="headerlink" title="33、颈内线"></a>33、颈内线</h3><blockquote><p>函数名：CDLINNECK<br>名称：In-Neck Pattern 颈内线<br>简介：二日K线模式，下跌趋势中，第一日长阴线， 第二日开盘价较低，收盘价略高于第一日收盘价，阳线，实体较短，预示着下跌继续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLINNECK(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="34、倒锤头"><a href="#34、倒锤头" class="headerlink" title="34、倒锤头"></a>34、倒锤头</h3><blockquote><p>函数名：CDLINVERTEDHAMMER<br>名称：Inverted Hammer 倒锤头<br>简介：一日K线模式，上影线较长，长度为实体2倍以上， 无下影线，在下跌趋势底部，预示着趋势反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLINVERTEDHAMMER(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="35、反冲形态"><a href="#35、反冲形态" class="headerlink" title="35、反冲形态"></a>35、反冲形态</h3><blockquote><p>函数名：CDLKICKING<br>名称：Kicking 反冲形态<br>简介：二日K线模式，与分离线类似，两日K线为秃线，颜色相反，存在跳空缺口。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLKICKING(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="36、由较长缺影线决定的反冲形态"><a href="#36、由较长缺影线决定的反冲形态" class="headerlink" title="36、由较长缺影线决定的反冲形态"></a>36、由较长缺影线决定的反冲形态</h3><blockquote><p>函数名：CDLKICKINGBYLENGTH<br>名称：Kicking - bull/bear determined by the longer marubozu 由较长缺影线决定的反冲形态<br>简介：二日K线模式，与反冲形态类似，较长缺影线决定价格的涨跌。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLKICKINGBYLENGTH(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="37、梯底"><a href="#37、梯底" class="headerlink" title="37、梯底"></a>37、梯底</h3><blockquote><p>函数名：CDLLADDERBOTTOM<br>名称：Ladder Bottom 梯底<br>简介：五日K线模式，下跌趋势中，前三日阴线， 开盘价与收盘价皆低于前一日开盘、收盘价，第四日倒锤头，第五日开盘价高于前一日开盘价， 阳线，收盘价高于前几日价格振幅，预示着底部反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLLADDERBOTTOM(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="38、长脚十字"><a href="#38、长脚十字" class="headerlink" title="38、长脚十字"></a>38、长脚十字</h3><blockquote><p>函数名：CDLLONGLEGGEDDOJI<br>名称：Long Legged Doji 长脚十字<br>简介：一日K线模式，开盘价与收盘价相同居当日价格中部，上下影线长， 表达市场不确定性。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLLONGLEGGEDDOJI(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="39、长蜡烛"><a href="#39、长蜡烛" class="headerlink" title="39、长蜡烛"></a>39、长蜡烛</h3><blockquote><p>函数名：CDLLONGLINE<br>名称：Long Line Candle 长蜡烛<br>简介：一日K线模式，K线实体长，无上下影线。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLLONGLINE(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="40、光头光脚-缺影线"><a href="#40、光头光脚-缺影线" class="headerlink" title="40、光头光脚/缺影线"></a>40、光头光脚/缺影线</h3><p>函数名：CDLMARUBOZU<br>名称：Marubozu 光头光脚/缺影线<br>简介：一日K线模式，上下两头都没有影线的实体， 阴线预示着熊市持续或者牛市反转，阳线相反。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLMARUBOZU(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="41、相同低价"><a href="#41、相同低价" class="headerlink" title="41、相同低价"></a>41、相同低价</h3><blockquote><p>函数名：CDLMATCHINGLOW<br>名称：Matching Low 相同低价<br>简介：二日K线模式，下跌趋势中，第一日长阴线， 第二日阴线，收盘价与前一日相同，预示底部确认，该价格为支撑位。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLMATCHINGLOW(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="42、铺垫"><a href="#42、铺垫" class="headerlink" title="42、铺垫"></a>42、铺垫</h3><blockquote><p>函数名：CDLMATHOLD<br>名称：Mat Hold 铺垫<br>简介：五日K线模式，上涨趋势中，第一日阳线，第二日跳空高开影线， 第三、四日短实体影线，第五日阳线，收盘价高于前四日，预示趋势持续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLMATHOLD(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>, penetration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="43、十字晨星"><a href="#43、十字晨星" class="headerlink" title="43、十字晨星"></a>43、十字晨星</h3><blockquote><p>函数名：CDLMORNINGDOJISTAR<br>名称：Morning Doji Star 十字晨星<br>简介：三日K线模式， 基本模式为晨星，第二日K线为十字星，预示底部反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLMORNINGDOJISTAR(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>, penetration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="44、晨星"><a href="#44、晨星" class="headerlink" title="44、晨星"></a>44、晨星</h3><blockquote><p>函数名：CDLMORNINGSTAR<br>名称：Morning Star 晨星<br>简介：三日K线模式，下跌趋势，第一日阴线， 第二日价格振幅较小，第三天阳线，预示底部反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLMORNINGSTAR(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>, penetration=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="45、颈上线"><a href="#45、颈上线" class="headerlink" title="45、颈上线"></a>45、颈上线</h3><blockquote><p>函数名：CDLONNECK<br>名称：On-Neck Pattern 颈上线<br>简介：二日K线模式，下跌趋势中，第一日长阴线，第二日开盘价较低， 收盘价与前一日最低价相同，阳线，实体较短，预示着延续下跌趋势。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLONNECK(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="46、刺透形态"><a href="#46、刺透形态" class="headerlink" title="46、刺透形态"></a>46、刺透形态</h3><blockquote><p>函数名：CDLPIERCING<br>名称：Piercing Pattern 刺透形态<br>简介：两日K线模式，下跌趋势中，第一日阴线，第二日收盘价低于前一日最低价， 收盘价处在第一日实体上部，预示着底部反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLPIERCING(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="47、黄包车夫"><a href="#47、黄包车夫" class="headerlink" title="47、黄包车夫"></a>47、黄包车夫</h3><blockquote><p>函数名：CDLRICKSHAWMAN<br>名称：Rickshaw Man 黄包车夫<br>简介：一日K线模式，与长腿十字线类似， 若实体正好处于价格振幅中点，称为黄包车夫。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLRICKSHAWMAN(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="48、上升-下降三法"><a href="#48、上升-下降三法" class="headerlink" title="48、上升/下降三法"></a>48、上升/下降三法</h3><blockquote><p>函数名：CDLRISEFALL3METHODS<br>名称：Rising/Falling Three Methods 上升/下降三法<br>简介： 五日K线模式，以上升三法为例，上涨趋势中， 第一日长阳线，中间三日价格在第一日范围内小幅震荡， 第五日长阳线，收盘价高于第一日收盘价，预示股价上升。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLRISEFALL3METHODS(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="49、分离线"><a href="#49、分离线" class="headerlink" title="49、分离线"></a>49、分离线</h3><blockquote><p>函数名：CDLSEPARATINGLINES<br>名称：Separating Lines 分离线<br>简介：二日K线模式，上涨趋势中，第一日阴线，第二日阳线， 第二日开盘价与第一日相同且为最低价，预示着趋势继续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLSEPARATINGLINES(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="50、射击之星"><a href="#50、射击之星" class="headerlink" title="50、射击之星"></a>50、射击之星</h3><blockquote><p>函数名：CDLSHOOTINGSTAR<br>名称：Shooting Star 射击之星<br>简介：一日K线模式，上影线至少为实体长度两倍， 没有下影线，预示着股价下跌</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLSHOOTINGSTAR(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="51、短蜡烛"><a href="#51、短蜡烛" class="headerlink" title="51、短蜡烛"></a>51、短蜡烛</h3><blockquote><p>函数名：CDLSHORTLINE<br>名称：Short Line Candle 短蜡烛<br>简介：一日K线模式，实体短，无上下影线</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLSHORTLINE(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="52、纺锤"><a href="#52、纺锤" class="headerlink" title="52、纺锤"></a>52、纺锤</h3><blockquote><p>函数名：CDLSPINNINGTOP<br>名称：Spinning Top 纺锤<br>简介：一日K线，实体小。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLSPINNINGTOP(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="53、停顿形态"><a href="#53、停顿形态" class="headerlink" title="53、停顿形态"></a>53、停顿形态</h3><blockquote><p>函数名：CDLSTALLEDPATTERN<br>名称：Stalled Pattern 停顿形态<br>简介：三日K线模式，上涨趋势中，第二日长阳线， 第三日开盘于前一日收盘价附近，短阳线，预示着上涨结束</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLSTALLEDPATTERN(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="54、条形三明治"><a href="#54、条形三明治" class="headerlink" title="54、条形三明治"></a>54、条形三明治</h3><blockquote><p>函数名：CDLSTICKSANDWICH<br>名称：Stick Sandwich 条形三明治<br>简介：三日K线模式，第一日长阴线，第二日阳线，开盘价高于前一日收盘价， 第三日开盘价高于前两日最高价，收盘价于第一日收盘价相同。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLSTICKSANDWICH(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="55、探水竿"><a href="#55、探水竿" class="headerlink" title="55、探水竿"></a>55、探水竿</h3><blockquote><p>函数名：CDLTAKURI<br>名称：Takuri (Dragonfly Doji with very long lower shadow) 探水竿<br>简介：一日K线模式，大致与蜻蜓十字相同，下影线长度长。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLTAKURI(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="56、跳空并列阴阳线"><a href="#56、跳空并列阴阳线" class="headerlink" title="56、跳空并列阴阳线"></a>56、跳空并列阴阳线</h3><blockquote><p>函数名：CDLTASUKIGAP<br>名称：Tasuki Gap 跳空并列阴阳线<br>简介：三日K线模式，分上涨和下跌，以上升为例， 前两日阳线，第二日跳空，第三日阴线，收盘价于缺口中，上升趋势持续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLTASUKIGAP(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="57、插入"><a href="#57、插入" class="headerlink" title="57、插入"></a>57、插入</h3><blockquote><p>函数名：CDLTHRUSTING<br>名称：Thrusting Pattern 插入<br>简介：二日K线模式，与颈上线类似，下跌趋势中，第一日长阴线，第二日开盘价跳空， 收盘价略低于前一日实体中部，与颈上线相比实体较长，预示着趋势持续。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLTHRUSTING(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="58、三星"><a href="#58、三星" class="headerlink" title="58、三星"></a>58、三星</h3><blockquote><p>函数名：CDLTRISTAR<br>名称：Tristar Pattern 三星<br>简介：三日K线模式，由三个十字组成， 第二日十字必须高于或者低于第一日和第三日，预示着反转。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLTRISTAR(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="59、奇特三河床"><a href="#59、奇特三河床" class="headerlink" title="59、奇特三河床"></a>59、奇特三河床</h3><blockquote><p>函数名：CDLUNIQUE3RIVER<br>名称：Unique 3 River 奇特三河床<br>简介：三日K线模式，下跌趋势中，第一日长阴线，第二日为锤头，最低价创新低，第三日开盘价低于第二日收盘价，收阳线， 收盘价不高于第二日收盘价，预示着反转，第二日下影线越长可能性越大。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLUNIQUE3RIVER(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="60、向上跳空的两只乌鸦"><a href="#60、向上跳空的两只乌鸦" class="headerlink" title="60、向上跳空的两只乌鸦"></a>60、向上跳空的两只乌鸦</h3><blockquote><p>函数名：CDLUPSIDEGAP2CROWS<br>名称：Upside Gap Two Crows 向上跳空的两只乌鸦<br>简介：三日K线模式，第一日阳线，第二日跳空以高于第一日最高价开盘， 收阴线，第三日开盘价高于第二日，收阴线，与第一日比仍有缺口。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLUPSIDEGAP2CROWS(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="61、上升-下降跳空三法"><a href="#61、上升-下降跳空三法" class="headerlink" title="61、上升/下降跳空三法"></a>61、上升/下降跳空三法</h3><blockquote><p>函数名：CDLXSIDEGAP3METHODS<br>名称：Upside/Downside Gap Three Methods 上升/下降跳空三法<br>简介：五日K线模式，以上升跳空三法为例，上涨趋势中，第一日长阳线，第二日短阳线，第三日跳空阳线，第四日阴线，开盘价与收盘价于前两日实体内， 第五日长阳线，收盘价高于第一日收盘价，预示股价上升。</p></blockquote><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> = CDLXSIDEGAP3METHODS(<span class="built_in">open</span>, high, low, <span class="built_in">close</span>)</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>更详细的信息见《日本蜡烛图技术》第2版</p><p>链接：<a href="https://pan.baidu.com/s/1ElSID3Y2lIAKqGcXCzVlLQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1ElSID3Y2lIAKqGcXCzVlLQ</a><br>提取码：8888</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本知识&lt;br&gt;“千里之行 始于足下”&lt;/p&gt;
&lt;p&gt;日本蜡烛线图表分析名副其实，其图线与蜡烛相像。它出自远东，经受了世世代代的千锤百炼。日本人创造了一套活色生香的命名体系，而这些名目所描述的，正是当对应的蜡烛图形态出现时，市场在情绪上的健康状态。如果您听到了“乌云盖顶”这
      
    
    </summary>
    
      <category term="其他" scheme="https://www.ljjyy.com/categories/other/"/>
    
    
      <category term="stock" scheme="https://www.ljjyy.com/tags/stock/"/>
    
  </entry>
  
  <entry>
    <title>劲道指数ForceIndex</title>
    <link href="https://www.ljjyy.com/archives/2023/04/100717.html"/>
    <id>https://www.ljjyy.com/archives/2023/04/100717.html</id>
    <published>2023-04-05T04:51:00.000Z</published>
    <updated>2023-09-20T01:50:16.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是劲道指数"><a href="#什么是劲道指数" class="headerlink" title="什么是劲道指数"></a>什么是劲道指数</h2><p>　　劲道指数是由<a href="https://wiki.mbalib.com/w/index.php?title=亚历山大·埃尔德&amp;action=edit" target="_blank" rel="noopener">亚历山大·埃尔德</a>(Alexander Elder)博士设计的一种<a href="https://wiki.mbalib.com/wiki/摆荡指标" target="_blank" rel="noopener">摆荡指标</a>，藉以衡量每个涨势中的<a href="https://wiki.mbalib.com/wiki/多头" target="_blank" rel="noopener">多头</a>劲道与每个跌势中的空头劲道。</p><p>　　劲道指数结合三项主要的市场资讯：价格变动的方向、它的幅度与<a href="https://wiki.mbalib.com/wiki/成交量" target="_blank" rel="noopener">成交量</a>。它是由一个崭新而实用的角度，把成交量纳入交易决策中。</p><p>　　我们可以直接使用劲道指数，但经过平滑之后的效果比较理想，经过短期均线平滑之后的劲道指数，可以协助判断进／出场点。经过长期均线平滑之后的劲道指数。可以显示多／空劲道的主要变化。</p><h2 id="劲道指数的结构"><a href="#劲道指数的结构" class="headerlink" title="劲道指数的结构"></a>劲道指数的结构</h2><p>　　每个走势的劲道是由三个因子界定：方向、距离与成交量。如果今天的<a href="https://wiki.mbalib.com/wiki/收盘价" target="_blank" rel="noopener">收盘价</a>高于前一天的收盘价，劲道指数为正值。如果今天的收盘价低于前一天的收盘价，劲道指数为负值。价格的变动程度愈大，劲道愈足，成交量愈高，走势的劲道也愈大。多头主控行情。当它翻为负值，代表<a href="https://wiki.mbalib.com/wiki/空头" target="_blank" rel="noopener">空头</a>居于主控地位。劲道指数13天EMA与价格之间的<a href="https://wiki.mbalib.com/wiki/背离" target="_blank" rel="noopener">背离</a>现象，代表重要的转折点。见下图：</p><p><a href="https://wiki.mbalib.com/wiki/Image:劲道指数.jpg" target="_blank" rel="noopener"><img src="https://wiki.mbalib.com/w/images/2/2b/%E5%8A%B2%E9%81%93%E6%8C%87%E6%95%B0.jpg" alt="劲道指数"></a></p><p>　　劲道指数＝成交量（今天）×［收盘价（今天）－收盘价（昨天）］</p><p>　　未经平滑的劲道指数是以柱状图表示，如果今天的收盘价较高，劲道指数为正值，柱状图绘制在零线之上。如果今天的收盘价较低，劲道指数为负值，柱状图绘制在零线之下，如果收盘价不变，劲道指数为零。</p><p>　　由于劲道指数的每天数值变化很大，最好是经过<a href="https://wiki.mbalib.com/wiki/均线" target="_blank" rel="noopener">均线</a>的平滑。平滑之后的指标，可以提供比较理想的讯号，劲道指数的2天EMA，是最低程度的平滑，适用于寻找进／出场点。如果你顺着价格的13天EMA方向交易，应该在劲道指数2天EMA为负值时买进，在正值中卖出。</p><p>　　劲道指数的13天EMA，可以追踪多／空劲道的长期变动，当它穿越到零线之上，代表多头主控行情。当它翻为负值，代表空头居于主控地位。劲道指数13天EMA与价格之间的背离现象，代表重要的转折点。</p><p>　　劲道指数＝成交量(今天)×［<a href="https://wiki.mbalib.com/wiki/收盘价" target="_blank" rel="noopener">收盘价</a>(今天)－收盘价(昨天)］</p><p>　　短期的劲道指数是经过2天EMA的平滑，中期的劲道指数是经过13天EMA的平滑。如果劲道指数的数值很大，你可以采用一个技巧——将它们除以最近的收盘价。</p><h2 id="劲道指数的交易心理"><a href="#劲道指数的交易心理" class="headerlink" title="劲道指数的交易心理"></a>劲道指数的交易心理</h2><p>　　如果价格收高，代表多头赢得当天的胜利；如果价格收低，代表空头主导当天的行情。今天与昨天收盘价之间的距离，可以反映多／空双方的胜利程度。距离愈大，胜负的分野愈明显。</p><p>　　成交量可以反映市场参与者的投入程度，夹着大成交量的走势，就像愈滚愈大的雪球。大成交量的涨势与跌势，它们所拥有的惯性较大，比较可能继续发展。在另一方面，偏低的<a href="https://wiki.mbalib.com/wiki/成交量" target="_blank" rel="noopener">成交量</a>，代表输家的供给短缺，趋势的发展已经接近尾声。</p><p>　　成交量反映市场参与者的感受，价格反映他们的想法。劲道指数结合成交量与价格，说明市场的“心”与“智”是否相互配合。</p><p>　　如果劲道指数持续创新高，代表多头的劲道十足，上升趋势应该会继续发展。如果劲道指数持续创新低，代表空头的劲道十足，下降趋势应该会继续发展。如果价格的变动没有受到成交量的确认，劲道指数将走平，这是趋势可能反转的警讯。同理，如果大成交量仅驱动小幅的价格走势，劲道指数也会走平，代表趋势即将反转的警讯。</p><h2 id="劲道指数的交易法则"><a href="#劲道指数的交易法则" class="headerlink" title="劲道指数的交易法则"></a>劲道指数的交易法则</h2><p>　　<strong>1、短期劲道指数</strong></p><p>　　劲道指数的2天期EMA，是代表多／空短期劲道的敏感指标。当它摆动到零线之上，显示多方的力量比较强；当它摆动到零线之下，显示空方的力量比较强。由于劲道指数的2天期EMA非常敏感，最好配合其他指标而<a href="https://wiki.mbalib.com/wiki/微调" target="_blank" rel="noopener">微调</a>交易讯号。如果某种<a href="https://wiki.mbalib.com/wiki/顺势指标" target="_blank" rel="noopener">顺势指标</a>显示上升趋势，劲道指数的2天期EMA可以寻找最佳的买点。反之，如果顺势指标显示下降趋势，劲道指数的2天期EMA可以寻找最佳的放空位置。</p><p><a href="https://wiki.mbalib.com/wiki/Image:短期劲道指数.jpg" target="_blank" rel="noopener"><img src="https://wiki.mbalib.com/w/images/8/8a/%E7%9F%AD%E6%9C%9F%E5%8A%B2%E9%81%93%E6%8C%87%E6%95%B0.jpg" alt="劲道指数"></a></p><p>　　1）上升趋势中，当劲道指数的2天期EMA低于零线，代表买进的机会。不论上升趋势多么强劲，它也一定会拉回。如果你在劲道指数的2天期EMA低于零线时买进，买点应该位在短期底部的附近。</p><p>　　当劲道指数的2天期EMA低于零线，买单设定在当天高价的稍上方。如果价格恢复涨势，停止买单将被触发。如果价格继续下滑，买单价位向下调整到最近高价的上方一档。一旦<a href="https://wiki.mbalib.com/wiki/建立多头部位" target="_blank" rel="noopener">建立多头部位</a>之后，<a href="https://wiki.mbalib.com/wiki/停损" target="_blank" rel="noopener">停损</a>设定在交易当天或前一天的最低价稍下方（取两者的较低者）。如果上升趋势很强，这种紧密的停损通常不会被触发。但如果趋势很弱的话，很快就会被停损出场。</p><p>　　2）下降趋势中，当劲道指数的2天期EMA高于零线，代表放空的机会。</p><p>　　当顺势指标认定下降趋势之后，等待劲道指数的2天期EMA翻为正值。价格反弹 是放空的机会，将空单设定在最近一支长条图低价的稍下方。</p><p>　　当你设定停止卖单之后，如果劲道指数的2天期EMA继续上升，每天把卖出价位调高到最近低价的下方一档处，一旦建立空头部位之后，把停损设定在交易当天或前一天的最高价稍上方（取两者的较高者），尽早把停损点移到损益两平价位。劲道指数的2天期EMA可以协助你拟定加码的策略。上升趋势中，每当劲道指数的2天期EMA跌破零线，就可以追加多头部位；下降趋势中，每当劲道指数的2天期EMA 向上穿越零线，就可以追加空头部位。</p><p>　　劲道指数甚至于可以预示未来。如果它的2天期EMA创一个月之内的新低，代表空头劲道十足，价格应该继续下跌，反之，如果劲道指数的2天期EMA创一个月之内的新高，代表多头劲道十足，价格应该继续上涨。</p><p>　　劲道指数的2天期EMA可以协助判断部位的<a href="https://wiki.mbalib.com/wiki/平仓" target="_blank" rel="noopener">平仓</a>时机。短线交易者是在指标跌破零线时买进，当它向上穿越零线时卖出。短线交易者是在指标向上穿越零线时抛空，当它跌破零线时回补。对于<a href="https://wiki.mbalib.com/wiki/长线交易者" target="_blank" rel="noopener">长线交易者</a>来说，唯有当趋势发生变化（根据13天EMA判断）或劲道指数的2天期EMA与价格发生背离，才需要平仓。</p><p>　　3）价格与劲道指数2天期EMA之间的多头背离，是代表强烈的买进讯号。换言之，价格创新低而劲道指数的底部垫高。</p><p>　　4）价格与劲道指数2天期EMA之间的空头背离，是代表强烈的卖出讯号。换言之，价格创新高而劲道指数的头部下滑。</p><p>　　劲道指数——2天期EMA：这个敏感的短期指标适合在上升趋势中寻找买进机会，在下降趋势中寻找放空机会。它帮助交易者在弱势中买进，在强势中卖出。如果根据13天期EMA斜率所认定的趋势向上，而且劲道指数跌破零线，这代表买进讯号。如果趋势向下而劲道指数向上穿越零线，这代表放空的讯号。</p><p>　　平仓的方法取决于你是一位短线或长线的交易者，如果你从事短线的交易，则在劲道指数翻为正值时卖出，在劲道指数翻为负值时回补。<a href="https://wiki.mbalib.com/wiki/长线交易者" target="_blank" rel="noopener">长线交易者</a>的平仓，应该等待EMA改变方向或劲道指数与价格之间发生背离（图形中以斜箭头标示）。如果 顺着趋势方向进行交易，当劲道指数发生顺势的讯号，可以利用既有部位的获利加码。</p><p>　　劲道指数的2天期EMA非常适用于<a href="https://wiki.mbalib.com/wiki/三重滤网交易系统" target="_blank" rel="noopener">三重滤网交易系统</a>，它擅长于捕捉短线的买／卖点，尤其是当它与某种相对长期的顺势指标配合使用。 中期的劲道指数</p><p>　　<strong>2、中期的劲道指数</strong></p><p>　　劲道指数的13天EMA可以辨识多／空力量比较长期的变化，它与零线的相对位置，可以显示哪一方握有主控权，它与价格之间的背离，代表主要的转折点。</p><p><a href="https://wiki.mbalib.com/wiki/Image:中期的劲道指数.jpg" target="_blank" rel="noopener"><img src="https://wiki.mbalib.com/w/images/0/02/%E4%B8%AD%E6%9C%9F%E7%9A%84%E5%8A%B2%E9%81%93%E6%8C%87%E6%95%B0.jpg" alt="劲道指数"></a></p><p>　　劲道指数——13天EMA：价格与劲道指数13天EMA之间的背离，代表重要的转折点。八月份，<a href="https://wiki.mbalib.com/wiki/日经指数" target="_blank" rel="noopener">日经指数</a>发生多头的背离，这是一个买进机会，<a href="https://wiki.mbalib.com/wiki/指数" target="_blank" rel="noopener">指数</a>再度测试低点，但劲道指标的底部垫高，指标发出买进讯号。</p><p>　　如果劲道指数暴挫而创低点（例如八月份的情况），这有两个涵意，就长期来说，往往代表下跌趋势已经告一段落，就短期而言，价格可能重新测试或跌破最近的底部。</p><p>　　日经指数在十月份创新高，但劲道指数的头部下滑。这个空头背离显示多头的气力已经放尽，价格接近头部。随后出现许多放空的机会。在图形的最右端，劲道 指数暴涨，代表价格将测试或跌破最近的低点。</p><p>　　1）当劲道指数的13天EMA位在零线之上，多头掌握大局；当它位在零线之下，空头掌控大局。当指标徘徊在零线附近，代表市场没有明确的趋势——这是停止采用顺势指标的警讯。</p><p>　　当涨势发动时，价格经常是夹着大量上涨。当劲道指数的13天EMA持续创新高，这可以确认上升趋势。当上升趋势老化之后，价格的涨幅比较有限或成交量相对缩小，劲道指数的13天EMA将形成愈来愈低的头部，最后跌破零线，这是多头彻底瓦解的讯号。</p><p>　　2）当劲道指数的13天EMA创新高，涨势应该会持续发展。可是，如果价格与劲道指数的13天EMA之间形成空头背离，这是强烈的放空讯号。换言之，如果价格创新高而指标的峰位下滑，代表多方的力量正在消退中，空方即将掌握大局。</p><p>　　3）当劲道指数的13天EMA创新低，跌势应该会持续发展。可是，如果价格创新低而指标的底部垫高，代表空方的力量正在消退中，这种多头背离是强烈的买进讯号。在跌势的初期，价格经常是夹着大量下跌。当劲道指数的13天EMA持续创新低，这可以确认下降趋势。可是，当下降趋势老化之后，价格的跌幅比较有限或成交量相对缩小，劲道指数的13天EMA将形成愈来愈高的底部，最后向上穿越零线，这是空头彻底瓦解的讯号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是劲道指数&quot;&gt;&lt;a href=&quot;#什么是劲道指数&quot; class=&quot;headerlink&quot; title=&quot;什么是劲道指数&quot;&gt;&lt;/a&gt;什么是劲道指数&lt;/h2&gt;&lt;p&gt;　　劲道指数是由&lt;a href=&quot;https://wiki.mbalib.com/w/index.p
      
    
    </summary>
    
      <category term="其他" scheme="https://www.ljjyy.com/categories/other/"/>
    
    
      <category term="stock" scheme="https://www.ljjyy.com/tags/stock/"/>
    
  </entry>
  
  <entry>
    <title>相对离散指数RVI</title>
    <link href="https://www.ljjyy.com/archives/2023/04/100716.html"/>
    <id>https://www.ljjyy.com/archives/2023/04/100716.html</id>
    <published>2023-04-05T04:50:00.000Z</published>
    <updated>2023-09-20T01:51:24.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是相对离散指数"><a href="#什么是相对离散指数" class="headerlink" title="什么是相对离散指数"></a>什么是相对离散指数</h2><p>　　<strong>相对离散指数</strong>（RVI）又称“<strong>相对波动性指标</strong>”，用于测量价格的发散趋势，由著名分析家<a href="https://wiki.mbalib.com/w/index.php?title=唐纳德·多西&amp;action=edit" target="_blank" rel="noopener">唐纳德·多西</a>（Donald Dorsey）于1993年提出。其原理与<a href="https://wiki.mbalib.com/wiki/相对强弱指标" target="_blank" rel="noopener">相对强弱指标</a>（<a href="https://wiki.mbalib.com/wiki/RSI" target="_blank" rel="noopener">RSI</a>）类似，但它是以价格的<a href="https://wiki.mbalib.com/wiki/方差" target="_blank" rel="noopener">方差</a>而不是简单的升跌来测量价格变化的强度。</p><p>　　相对离散指数（RVI）主要用作辅助的确认指标，即配合均线系统、<a href="https://wiki.mbalib.com/wiki/动量指标" target="_blank" rel="noopener">动量指标</a>或其它<a href="https://wiki.mbalib.com/wiki/趋势指标" target="_blank" rel="noopener">趋势指标</a>使用。用于RVI综合了多种不同的因素，通常比其它辅助指标要好。</p><p>RVI是归类为“动量型指标”或“振荡器型指标”的指标，其特点是在考虑了波动率（波动幅度）后，具有明确的超买和超卖信号，是振荡器特有的信号。</p><p><strong>RVI是</strong>Relative Vigor Index的缩写，是衡量市场波动变化的震荡指标和动量技术指标。</p><p>RVI 由两条线组成，RVI 线和信号线，就像随机指标和 MACD。信号线是RVI线的平均线，从信号线与RVI线的位置关系可以判断买卖动量。</p><p><a href="https://wiki.mbalib.com/wiki/Image:相对离散指数.gif" target="_blank" rel="noopener"><img src="https://wiki.mbalib.com/w/images/c/c4/%E7%9B%B8%E5%AF%B9%E7%A6%BB%E6%95%A3%E6%8C%87%E6%95%B0.gif" alt="相对离散指数"></a></p><h2 id="计算公式"><a href="#计算公式" class="headerlink" title="计算公式"></a>计算公式</h2><ol><li><p>计算最近4根K线的收盘价开仓价差值的对称加权移动平均 <code>Value1 = ((Close - Open) + 2 * (Close1 - Open1) + 2 * (Close2 - Open2) + (Close3 - Open3))/6</code></p></li><li><p>计算最近4根K线的最高价最低价差值的对称加权移动平均 <code>Value2 = ((High - Low) + 2 * (High1 - Low1) + 2 * (High2 - Low2) + (High3 - Low3))/6</code></p></li><li><p>计算N日的Value1 的和 <code>Num = Sum(Value1,N)</code></p></li><li><p>计算N日的Value2 的和 <code>Denum = Sum(Value2,N)</code></p></li><li><p><code>RVI = Num / Denum</code></p></li><li><p>计算RVI信号的值 <code>RVISig = (RVI + 2 * RVI1 + 2 * RVI2 + RVI3)/6</code></p></li></ol><p>Close表示收盘价，Close1表示前面一根K线的收盘价，一次类推，Close2表示前面第二根的K线收盘价，Open表示开盘价，High表示最高价，Low表示最低价。</p><h2 id="RVI-和-RSI-的区别"><a href="#RVI-和-RSI-的区别" class="headerlink" title="RVI 和 RSI 的区别"></a>RVI 和 RSI 的区别</h2><p>RVI 是基于 RSI 的指标。RSI表示价格在一定时期内上涨或下跌了多少，表示“价格的绝对变化”，而RVI则有很大的不同，它是以“价格高低的标准差”来计算的。</p><p>作为一个很大的区别，这是你擅长的市场之间的区别。RSI擅长在区间内移动，而RVI擅长波动大、趋势明显的市场。另一个特点是在趋势出现时没有像 RSI 那样的“天花板附件”。</p><table><thead><tr><th>比较目标</th><th><strong>RSI</strong></th><th>RVI</th></tr></thead><tbody><tr><td><strong>专长</strong></td><td>查看趋势如何升温</td><td>观察趋势动量 Observing trend changes</td></tr><tr><td><strong>不擅长</strong></td><td>预测趋势何时结束</td><td>没有动能的市场攻防判断</td></tr><tr><td><strong>良好的市场环境</strong></td><td>盒子范围市场 停滞不前的市场</td><td>高波动性市场</td></tr><tr><td><strong>不利的市场环境</strong></td><td>具有可变波动性的持续趋势 市场</td><td>停滞市场 低波动市场</td></tr></tbody></table><h2 id="如何使用-RVI"><a href="#如何使用-RVI" class="headerlink" title="如何使用 RVI"></a>如何使用 RVI</h2><p>使用 RVI 进行交易时，有几点需要重点关注。<br>1、<strong>“RVI 有多高</strong>。 ” RVI数以0为基准分为正数和负数。正值越高，波动性越大，上升势头越强。</p><p>2、<strong>“RVI线与信号线的位置关系”</strong>。信号线突破RVI线的状态称为金叉，预示未来上涨，信号线跌破RVI线的状态称为债叉，预示未来下跌。</p><p>3、RVI指标的背离</p><p>大家还可以利用RVI指标的背离来判断交易信号。当RVI指标出现底部背离时，就是短期做多信号；当RVI指标出现顶部背离时，就是短期做空信号。</p><p>RVI 视图</p><ul><li><p>较大的正数表示强劲的上升势头。</p></li><li><p>较大的负数表示强劲的下行势头。</p></li><li><p>如果有黄金交叉，未来有上涨的可能</p></li><li><p>如果出现死叉，则未来有向下的可能。</p></li></ul><p>在使用RVI的方法中，总是尝试检查RVI线和信号线的金叉（死叉），或者RVI<strong>线有多高，不只是一个，但总是同时检查两个轴。</strong></p><p>RVI是由RSI的原型演变而来，但实际上，在公式和概念上与RVI最相似的指标不是RSI，而是STOCHRSI。如果结合 RVI 的方法产生高胜率，用 STOCHRSI 代替 RVI 可能会增加 1-2% 的胜率。（反之亦然）</p><p>参考：<a href="https://maths-in-industry.org/2022/03/16/rvi/" target="_blank" rel="noopener">https://maths-in-industry.org/2022/03/16/rvi/</a></p><h2 id="RVI和KD、RSI、MACD结合"><a href="#RVI和KD、RSI、MACD结合" class="headerlink" title="RVI和KD、RSI、MACD结合"></a>RVI和KD、RSI、MACD结合</h2><p>KD和RSI、MACD指标的超卖和超买信号发出后，很快RVI指标2条线交叉，验证了相应的多空信号。</p><h2 id="RVI和均线的结合"><a href="#RVI和均线的结合" class="headerlink" title="RVI和均线的结合"></a>RVI和均线的结合</h2><p><strong>通常是用2条均线的交叉来验证RVI发出的多空信号。这是日内交易者的最佳指标组合。</strong></p><h2 id="RVI和BOLL结合"><a href="#RVI和BOLL结合" class="headerlink" title="RVI和BOLL结合"></a>RVI和BOLL结合</h2><p>用布林带的中线验证RVI发出的多空信号，同样还是<strong>借助布林带中线与K线的交叉关系。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是相对离散指数&quot;&gt;&lt;a href=&quot;#什么是相对离散指数&quot; class=&quot;headerlink&quot; title=&quot;什么是相对离散指数&quot;&gt;&lt;/a&gt;什么是相对离散指数&lt;/h2&gt;&lt;p&gt;　　&lt;strong&gt;相对离散指数&lt;/strong&gt;（RVI）又称“&lt;strong&gt;相
      
    
    </summary>
    
      <category term="其他" scheme="https://www.ljjyy.com/categories/other/"/>
    
    
      <category term="stock" scheme="https://www.ljjyy.com/tags/stock/"/>
    
  </entry>
  
  <entry>
    <title>十字过滤线VHF</title>
    <link href="https://www.ljjyy.com/archives/2023/04/100715.html"/>
    <id>https://www.ljjyy.com/archives/2023/04/100715.html</id>
    <published>2023-04-05T04:49:00.000Z</published>
    <updated>2023-09-20T01:52:00.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是十字过滤线"><a href="#什么是十字过滤线" class="headerlink" title="什么是十字过滤线"></a>什么是十字过滤线</h2><p>　　十字过滤线，英文全名Vertical Horizontal Filter，缩写VHF。1991年8月于Futures杂志，由<a href="https://wiki.mbalib.com/w/index.php?title=怀特&amp;action=edit" target="_blank" rel="noopener">怀特</a>（Adam White）首次发表，其主要的作用在于分辨行情的种类。</p><p>　　趋势行情应该采用<a href="https://wiki.mbalib.com/wiki/趋势指标" target="_blank" rel="noopener">趋势指标</a>，横向整理行情应该采用<a href="https://wiki.mbalib.com/wiki/超买超卖指标" target="_blank" rel="noopener">超买超卖指标</a>，不同的指标适用于不同的市场走势。但是，如何区别目前的走势，属于单一方向的趋势行情？还是横向震荡的整理行情？是许多使用技术分析的股民，共同遭遇的难题。</p><p>　　<a href="https://wiki.mbalib.com/wiki/MACD指标" target="_blank" rel="noopener">MACD指标</a>及<a href="https://wiki.mbalib.com/wiki/移动平均线" target="_blank" rel="noopener">移动平均线</a>，都是典型的趋势指标。当行情朝单一方向前进时，这两种指标，可以提供股民明确的方向指示及买卖讯号。然而，行情一旦朝横向箱型发展时，MACD和移动平均线，会因为波动频繁的关系，出现很多假讯号陷阱，使得股民顿时失去方向感。</p><p>　　股价呈箱型走势波动时，<a href="https://wiki.mbalib.com/wiki/相对强弱指标" target="_blank" rel="noopener">相对强弱指标</a>（<a href="https://wiki.mbalib.com/wiki/RSI" target="_blank" rel="noopener">RSI</a>）及<a href="https://wiki.mbalib.com/wiki/KD指标" target="_blank" rel="noopener">KD指标</a>可以提供短期的买卖讯号，然而，行情的发展没有一定的规则。当弱势的箱形行情，演变成强势的趋势行情时，股民如果仍然参考<a href="https://wiki.mbalib.com/wiki/RSI" target="_blank" rel="noopener">RSI</a>和<a href="https://wiki.mbalib.com/wiki/KD指标" target="_blank" rel="noopener">KD指标</a>的买卖讯号，则会在指标到达80时立即卖出<a href="https://wiki.mbalib.com/wiki/股票" target="_blank" rel="noopener">股票</a>。结果，这个价位却是趋势行情的起涨点，此时卖出股票真的很冤枉。</p><p>　　为了让技术分析的讯号，充分的发挥功能，不同的市况，必须搭配不同的指标。如果指标的选择错误，必然没办法得到好的操作结果。因此，辨别目前行情的地位，是每一位股民进行交易投资之前最重要的工作。</p><p>　　怀特所设计的VHF指标，解决了上述的问题，提供股民清晰明确的讯号，可以澄清“趋势行情”与“箱型行情”的界限。经过VHF指标过滤后的行情，可以帮助股民选择最佳的指标组合。</p><h2 id="十字过滤线的公式概说"><a href="#十字过滤线的公式概说" class="headerlink" title="十字过滤线的公式概说"></a>十字过滤线的公式概说</h2><p>　　1、NUM＝│HCP-LCP│</p><p>　　2、DEN＝SUM（CLS-CLSn）</p><p>　　3、VHF＝NUM÷DEN</p><p>　　4、本指标参数一般设为28天，视个股状况不同，可调整为14天或7天。</p><h2 id="十字过滤线的指标剑法"><a href="#十字过滤线的指标剑法" class="headerlink" title="十字过滤线的指标剑法"></a>十字过滤线的指标剑法</h2><p>　　1、VHF的值越高，代表目前正处于趋势行情，应选择趋势指标为参考工具。</p><p>　　2、VHF的值越低，代表目前正处于箱型行情，应选择<a href="https://wiki.mbalib.com/wiki/超买超卖指标" target="_blank" rel="noopener">超买超卖指标</a>为参考工具。</p><p>　　3、VHF处于上升状态时，代表股价处于趋势行情。</p><p>　　4、VHF处于下跌状态时，代表股价处于箱型行情。</p><p>　　VHF指标的图表上，可以切划一条中界线，分隔趋势和箱型的<a href="https://wiki.mbalib.com/wiki/波动范围" target="_blank" rel="noopener">波动范围</a>。这一条中界线一般位于0.35～0.4之间，但是，不同的个股，其中界线位置稍有差异，读者应自行设定最佳的中界线。</p><p>　　将中界线视为X轴，另外设一条Y轴与X轴交叉成十字坐标轴，Y轴可任意左右移动。将Y轴移至VHF曲线穿越X轴处，如果VHF曲线位于十字坐标轴的右上方，代表股价处于趋势行情。如果VHF曲线位于十字坐标轴的右下方，则代表股价处于箱型行情。</p><p>　　5、如果<a href="https://wiki.mbalib.com/wiki/动向指数（DMI）" target="_blank" rel="noopener">动向指数（DMI）</a>中的＋DI值高于-DI值，而VHF曲线向上或向下突破X轴时，为中线买点。</p><p>　　6、如果DMI指标中的＋DI值低于-DI值，而VHF曲线向上或向下跌破X轴时，为中线卖点。</p><p>　　<strong>深入讲解：</strong></p><p>　　股民选择股票时，一定选择介入<a href="https://wiki.mbalib.com/wiki/强势股" target="_blank" rel="noopener">强势股</a>，也就是说，选择<a href="https://wiki.mbalib.com/wiki/股价趋势" target="_blank" rel="noopener">股价趋势</a>已经正式启动的个股。<a href="https://wiki.mbalib.com/wiki/ADX指标" target="_blank" rel="noopener">ADX指标</a>中的ADXR评比线可以分辨趋势行情与箱型行情，藉以选择介入趋势行情的个股。VHF指标与ADXR评比线，虽然有异曲同工之处，但是，显示在图表上时，VHF指标的作用，比ADXR评比线更明确。VHF指标可以直接产生买卖讯号，ADXR评比线却欠缺这一方面的功能。</p><p>　　一般而言，当股民决定进入市场之前，首要之务，在于先搞清楚当时行情的定位，经过第一道辨认手续后，才能进一步规划操作策略。由于<a href="https://wiki.mbalib.com/wiki/股票市场" target="_blank" rel="noopener">股票市场</a>里<a href="https://wiki.mbalib.com/wiki/上市公司" target="_blank" rel="noopener">上市公司</a>的数目相当多，想要过滤属于趋势行情的个股，必然需要花费相当多的时间。因此，现阶段国际金融交易市场，流行人工智慧选股系统，其整个系统第一步最重要的流程，就是扫瞄过滤趋势行情股。利用这层原理，我们可以藉VHF指标，帮我们过滤筛选出值得介入的个股。</p><p>　　如果你选择介入的股票，它的VHF曲线位于十字坐标轴的有上方，那么，它一定是趋势股。接下来的第二道流程，必定是选择最适当的趋势指标，做为主要的参考工具。如果你选择介入的股票，它的VHF曲线位于十字坐标轴的右下方，那么，它一定是箱型整理股。箱型整理股的操作策略，必须选择<a href="https://wiki.mbalib.com/wiki/超买超卖指标" target="_blank" rel="noopener">超买超卖指标</a>为主要参考工具。换句话说，当VHF曲线的数值较高时，应进行中线交易。当VHF曲线的数值较低时，则进行<a href="https://wiki.mbalib.com/wiki/短线交易" target="_blank" rel="noopener">短线交易</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是十字过滤线&quot;&gt;&lt;a href=&quot;#什么是十字过滤线&quot; class=&quot;headerlink&quot; title=&quot;什么是十字过滤线&quot;&gt;&lt;/a&gt;什么是十字过滤线&lt;/h2&gt;&lt;p&gt;　　十字过滤线，英文全名Vertical Horizontal Filter，缩写VHF。1
      
    
    </summary>
    
      <category term="其他" scheme="https://www.ljjyy.com/categories/other/"/>
    
    
      <category term="stock" scheme="https://www.ljjyy.com/tags/stock/"/>
    
  </entry>
  
  <entry>
    <title>区间震荡线DPO</title>
    <link href="https://www.ljjyy.com/archives/2023/04/100714.html"/>
    <id>https://www.ljjyy.com/archives/2023/04/100714.html</id>
    <published>2023-04-05T04:48:00.000Z</published>
    <updated>2023-09-20T01:49:55.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是区间震荡线"><a href="#什么是区间震荡线" class="headerlink" title="什么是区间震荡线"></a>什么是区间震荡线</h2><p>　　区间震荡线，英文全名Detrended price Oscillator，缩写为DPO。1970～1980年代，<a href="https://wiki.mbalib.com/w/index.php?title=沃尔特·巴塞特&amp;action=edit" target="_blank" rel="noopener">沃尔特·巴塞特</a>（Walt Bressert）将他对于衍生性<a href="https://wiki.mbalib.com/wiki/期货商品" target="_blank" rel="noopener">期货商品</a>，循环规则的研究心得，发表于期货商品杂志。虽然，这份研究报告，对目前的技术分析研究者而言，似乎太过于简单。但是，他已经把<a href="https://wiki.mbalib.com/wiki/移动平均线" target="_blank" rel="noopener">移动平均线</a>，从传统的观念上跳脱出来。这个观点，逐渐被研究周期循环的学者采用。</p><p>　　宇宙间的事物，是一种生生不息的循环，例如：四季的循环、日夜的循环、潮汐的循环、动物的冬眠……等等，都是人类可以<a href="https://wiki.mbalib.com/wiki/预测" target="_blank" rel="noopener">预测</a>的。然而宇宙间，仍存在着人类无法准确预测的循环。例如：天气、地震。这是因为很多周期长短不同的循环，错综干扰的交互作用，使得个别周期无法单独显现。</p><p>　　巴塞特研究这种交互作用后发现，一个长周波包含了数个短周波。数个短周波的组合，构成一个长周波。观察短周波的运动规律，可以估计长周波峰谷出现的时机。例如：四个短期循环底部，构成一个长期循环底部。因此，DPO指标刻意忽略较长周期的波动，一方面可以减少周期干扰的混淆，一方面可以凸显个别周期的波动。</p><p>　　一段周期的移动平均线，其周期的二分之一处，是价格重心的聚集点。以20天的周期为例，第10天是整段周期的重心平衡点。移动平均线的形状，很像一条波浪状扭曲的绳子，股价在这条绳子的周围，上下来回穿梭。如果消除扭曲的波动，将这条绳子拉平，重心平衡点视为图表上的0轴。把当日价格与重心平衡点间的差距，绘制于0轴的上下方。如此一来，可以更清楚的显现出短周期的高、低点。</p><p>　　假设移动平均线是长周期的循环，<a href="https://wiki.mbalib.com/wiki/股价波动" target="_blank" rel="noopener">股价波动</a>是短周期循环。那么，大家可以发现，DPO指标为了避免长、短周期互相干扰，直接将移动平均线拉直后，当成0轴。然后依据<a href="https://wiki.mbalib.com/w/index.php?title=Envelope轨道线&amp;action=edit" target="_blank" rel="noopener">Envelope轨道线</a>的做法，在移动平均线（0轴）的上下方，以固定百分比的差距，设定两条上限和下限，代表股价的超买超卖界限值。</p><h2 id="区间震荡线的公式概说"><a href="#区间震荡线的公式概说" class="headerlink" title="区间震荡线的公式概说"></a>区间震荡线的公式概说</h2><p>　　1、MA＝N天的移动平均值。</p><p>　　2、DPO＝CMX-MA (N÷2+1)。</p><p>　　3、一般参数N设定为20天或28天。</p><p>　　4、MADPO=DPOM日的简单移动平均值。</p><p>​        其中，N=20或者28，M=6。</p><h2 id="区间震荡线的指标剑法"><a href="#区间震荡线的指标剑法" class="headerlink" title="区间震荡线的指标剑法"></a>区间震荡线的指标剑法</h2><p>　　1、在0轴上方，设定一条<a href="https://wiki.mbalib.com/wiki/超买" target="_blank" rel="noopener">超买</a>线，DPO波动至超买线时，代表股价处于短期高点。</p><p>　　2、在0轴下方，设定一条<a href="https://wiki.mbalib.com/wiki/超卖" target="_blank" rel="noopener">超卖</a>线，DPO波动至超卖线时，代表股价处于短期低点。</p><p>　　注意！不同<a href="https://wiki.mbalib.com/wiki/股票" target="_blank" rel="noopener">股票</a>的超买超卖界限值都不同，读者应观察其历史数据后，自行设定。</p><p>　　3、DPO位于0轴上方，代表<a href="https://wiki.mbalib.com/wiki/多头" target="_blank" rel="noopener">多头</a>趋势。或者，DPO由负值向上穿越0轴时，视为买进讯号。</p><p>　　4、DPO位于0轴下方，代表<a href="https://wiki.mbalib.com/wiki/空头" target="_blank" rel="noopener">空头</a>趋势。或者，DPO由正值向下穿越0轴时，视为卖出讯号。</p><h2 id="“DPO-MADPO”的组合"><a href="#“DPO-MADPO”的组合" class="headerlink" title="“DPO+MADPO”的组合"></a><strong>“DPO+MADPO”的组合</strong></h2><p>1、DPO由下向上穿越MADPO时，形成金叉，是买入信号;DPO由上向下穿越MADPO时，形成死叉，是卖出信号。</p><p>2、股价创新低，而DPO未创新低，属底背离，是买入信号;股价创新高，而DPO未创新高，属顶背离，是卖出信号。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>1、DPO在低档出现第二次向上穿越MADPO时，股价上行幅度会较大</p><p>DPO在高档出现第二次向下交叉MADPO时，股价下行幅度较深</p><p>2、DPO与MADPO都在“0”值以上时为多方市场</p><p>DPO与MADPO都在“0”值以下时为空头市场</p><p>3、去势价格摆动差指数DPO的时间周期n所取的天数，决定了去势价格摆动差指数DPO所能研判的股价变化周期的长短;也就是说，只能确定n天以下周期的波峰与波谷;</p><p>4、去势价格摆动差指数DPO的另一种计算方法</p><p>是变作差为作商，指数以比率形式表示出来</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是区间震荡线&quot;&gt;&lt;a href=&quot;#什么是区间震荡线&quot; class=&quot;headerlink&quot; title=&quot;什么是区间震荡线&quot;&gt;&lt;/a&gt;什么是区间震荡线&lt;/h2&gt;&lt;p&gt;　　区间震荡线，英文全名Detrended price Oscillator，缩写为DPO。
      
    
    </summary>
    
      <category term="其他" scheme="https://www.ljjyy.com/categories/other/"/>
    
    
      <category term="stock" scheme="https://www.ljjyy.com/tags/stock/"/>
    
  </entry>
  
  <entry>
    <title>超级趋势指标SuperTrend</title>
    <link href="https://www.ljjyy.com/archives/2023/04/100713.html"/>
    <id>https://www.ljjyy.com/archives/2023/04/100713.html</id>
    <published>2023-04-05T04:45:00.000Z</published>
    <updated>2023-09-20T01:51:42.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="超级趋势指标"><a href="#超级趋势指标" class="headerlink" title="超级趋势指标"></a>超级趋势指标</h2><p>顾名思义，SuperTrend 指标跟踪趋势市场的方向。该指标以其在发现交易的有效买卖信号方面的准确性而闻名。老实说，SuperTrend 的计算有点复杂，但我会分解成几个部分让您更好地理解。</p><p>该指标的计算涉及两个主要组成部分，即回顾期和乘数。回溯期不过是计算中要考虑的数据点数，乘数是用于乘以 ATR 的值。SuperTrend 指标的传统设置是 10 作为回顾期，3 作为乘数。考虑到这些设置，让我们继续执行 SuperTrend 指标计算中涉及的步骤。</p><p>计算中涉及的第一步是使用我们之前讨论的公式确定 10 天 ATR。第二步是确定基本的上下波段。要计算这两个波段，我们需要首先找到高低平均值（我们现在称之为 HLA），它是通过将股票的高值和低值相加并除以 2 计算得出的。使用这些 HLA 值，上波段是通过首先将 10 天 ATR 值乘以乘数（即 3）并将乘积与 HLA 值相加来计算。相同的程序也适用于基本较低频带的计算，但我们需要减去与 HLA 值的乘积而不是相加。两个波段的计算可以在数学上表示如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">基本上限= HLA + [乘数* 10 天 ATR ]</span><br><span class="line">基本下限= HLA -  [乘数* 10 天 ATR ]其中，</span><br><span class="line">HLA = 高低平均值</span><br><span class="line">MULTIPLIER = 3</span><br></pre></td></tr></table></figure><p>然后是计算最终的上下波段，它们是 SuperTrend 指标计算中涉及的核心组成部分。没有用于计算最终波段的公式，而是通过条件，并将值附加到与满足条件有关的波段。当前最终上限的条件如下：</p><ul><li>如果当前基本上轨小于前一个最终上轨或股票前一个收盘价大于前一个最终上轨，则当前最终上轨的值为当前基本上轨。</li><li>如果条件未能得到满足，则当前最终上带的值是先前的最终上带。最终上带的条件可以表示如下：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IF C<span class="selector-class">.BUB</span> &lt; P<span class="selector-class">.FUB</span> OR P<span class="selector-class">.CLOSE</span> &gt; P<span class="selector-class">.FUB</span> : C<span class="selector-class">.FUB</span> = C.BUB</span><br><span class="line">如果条件不满足： C<span class="selector-class">.FUB</span> = P.FUB其中，</span><br><span class="line">C<span class="selector-class">.BUB</span> = 当前基本上限</span><br><span class="line">P<span class="selector-class">.FUB</span> = 之前的最终上限</span><br><span class="line">P<span class="selector-class">.CLOSE</span> = 股票的先前收盘价</span><br><span class="line">C<span class="selector-class">.FUB</span> = 当前最终上限</span><br></pre></td></tr></table></figure><p>当前较低频带的条件如下：</p><ul><li>如果当前基本下轨大于前一最终下轨或股票前一收盘价小于前一最终下轨，则当前最终下轨值就是当前基本下轨。</li><li>如果当前最终下带的这个条件不满足，那么当前最终下带就是之前的最终下带。条件可以表示如下：</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果C<span class="selector-class">.BLB</span> &gt; P.FLB或P<span class="selector-class">.CLOSE</span> &lt; P.FLB：C<span class="selector-class">.FLB</span> = C.BLB</span><br><span class="line">如果条件不满足：C<span class="selector-class">.FLB</span> = P.FLB其中，</span><br><span class="line">C<span class="selector-class">.BLB</span> = 当前基本下限</span><br><span class="line">P<span class="selector-class">.FLB</span> = 前一个最终下限</span><br><span class="line">P<span class="selector-class">.CLOSE</span> = 股票的前一个收盘价</span><br><span class="line">C<span class="selector-class">.FLB</span> = 当前最终下限</span><br></pre></td></tr></table></figure><h2 id="然后使用"><a href="#然后使用" class="headerlink" title="然后使用"></a>然后使用</h2><p>现在我们拥有确定 SuperTrend 指标值的所有基本组件。就像我们如何使用条件来计算最终波段的值一样，这同样适用于 SuperTrend 指标的计算。虽然确定最终波段值的条件只有一种，但 SuperTrend 指标有四种不同的条件。当前 SuperTrend 值的条件如下：</p><ul><li>如果之前的 SuperTrend 指标值等于之前的最终上限，而股票当前收盘价小于当前最终上限，则当前 SuperTrend 指标值是当前最终上限。</li><li>如果之前的 SuperTrend 指标值等于之前的最终上限并且股票当前收盘价大于当前最终上限，则当前 SuperTrend 指标值是当前最终下限。</li><li>如果先前的 SuperTrend 指标值等于先前的最终较低波段并且股票当前收盘价大于当前最终较低波段，则当前 SuperTrend 指标值是当前最终较低波段。</li><li>如果之前的 SuperTrend 指标值等于之前的最终下波段并且股票当前收盘价小于当前最终下波段，则当前 SuperTrend 指标值是当前最终上波段。</li></ul><p>当把所有这些条件放在一起时，条件的总数量可以表示如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果P<span class="selector-class">.ST</span> == P.FUB和C<span class="selector-class">.CLOSE</span> &lt; C<span class="selector-class">.FUB</span> : C<span class="selector-class">.ST</span> = C.FUB</span><br><span class="line">如果P<span class="selector-class">.ST</span> == P.FUB和C<span class="selector-class">.CLOSE</span> &gt; C<span class="selector-class">.FUB</span> : C<span class="selector-class">.ST</span> = C.FLB</span><br><span class="line">如果P<span class="selector-class">.ST</span> == P.FLB和C<span class="selector-class">.CLOSE</span> &gt; C.FLB：C<span class="selector-class">.ST</span> = C.FLB</span><br><span class="line">如果P<span class="selector-class">.ST</span> == P.FLB和C<span class="selector-class">.CLOSE</span> &lt; C.FLB：C<span class="selector-class">.ST</span> = C.FUB其中，</span><br><span class="line">P<span class="selector-class">.ST</span> = 之前的 SuperTrend 指标值</span><br><span class="line">P<span class="selector-class">.FUB</span> = 之前的最终上限</span><br><span class="line">P<span class="selector-class">.FLB</span> = 之前的最终下限</span><br><span class="line">C<span class="selector-class">.CLOSE</span> = 股票的当前收盘价</span><br><span class="line">C<span class="selector-class">.ST</span> = 当前 SuperTrend 指标值</span><br><span class="line">C<span class="selector-class">.FUB</span> = 当前最终上限</span><br><span class="line">C<span class="selector-class">.FLB</span> = 当前最终下限</span><br></pre></td></tr></table></figure><p>这就是计算 SuperTrend 指标值的整个过程。为了更好地理解该指标及其工作原理，让我们探索一张图表，其中绘制了一只股票的收盘价以及 SuperTrend 指标的读数。</p><p><img src="https://miro.medium.com/v2/resize:fit:1050/1*h7PgoDZ0elyTllJQw3rdBg.png" alt="img"></p><p>图片作者</p><p>在上图中，蓝线代表特斯拉股票的收盘价，红绿线代表 SuperTrend 指标的读数。如果指标读数低于收盘价，SuperTrend 指标线变为绿色，如果高于收盘价，则变为红色。正如我之前所说，SuperTrend 指标是一个趋势跟踪指标，这一点可以在图表中观察到，该指标更准确地直接揭示了市场的当前趋势。</p><p>交易者使用在 SuperTrend 指标线中观察到的颜色变化或趋势变化来标记其交易的买入和卖出信号。更详细地说，如果指标线从收盘价线上方穿越到收盘价线下方，交易者做多（买入股票），同样，如果指标线从收盘价线下方穿越到收盘价线上方，交易者做空（卖出股票）线。这种 SuperTrend 策略称为交叉策略。该策略可以表示如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IF PREV<span class="selector-class">.ST</span> &gt; PREV<span class="selector-class">.CLOSE</span> AND CUR<span class="selector-class">.ST</span> &lt; CUR<span class="selector-class">.CLOSE</span> ==&gt;买入信号</span><br><span class="line">IF PREV<span class="selector-class">.ST</span> &lt; PREV<span class="selector-class">.CLOSE</span> AND CUR<span class="selector-class">.ST</span> &gt; CUR<span class="selector-class">.CLOSE</span> ==&gt;卖出信号</span><br></pre></td></tr></table></figure><p>这也是我们将在本文中实施的策略。</p><p>参考：<a href="https://medium.com/codex/step-by-step-implementation-of-the-supertrend-indicator-in-python-656aa678c111" target="_blank" rel="noopener">https://medium.com/codex/step-by-step-implementation-of-the-supertrend-indicator-in-python-656aa678c111</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;超级趋势指标&quot;&gt;&lt;a href=&quot;#超级趋势指标&quot; class=&quot;headerlink&quot; title=&quot;超级趋势指标&quot;&gt;&lt;/a&gt;超级趋势指标&lt;/h2&gt;&lt;p&gt;顾名思义，SuperTrend 指标跟踪趋势市场的方向。该指标以其在发现交易的有效买卖信号方面的准确性而闻名
      
    
    </summary>
    
      <category term="其他" scheme="https://www.ljjyy.com/categories/other/"/>
    
    
      <category term="stock" scheme="https://www.ljjyy.com/tags/stock/"/>
    
  </entry>
  
  <entry>
    <title>LazyBear&#39;s Wave Trend指标WT</title>
    <link href="https://www.ljjyy.com/archives/2023/04/100712.html"/>
    <id>https://www.ljjyy.com/archives/2023/04/100712.html</id>
    <published>2023-04-05T04:45:00.000Z</published>
    <updated>2023-09-20T01:52:24.719Z</updated>
    
    <content type="html"><![CDATA[<p>j</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>该指标提高了我抓住顶部的可能性。我主要用于入场，等待极端数字，然后进行一些小额交易以尝试捕捉反转。</p><p>WTwC 有点像 RSI，但速度较慢，并且在 12 小时和每天提供良好的结果。在较短的时间范围内，它容易产生更多的噪音。</p><p>让我们开始。</p><blockquote><p>study(title=”WaveTrend with Crosses [LazyBear]”, shorttitle=”WT_CROSS_LB”)</p></blockquote><p><strong>研究名字和头衔，也为 Lazybear 的伟大工作而呐喊。</strong></p><blockquote><p>n1 = input(10, “通道长度”)<br>n2 = input(21, “平均长度”)</p></blockquote><p><strong>第一组对象包含两个输入，10 和 21，稍后用作 EMA 的输入长度。降低数字会产生更多信号，增加数字会产生更少信号。</strong></p><blockquote><p>obLevel1 = input(60, “Over Bought Level 1”)<br>obLevel2 = input(53, “Over Bought Level 2”)<br>osLevel1 = input(-60, “Over Sold Level 1”)<br>osLevel2 = input(-53, “Over Sold 2级”）</p></blockquote><p><strong>这些水平将定义指标的极值。</strong>它的工作原理类似于 RSI，高于 60 的水平被视为超买，低于 -60 的水平被视为超卖。与 RSI 不同，至少在每日或 12 日，读数很少会在任何延长的时间段内保持在这些极端值之上或之下。</p><blockquote><p>ap = hlc3</p></blockquote><p><strong>将 ap 设置为等于高低和收盘价的平均值。</strong>Open 不包括在其中，因为它是无关紧要的。它包含在前一根蜡烛的收盘价中。就价格而言，ap 将紧密匹配。</p><blockquote><p>esa = ema(ap, n1)</p></blockquote><p><strong>将 esa 设置为等于上述价格平均值的指数移动平均值。</strong>在这种情况下，EMA 基于前十根蜡烛。也将与价格密切相关。</p><blockquote><p>d = ema(abs(ap — esa), n1)</p></blockquote><p><strong>将 d 设置为等于平均值绝对值的 EMA 减去平均值的 EMA，长度为过去 21 根蜡烛。</strong>这个数字总是正数，并将在下一部分发挥作用。这将是价格的一小部分。</p><blockquote><p>ci = (ap — esa) / (0.015 * d)</p></blockquote><p><strong>这是建立指标其余部分的等式。它采用 HLC 的平均值并减去过去 10 (n1) 根柱线的 EMA。结果除以 d 的 1.5%。</strong>顶部数字可以是正数也可以是负数，但 d 始终为正数，这允许指标在两个超买/卖出水平之间来回移动。这个数字还限制了下面列出的 tci 在级别内的范围。在我的头顶，它可以范围的最大值应该在 90 左右。</p><blockquote><p>tci = ema(ci, n2)</p></blockquote><p><strong>上一个公式的 21 周期 EMA。这是一个平滑函数。</strong></p><blockquote><p>wt1 = tci<br>wt2 = sma(wt1,4)</p></blockquote><p><strong>将 wt1 设置为等于 tci，将 wt2 设置为等于 wt2 的 4 周期 SMA。</strong>这两个对象将用于在先前介绍的超买和超卖水平上绘制指标。我想知道他为什么不只是从上面使用 tci，但我认为他在编写绘图函数时希望易于编码。</p><blockquote><p>绘图（0，颜色=灰色）<br>绘图（obLevel1，颜色=红色）<br>绘图（osLevel1，颜色=绿色）<br>绘图（obLevel2，颜色=红色）<br>绘图（osLevel2，颜色=绿色）</p><p>绘图（wt1，颜色=绿色）<br>绘图（wt2，颜色=红色）<br>绘图（wt1-wt2，颜色=蓝色，样式=面积，transp=80）<br>绘图（交叉（wt1，wt2）？wt2：na，颜色=黑色, style = circles, linewidth = 3)<br>plot(cross(wt1, wt2) ? wt2 : na, color = (wt2 — wt1 &gt; 0 ? red : lime) , style = circles, linewidth = 2) barcolor(cross(wt1<br>, wt2) ? (wt2 — wt1 &gt; 0 ? aqua : yellow) : na)</p></blockquote><p>以上大部分都是plot()函数来定义需要绘制的对象。这里的主要功能是 plot(cross())，它突出显示了 wt1 与 wt2 的交叉点。</p><p>实际上，WTwC 取 EMA 之间的差异，除以其绝对值，然后绘制它。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>它的工作原理类似于 RSI，高于 60 的水平被视为超买，低于 -60 的水平被视为超卖。当振荡器高于超买带并向下穿过信号时，通常是一个很好的卖出信号。同样，当震荡指标在超卖带下方穿过信号上方时，这是一个很好的买入信号。与 RSI 不同，至少在每日或 12 日，读数很少会在任何延长的时间段内保持在这些极端值之上或之下。</p><p>参考：<a href="https://medium.com/@samuel.mcculloch/lets-take-a-look-at-wavetrend-with-crosses-lazybear-s-indicator-2ece1737f72f" target="_blank" rel="noopener">https://medium.com/@samuel.mcculloch/lets-take-a-look-at-wavetrend-with-crosses-lazybear-s-indicator-2ece1737f72f</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;j&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;该指标提高了我抓住顶部的可能性。我主要用于入场，等待极端数字，然后进行一些小额交易以尝试捕捉反转。&lt;/p&gt;
&lt;p&gt;WTwC
      
    
    </summary>
    
      <category term="其他" scheme="https://www.ljjyy.com/categories/other/"/>
    
    
      <category term="stock" scheme="https://www.ljjyy.com/tags/stock/"/>
    
  </entry>
  
</feed>
